//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "HmiChkBitList"
	Revision           = "0.2"
	GUID               = "{9427936C-1195-4248-B393-AC7B6C2B379A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Client Name="Label" Required="true" Internal="true"/>
		<Client Name="StringLib" Required="true" Internal="false"/>
		<Client Name="VarList" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.2" Date="2017-11-27" Author="kolott" Company="sigmatek" Description="new Method GetChkBitIndex() added"/>
		<Dokumentation Revision="0.1" Date="2014-04-15" Author="kolott" Company="sigmatek" Description="new method FreeMem()"/>
	</RevDoku>
	<Network Name="HmiChkBitList">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{361C9BA1-D933-4984-AFD7-C74FCAA78746}"
				Class      = "HmiBaseList"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "Label"
				GUID       = "{A1AA71E0-A550-42A4-85B6-77DB89E871D8}"
				Class      = "HmiAsciiBuffer"
				Position   = "(210,330)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
					<Client Name="StringLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(690,210),(518,210),"/>
			<Connection Source="_base.File" Destination="this.File" Vertices="(218,210),(38,210),"/>
			<Connection Source="this.Label" Destination="Label.ClassSvr"/>
			<Connection Source="Label.File" Destination="this.File" Vertices="(210,420),(38,210),"/>
			<Connection Source="Label.StringLib" Destination="this.StringLib" Vertices="(210,480),(38,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using HmiBaseList

HmiChkBitList : CLASS
: HmiBaseList
	TYPE
#pragma pack(push, 1)
	  CBIT : STRUCT
	    size : UINT;
	    ptr : ^USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  CLEXEM : STRUCT
	    id : USINT;
	    op : USINT;
	    value : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  MEM_CBIT : STRUCT
	    no : UDINT;
	    ptr : ^CBIT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
  //Clients:
	VarList 	: CltChCmd_HmiVarList;
	Label 	: CltChCmd_HmiAsciiBuffer;
	StringLib 	: CltChCmd_HmiStrLib;
  //Variables:
		Data 	: MEM_CBIT;
		C_Source 	: ^USINT;
		C_Error 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL Load
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL Free;
	
	FUNCTION Init_CBIT
		VAR_INPUT
			ptc 	: ^CBIT;
		END_VAR;
	
	FUNCTION Free_CBIT
		VAR_INPUT
			ptc 	: ^CBIT;
		END_VAR;
	
	FUNCTION Load_CBIT
		VAR_INPUT
			ptc 	: ^CBIT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Call
		VAR_INPUT
			pck 	: ^HMI_CHKBIT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Get
		VAR_INPUT
			pck 	: ^HMI_CHKBIT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CBIT;
		END_VAR;
	
	FUNCTION CallSub
		VAR_INPUT
			ptc 	: ^CBIT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION C_DoPart
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION C_GetLexem
		VAR_INPUT
			ptc 	: ^CLEXEM;
		END_VAR;
	
	FUNCTION C_GetVarlabel
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION C_GetBit
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION C_GetChkBit
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION C_Save
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetLabel
		VAR_INPUT
			cbit 	: ^HMI_CHKBIT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL FreeMem;
	
	FUNCTION GLOBAL GetChkBitIndex
		VAR_INPUT
			name 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using HmiAsciiBuffer
#pragma usingLtd HmiStrLib
#pragma usingLtd HmiVarList


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiChkBitList::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMICHKBITLIST
0$UINT, 2$UINT, (SIZEOF(::HmiChkBitList))$UINT, 
0$UINT, 3$UINT, 0$UINT, 
TO_UDINT(3930770040), "HmiChkBitList", //Class
TO_UDINT(3735923847), "HmiBaseList", 0$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::HmiChkBitList.VarList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(145198113), "VarList", TO_UDINT(3793961451), "HmiVarList", 0$UINT, 17$UINT, 
(::HmiChkBitList.Label.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4193489496), "Label", TO_UDINT(3253426089), "HmiAsciiBuffer", 0$UINT, 1$UINT, 
(::HmiChkBitList.StringLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(3243119075), "StringLib", TO_UDINT(103556616), "HmiStrLib", 0$UINT, 2$UINT, 
END_FUNCTION


#define USER_CNT_HmiChkBitList 2

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiChkBitList] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiChkBitList::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= HmiBaseList::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= HmiBaseList::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, HmiBaseList::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_HmiChkBitList;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Load();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #Free();

#pragma warning (default : 74)
	HmiBaseList::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF HmiBaseList::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL HmiChkBitList::Free
  VAR
  	nox : udint;
    ptc : ^CBIT;
  END_VAR

  nox := Data.no;
  ptc := Data.ptr;
  while(nox) do
    Free_CBIT(ptc);
    nox -= 1;
    ptc += sizeof(CBIT);
  end_while;

  Label.Free();
  ClassSvr := 0;

END_FUNCTION

FUNCTION VIRTUAL HmiChkBitList::Load
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    anz : uint;
    size : udint;
    ptc : ^CBIT;
  end_var

  retcode := false;

  if(File.FRead(#anz, 2) = true) then
    size := anz * sizeof(CBIT);
    if(File.FMemory(#Data.ptr$^void, size) = true) then
    
      retcode := true;
      Data.no := anz;
      ptc     := Data.ptr;
      while(anz) do
        Init_CBIT(ptc);
        
        if(retcode = true) then
          retcode := Load_CBIT(ptc);
        end_if;
        
        anz -= 1;
        ptc += sizeof(CBIT);
      end_while;
      
      Label.Load(); // load chkbitnamen
    end_if;
  end_if;

  ClassSvr := to_dint(Label.GetNo());

END_FUNCTION

FUNCTION GLOBAL HmiChkBitList::GetLabel
	VAR_INPUT
		cbit 	: ^HMI_CHKBIT;
	END_VAR
  VAR_OUTPUT
    retcode : ^char;
  END_VAR

  retcode := Label.GetText(cbit^.no);
  if(retcode <> nil) then
    if(retcode^ = 0) then
      retcode := nil;
    end_if;
  end_if;

END_FUNCTION

FUNCTION HmiChkBitList::Init_CBIT
	VAR_INPUT
		ptc 	: ^CBIT;
	END_VAR

  ptc^.size := 0;
  ptc^.ptr := nil;

END_FUNCTION

FUNCTION HmiChkBitList::Free_CBIT
	VAR_INPUT
		ptc 	: ^CBIT;
	END_VAR

  File.Memory(#ptc^.ptr$^void, 0);
  Init_CBIT(ptc);

END_FUNCTION

FUNCTION HmiChkBitList::Load_CBIT
	VAR_INPUT
		ptc 	: ^CBIT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    seqsize : uint;
  end_var
  
  if(File.FRead(#seqsize, 2) = true) then
    if(File.FMemory(#ptc^.ptr$^void, seqsize) = true) then
      if(File.FRead(ptc^.ptr, seqsize) = true) then
        ptc^.size := seqsize;
        retcode   := true;
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiChkBitList::Get
	VAR_INPUT
		pck 	: ^HMI_CHKBIT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^CBIT;
	END_VAR

  retcode := nil;
  if(pck^.no < Data.no) then
    retcode := Data.ptr + pck^.no * sizeof(CBIT);
  end_if;

END_FUNCTION

FUNCTION HmiChkBitList::CallSub
	VAR_INPUT
		ptc 	: ^CBIT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode  := false;
  C_Source := ptc^.ptr;
  C_Error  := 0;
  if(C_DoPart() <> 0) then
    if(C_Error = 0) then
      retcode := true;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiChkBitList::Call
	VAR_INPUT
		pck 	: ^HMI_CHKBIT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	ptc : ^CBIT;
  END_VAR

  retcode := true;
  ptc     := Get(pck);
  if(ptc <> nil) then
    if(ptc^.ptr <> nil) then
      retcode := CallSub(ptc);
      if(pck^.invert <> 0) then
        if(retcode = true) then
          retcode := false;
        else
          retcode := true;
        end_if;
      end_if;
    end_if;
  end_if;

END_FUNCTION



#define hID_OPERATOR       16#00 // es folgt ein _UBYTE (operator (+,-,/,*,|, etc))
#define hID_VARLABEL       16#01 // es folgt ein _VARLABEL (variable, konstante)
#define hID_BITNO          16#02 // es folgt ein _UWORD (kennbitnummer (#2))
#define hID_CHKBIT         16#03 // es folgt ein _UWORD (verweis in kennbitliste (#kennbit01))
#define hID_CONSTANT       16#04 // nur compiler intern (from here keep in order !!)
#define hID_NONE           16#05 // nur compiler intern (continue keep in order !!)
#define hIOP_NOP           16#00 // nop
#define hIOP_BRACKET_OPEN  16#01 // (
#define hIOP_BRACKET_CLOSE 16#02 // )
#define hIOP_A_PLUS        16#03 // arithmetic +
#define hIOP_A_MINUS       16#04 // arithmetic -
#define hIOP_A_MULTI       16#05 // arithmetic *
#define hIOP_A_DIV         16#06 // arithmetic /
#define hIOP_A_MOD         16#07 // arithmetic %
#define hIOP_A_OR          16#08 // arithmetic |
#define hIOP_A_AND         16#09 // arithmetic &
#define hIOP_A_XOR         16#0A // arithmetic ^
#define hIOP_A_NOT         16#0B // arithmetic ~
#define hIOP_A_EQUAL       16#0C // arithmetic =
#define hIOP_OR            16#0D // logic ||
#define hIOP_AND           16#0E // logic &&
#define hIOP_SMALLER       16#0F // logic <
#define hIOP_SMALLEREQUAL  16#10 // logic <=
#define hIOP_EQUAL         16#11 // logic ==
#define hIOP_BIGGER        16#12 // logic >
#define hIOP_BIGGEREQUAL   16#13 // logic >=
#define hIOP_NOTEQUAL      16#14 // logic !=
#define hIOP_NOT           16#15 // logic not
#define hIOP_END           16#16 // commandline end ;

FUNCTION HmiChkBitList::C_GetVarlabel
  VAR_OUTPUT
    retcode : dint;
  END_VAR
  VAR
    any    : HMI_ANYTHING;
//    result : LME_RESULT;
    no     : uint;
    p2     : ^uint;
    p4     : ^dint;
  END_VAR

  init_HMI_ANYTHING(#any);
  
  no := C_Source^; C_Source += 1;
  while(no) do
    no -= 1;
    p2 := C_Source$^uint; C_Source += 2;
    p4 := C_Source$^dint; C_Source += 4;
    case (p2^) of
      0 : // default
          init_HMI_ANYTHING(#any);
      1 : // serverno
          any.ima   := HMI_IMA_V_SERVERLIST;
          any.value := p4^;
      2 : // constant
          any.ima   := HMI_IMA_DINT_CONSTANT;
          any.value := p4^;
    end_case;
  end_while;

  if(VarList.GetValueAnything(#retcode, #any) = false) then
    retcode := 0;
  end_if;
  
END_FUNCTION

FUNCTION HmiChkBitList::C_GetBit
  VAR_OUTPUT
    retcode : dint;
  END_VAR
  VAR
    lexem : CLEXEM;
  END_VAR

  retcode := 0;
  C_GetLexem(#lexem);
  
  if(C_Error = 0) then
    if(lexem.value <> 0) then
      retcode := 1;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION HmiChkBitList::C_GetChkBit
  VAR_OUTPUT
    retcode : dint;
  END_VAR
  VAR
    chkbit : HMI_CHKBIT;
    p2     : ^uint;
    mem_e  : udint;
    mem_s  : ^usint;
  END_VAR
  
  retcode := 0;

  if(C_Error = 0) then
    init_HMI_CHKBIT(#chkbit);
    p2            := C_Source$^uint; C_Source += 2;
    chkbit.no     := p2^;
    chkbit.invert := 0;
    mem_e         := C_Error;
    mem_s         := C_Source;
    if(Call(#chkbit) = true) then
      retcode     := 1;
    end_if;
    C_Error       := mem_e;
    C_Source      := mem_s;
  end_if;
  
END_FUNCTION

FUNCTION HmiChkBitList::C_GetLexem
	VAR_INPUT
		ptc 	: ^CLEXEM;
	END_VAR
  var
    id : usint;
  end_var

  id := C_Source^;  C_Source += 1;

  case id of
    hID_OPERATOR : ptc^.id    := hID_OPERATOR;
                   ptc^.op    := C_Source^;  C_Source += 1;
    hID_VARLABEL : ptc^.id    := hID_CONSTANT;
                   ptc^.value := C_GetVarlabel();
    hID_BITNO    : ptc^.id    := hID_CONSTANT;
                   ptc^.value := C_GetBit();
    hID_CHKBIT   : ptc^.id    := hID_CONSTANT;
                   ptc^.value := C_GetChkBit();
    else           C_Error    := 3;
  end_case;
  
END_FUNCTION

FUNCTION HmiChkBitList::C_Save
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  // geht einfach noch nicht
  C_Error := 4;
  retcode := 0;
  
END_FUNCTION

FUNCTION HmiChkBitList::C_DoPart
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    lexem      : CLEXEM;
    log_invert : uint;
    ari_invert : uint;
    run        : bool;
    op         : uint; 
    mux        : uint; 
  END_VAR

  log_invert := 0;
  ari_invert := 0;
  retcode    := 1; 
  op         := hIOP_NOP; 
  mux        := 0; 
  run        := true; 
  
  while(run = true) do 
    C_GetLexem(#lexem); 

    hCOMP_START: 

    if(C_Error = 0) then
    
      case lexem.id of
        hID_OPERATOR : 
          case lexem.op of
            hIOP_END           : run := false;                       
            hIOP_BRACKET_CLOSE : run := false;                       
            hIOP_BRACKET_OPEN  : lexem.id    := hID_CONSTANT; 
                                 lexem.value := C_DoPart(); 
                                 goto hCOMP_START; 
            hIOP_NOT           : log_invert := log_invert xor 1;                   
            hIOP_A_NOT         : ari_invert := ari_invert xor 1;                   
            hIOP_NOP           :                                    
            hIOP_A_EQUAL       : retcode := C_Save(); 
                                 run     := false;      
            else                 op      := lexem.op;                     
          end_case;

        hID_CONSTANT : 
          if(log_invert) then
            if(lexem.value > 0) then
              lexem.value := 0;
            else
              lexem.value := 1;
            end_if;
            log_invert := 0;
          end_if;
          
          if(ari_invert) then
            lexem.value := to_dint(lexem.value$udint xor 16#FFFFFFFF); 
            ari_invert  := 0; 
          end_if;

          if(mux = 0) then
            retcode := lexem.value; 
            mux   := 1; 
          else
            case op of
              hIOP_A_PLUS      : retcode := retcode + lexem.value;
              hIOP_A_MINUS     : retcode := retcode - lexem.value;
              hIOP_A_MULTI     : retcode := retcode * lexem.value;
              hIOP_A_DIV       : retcode := retcode / lexem.value;
              hIOP_A_MOD       : retcode := retcode mod lexem.value;
              hIOP_A_OR        : retcode := retcode or  lexem.value;
              hIOP_A_AND       : retcode := retcode and lexem.value;
              hIOP_A_XOR       : retcode := retcode xor lexem.value;
              hIOP_OR          : if(retcode | lexem.value) then
                                   retcode := 1;
                                 else
                                   retcode := 0;
                                 end_if;
              hIOP_AND         : if(retcode & lexem.value) then
                                   retcode := 1;
                                 else
                                   retcode := 0;
                                 end_if;
              hIOP_SMALLER     : if(retcode < lexem.value) then
                                   retcode := 1;
                                 else
                                   retcode := 0;
                                 end_if;
              hIOP_SMALLEREQUAL: if(retcode <= lexem.value) then
                                   retcode := 1;
                                 else
                                   retcode := 0;
                                 end_if;
              hIOP_EQUAL       : if(retcode = lexem.value) then
                                   retcode := 1;
                                 else
                                   retcode := 0;
                                 end_if;
              hIOP_BIGGER      : if(retcode > lexem.value) then
                                   retcode := 1;
                                 else
                                   retcode := 0;
                                 end_if;
              hIOP_BIGGEREQUAL : if(retcode >= lexem.value) then
                                   retcode := 1;
                                 else
                                   retcode := 0;
                                 end_if;
              hIOP_NOTEQUAL    : if(retcode <> lexem.value) then
                                   retcode := 1;
                                 else
                                   retcode := 0;
                                 end_if;
              else               C_Error := 1; 
                                 run     := false;
            end_case;
          end_if;
          
        else 
          C_Error := 2;
      end_case;
    
    else
      run := false;
    end_if;
  
  end_while;
  
END_FUNCTION

FUNCTION GLOBAL HmiChkBitList::FreeMem

  Free();

END_FUNCTION

FUNCTION GLOBAL HmiChkBitList::GetChkBitIndex
	VAR_INPUT
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := 16#FFFFFFFF;
  if(name <> nil) then
    retcode := Label.GetNoByName(name);
  end_if; 
  
END_FUNCTION
