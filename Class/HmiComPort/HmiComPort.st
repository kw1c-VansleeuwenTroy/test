//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "HmiComPort"
	Revision           = "0.16"
	GUID               = "{FF891D88-15AD-4F19-8106-E8E8C4CA74EE}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{D37B9BB5-9371-4811-B09E-A4C0424127E7}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorCnt" GUID="{07A1A5B1-7F12-46DC-8733-190FC88F8611}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="RetryCnt" GUID="{9E0BAA7B-365A-451D-8BD9-D810631C53B8}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="RxData" GUID="{2E0547EB-9B30-44EB-B3A7-EE61FFD7AB91}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="TxData" GUID="{1007954A-F996-451A-B3DA-62922BCBB987}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="CoSys" Required="false" Internal="false"/>
		<Client Name="File" Required="true" Internal="true"/>
		<Client Name="StdLib" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.16" Date="2019-07-08" Author="kolott" Company="sigmatek" Description="Measurenent of Humidity supported"/>
		<Dokumentation Revision="0.15" Date="2017-11-30" Author="kolott" Company="sigmatek" Description="sa39546: betterment in method UpdateString() to skip too much data"/>
		<Dokumentation Revision="0.14" Date="2016-04-11" Author="kolott" Company="sigmatek" Description="new method GetHardwareDataEx() to get ProductName from HMI as well"/>
		<Dokumentation Revision="0.13" Date="2016-02-08" Author="kolott" Company="sigmatek" Description="Command to get Data fron HMI (ComCMD_ASK_VARIABLE) will work"/>
		<Dokumentation Revision="0.12" Date="2015-11-20" Author="kolott" Company="sigmatek" Description="new virtual method RecieveExtentionData() to get access to userdefined data sent from hmi"/>
		<Dokumentation Revision="0.11" Date="2015-06-02" Author="kolott" Company="sigmatek" Description="correction in method SaveScreenShot() to ensure correct pixel in right column of image"/>
		<Dokumentation Revision="0.10" Date="2015-03-17" Author="kolott" Company="sigmatek" Description="new Method GetVariable()"/>
		<Dokumentation Revision="0.9" Date="2014-11-27" Author="kolott" Company="sigmatek" Description="ensure ability of different physical connections to hmi than can-bus"/>
		<Dokumentation Revision="0.8" Date="2014-06-13" Author="kolott" Company="sigmatek" Description="new Method SendData()"/>
		<Dokumentation Revision="0.7" Date="2014-04-24" Author="kolott" Company="sigmatek" Description="new Method SendRestartSetup()"/>
		<Dokumentation Revision="0.6" Date="2014-03-04" Author="kolott" Company="sigmatek" Description="new Method GetNode()"/>
		<Dokumentation Revision="0.5" Date="2014-02-21" Author="kolott" Company="sigmatek" Description="new Method GetHwVersion(), GetSwVersion()"/>
		<Dokumentation Revision="0.4" Date="2014-02-13" Author="kolott" Company="sigmatek" Description="innovation"/>
		<Dokumentation Revision="0.3" Date="2014-02-12" Author="kolott" Company="sigmatek" Description="new command LastUsage of HMI implemented"/>
		<Dokumentation Revision="0.1" Date="2014-01-16" Author="kolott" Company="sigmatek" Description="some needfull methods added"/>
	</RevDoku>
	<Network Name="HmiComPort">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "File"
				GUID       = "{AF8E049A-1A36-4D27-B348-4C302BD7400E}"
				Class      = "HmiFile"
				Position   = "(180,450)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="OpSysFile"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.File" Destination="File.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
HmiComPort : CLASS
	TYPE
#pragma pack(push, 1)
	  _HMI35_HWINFO : STRUCT
	    Version : UINT;
	    FlashSize : UDINT;
	    RamSize : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  TFileData : STRUCT
	    command : USINT;
	    flashid : UINT;
	    data : ARRAY [0..1] OF DINT;
	  END_STRUCT;
#pragma pack(pop)
	  TPLseEasy : ^LseEasy;
	  TRxTimeout :
	  (
	    RxDelayStandard,
	    RxDelayFlashWrite,
	    RxDelayFlashKill
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	RxData 	: SvrCh_UDINT;
	TxData 	: SvrCh_UDINT;
	ErrorCnt 	: SvrCh_UDINT;
	RetryCnt 	: SvrCh_UDINT;
  //Clients:
	CoSys 	: CltChCmd_System;
	File 	: CltChCmd_HmiFile;
	StdLib 	: CltChCmd__StdLib;
  //Variables:
		PHmi 	: TPLseEasy;
		PScreenshot 	: ^void;
		HmiData : ARRAY [0..10] OF UDINT;

		HmiDataUpd : ARRAY [0..10] OF UDINT;

		LastTxTix 	: UDINT;
		HwData 	: _HMI35_HWINFO;
		RetryNo 	: UDINT;
		ProductName : ARRAY [0..17] OF CHAR;

  //Functions:
	
	FUNCTION HmiComPort
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendReset
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendRun
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to call individual screen on hmi&#13;&#10;screenno ... number of screen where to go" Name="SendGotoScreen"/>
	FUNCTION VIRTUAL GLOBAL SendGotoScreen
		VAR_INPUT
			screenno 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendFormatFlash
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendFile
		VAR_INPUT
			fileid 	: UDINT;
			size 	: UDINT;
			ptr 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetFileCrc
		VAR_INPUT
			fileid 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateData
		VAR_INPUT
			varno 	: UDINT;
			value 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateString
		VAR_INPUT
			varno 	: UDINT;
			puni 	: ^UINT;
			bytesize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ShowProgressBar
		VAR_INPUT
			percentage 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Start
		VAR_INPUT
			pthis 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetBacklightInfo
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
				//! <Function Comment="method is used to turn on (1) or off (0) backlight of hmi" Name="SendBacklightOnOff"/>
	FUNCTION VIRTUAL GLOBAL SendBacklightOnOff
		VAR_INPUT
			state 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to send duration for &quot;displaybacklight off&quot; in milliseconds to hmi (screensaver)&#13;&#10;each value &lt; 1000 will be treated as &quot;eternal backlight on&quot;" Name="SendBacklightTimeOff"/>
	FUNCTION VIRTUAL GLOBAL SendBacklightTimeOff
		VAR_INPUT
			time_ms 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to dim backlight of hmi&#13;&#10;use value from 0 (faded) to 100 (bright)" Name="SendBacklightDim"/>
	FUNCTION VIRTUAL GLOBAL SendBacklightDim
		VAR_INPUT
			state 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateHwInfo
		VAR_INPUT
			pdat 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetHardwareData
		VAR_INPUT
			pversion 	: ^UINT;
			psize_ram 	: ^UDINT;
			psize_flash 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetHardwareDataEx
		VAR_INPUT
			pversion 	: ^UINT;
			psize_ram 	: ^UDINT;
			psize_flash 	: ^UDINT;
			pname 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendAliveTrigger
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendHwData
		VAR_INPUT
			phwdat 	: ^_HMI35_HWINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendReboot
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendNewFirmware
		VAR_INPUT
			pbinary 	: ^void;
			length 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Ping
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to send data to trend in hmi&#13;&#10;id ...... id of trend in hmi (0,1)&#13;&#10;pdata ... pointer to data (0-255)&#13;&#10;length .. number of data to send&#13;&#10;" Name="SendTrendValue"/>
	FUNCTION VIRTUAL GLOBAL SendTrendValue
		VAR_INPUT
			id 	: UDINT;
			pdata 	: ^USINT;
			length 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="methode is used to get screenshot from hmi&#13;&#10;dpne .... drive:path\name.extention of bmp-file which will be created on plc" Name="GetScreenShot"/>
	FUNCTION VIRTUAL GLOBAL GetScreenShot
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION MemorizeScreenshot
		VAR_INPUT
			pdata 	: ^USINT;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaveScreenshot
		VAR_INPUT
			dpne 	: ^CHAR;
			pscrshot 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Run;
	
	FUNCTION VIRTUAL GLOBAL SendChkTraceView
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetSwVersion
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetHwVersion
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetNode
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendStateBit
		VAR_INPUT
			no 	: UINT;
			value 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SendRestartSetup
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SendData
		VAR_INPUT
			src 	: ^void;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION Update
		VAR_INPUT
			ima 	: UDINT;
			value 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL RecieveData
		VAR_INPUT
			pdata 	: ^USINT;
			size 	: UDINT;
		END_VAR;
	
	FUNCTION RxDataWaitFor
		VAR_INPUT
			pdata 	: ^UDINT;
			ima 	: UDINT;
			crc 	: UDINT;
			timeout 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION RxDataStart
		VAR_INPUT
			ima 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GetHardwareDataSub
		VAR_INPUT
			pversion 	: ^UINT;
			psize_ram 	: ^UDINT;
			psize_flash 	: ^UDINT;
			pname 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL SendDataIntern
		VAR_INPUT
			src 	: ^void;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Get timeout in milliseconds to wait for rx-data" Name="GetRxTimeout"/>
	FUNCTION VIRTUAL GetRxTimeout
		VAR_INPUT
			index 	: TRxTimeout;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL PerformRetry
		VAR_INPUT
			success 	: BOOL;
			retry 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
				//! <Function Comment="method is used to ask hmi for value of any variable.&#13;&#10;value .,,.. address of data where value should be written&#13;&#10;varno ..... number of variable&#13;&#10;&#13;&#10;method will return &apos;true&apos; on success, otherwise &apos;false&apos;&#13;&#10;&#13;&#10;note: functionality of method requires firmwareversion &gt;= 1.30&#13;&#10;to determine firmwareversion use server LseEasy.HmiSwVersion or following snippet&#13;&#10;&#13;&#10;var&#13;&#10;  version : dint;&#13;&#10;end_var&#13;&#10;&#13;&#10;if(ComPort.GetVariable(#version, VARNO_SWVERSION) = true) then&#13;&#10;  if(version &gt;= 130) then&#13;&#10;    // firmwareversion &gt;= 1.30&#13;&#10;  end_if;&#13;&#10;end_if;&#13;&#10;" Name="GetVariable"/>
	FUNCTION VIRTUAL GLOBAL GetVariable
		VAR_INPUT
			value 	: ^DINT;
			varno 	: UINT;
		END_VAR
		VAR_OUTPUT
			success 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to get access to userdefined data sent from hmi&#13;&#10;pdata .... pointer to data&#13;&#10;size ..... lenght of data in byte" Name="RecieveExtentionData"/>
	FUNCTION VIRTUAL RecieveExtentionData
		VAR_INPUT
			pdata 	: ^USINT;
			size 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateHwInfoEx
		VAR_INPUT
			pdat 	: ^void;
			size 	: UDINT;
		END_VAR;
	
	FUNCTION UpdateTemp
		VAR_INPUT
			pdata 	: ^USINT;
			size 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using HmiFile
#pragma usingLtd _StdLib
#pragma usingLtd System


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiComPort::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMICOMPORT
0$UINT, 16$UINT, (SIZEOF(::HmiComPort))$UINT, 
5$UINT, 3$UINT, 0$UINT, 
TO_UDINT(136722037), "HmiComPort", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiComPort.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::HmiComPort.RxData.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1120226718), "RxData", 
(::HmiComPort.TxData.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2493296259), "TxData", 
(::HmiComPort.ErrorCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(987008716), "ErrorCnt", 
(::HmiComPort.RetryCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2012947345), "RetryCnt", 
//Clients:
(::HmiComPort.CoSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3991399253), "CoSys", TO_UDINT(968218125), "System", 0$UINT, 1$UINT, 
(::HmiComPort.File.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3121273764), "File", TO_UDINT(2548286290), "HmiFile", 0$UINT, 4$UINT, 
(::HmiComPort.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_HmiComPort 37

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiComPort] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiComPort::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_HmiComPort, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #SendReset();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #SendRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #SendGotoScreen();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #SendFormatFlash();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #SendFile();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #GetFileCrc();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #UpdateData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #UpdateString();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ShowProgressBar();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #GetBacklightInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #SendBacklightOnOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #SendBacklightTimeOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #SendBacklightDim();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #UpdateHwInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetHardwareData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #GetHardwareDataEx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #SendAliveTrigger();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #SendHwData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #SendReboot();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #SendNewFirmware();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #Ping();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #SendTrendValue();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #GetScreenShot();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #SaveScreenshot();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #SendChkTraceView();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #GetSwVersion();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #GetHwVersion();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #GetNode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #SendStateBit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #SendRestartSetup();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #SendDataIntern();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #GetRxTimeout();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #PerformRetry();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #GetVariable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #RecieveExtentionData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #UpdateHwInfoEx();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HmiComPort();

END_FUNCTION

#pragma usingLtd LseEasy

//{{LSL_IMPLEMENTATION
#includeC "..\LseEasy\MiniSrcData.h"

#pragma usingLtd LseEasy

#define UPD_HW_VER                0
#define UPD_SW_VER                1
#define UPD_CRC                   2
#define UPD_FLASHREADY            3
#define UPD_FLASHERROR            4
#define UPD_HMI35HWINFO           5
#define UPD_ALIVE                 6
#define UPD_BACKLIGHTINFO         7
#define UPD_UPDATEVARIABLE        8

FUNCTION HmiComPort::HmiComPort
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code    := C_OK;
  PHmi        := nil;
  PScreenshot := nil;
  RetryNo     := 0;  // no retrys

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::UpdateData
	VAR_INPUT
		varno 	: UDINT;
		value 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  VAR
  	tmp : array[0..5] of usint;
  END_VAR

  tmp[0]      := ComCMD_UPDATE;
  tmp[1]$uint := varno$uint;
  tmp[3]$dint := value;
  retcode     := SendData(#tmp[0], 7);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::UpdateString
	VAR_INPUT
		varno 	: UDINT;
		puni 	: ^UINT;
		bytesize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  VAR
  	tmp : array[0..150] of usint;
  END_VAR

  retcode := false;
  if((bytesize + 3) <= sizeof(tmp)) then
    tmp[0]      := ComCMD_UPDATESTRING;
    tmp[1]$uint := varno$uint;
    _memcpy(#tmp[3], puni, bytesize);
    retcode := SendData(#tmp[0], bytesize + 3);
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendReset
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  VAR
  	command : usint;
  END_VAR
  
  command := COMCMD_RESET;
  retcode := SendData(#command, 1);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendRestartSetup
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  VAR
  	command : usint;
  END_VAR

  command := COMCMD_RESTARTSETUP;
  retcode := SendData(#command, 1);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendReboot
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	command : usint;
  END_VAR

  command := ComCMD_REBOOT;
  retcode := SendData(#command, 1);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendRun
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  VAR
  	command : usint;
  END_VAR

  command  := ComCMD_RUN;
  retcode  := SendData(#command, 1);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendFormatFlash
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  VAR
  	command : usint;
    crc : udint;
  END_VAR

  retcode := false;
  command := ComCMD_FLASHKILL;
  
  crc := RxDataStart(UPD_FLASHREADY);
  if(SendData(#command, 1) = true) then
    retcode := RxDataWaitFor(nil, UPD_FLASHREADY, crc, GetRxTimeout(RxDelayFlashKill));
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendGotoScreen
	VAR_INPUT
		screenno 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR  
  	tmp : array[0..3] of usint;
  END_VAR

  if(screenno < 0) then
    tmp[0]      := COMCMD_SCREENRETURN;
    retcode := SendData(#tmp[0], 1);
  else
    tmp[0]      := COMCMD_SCREEN;
    tmp[1]$uint := screenno$uint;
    retcode := SendData(#tmp[0], 3);
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendFile
	VAR_INPUT
		fileid 	: UDINT;
		size 	: UDINT;
		ptr 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: bool;
  END_VAR
  VAR
  	ph : ^TFileData;
    crc : udint;
    delay, tix : udint;
    retry : udint;
  END_VAR

  retcode := false;
  
  ph$^void := StdLib.MallocV1(size + 3, 0);
  if(ph <> nil) then
    _memcpy(#ph^.data[0], ptr, size);
    ph^.command := ComCMD_FLASHWRITE;
    ph^.flashid := fileid$uint;
    
    retry := 0;
    repeat
      
      crc := RxDataStart(UPD_FLASHREADY);
      if(SendData(ph, size+3) = true) then
        // WaitBusy();
      
        delay := (GetRxTimeout(RxDelayFlashWrite) * size) / 153000;
        if(delay < 7500) then
          delay := 7500;
        end_if;
      
        tix := ops.tabsolute;
        retcode := RxDataWaitFor(nil, UPD_FLASHREADY, crc, delay);
      end_if;
        
    until(PerformRetry(retcode, #retry)) end_repeat;
      
    StdLib.Free(ph);
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::ShowProgressBar
	VAR_INPUT
		percentage 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  VAR
  	tmp : array[0..1] of usint;
  END_VAR

  retcode := true;
  tmp[0] := ComCMD_PROGRESSBAR;
  tmp[1] := percentage;
  SendData(#tmp[0], 2);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::Start
  VAR_INPUT
    pthis : ^void;
  END_VAR
  
  PHmi                       := pthis$TPLseEasy;
  HmiData[UPD_BACKLIGHTINFO] := 0xFFFFFFFF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendBacklightOnOff
	VAR_INPUT
		state 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmp : array[0..1] of usint;
  END_VAR

  tmp[0] := ComCMD_BACKLIGHT;
  tmp[1] := 1;
  if(state = 0) then
    tmp[1] := 0;
  end_if;
  retcode := SendData(#tmp, 2);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendBacklightDim
	VAR_INPUT
		state 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmp : array[0..1] of usint;
  END_VAR

  tmp[0] := ComCMD_BACKLIGHTDIM;
  if(state > 100) then
    state := 100;
  end_if;
  tmp[1] := state;
  retcode := SendData(#tmp, 2);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendBacklightTimeOff
	VAR_INPUT
		time_ms 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmp : array[0..3] of usint;
  END_VAR

  tmp[0] := ComCMD_BACKLIGHTTIME;
  tmp[1]$UINT := to_UINT(time_ms / 1000);
  retcode := SendData(#tmp, 3);

END_FUNCTION

FUNCTION VIRTUAL HmiComPort::PerformRetry
	VAR_INPUT
		success 	: BOOL;
		retry 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retry^ += 1;

  retcode := 0;
  if(success = true) then
    retcode := 1;  // no furthermore retry
  else
    if(retry^ <= RetryNo) then
      RetryCnt += 1;
    else
      retcode := 1;  // no furthermore retry
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::GetFileCrc
	VAR_INPUT
		fileid 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	tmp : array[0..3] of usint;
    crc, retry : udint;
    success : bool;
  END_VAR

  // return: 0............... did not get crc from hmi
  // return: 16#FFFFFFFF .... file in hmi not present
  // return: any other value is valid crc
  
  retcode     := 0;
  success     := false;
  tmp[0]      := ComCMD_ASK_FILE_CRC;
  tmp[1]$uint := fileid$uint;
  
  retry := 0;
  repeat
    crc := RxDataStart(UPD_CRC);
    if(SendData(#tmp[0], 3) = true) then
      success := RxDataWaitFor(#retcode, UPD_CRC, crc, GetRxTimeout(RxDelayStandard));
    end_if;
  until(PerformRetry(success, #retry)) end_repeat;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::GetVariable
	VAR_INPUT
		value 	: ^DINT;
		varno 	: UINT;
	END_VAR
	VAR_OUTPUT
		success 	: BOOL;
	END_VAR
  VAR
  	tmp : array[0..3] of usint;
    crc, retry : udint;
  END_VAR

  // return: 16#FFFFFFFF .... file in hmi not present
  
  success     := false;
  tmp[0]      := ComCMD_ASK_VARIABLE;
  tmp[1]$uint := varno;
  
  retry := 0;
  repeat
    crc := RxDataStart(UPD_UPDATEVARIABLE);
    if(SendData(#tmp[0], 3) = true) then
      success := RxDataWaitFor(value$^udint, UPD_UPDATEVARIABLE, crc, GetRxTimeout(RxDelayStandard));
    end_if;
  until(PerformRetry(success, #retry)) end_repeat;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::GetBacklightInfo
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR
  VAR
  	tmp : usint;
    crc : udint;
    state : udint;
  END_VAR

  retcode := 16#FF;
  if(HmiData[UPD_BACKLIGHTINFO] <> 16#FFFFFFFF) then
    retcode := HmiData[UPD_BACKLIGHTINFO]$usint;
  else
    tmp := COMCMD_ASK_BACKLIGHTINFO;
    crc := RxDataStart(UPD_BACKLIGHTINFO);
    if(SendData(#tmp, 1) = true) then
      if(RxDataWaitFor(#state, UPD_BACKLIGHTINFO, crc, GetRxTimeout(RxDelayStandard)) = true) then
        retcode := state$usint;
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::UpdateHwInfo
	VAR_INPUT
		pdat 	: ^void;
	END_VAR

  HwData := pdat$^_HMI35_HWINFO^;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::UpdateHwInfoEx
	VAR_INPUT
		pdat 	: ^void;
    size : udint;
	END_VAR
  VAR
  	len : udint;
    ptx : ^char;
  END_VAR

  UpdateHwInfo(pdat);
  ProductName[0] := 0;
  if(size > sizeof(_HMI35_HWINFO)) then
    ptx := pdat$^char+sizeof(_HMI35_HWINFO);
    len := _strlen(ptx);
    if(len < sizeof(ProductName)) then
      _strcpy(#ProductName[0], ptx);
    end_if;
  end_if;
  Update(UPD_HMI35HWINFO, size);
  
END_FUNCTION

FUNCTION HmiComPort::GetHardwareDataSub
	VAR_INPUT
		pversion 	: ^UINT;
		psize_ram 	: ^UDINT;
		psize_flash 	: ^UDINT;
		pname 	: ^char;
	END_VAR

  if(pversion <> NIL) then
    pversion^ := HwData.Version;
  end_if;
  if(psize_ram <> NIL) then
    psize_ram^ := HwData.RamSize;
  end_if;
  if(psize_flash <> NIL) then
    psize_flash^ := HwData.FlashSize;
  end_if;
  if(pname <> NIL) then
    _strcpy(pname, #ProductName[0]);
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::GetHardwareDataEx
	VAR_INPUT
		pversion 	: ^uint;
		psize_ram 	: ^udint;
		psize_flash 	: ^udint;
		pname 	: ^char;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmp : array[0..1] of usint;
    crc, retry : udint;
  END_VAR

  retcode := false;
  tmp[0]  := COMCMD_ASK_HARDWAREDATA;
  
  retry := 0;
  repeat
    crc := RxDataStart(UPD_HMI35HWINFO);
    if(SendData(#tmp[0], 1) = true) then
      if(RxDataWaitFor(NIL, UPD_HMI35HWINFO, crc, GetRxTimeout(RxDelayStandard)) = true) then
        GetHardwareDataSub(pversion, psize_ram, psize_flash, pname);
        retcode := true;
      end_if;
    end_if;
  until(PerformRetry(retcode, #retry)) end_repeat;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::GetHardwareData
	VAR_INPUT
		pversion 	: ^uint;
		psize_ram 	: ^udint;
		psize_flash 	: ^udint;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := GetHardwareDataEx(pversion, psize_ram, psize_flash, NIL);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendAliveTrigger
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	data : usint;
  END_VAR

  retcode := true;
  if((ops.tAbsolute - LastTxTix) > 1000) then
    data    := ComCMD_ALIVE;
    retcode := SendData(#data, 1);
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendHwData
	VAR_INPUT
		phwdat 	: ^_HMI35_HWINFO;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	data : array[0..30] of usint;
  END_VAR

  data[0] := COMCMD_HARDWAREDATA;
  _memcpy(#data[1], phwdat, sizeof(_HMI35_HWINFO));
  retcode := SendData(#data[0], sizeof(_HMI35_HWINFO)+1);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendNewFirmware
	VAR_INPUT
		pbinary 	: ^void;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	command : usint;
    tix : udint;
  END_VAR
  
  retcode := false;
  
  command := COMCMD_UPDATESOFTWARE;
  if(SendData(#command, 1) = true) then
    tix := ops.tAbsolute;
    while((ops.tAbsolute - tix) < 1000) do
    end_while;
    
    retcode := SendData(pbinary, length);
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::Ping
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  VAR
  	command : usint;
    crc : udint;
  END_VAR

  retcode := false;
  command := ComCMD_ASK_ALIVE;
  
  // no retry at ping, ping will be done continously when hmi is unreachable
  crc := RxDataStart(UPD_ALIVE);
  if(SendData(#command, 1) = true) then
    retcode := RxDataWaitFor(nil, UPD_ALIVE, crc, GetRxTimeout(RxDelayStandard));
  end_if;
 
END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendTrendValue
	VAR_INPUT
		id 	: UDINT;
		pdata 	: ^USINT;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	data : array[0..329] of usint;
  END_VAR

  retcode := false;
  if(id <= 1) then
    if(length = 1) then
      data[0] := ComCMD_UPDATETREND0_SINGLE;
      if(id <> 0) then
        data[0] := ComCMD_UPDATETREND1_SINGLE;
      end_if;
      
      data[1] := pdata^;
      retcode := SendData(#data[0], 2);
    else
      if(length > 320) then
        pdata += length - 320; // skip old data in buffer
        length := 320;
      end_if;
      data[0] := ComCMD_UPDATETREND0;
      if(id <> 0) then
        data[0] := ComCMD_UPDATETREND1;
      end_if;
      
      data[1]$uint := length$uint;
      _memcpy(#data[3], pdata, length);
      retcode := SendData(#data[0], length + 3);
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendStateBit
	VAR_INPUT
		no 	: UINT;
		value 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmp : array[0..2] of usint;
  END_VAR

  // bit 0 ... 0...invisible, 1...visible
  // bit 1 ... 0...writeprotected, 1...writeenable
  // to be continued...

  tmp[0]  := ComCMD_UPDATESTATEBIT;
  tmp[1]  := no$usint;
  tmp[2]  := value;
  retcode := SendData(#tmp[0], 3);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::GetScreenShot
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmp : array[0..1] of usint;
//    crc : udint;
  END_VAR

  retcode := false;
  tmp[0]  := COMCMD_ASK_SCREENSHOT;
  
//  crc := RxDataStart(UPD_HMI35SCREENSHOT);
  if(SendData(#tmp[0], 1) = true) then
//    if(RxDataWaitFor(NIL, UPD_HMI35SCREENSHOT, crc, 60000) = true) then
//      retcode := SaveScreenshot(dpne);
//    end_if;
    retcode := true;
  end_if;
END_FUNCTION

FUNCTION HmiComPort::MemorizeScreenshot
	VAR_INPUT
		pdata 	: ^USINT;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  // [] ..... state (0x00 = unkomprimiert, 0xFF=error)
  // [][] ... displaywidth
  // [][] ... displayheight

  retcode := false;
  
  if(PScreenshot <> nil) then
    CoSys.Free(PScreenshot);
    PScreenshot := nil;
  end_if;

  PScreenshot := CoSys.Malloc(size);
  if(Pscreenshot <> nil) then
    _memcpy(PScreenshot, pdata, size);
    retcode := true;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SaveScreenshot
	VAR_INPUT
		dpne 	: ^CHAR;
		pscrshot 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	ph, pup, pdn : ^uint;
    xx, yy, size, hh, bb : udint;
    data : array[0..54] of usint;
    r, g, b : uint;
  END_VAR

  retcode := false;
  
  if(pscrshot <> nil) then
    ph := pscrshot$^uint;
    
    if(ph$^usint^ = 0) then
      ph += 1;
      xx := ph^;  ph += 2;
      yy := ph^;  ph += 2;

      // convert 565-color to 555-color
      size := xx * yy;
      pup  := ph;
      while(size) do
        r := pup^;
        b := r and 16#001F;
        g := (r shr 1) and 16#03E0;
        r := (r shr 1) and 16#7C00;
      
        pup^ := (r or g or b);
        pup += 2;
        size -= 1;
      end_while;

      // turn image upside down
      hh  := yy / 2;
      pup := ph;
      pdn := pup + yy * xx * 2;
      while(hh) do
        hh  -= 1;
        bb  := xx;
        pdn -= xx * 2;
        while(bb) do
          bb   -= 1;
          r    := pup^;
          pup^ := pdn^;
          pdn^ := r;
          pdn  += 2;
          pup  += 2;
        end_while;
        pdn -= xx * 2;
      end_while;

      // create and write file
      if(File.FOpen(dpne, 'w') = true) then
        data[0]        := 16#42;
        data[1]        := 16#4D;
        data[2]$udint  := (xx * yy * 2) + 54;
        data[6]$uint   := 0;
        data[8]$uint   := 0;
        data[10]$udint := 54;

        data[14]$udint := 40;
        data[18]$udint := xx;
        data[22]$udint := yy;
        data[26]$uint  := 1;
        data[28]$uint  := 16;
        data[30]$udint := 0;
        data[34]$udint := 0;
        data[38]$udint := 0;
        data[42]$udint := 0;
        data[46]$udint := 0;
        data[50]$udint := 0;

        File.FWrite(#data[0], 54);
        File.FWrite(ph, xx * yy * 2);
        retcode := File.FClose();
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL HmiComPort::Run

  if(PScreenshot <> nil) then
    PHmi$^LseEasy^.UpdateScreenshot(PScreenshot);
    CoSys.Free(PScreenshot);
    PScreenshot := nil;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::SendChkTraceView
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    command : usint;
  END_VAR

  command := ComCMD_ERROR_TRACEVIEW;
  retcode := SendData(#command, 1);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::GetSwVersion
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	tmp : usint;
    crc, state, retry : udint;
    success : bool;
  END_VAR

  retcode := 0;

  tmp     := COMCMD_ASK_SW_VER;
  success := false;
  retry   := 0;
  repeat
    crc := RxDataStart(UPD_SW_VER);
    if(SendData(#tmp, 1) = true) then
      if(RxDataWaitFor(#state, UPD_SW_VER, crc, GetRxTimeout(RxDelayStandard)) = true) then
        retcode := state$udint;
        success := true;
      end_if;
    end_if;
  until(PerformRetry(success, #retry)) end_repeat;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::GetHwVersion
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	tmp : usint;
    crc, state, retry : udint;
    success : bool;
  END_VAR

  retcode := 0;
  tmp     := COMCMD_ASK_HW_VER;
  success := false;
  retry   := 0;
  repeat
    crc := RxDataStart(UPD_HW_VER);
    if(SendData(#tmp, 1) = true) then
      if(RxDataWaitFor(#state, UPD_HW_VER, crc, GetRxTimeout(RxDelayStandard)) = true) then
        retcode := state$udint;
        success := true;
      end_if;
    end_if;
  until(PerformRetry(success, #retry)) end_repeat;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HmiComPort::GetNode
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := 0;

END_FUNCTION

#pragma warning (disable : 73)
FUNCTION VIRTUAL HmiComPort::GetRxTimeout
	VAR_INPUT
		index 	: TRxTimeout;
	END_VAR
	VAR_OUTPUT
		retcode 	: udint;
	END_VAR
  
  retcode := 100;

END_FUNCTION
#pragma warning (default : 73)

#pragma warning (disable : 73)
FUNCTION VIRTUAL HmiComPort::SendDataIntern
	VAR_INPUT
		src 	: ^void;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := false;
  
END_FUNCTION
#pragma warning (default : 73)

FUNCTION GLOBAL HmiComPort::SendData
	VAR_INPUT
		src 	: ^void;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := true;
  if((size > 0) & (src <> nil)) then
  
    retcode := SendDataIntern(src, size);
    
    if(retcode = true) then
      TxData    += 1;
      LastTxTix := ops.tAbsolute;
    else
      ErrorCnt += 1;
    end_if;
  end_if;
  
END_FUNCTION
  
FUNCTION HmiComPort::RxDataStart
	VAR_INPUT
		ima 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := HmiDataUpd[ima];

END_FUNCTION
  
FUNCTION HmiComPort::RxDataWaitFor
	VAR_INPUT
		pdata 	: ^UDINT;
		ima 	: UDINT;
		crc 	: UDINT;
		timeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tix : udint;
  END_VAR

  retcode := true;
  tix     := ops.tAbsolute;
  while((ops.tAbsolute - tix) < timeout) do
    if(crc <> HmiDataUpd[ima]) then
      exit;
    end_if;
  end_while;

  if(crc <> HmiDataUpd[ima]) then
    if(pdata <> nil) then
      pdata^ := HmiData[ima]; 
    end_if;
  else
    retcode := false;
    ErrorCnt += 1;
  end_if;

END_FUNCTION  
    
FUNCTION HmiComPort::Update
	VAR_INPUT
		ima 	: UDINT;
		value 	: UDINT;
	END_VAR

  if(ima < (sizeof(HmiData) / sizeof(HmiData[0]))) then
    HmiData[ima]    := value;
    HmiDataUpd[ima] += 1;
  end_if;

END_FUNCTION  
  
FUNCTION HmiComPort::UpdateTemp
	VAR_INPUT
		pdata 	: ^USINT;
		size 	: UDINT;
	END_VAR

  PHmi^.UpdateTemperature35(pdata$^dint^);
  if(size >= 6) then
    PHmi^.UpdateHumidity35((pdata+4)$^int^);
  end_if;
  
END_FUNCTION  
  
FUNCTION GLOBAL HmiComPort::RecieveData
	VAR_INPUT
		pdata 	: ^USINT;
		size 	: UDINT;
	END_VAR
  VAR
  	ccc : usint;
  END_VAR

  RxData += 1;

  if(PHmi <> nil) then

    ccc   := pdata^;
    pdata += 1;
    
    case ccc of
     COMCMD_UPDATESTRINGASCII : PHmi^.UpdateString35(pdata$^uint^, pdata+2, 1);
                                PHmi^.UpdateAliveSignal35(); // alivetrigger
     COMCMD_UPDATESTRING      : PHmi^.UpdateString35(pdata$^uint^, pdata+2, 2);
                                PHmi^.UpdateAliveSignal35(); // alivetrigger
     ComCMD_UPDATE            : PHmi^.UpdateValue35(pdata$^uint^, (pdata+2)$^dint^);
                                PHmi^.UpdateAliveSignal35(); // alivetrigger
     ComCMD_TEMP              : UpdateTemp(pdata, size-1);
                                PHmi^.UpdateAliveSignal35(); // alivetrigger
     ComCMD_HMI_INUSE         : PHmi^.UpdateInUse();
                                PHmi^.UpdateAliveSignal35(); // alivetrigger
     ComCMD_ALIVE             : Update(UPD_ALIVE, pdata$^udint^);
                                PHmi^.UpdateAliveSignal35(); // alivetrigger
     ComCMD_ACTSCREEN         : PHmi^.UpdateActScreen(pdata$^uint^);
     ComCMD_HW_VER            : Update(UPD_HW_VER, pdata$^udint^);
     ComCMD_SW_VER            : Update(UPD_SW_VER, pdata$^udint^);
     ComCMD_FILE_CRC          : Update(UPD_CRC, pdata$^udint^);
     ComCMD_FLASHDATAREADY    : Update(UPD_FLASHREADY, pdata$^udint^);
     ComCMD_FLASHDATAERROR    : Update(UPD_FLASHERROR, pdata$^udint^);
     ComCMD_HARDWAREDATA      : UpdateHwInfoEx(pdata, size-1);
     COMCMD_BACKLIGHTINFO     : Update(UPD_BACKLIGHTINFO, pdata$^usint^);
     ComCMD_UPDATEVARIABLE    : Update(UPD_UPDATEVARIABLE, (pdata+2)$^udint^);
                                PHmi^.UpdateValue35(pdata$^uint^, (pdata+2)$^dint^);
     ComCMD_SCREENSHOT        : MemorizeScreenshot(pdata, size-1);
     ComCMD_RUN               : PHmi^.UpdateAll(pdata$^udint^);
                                PHmi^.UpdateAliveSignal35(); // alivetrigger
     ComCMD_USERCALL          : PHmi^.UserCall(pdata$^uint^, (pdata+2)$^dint^);
                                PHmi^.UpdateAliveSignal35(); // alivetrigger
     ComCMD_EXTENTION         : RecieveExtentionData(pdata, size-1);
    end_case;
  end_if;

END_FUNCTION  

FUNCTION VIRTUAL HmiComPort::RecieveExtentionData
	VAR_INPUT
   #pragma warning (disable : 73)
		pdata 	: ^USINT;
		size 	: UDINT;
   #pragma warning (default : 73)
	END_VAR


END_FUNCTION
