//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_AlarmDisplay"
	Revision           = "0.11"
	GUID               = "{FC597403-EBE4-11D6-8BC9-0048545E8899}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "class is used to display list of alarms">
	<Channels>
		<Server Name="Acknowledge" GUID="{7FFC4C42-F15A-11D6-8BC9-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="-1: quit all/ any other value: quit selected"/>
		<Server Name="Delete" GUID="{7FFC4C43-F15A-11D6-8BC9-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="0-...: delete single line&#13;&#10;-1: delete all, according filtersettings and alarmstate&#13;&#10;-2: delete all, regardless any settings &#13;&#10;-3: delete all entris up to last POWER_ON Line&#13;&#10;"/>
		<Server Name="NoActive" GUID="{B3130461-F86D-11D6-8BC9-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="number of active entries"/>
		<Server Name="Server0">
		</Server>
		<Server Name="SortAlgorithm" GUID="{D64CF382-ECA3-11D6-8BC9-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="0: no sort/ any other value look for methode Sort"/>
		<Client Name="cDpne" Required="false" Internal="false"/>
		<Client Name="Filter" Required="true" Internal="false"/>
		<Client Name="HistoryTemporary" Required="true" Internal="false" Comment="0...history/1...temporary"/>
		<Client Name="MaxNo" Required="true" Internal="false" Comment="max size of entrys in ringbuffer"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.11" Date="2019-05-13" Author="kolott" Company="sigmatek" Description="sa42518: new client &quot;cDpne&quot; to give Drive Path Name and Extention of Historyfile"/>
		<Dokumentation Revision="0.10" Date="2017-11-22" Author="kolott" Company="sigmatek" Description="sa39401: Writing -2 to server &apos;Delete&apos; will delete all entrys from list without taking care of any Alarmstate and Filtersetting.&#13;&#10;sa39254: Filterbit &quot;POWER_ON&quot; implemented. Writing -3 to server &apos;Delete&apos; will delete all entris up to last POWER_ON Line "/>
		<Dokumentation Revision="0.9" Date="2016-05-12" Author="kolott" Company="sigmatek" Description="sa33569: new virtual Method CreateParameterFilter() added"/>
		<Dokumentation Revision="0.8" Date="2016-03-30" Author="kolott" Company="sigmatek" Description="sa32974: Command Acknowledge -2 added (QuitEx())"/>
		<Dokumentation Revision="0.7" Date="2013-04-04" Author="kolott" Company="sigmatek" Description="ARM-Ready"/>
		<Dokumentation Revision="0.6" Date="2013-01-10" Author="kolott" Company="sigmatek" Description="dr1830: new client to set lineheight in pixel"/>
		<Dokumentation Revision="0.5" Date="2012-12-18" Author="kolott" Company="sigmatek" Description="betterment in sort-function"/>
		<Dokumentation Revision="0.4" Date="2011-09-28" Author="kolott" Company="sigmatek" Description="betterment in datatypeconversion"/>
	</RevDoku>
	<Network Name="_AlarmDisplay">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{FC597408-EBE4-11D6-8BC9-0048545E8899}"
				Class      = "_ScrollArea"
				Position   = "(240,240)"
				Visualized = "true">
				<Channels>
					<Server Name="ActPos"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="ExtendedScrollBar" Value="0"/>
					<Client Name="LineHighness"/>
					<Client Name="LineWidth" Value="1"/>
					<Client Name="Lse"/>
					<Client Name="VerticalLevel" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(998,210),(826,330),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(998,270),(826,390),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(240,330),(38,210),"/>
			<Connection Source="this.ActPos" Destination="_base.ActPos" Vertices="(998,330),(826,450),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _ScrollArea

_AlarmDisplay : CLASS
: _ScrollArea
  //Servers:
	SortAlgorithm 	: SvrCh_DINT;
	Acknowledge 	: SvrCh_DINT;
	Delete 	: SvrCh_DINT;
	NoActive 	: SvrCh_UDINT;
  //Clients:
	HistoryTemporary 	: CltCh_DINT;
	MaxNo 	: CltCh_UDINT;
	Filter 	: CltCh_DINT;
	cDpne 	: CltChCmd_StringInternal;
  //Variables:
		Pms 	: ^_MEM_SINGLEALARM;
		ChangeCnt 	: _UWORD;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when redraw of a single line is necessary.&#13;&#10;ps ..... --&gt; to structure _SCROLL&#13;&#10;pr ..... --&gt; to place where line should be drawn&#13;&#10;line ... number of line which should be drawn&#13;&#10;state .. line ia selected (TRUE) or passive (FALSE)&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to structure _SCROLL" Name="Line.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to place where line should be drawn" Name="Line.pr"/>
			line 	: UINT;			//! <Variable Comment="16 bit linenumber " Name="Line.line"/>
			state 	: BOOL;			//! <Variable Comment="line is selected (true) or passive (false)" Name="Line.state"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL Out
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR;
	
	FUNCTION GetPms;
	
	FUNCTION __CDECL VIRTUAL GLOBAL Sort
		VAR_INPUT
			sortal 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL Store
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when system wants to insert an entry into ringbuffer&#13;&#10;call this methode if you want to add an entry&#13;&#10;if you decide that entry shouldn&apos;t be added, dont call function add_SINGLEALARM() inside&#13;&#10;ptr .... --&gt; to new entry&#13;&#10;at success method returns TRUE, on the other hand FALSE&#13;&#10;" Name="AddEntry"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AddEntry
		VAR_INPUT
			ptr 	: ^_SINGLEALARM;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="Method can be used to change DrivePathName and Extention of File where historydata are filed.&#13;&#10;eg:: retcode := &quot;f:\alahist.dat&quot;" Name="AlarmDPNE"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AlarmDPNE
		VAR_INPUT
			dpne 	: ^_ASCII;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: ^_ASCII;
		END_VAR;
				//! <Function Comment="method is used to create filterbits for each added parameter.&#13;&#10;this filterbits will be used to identify an already occured alarm of same type when confignumbers are equal.&#13;&#10;each parameter is identified by a single bit in retcode&#13;&#10;&#13;&#10;eg.: &#13;&#10;retcode := 3; // 2#00000011 first and second parameter has to be the same to identify same alarmtype.&#13;&#10;retcode := 0; // 2#00000000 all parameters are allowed to be different." Name="CreateParameterFilter"/>
	FUNCTION VIRTUAL CreateParameterFilter
		VAR_INPUT
			ptr 	: ^_SINGLEALARM;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Server0::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SortAlgorithm::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SortAlgorithm::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Acknowledge::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Delete::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL NoActive::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd StringInternal


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _AlarmDisplay::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__ALARMDISPLAY
0$UINT, 11$UINT, (SIZEOF(::_AlarmDisplay))$UINT, 
4$UINT, 4$UINT, 0$UINT, 
TO_UDINT(1738954212), "_AlarmDisplay", //Class
TO_UDINT(3043040051), "_ScrollArea", 0$UINT, 15$UINT, //Baseclass
//Servers:
(::_AlarmDisplay.SortAlgorithm.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1579200915), "SortAlgorithm", 
(::_AlarmDisplay.Acknowledge.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(889253692), "Acknowledge", 
(::_AlarmDisplay.Delete.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3404380929), "Delete", 
(::_AlarmDisplay.NoActive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3780284417), "NoActive", 
//Clients:
(::_AlarmDisplay.HistoryTemporary.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2406933960), "HistoryTemporary", 
(::_AlarmDisplay.MaxNo.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2950632767), "MaxNo", 
(::_AlarmDisplay.Filter.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2403113115), "Filter", 
(::_AlarmDisplay.cDpne.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3388466122), "cDpne", TO_UDINT(2898603620), "StringInternal", 1$UINT, 85$UINT, 
END_FUNCTION


#define USER_CNT__AlarmDisplay 28

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__AlarmDisplay] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _AlarmDisplay::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _ScrollArea::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__AlarmDisplay;
	vmt.CmdTable.Read		:= #Server0::Read();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #Out();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #Sort();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #Store();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #AddEntry();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #AlarmDPNE();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #CreateParameterFilter();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SortAlgorithm.pMeth			:= StoreMethod( #SortAlgorithm::Read(), #SortAlgorithm::Write() );
	IF SortAlgorithm.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Acknowledge.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Acknowledge::Write() );
	IF Acknowledge.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Delete.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Delete::Write() );
	IF Delete.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	NoActive.pMeth			:= StoreMethod( #NoActive::Read(), #M_NO_F() );
	IF NoActive.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma using _Lse


// Server0
// spiegelt die anzahl der einträge

// SortAlgorithm : 
// auf diesen server wird die nummer des gewünschten sort-algorithmus geschrieben. 
// 0 ... liste nicht sortiert
// 1 ... liste wird nach zeit sortiert
// 2 ... liste wird nach aktiv (passive) und zeit sortiert
// 3 ... liste wird nach alarmnummer sortiert
// 4 ... liste wird nach priorität sortiert
// 5 ... liste wird nach zeit sortiert (letzter am ende)

// Delete : 
// bei einem schreibzugriff auf diesen server wird ein 'eintraglöschen' ausgeführt
// prinzipiell werden nur einträge mit acknowledge <> 0 gelöscht
// wird der wert -1 eingetragen werden alle einträge gelöscht (acknowledge beachten)
// bei allen anderen werten wird der aktuell angewählte eintrag gelöscht (acknowledge beachten)

// Acknowledge : 
// selbes prinzip wie Delete, es wird jedoch nicht gelöscht sondern das acknowledge flag auf 1 gesetzt

// NoActive
// spiegelt die anzahl aller einträge mit state <> 0 (anzahl aller aktiven alarme)

// Lse
// muss mit klasse _Lse.Server0 verbunden werden 

// HistoryTemporary : 
// es stehen 2 puffer zur verfügung. mit 0 und 1 wird zwischen beiden puffern gewählt

// MaxNo : 
// maximale anzahl der einträge im ringpuffer

// Filter : 
// bit0=1 .... (1)  unused
// bit1=1 .... (2)  bei alarm wird zeit gekommen und zeit gegangen eingetragen, ansonsten wird für alarm gegangen ein weiterer eintrag angelegt 
// bit2=1 .... (4)  tritt ein alarm wiederholt auf wird ein counter bei bestehenden eintrag erhöht, ansonsten neuer eintrag
// bit3=1 .... (8)  aktive alarme können nicht aus der liste gelöscht werden, alarm wird in diesem fall quittiert
// bit4=1 .... (16) langtext anstelle von kurztext wird angezeigt
// bit5=1 .... (32) alle aktiven alarme werden beim einschalten der anlage auf inaktiv gesetzt
// bit6=1 .... (64) beim Einschalten wird in der History eine grüne Zeile "POWER ON" samt Datum und Uhrzeit eingetragen


FUNCTION __CDECL GLOBAL AlarmDPNE
VAR_INPUT
  pms  : ^_MEM_SINGLEALARM; 
  dpne : ^_ASCII;  
END_VAR
VAR_OUTPUT
  retcode : ^_ASCII; 
END_VAR
VAR
  pthis : ^_AlarmDisplay; 
END_VAR

  retcode := dpne; 
  pthis   := pms^.pthis$^_AlarmDisplay; 
  if(pthis <> NIL) then
    retcode := pthis^.AlarmDPNE(dpne); 
  end_if; 

END_FUNCTION

FUNCTION __CDECL GLOBAL AlarmDisplayAddEntry
VAR_INPUT
  pms     : ^_MEM_SINGLEALARM;  
  psa     : ^_SINGLEALARM; 
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR
VAR
  pthis : ^_AlarmDisplay; 
END_VAR

  retcode := FALSE; 
  pthis   := pms^.pthis$^_AlarmDisplay; 
  if(pthis <> NIL) then
    retcode := pthis^.AddEntry(psa); 
  end_if; 

END_FUNCTION

//[#ENGLISH]
//method is called cyclic during object is on screen
//
//pio ....... pointer to io information
//input .... TRUE it's an input / FALSE it's an output
FUNCTION __CDECL VIRTUAL GLOBAL _AlarmDisplay::IF_Run
VAR_INPUT
	pio		: ^_IO;
	input		: BOOL;
END_VAR

  _ScrollArea::IF_Run(pio, input); 
  if(Pms^.xchange <> ChangeCnt) then
    Scroll.position.no := TO_DINT(no_RINGBUFFER(#Pms^.ringbuffer)); 
    Sort(Pms^.sortalgorithm); 
	OutPage(); 
    ChangeCnt := Pms^.xchange; 
  end_if; 

END_FUNCTION

//[#ENGLISH]
//this method is called once right in front of drawing the object.
//for example open screen
FUNCTION __CDECL VIRTUAL GLOBAL _AlarmDisplay::IF_Start
VAR_INPUT
	pio		: ^_IO;
	firsttime		: BOOL;
END_VAR

  _ScrollArea::IF_Start(pio, firsttime); 
  GetPms(); 
 
END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _AlarmDisplay::Out
VAR_INPUT 
  pio : ^_IO; 
END_VAR

  InitScroll(pio, TO_UINT(no_RINGBUFFER(#Pms^.ringbuffer))); 
  Sort(Pms^.sortalgorithm); 
  Draw_SCROLL(#Scroll, FALSE);
  If(IsDrawBackground() = FALSE) then
    ChangeCnt := Pms^.xchange; 
  end_if; 

END_FUNCTION

//[#ENGLISH]
//method is called every time when redraw of a single line is necessary.
//ps ..... --> to structure _SCROLL
//pr ..... --> to place where line should be drawn
//line ... number of line which should be drawn
//state .. line ia selected (TRUE) or passive (FALSE)

FUNCTION __CDECL VIRTUAL GLOBAL _AlarmDisplay::Line
VAR_INPUT
	ps		: ^_SCROLL;
	pr		: ^_ROOM;
	line		: UINT;
	state		: BOOL;
END_VAR
VAR
  color : _COLOR;
  psa   : ^_SINGLEALARM; 
  no    : UINT; 
END_VAR

  no := TO_UINT(no_RINGBUFFER(#Pms^.ringbuffer)); 

  if(line < no) then
    line := no - line - 1; 

    if(state = TRUE) then
      color := Graphic.MakeColor(INVISIBLE, BLACK); //ps^.color_activ); 
    else
      color := Graphic.MakeColor(WHITE, BLACK);
    end_if; 

    psa := Pms^.ptr + (rpos_RINGBUFFER(#Pms^.ringbuffer, line) * sizeof(_SINGLEALARM)); 
    out_standard_alarmline(psa, pr, color, Pms^.filter, ps);   
  end_if; 


END_FUNCTION

FUNCTION  _AlarmDisplay::GetPms
VAR
  st : BOOL; 
END_VAR

  st := FALSE; 
  if(HistoryTemporary.Read() = 0) then
    st := TRUE; 
  end_if; 

  Pms        := get_MEM_SINGLEALARM(st); 
  Pms^.pthis := this$^void; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmDisplay::Server0::Read
VAR_OUTPUT
	output		: DINT;
END_VAR

  GetPms(); 
  Server0 :=   
  output := to_dint(no_RINGBUFFER(#Pms^.ringbuffer)); 

END_FUNCTION

FUNCTION __CDECL GLOBAL sort_aladatim
VAR_INPUT
  p1 : ^_SINGLEALARM; 
  p2 : ^_SINGLEALARM; 
END_VAR
VAR_OUTPUT 
  retcode : UINT; 
END_VAR
VAR
  tmp1 : _IVALUE; 
  tmp2 : _IVALUE; 
END_VAR
 
  retcode := 0; 
 
  tmp1 := p1^.date_on; 
  if(p1^.state = 0) then
    tmp1 := p1^.date_off; 
  end_if;
   
  tmp2 := p2^.date_on; 
  if(p2^.state = 0) then
    tmp2 := p2^.date_off; 
  end_if; 
  
  if(tmp2 > tmp1) then
    return; 
  elsif(tmp2 = tmp1) then
    tmp1 := p1^.time_on; 
    if(p1^.state = 0) then
      tmp1 := p1^.time_off; 
    end_if;
   
    tmp2 := p2^.time_on; 
    if(p2^.state = 0) then
      tmp2 := p2^.time_off; 
    end_if; 
 
    if(tmp2 >= tmp1) then
      return;
    end_if; 
  end_if; 
 
  retcode := 1; 
 
END_FUNCTION

FUNCTION __CDECL GLOBAL sort_alastatedatim
VAR_INPUT
  p1 : ^_SINGLEALARM; 
  p2 : ^_SINGLEALARM; 
END_VAR
VAR_OUTPUT 
  retcode : UINT; 
END_VAR
VAR 
  sa1 : UINT; 
  sa2 : UINT; 
END_VAR

  sa1      := p1^.state and 1;
  sa2      := p2^.state and 1; 
  retcode := 0; 

  if(sa2 > sa1) then
    return;
  end_if; 
  if(sa1 = sa2) then
    retcode := sort_aladatim(p1, p2); 
    return;
  end_if; 

  retcode := 1;

END_FUNCTION

FUNCTION __CDECL GLOBAL sort_alapriority
VAR_INPUT
  p1 : ^_SINGLEALARM; 
  p2 : ^_SINGLEALARM; 
END_VAR
VAR_OUTPUT 
  retcode : UINT; 
END_VAR
//VAR 
//  s1 : UDINT; 
//  s2 : UDINT; 
//END_VAR

  retcode := 0; 
//  s1 := p1^.no;  
//  s2 := p2^.no;  

//  if(s2 > s1) then
  if(p2^.no > p1^.no) then
    return;
  end_if; 
//  if(s1 = s2) then
  if(p1^.no = p2^.no) then
    retcode := sort_aladatim(p1, p2); 
    return;
  end_if; 

  retcode := 1;

END_FUNCTION

FUNCTION __CDECL GLOBAL sort_alapriority1
VAR_INPUT
  p1 : ^_SINGLEALARM;
  p2 : ^_SINGLEALARM;
END_VAR
VAR_OUTPUT
  retcode : UINT;
END_VAR
VAR
  sa1 : UINT;
  sa2 : UINT;
  psa1 : ^_SINGLE_ALARM;
  psa2 : ^_SINGLE_ALARM;
END_VAR


  retcode := 0;

  psa1 := get_ANYTHING(#p1^.anything, NIL)$^_SINGLE_ALARM;
  psa2 := get_ANYTHING(#p2^.anything, NIL)$^_SINGLE_ALARM;

  if((psa1 <> NIL) & (psa2 <> NIL)) then
    sa1 := psa1^.priority;
    sa2 := psa2^.priority;
  end_if;

  if(sa2 > sa1) then
    return;
  end_if;
  if(sa1 = sa2) then
    retcode := sort_aladatim(p1, p2);
    return;
  end_if;

  retcode := 1;

END_FUNCTION

FUNCTION __CDECL GLOBAL sort_aladatim_inv
VAR_INPUT
  p1 : ^_SINGLEALARM;
  p2 : ^_SINGLEALARM;
END_VAR
VAR_OUTPUT
  retcode : UINT;
END_VAR
VAR
  tmp1 : _IVALUE; 
  tmp2 : _IVALUE; 
END_VAR

  retcode := 0; 

  tmp1 := p1^.date_on; 
  if(p1^.state = 0) then
    tmp1 := p1^.date_off; 
  end_if;
   
  tmp2 := p2^.date_on; 
  if(p2^.state = 0) then
    tmp2 := p2^.date_off; 
  end_if; 
  
  if(tmp2 < tmp1) then
    return; 
  elsif(tmp2 = tmp1) then
    tmp1 := p1^.time_on; 
    if(p1^.state = 0) then
      tmp1 := p1^.time_off; 
    end_if;
   
    tmp2 := p2^.time_on; 
    if(p2^.state = 0) then
      tmp2 := p2^.time_off; 
    end_if; 

    if(tmp2 <= tmp1) then
      return;
    end_if; 
  end_if; 

  retcode := 1; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _AlarmDisplay::Sort
VAR_INPUT
    sortal  : UINT;
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR
VAR
    pfkt : ^void; 
END_VAR

  GetPms(); 
  pfkt := NIL;
  retcode := FALSE;  

  case sortal of
    0 : retcode := TRUE;                 // entrys in order of occurance
    1 : pfkt := #sort_aladatim();         // entries sorted by time
    2 : pfkt := #sort_alastatedatim();    // entries sorted by active/inactive and time
    3 : pfkt := #sort_alapriority();      // entries sorted by alarmnumber
    4 : pfkt := #sort_alapriority1();     // entries sorted by priotity
    5 : pfkt := #sort_aladatim_inv();     // entries sorted by time (last at the end)
  end_case;	
	
  if(pfkt <> NIL) then
    sort_ringbuffer(Pms^.ptr, #Pms^.ringbuffer, sizeof(_SINGLEALARM), pfkt); 
    Pms^.xchange += 1;  
    retcode      := TRUE; 
  end_if; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmDisplay::SortAlgorithm::Read
VAR_OUTPUT
	output		: DINT;
END_VAR
    
  GetPms(); 
  output        := 
  SortAlgorithm := Pms^.sortalgorithm;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmDisplay::SortAlgorithm::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

  if(input <> SortAlgorithm) then
    GetPms(); 
    Pms^.sortalgorithm := TO_UINT(input); 
    SortAlgorithm      := input; 
    if(input <> 0) then
      Pms^.xchange += 1;  
    end_if; 
  end_if; 

  result := input; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmDisplay::Init

  if(_firstscan) then
    GetPms(); 
    make_MEM_SINGLEALARM(Pms, MaxNo.Read(), TO_UINT(Filter.Read()));
	GetPms(); // explizit necessary to insert this pointer
  end_if; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _AlarmDisplay::Store
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := FALSE; 

  if(HistoryTemporary.Read() = 0) then
    retcode := alarm_save(); 
  end_if; 
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmDisplay::Acknowledge::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

  GetPms(); 
  if(input = -1) then
    acknowledge_alarm(Pms, -1);
  elsif(input = -2) then
    acknowledge_alarm(Pms, -2);
  elsif(Focus = TRUE) then
    acknowledge_alarm(Pms, to_dint(no_RINGBUFFER(#Pms^.ringbuffer))-1-Scroll.position.pos) ; 
  end_if; 

  result      := 
  Acknowledge := input;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmDisplay::Delete::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

  GetPms();
  if((input < 0) & (input >= -3)) then
    delete_alarm(Pms, input);
  elsif(Focus = TRUE) then
    delete_alarm(Pms, to_dint(no_RINGBUFFER(#Pms^.ringbuffer))-1-Scroll.position.pos);
  end_if;

  result :=
  Delete := input;

END_FUNCTION

//[#ENGLISH]
//method is called every time when system wants to insert an entry into ringbuffer
//call this methode if you want to add an entry
//if you decide that entry shouldn't be added, dont call function add_SINGLEALARM() inside
//ptr .... --> to new entry
//at success method returns TRUE, on the other hand FALSE
FUNCTION __CDECL VIRTUAL GLOBAL _AlarmDisplay::AddEntry
VAR_INPUT
	ptr		: ^_SINGLEALARM;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  GetPms();
  Pms^.para_filter := CreateParameterFilter(ptr); // SA33569
  retcode := add_SINGLEALARM(Pms, ptr); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmDisplay::NoActive::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

  GetPms(); 
  NoActive := pms^.noactive; 
  output   := NoActive;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _AlarmDisplay::AlarmDPNE
VAR_INPUT
	dpne		: ^_ASCII;
END_VAR
VAR_OUTPUT
	retcode		: ^_ASCII;
END_VAR
VAR
	chrsize : udint;
END_VAR

  retcode := dpne; 

  if(IsClientConnected(#cDpne)) then
    if(cDpne.TxtLen() > 2) then
      chrsize := cDpne.GetCharSize();
      cDpne.TxtGet(dpne, _MAX_PATHLENGTH);
      if(chrsize > 1) then
        StrCpy(dpne, 1, dpne, 2);
      end_if;
    end_if;
  end_if;

END_FUNCTION

#pragma warning (disable: 73)
FUNCTION VIRTUAL _AlarmDisplay::CreateParameterFilter
	VAR_INPUT
		ptr 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := 0;

END_FUNCTION
#pragma warning (default: 73)
