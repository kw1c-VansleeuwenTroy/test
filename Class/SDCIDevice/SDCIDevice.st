//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\SdiasBase\SdiasBase.h"
#include "..\..\Class\SdiasSDCIMaster\SdiasSDCIMaster.h"

(*!
<Class
	Name               = "SDCIDevice"
	Revision           = "1.8"
	GUID               = "{91BBED1F-E88A-4449-AE23-662CD017F568}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\SDCI.ico"
	SharedCommandTable = "true"
	Objectsize         = "(652,120)"
	Comment            = "Base class for any SDCI device or if there is no description file available this class can also serve as generic SDCI Device class&#13;&#10;&#13;&#10;New hardware classes of SDCI devices can be generated as follows:&#13;&#10; - open the hardware editor with the SDCI master module placed&#13;&#10; - right-click on an empty SDCI port and select &quot;Create new SDCI device type&quot; from context menu&#13;&#10; - edit the new class and press the &quot;Import Device&quot; button on the left to import a device description file in .xml format">
	<Channels>
		<Server Name="ActualMode" GUID="{DF443C00-58BB-4CB9-9642-E3506E8F16B4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the currently active mode of the device (is only valid when the ClassState is _ClassOk and the FaultFlags are on _NoFault)"/>
		<Server Name="ClassState" GUID="{FF16F470-CB74-47DD-B6B7-D3CCBF4F6542}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the current Status of the Hardware Class"/>
		<Server Name="DeviceID" GUID="{CE3C5E2F-3759-4AA8-8D48-30A91FE836B0}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This information has been read from the module:&#13;&#10;Unique device identification allocated by a vendor"/>
		<Server Name="DirectInput" GUID="{E1E080A4-23C2-4B7D-91FD-EE98F772586C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input (pin 2 of the SDCI port) that does not pass the firmware and is directly fetched from the module&apos;s FPGA"/>
		<Server Name="FaultFlags" GUID="{9FF3155F-6598-4E0C-BD54-21DC659717A3}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the current fault flags of this port"/>
		<Server Name="Input" GUID="{3685DB7A-BC25-4054-B23A-FEEFA8D88F79}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="If the port is in _DigitalInput mode this server shows the value of the digital input at the C/Q pin (pin 4) of the SDCI port"/>
		<Server Name="MinCycleTime" GUID="{1C584829-C990-4A35-9002-EAB6A805CF2F}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="true" Retentive="false" Comment="This information has been read from the module:&#13;&#10;minimum possible cycle time of this module in µs&#13;&#10;&#13;&#10;Set a time in 100µs steps as init value to override the time provided by the module."/>
		<Server Name="NbrOfEventsAvailable" GUID="{CDAC79EA-E391-4A09-A068-DCFEA96A086E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Number of events available at this port&#13;&#10;&#13;&#10;The events can be fetched one by one (beginning with the oldest) via method GetEvent()"/>
		<Server Name="Output" GUID="{E24B5728-F784-4722-855C-D53EB66DA61F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="If the port is in _DigitalOutput mode this server is used to change the value of the digital output at the C/Q pin (pin 4) of the SDCI port"/>
		<Server Name="PortStateBits" GUID="{252ADF1A-187B-4E13-8C6A-EFDFA7474834}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="These bits show the current state of this port"/>
		<Server Name="VendorID" GUID="{929E4CA0-A0A9-444A-B615-EB4737394F26}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This information has been read from the module:&#13;&#10;Unique vendor identification"/>
		<Client Name="AutoConnectTime" Required="false" Internal="false" DefValue="0" Comment="With this setting the time interval in [sec] in which the port is scanned for an SDCI device can be defined.&#13;&#10;The minimum interval time is specified. The actual interval time can be higher if this setting is selected for several devices and these devices are not present.&#13;&#10;The scanning process for a non-existent device takes about 3.2 seconds. The maximum value is 604800 seconds = 7 days.&#13;&#10;0 ... deactivated (default)&#13;&#10;1-604800  ... Interval time for Device Scan in [sec]"/>
		<Client Name="ModeChangeTime" Required="false" Internal="false" DefValue="500" Comment="With this setting the wait time in [msec] for mode change of SDCI device can be defined.&#13;&#10;500  ... default value&#13;&#10;0-1000  ... value range"/>
		<Client Name="PdoProtection" Required="true" Internal="true"/>
		<Client Name="ReadPdoSize" Required="false" Internal="false" Comment="Size of the whole read PDO of this device in bits"/>
		<Client Name="Required" Required="true" Internal="false" DefValue="0" Comment="0 = module is not required&#13;&#10;1 = module is required (CPU will crash if module is missing)"/>
		<Client Name="SdciIn" Required="true" Internal="false" Comment="Connect to SdciOut_x Server of SDCI master module"/>
		<Client Name="SkipEndianSwap" Required="false" Internal="false" DefValue="0" Comment="By default the PDO data byte order (read and write) gets swapped when reading or writing data.&#13;&#10;If a device delivers data in the wrong byte order (i.e. Balluff BIS M-4...), the user has to swap the data again.&#13;&#10;Therefore the user can just disable the byte order swap with setting this client to 1 to save time in development and during runtime."/>
		<Client Name="SkipEndianSwapAsy" Required="true" Internal="false" DefValue="1" Comment="By default the SDO data byte order (read and write) gets swapped when reading or writing data.&#13;&#10;If a device delivers data in the wrong byte order, the user has to swap the data again.&#13;&#10;Therefore the user can just disable the byte order swap with setting this client to 1 to save time in development and during runtime."/>
		<Client Name="StartUpMode" Required="false" Internal="false" DefValue="_SDCI" Comment="Choose which mode should be enabled after downloading the parameters to the module"/>
		<Client Name="WritePdoSize" Required="false" Internal="false" Comment="Size of the whole write PDO of this device in bits"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\SdiasBase\SdiasBase.h" Include="true"/>
			<File Path=".\Class\SdiasSDCIMaster\SdiasSDCIMaster.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.8" Date="24.08.2021" Author="RamAnd" Company="Sigmatek" Description="Added possibility to override the minimum cycle time of a device."/>
		<Dokumentation Revision="1.7" Date="04.06.2020" Author="PieSte" Company="Sigmatek" Description="Add client at SDCIDevice to set wait time after port activation for communication with SDCI Device. For this the IIO041 class must be equal or above v1.14 (SA 57162).&#13;&#10;Reduced data which is read from SDCI Device at init."/>
		<Dokumentation Revision="1.6" Date="19.06.2020" Author="LanSte" Company="Sigmatek" Description="Added the methods GetReadPdoDataBit und SetWritePdoDataBit"/>
		<Dokumentation Revision="1.5" Date="24.03.2020" Author="PieSte" Company="Sigmatek" Description="Added support to scan and connect SDCI Devices automatically with setting of new AutoConnectTime client. For this the IO041 class must be equal or above v1.12 (SA 54052)."/>
		<Dokumentation Revision="1.4" Date="08.07.2019" Author="LanSte" Company="Sigmatek" Description="Added client SkipEndianSwapAsy."/>
		<Dokumentation Revision="1.3" Date="24.06.2019" Author="LanSte" Company="Sigmatek" Description="Added methods for buffered asy accesses."/>
		<Dokumentation Revision="1.2" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.1" Date="05.04.2017" Author="RamAnd" Company="Sigmatek" Description="Added the possibility to skip the endian swap of the PDO data in both directions."/>
		<Dokumentation Revision="1.0" Date="14.02.2017" Author="ZoePat" Company="Sigmatek" Description="first release version."/>
	</RevDoku>
	<Network Name="SDCIDevice">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "PdoProtection"
				GUID       = "{9E53C719-0E16-4744-ABB4-78E644C4A6D1}"
				Class      = "CriticalSection"
				Position   = "(270,210)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.PdoProtection" Destination="PdoProtection.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
SDCIDevice : CLASS
	TYPE
#pragma pack(push, 1)
	  t_AdditionalInfo : STRUCT  //! <Type Public="true" Name="t_AdditionalInfo"/>
	    PortNo : USINT;
	    TotalReadSize : USINT;
	    TotalWriteSize : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_FaultFlagSvr :  //! <Type Public="true" Name="t_FaultFlagSvr"/>
	  (
	    _NoFault,
	    _ComLost,
	    _RevisionFault,
	    _CompatibilityFault,
	    _SerialNumFault,
	    _DataStorageFault
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassState 	: SvrChCmd_t_e_VaranErrors;
	VendorID 	: SvrCh_UDINT;
	DeviceID 	: SvrCh_UDINT;
	MinCycleTime 	: SvrCh_UDINT;
	ActualMode 	: SvrCh_t_SDCIPortMode_PTofCls_SdiasSDCIMaster;
	PortStateBits 	: SvrCh_t_SDCIPortStateBits_PTofCls_SdiasSDCIMaster;
	NbrOfEventsAvailable 	: SvrCh_UDINT;
	FaultFlags 	: SvrCh_t_FaultFlagSvr_PTofCls_SDCIDevice;
	DirectInput 	: SvrCh_DINT;
	Input 	: SvrCh_DINT;
	Output 	: SvrCh_DINT;
  //Clients:
	SdciIn 	: CltChCmd_DINT;
	Required 	: CltCh_DINT;
	SkipEndianSwap 	: CltCh_DINT;
	SkipEndianSwapAsy 	: CltCh_DINT;
	StartUpMode 	: CltCh_t_SDCIPortMode_PTofCls_SdiasSDCIMaster;
	ReadPdoSize 	: CltCh_UDINT;
	WritePdoSize 	: CltCh_UDINT;
	AutoConnectTime 	: CltCh_UDINT;
	ModeChangeTime 	: CltCh_UDINT;
	PdoProtection 	: CltChCmd_CriticalSection;
  //Variables:
		usFirstScan 	: USINT;
		PortMode 	: SdiasSDCIMaster::t_SDCIPortMode;
		aReceiveData : ARRAY [0..SIOL_MAX_SDO_DATA_SIZE-1] OF USINT;

		EventBuffer 	: SdiasSDCIMaster::t_SDCIEventBuffer;
		LastPdoReadError 	: SdiasSDCIMaster::t_SDCIRetCode;
		bUnknownCmdLogged 	: BOOL;
  //Functions:
	
	FUNCTION SDCIDevice
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GetPtr2CfgTable
		VAR_OUTPUT
			pCfgTable 	: pVoid;
		END_VAR;
				//! <Function Comment="This method fetches the current read data of this module according to the specified length and offset" Name="GetReadPdoData"/>
	FUNCTION VIRTUAL GLOBAL GetReadPdoData
		VAR_INPUT
			pReadData 	: pVoid;			//! <Variable Comment="Pointer to the memory where the current read process data should be stored" Name="GetReadPdoData.pReadData"/>
			ReadLength 	: USINT;			//! <Variable Comment="Length in bytes" Name="GetReadPdoData.ReadLength"/>
			ReadOffset 	: USINT := 0;			//! <Variable Comment="Offset in bytes" Name="GetReadPdoData.ReadOffset"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="GetReadPdoData.retcode"/>
		END_VAR;
				//! <Function Comment="This method fetches the current read data of this module according to the specified length and offset in bits" Name="GetReadPdoDataBit"/>
	FUNCTION VIRTUAL GLOBAL GetReadPdoDataBit
		VAR_INPUT
			pReadData 	: pVoid;			//! <Variable Comment="Pointer to the memory where the current read process data should be stored" Name="GetReadPdoDataBit.pReadData"/>
			ReadLengthBit 	: UDINT;			//! <Variable Comment="Length in bits" Name="GetReadPdoDataBit.ReadLengthBit"/>
			ReadOffsetBit 	: UDINT := 0;			//! <Variable Comment="Offset in bits" Name="GetReadPdoDataBit.ReadOffsetBit"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="GetReadPdoDataBit.retcode"/>
		END_VAR;
				//! <Function Comment="This method fetches 1 byte of the current read data of this module according to the specified offset" Name="GetReadPdoByte"/>
	FUNCTION VIRTUAL GLOBAL GetReadPdoByte
		VAR_INPUT
			ReadOffset 	: USINT := 0;			//! <Variable Comment="Offset in bytes" Name="GetReadPdoByte.ReadOffset"/>
		END_VAR
		VAR_OUTPUT
			ReadValue 	: USINT;			//! <Variable Comment="Read data" Name="GetReadPdoByte.ReadValue"/>
		END_VAR;
				//! <Function Comment="This method fetches 2 bytes of the current read data of this module according to the specified offset" Name="GetReadPdoWord"/>
	FUNCTION VIRTUAL GLOBAL GetReadPdoWord
		VAR_INPUT
			ReadOffset 	: USINT := 0;			//! <Variable Comment="Offset in bytes" Name="GetReadPdoWord.ReadOffset"/>
		END_VAR
		VAR_OUTPUT
			ReadValue 	: UINT;			//! <Variable Comment="Read data" Name="GetReadPdoWord.ReadValue"/>
		END_VAR;
				//! <Function Comment="This method fetches 4 bytes of the current read data of this module according to the specified offset" Name="GetReadPdoDWord"/>
	FUNCTION VIRTUAL GLOBAL GetReadPdoDWord
		VAR_INPUT
			ReadOffset 	: USINT := 0;			//! <Variable Comment="Offset in bytes" Name="GetReadPdoDWord.ReadOffset"/>
		END_VAR
		VAR_OUTPUT
			ReadValue 	: UDINT;			//! <Variable Comment="Read data" Name="GetReadPdoDWord.ReadValue"/>
		END_VAR;
				//! <Function Comment="Delivers the returncode of a previously called GetReadPdoByte/GetReadPdoWord/GetReadPdoDWord" Name="GetPdoReadError"/>
	FUNCTION VIRTUAL GLOBAL GetPdoReadError
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the last GetReadPdoByte/GetReadPdoWord/GetReadPdoDWord method was executed successfully and if not what was the problem" Name="GetPdoReadError.retcode"/>
		END_VAR;
				//! <Function Comment="This method sets new write data to this module according to the specified length and offset" Name="SetWritePdoData"/>
	FUNCTION VIRTUAL GLOBAL SetWritePdoData
		VAR_INPUT
			pWriteData 	: pVoid;			//! <Variable Comment="Pointer to the memory where the new write data are being stored" Name="SetWritePdoData.pWriteData"/>
			WriteLength 	: USINT;			//! <Variable Comment="Length in bytes" Name="SetWritePdoData.WriteLength"/>
			WriteOffset 	: USINT := 0;			//! <Variable Comment="Offset in bytes" Name="SetWritePdoData.WriteOffset"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SetWritePdoData.retcode"/>
		END_VAR;
				//! <Function Comment="This method sets new write data to this module according to the specified length and offset in bits&#13;&#10;" Name="SetWritePdoDataBit"/>
	FUNCTION VIRTUAL GLOBAL SetWritePdoDataBit
		VAR_INPUT
			pWriteData 	: pVoid;			//! <Variable Comment="Pointer to the memory where the new write data are being stored" Name="SetWritePdoDataBit.pWriteData"/>
			WriteLengthBit 	: UDINT;			//! <Variable Comment="Length in bits" Name="SetWritePdoDataBit.WriteLengthBit"/>
			WriteOffsetBit 	: UDINT := 0;			//! <Variable Comment="Offset in bits" Name="SetWritePdoDataBit.WriteOffsetBit"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SetWritePdoDataBit.retcode"/>
		END_VAR;
				//! <Function Comment="This method sets 1 byte in the new write data to this module according to the specified offset" Name="SetWritePdoByte"/>
	FUNCTION VIRTUAL GLOBAL SetWritePdoByte
		VAR_INPUT
			WriteValue 	: USINT;			//! <Variable Comment="Write data" Name="SetWritePdoByte.WriteValue"/>
			WriteOffset 	: USINT := 0;			//! <Variable Comment="Offset in bytes" Name="SetWritePdoByte.WriteOffset"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SetWritePdoByte.retcode"/>
		END_VAR;
				//! <Function Comment="This method sets 2 bytes in the new write data to this module according to the specified offset" Name="SetWritePdoWord"/>
	FUNCTION VIRTUAL GLOBAL SetWritePdoWord
		VAR_INPUT
			WriteValue 	: UINT;			//! <Variable Comment="Write data" Name="SetWritePdoWord.WriteValue"/>
			WriteOffset 	: USINT := 0;			//! <Variable Comment="Offset in bytes" Name="SetWritePdoWord.WriteOffset"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SetWritePdoWord.retcode"/>
		END_VAR;
				//! <Function Comment="This method sets 4 bytes in the new write data to this module according to the specified offset" Name="SetWritePdoDWord"/>
	FUNCTION VIRTUAL GLOBAL SetWritePdoDWord
		VAR_INPUT
			WriteValue 	: UDINT;			//! <Variable Comment="Write data" Name="SetWritePdoDWord.WriteValue"/>
			WriteOffset 	: USINT := 0;			//! <Variable Comment="Offset in bytes" Name="SetWritePdoDWord.WriteOffset"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SetWritePdoDWord.retcode"/>
		END_VAR;
				//! <Function Comment="This method is used to request a parameter from the module&#13;&#10;Use GetAsyState() to check if the asynchronous channel is ready (can be used before calling the method to avoid errors because of a busy channel and also afterwards to check if the operation is finished and get the read data)" Name="GetAsyPara"/>
	FUNCTION VIRTUAL GLOBAL GetAsyPara
		VAR_INPUT
			ParaIndex 	: UINT;			//! <Variable Comment="Index of the requested parameter" Name="GetAsyPara.ParaIndex"/>
			ParaSubIndex 	: USINT;			//! <Variable Comment="SubIndex of the requested parameter" Name="GetAsyPara.ParaSubIndex"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="GetAsyPara.retcode"/>
		END_VAR;
				//! <Function Comment="This method is used to send a parameter value to the module&#13;&#10;Use GetAsyState() to check if the asynchronous channel is ready (can be used before calling the method to avoid errors because of a busy channel and also afterwards to check if the operation is finished)" Name="SetAsyPara"/>
	FUNCTION VIRTUAL GLOBAL SetAsyPara
		VAR_INPUT
			ParaIndex 	: UINT;			//! <Variable Comment="Index of the target parameter" Name="SetAsyPara.ParaIndex"/>
			ParaSubIndex 	: USINT;			//! <Variable Comment="SubIndex of the target parameter" Name="SetAsyPara.ParaSubIndex"/>
			WriteDataLength 	: USINT;			//! <Variable Comment="Length of data behind pData" Name="SetAsyPara.WriteDataLength"/>
			pWriteData 	: pVoid;			//! <Variable Comment="Pointer to new value of the target parameter" Name="SetAsyPara.pWriteData"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SetAsyPara.retcode"/>
		END_VAR;
				//! <Function Comment="This method is used to check the state of the asynchronous methods GetAsyPara(), SetAsyPara(), SetNewPortMode() and Reconnect()" Name="GetAsyState"/>
	FUNCTION VIRTUAL GLOBAL GetAsyState
		VAR_INPUT
			pErrorCode 	: ^HINT := NIL;			//! <Variable Comment="If the retcode is SDCI_MicroCtrl_ApplicationError and this pointer is valid the errorcode is written to the content of this pointer&#13;&#10;&#13;&#10;0x0080 .. Device application error&#13;&#10;0x1180 .. Index not available&#13;&#10;0x1280 .. Subindex not available&#13;&#10;0x2080 .. Service temporarily not available&#13;&#10;0x2180 .. Service temporarily not available - local control&#13;&#10;0x2280 .. Service temporarily not available - device control&#13;&#10;0x2380 .. Index not writeable&#13;&#10;0x3080 .. Parameter out of range&#13;&#10;0x3180 .. Parameter value above limit&#13;&#10;0x3280 .. Parameter value below limit&#13;&#10;0x3380 .. Parameter length overrun&#13;&#10;0x3480 .. Parameter length underrun&#13;&#10;0x3580 .. Function not available&#13;&#10;0x3680 .. Function temporarily unavailable&#13;&#10;0x4080 .. Invalid parameter set&#13;&#10;0x4180 .. Inconsistent parameter set&#13;&#10;0x8280 .. Application not ready&#13;&#10;0x??81 .. Vendor specific&#13;&#10;" Name="GetAsyState.pErrorCode"/>
			pReadDataLength 	: ^USINT := NIL;			//! <Variable Comment="If there are response data available and the pointer is valid, the length will be stored to the pointers destination memory." Name="GetAsyState.pReadDataLength"/>
			ppReadData 	: ^pVoid := NIL;			//! <Variable Comment="If there are response data available and the pointer is valid, the data will be stored to the pointers destination memory." Name="GetAsyState.ppReadData"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="GetAsyState.retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetConfiguredPortMode
		VAR_OUTPUT
			ActPortMode 	: SdiasSDCIMaster::t_SDCIPortMode;
		END_VAR;
	
	FUNCTION VIRTUAL LogError
		VAR_INPUT
			pMsg 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL LogValue
		VAR_INPUT
			pString 	: ^CHAR;
			udValue 	: UDINT;
			udValue2 	: UDINT := 16#FFFFFFFF;
			udValue3 	: UDINT := 16#FFFFFFFF;
		END_VAR;
	
	FUNCTION VIRTUAL AddEventToBuffer
		VAR_INPUT
			pEventDetails 	: ^SdiasSDCIMaster::t_SDCIEventDetails;
		END_VAR;
				//! <Function Comment="Fetch oldest available event" Name="GetEvent"/>
	FUNCTION VIRTUAL GLOBAL GetEvent
		VAR_OUTPUT
			OldestEventAvailable 	: SdiasSDCIMaster::t_SDCIEventDetails;			//! <Variable Comment="Returns the oldest available event in the buffer or an event code and info of 0 if there are no events" Name="GetEvent.OldestEventAvailable"/>
		END_VAR;
				//! <Function Comment="This method is used to set the port to a new mode&#13;&#10;Use GetAsyState() to check if the asynchronous channel is ready (can be used before calling the method to avoid errors because of a busy channel and also afterwards to check if the operation is finished)" Name="SetNewPortMode"/>
	FUNCTION VIRTUAL GLOBAL SetNewPortMode
		VAR_INPUT
			TargetMode 	: SdiasSDCIMaster::t_SDCIPortMode;			//! <Variable Comment="New port mode." Name="SetNewPortMode.TargetMode"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SetNewPortMode.retcode"/>
		END_VAR;
				//! <Function Comment="If the device lost it&apos;s communication or is being connected during runtime, this method starts the communication on the port (scan for the module, check the ID, download parameters and switch to StartUpMode)&#13;&#10;Use GetAsyState() to check if the asynchronous channel is ready (can be used before calling the method to avoid errors because of a busy channel and also afterwards to check if the operation is finished)" Name="Reconnect"/>
	FUNCTION VIRTUAL GLOBAL Reconnect
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="Reconnect.retcode"/>
		END_VAR;
				//! <Function Comment="Send function ID to SDCI master (for internal use)" Name="SendAsyFunctionId"/>
	FUNCTION VIRTUAL GLOBAL SendAsyFunctionId
		VAR_INPUT
			ParaDataLength 	: USINT;			//! <Variable Comment="Length of parameter stream (depending on function ID)" Name="SendAsyFunctionId.ParaDataLength"/>
			pParaData 	: pVoid;			//! <Variable Comment="Pointer to parameter stream (depending on function ID)" Name="SendAsyFunctionId.pParaData"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SendAsyFunctionId.retcode"/>
		END_VAR;
				//! <Function Comment="This method is used to send a parameter value to the module&#13;&#10;The request ist buffered by SdiasSDCIMaster.&#13;&#10;After the request was executed, a callback function with the following parameters is called:&#13;&#10;VAR_INPUT&#13;&#10;  pThis         : pVoid;&#13;&#10;  AsyState      : SdiasSDCIMaster::t_SDCIRetCode;&#13;&#10;  LengthOfData  : USINT;&#13;&#10;  pData         : ^USINT;&#13;&#10;END_VAR;" Name="SetAsyParaBuffered"/>
	FUNCTION VIRTUAL GLOBAL SetAsyParaBuffered
		VAR_INPUT
			ParaIndex 	: UINT;			//! <Variable Comment="Index of the target parameter" Name="SetAsyParaBuffered.ParaIndex"/>
			ParaSubIndex 	: USINT;			//! <Variable Comment="SubIndex of the target parameter" Name="SetAsyParaBuffered.ParaSubIndex"/>
			WriteDataLength 	: USINT;			//! <Variable Comment="Length of data behind pData" Name="SetAsyParaBuffered.WriteDataLength"/>
			pWriteData 	: pVoid;			//! <Variable Comment="Pointer to new value of the target parameter" Name="SetAsyParaBuffered.pWriteData"/>
			pThis 	: pVirtualBase;			//! <Variable Comment="This pointer of the calling object" Name="SetAsyParaBuffered.pThis"/>
			pCallBackFunction 	: pVoid;			//! <Variable Comment="Pointer to the function to be called during callback" Name="SetAsyParaBuffered.pCallBackFunction"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SetAsyParaBuffered.retcode"/>
		END_VAR;
				//! <Function Comment="This method is used to request a parameter from the module&#13;&#10;The request ist buffered by SdiasSDCIMaster.&#13;&#10;After the request was executed, a callback function with the following parameters is called:&#13;&#10;VAR_INPUT&#13;&#10;  pThis         : pVoid;&#13;&#10;  AsyState      : SdiasSDCIMaster::t_SDCIRetCode;&#13;&#10;  LengthOfData  : USINT;&#13;&#10;  pData         : ^USINT;&#13;&#10;END_VAR;&#13;&#10;" Name="GetAsyParaBuffered"/>
	FUNCTION VIRTUAL GLOBAL GetAsyParaBuffered
		VAR_INPUT
			ParaIndex 	: UINT;			//! <Variable Comment="Index of the requested parameter" Name="GetAsyParaBuffered.ParaIndex"/>
			ParaSubIndex 	: USINT;			//! <Variable Comment="SubIndex of the requested parameter" Name="GetAsyParaBuffered.ParaSubIndex"/>
			pThis 	: pVirtualBase;			//! <Variable Comment="This pointer of the calling object" Name="GetAsyParaBuffered.pThis"/>
			pCallBackFunction 	: pVoid;			//! <Variable Comment="Pointer to the function to be called during callback" Name="GetAsyParaBuffered.pCallBackFunction"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="GetAsyParaBuffered.retcode"/>
		END_VAR;
				//! <Function Comment="Send function ID to SDCI master (for internal use)&#13;&#10;The request ist buffered by SdiasSDCIMaster.&#13;&#10;After the request was executed, a callback function with the following parameters is called:&#13;&#10;VAR_INPUT&#13;&#10;  pThis         : pVoid;&#13;&#10;  AsyState      : SdiasSDCIMaster::t_SDCIRetCode;&#13;&#10;  LengthOfData  : USINT;&#13;&#10;  pData         : ^USINT;&#13;&#10;END_VAR;&#13;&#10;" Name="SendAsyFunctionIdBuffered"/>
	FUNCTION VIRTUAL GLOBAL SendAsyFunctionIdBuffered
		VAR_INPUT
			ParaDataLength 	: USINT;			//! <Variable Comment="Length of parameter stream (depending on function ID)" Name="SendAsyFunctionIdBuffered.ParaDataLength"/>
			pParaData 	: pVoid;			//! <Variable Comment="Pointer to parameter stream (depending on function ID)" Name="SendAsyFunctionIdBuffered.pParaData"/>
			pThis 	: pVirtualBase;			//! <Variable Comment="This pointer of the calling object" Name="SendAsyFunctionIdBuffered.pThis"/>
			pCallBackFunction 	: pVoid;			//! <Variable Comment="Pointer to the function to be called during callback" Name="SendAsyFunctionIdBuffered.pCallBackFunction"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SendAsyFunctionIdBuffered.retcode"/>
		END_VAR;
				//! <Function Comment="This method is used to set the port to a new mode&#13;&#10;The request ist buffered by SdiasSDCIMaster.&#13;&#10;After the request was executed, a callback function with the following parameters is called:&#13;&#10;VAR_INPUT&#13;&#10;  pThis         : pVoid;&#13;&#10;  AsyState      : SdiasSDCIMaster::t_SDCIRetCode;&#13;&#10;  LengthOfData  : USINT;&#13;&#10;  pData         : ^USINT;&#13;&#10;END_VAR;" Name="SetNewPortModeBuffered"/>
	FUNCTION VIRTUAL GLOBAL SetNewPortModeBuffered
		VAR_INPUT
			TargetMode 	: SdiasSDCIMaster::t_SDCIPortMode;			//! <Variable Comment="New port mode" Name="SetNewPortModeBuffered.TargetMode"/>
			pThis 	: pVirtualBase;			//! <Variable Comment="This pointer of the calling object" Name="SetNewPortModeBuffered.pThis"/>
			pCallBackFunction 	: pVoid;			//! <Variable Comment="Pointer to the function to be called during callback" Name="SetNewPortModeBuffered.pCallBackFunction"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="SetNewPortModeBuffered.retcode"/>
		END_VAR;
				//! <Function Comment="If the device lost it&apos;s communication or is being connected during runtime, this method starts the communication on the port (scan for the module, check the ID, download parameters and switch to StartUpMode)&#13;&#10;The request ist buffered by SdiasSDCIMaster.&#13;&#10;After the request was executed, a callback function with the following parameters is called:&#13;&#10;VAR_INPUT&#13;&#10;  pThis         : pVoid;&#13;&#10;  AsyState      : SdiasSDCIMaster::t_SDCIRetCode;&#13;&#10;  LengthOfData  : USINT;&#13;&#10;  pData         : ^USINT;&#13;&#10;END_VAR;" Name="ReconnectBuffered"/>
	FUNCTION VIRTUAL GLOBAL ReconnectBuffered
		VAR_INPUT
			pThis 	: pVirtualBase;			//! <Variable Comment="This pointer of the calling object" Name="ReconnectBuffered.pThis"/>
			pCallBackFunction 	: pVoid;			//! <Variable Comment="Pointer to the function to be called during callback" Name="ReconnectBuffered.pCallBackFunction"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;			//! <Variable Comment="Indicates if the method was executed successfully and if not what was the problem" Name="ReconnectBuffered.retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using CriticalSection


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SDCIDevice::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SDCIDEVICE
1$UINT, 8$UINT, (SIZEOF(::SDCIDevice))$UINT, 
11$UINT, 10$UINT, 0$UINT, 
TO_UDINT(205726265), "SDCIDevice", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::SDCIDevice.ClassState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
(::SDCIDevice.VendorID.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2218535187), "VendorID", 
(::SDCIDevice.DeviceID.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4261957967), "DeviceID", 
(::SDCIDevice.MinCycleTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2956357376), "MinCycleTime", 
(::SDCIDevice.ActualMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(208673156), "ActualMode", 
(::SDCIDevice.PortStateBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3372533464), "PortStateBits", 
(::SDCIDevice.NbrOfEventsAvailable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2952604227), "NbrOfEventsAvailable", 
(::SDCIDevice.FaultFlags.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2328286348), "FaultFlags", 
(::SDCIDevice.DirectInput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1505915117), "DirectInput", 
(::SDCIDevice.Input.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(796717159), "Input", 
(::SDCIDevice.Output.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1009177368), "Output", 
//Clients:
(::SDCIDevice.SdciIn.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000010$UINT, TO_UDINT(3500080180), "SdciIn", 
(::SDCIDevice.Required.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(648558917), "Required", 
(::SDCIDevice.SkipEndianSwap.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(115575080), "SkipEndianSwap", 
(::SDCIDevice.SkipEndianSwapAsy.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3894697660), "SkipEndianSwapAsy", 
(::SDCIDevice.StartUpMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3609141548), "StartUpMode", 
(::SDCIDevice.ReadPdoSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3663116841), "ReadPdoSize", 
(::SDCIDevice.WritePdoSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2988873991), "WritePdoSize", 
(::SDCIDevice.AutoConnectTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2898966935), "AutoConnectTime", 
(::SDCIDevice.ModeChangeTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(850400570), "ModeChangeTime", 
(::SDCIDevice.PdoProtection.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(802900649), "PdoProtection", TO_UDINT(794617671), "CriticalSection", 0$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_SDCIDevice 28

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SDCIDevice] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SDCIDevice::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_SDCIDevice, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetPtr2CfgTable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetReadPdoData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetReadPdoDataBit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetReadPdoByte();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetReadPdoWord();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #GetReadPdoDWord();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #GetPdoReadError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #SetWritePdoData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #SetWritePdoDataBit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #SetWritePdoByte();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #SetWritePdoWord();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #SetWritePdoDWord();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #GetAsyPara();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #SetAsyPara();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetAsyState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetConfiguredPortMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #LogError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #LogValue();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #AddEventToBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #SetNewPortMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #Reconnect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #SendAsyFunctionId();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #SetAsyParaBuffered();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #GetAsyParaBuffered();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #SendAsyFunctionIdBuffered();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #SetNewPortModeBuffered();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #ReconnectBuffered();

#pragma warning (default : 74)
	ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output::Write() );
	IF Output.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= SDCIDevice();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL SDCIDevice::Init
  VAR
  	TmpRetcode  : iprStates;
    MyPara      : CmdStruct;
    MyResult    : results;
  END_VAR

  usFirstScan += 1;

  if usFirstScan = 1 then
    Required          := Required.Read();
    SkipEndianSwap    := SkipEndianSwap.Read();
    SkipEndianSwapAsy := SkipEndianSwapAsy.Read();
    StartUpMode       := StartUpMode.Read();
    ReadPdoSize       := ReadPdoSize.Read();
    WritePdoSize      := WritePdoSize.Read();
    AutoConnectTime   := AutoConnectTime.Read();  
    ModeChangeTime    := ModeChangeTime.Read();
    PortMode          := GetConfiguredPortMode();

    // the client is in bits and the constant is in bytes
    if (ReadPdoSize > (SIOL_MAX_PDO_SIZE*8)) | (WritePdoSize > (SIOL_MAX_PDO_SIZE*8)) then
      ClassState := _InvalidConfguration;
      if (ReadPdoSize > (SIOL_MAX_PDO_SIZE*8)) then
        LogError("@052E (SDCIDevice::Init) Configured read PDO size too big!");
      else
        LogError("@052F (SDCIDevice::Init) Configured write PDO size too big!");
      end_if;
      return;
    end_if;

    // reset the parameter (to have a defined value at the unused parameters)
    _memset(dest:=#MyPara.aPara[0], usByte:=0, cntr:=sizeof(MyPara.aPara));

    // login to the master module
    MyPara.uiCmd := CMD_SIOL_DEVICE_OBJECT_LOGIN;
    MyPara.aPara[0] := this$DINT;
    MyPara.aPara[1] := PortMode$DINT;
    
    // convert pdo sizes from bits to bytes (round up to next byte)
    MyPara.aPara[2] := (((ReadPdoSize  MOD 8) <> 0) + (ReadPdoSize  / 8))$DINT;
    MyPara.aPara[3] := (((WritePdoSize MOD 8) <> 0) + (WritePdoSize / 8))$DINT;

    MyPara.aPara[4] := (#Input)$DINT;
    MyPara.aPara[5] := (#Output)$DINT;
    MyPara.aPara[6] := (GetPtr2CfgTable())$DINT;

    MyPara.aPara[7] := (#FaultFlags)$DINT;
    MyPara.aPara[8] := (#DirectInput)$DINT;

    // pdo sizes in bits also for comparison reasons with the expectations of the device
    MyPara.aPara[9] := ReadPdoSize$DINT;
    MyPara.aPara[10]:= WritePdoSize$DINT;

    MyPara.aPara[11]:= Required;
    MyPara.aPara[12]:= (#PortStateBits)$DINT;
    MyPara.aPara[13]:= StartUpMode$DINT;
    MyPara.aPara[14]:= SkipEndianSwap;
    
    if SkipEndianSwapAsy then
      MyPara.aPara[15]:= 1;
    else
      MyPara.aPara[15]:= 2; // Don't use 0 as that is the default value set by _memset
    end_if;
    
    //check for maximum time
    if AutoConnectTime > SIOL_MAX_AUTOCONNECT_TIME then
      //if time is higher then maximum, set maximum time
      AutoConnectTime := SIOL_MAX_AUTOCONNECT_TIME;
    end_if;

    //set time for port scan interval - default is 0 = deactivated
    MyPara.aPara[16] := AutoConnectTime$DINT * 1000;  // convert seconds to milliseconds
        
    //check for maximum time
    if ModeChangeTime > SIOL_WAIT_FOR_DISABLE*2 then
      //if time is higher then maximum, set maximum time
      ModeChangeTime := SIOL_WAIT_FOR_DISABLE*2;
    end_if;

    //set time for port scan interval - default is 500ms
    MyPara.aPara[17] := (ModeChangeTime or 1 shl 31)$DINT;  // set highest bit to set value valid
    
    // option to override the actual min cycle time of the device
    MyPara.aPara[18]$UDINT := MinCycleTime;

    MyResult.aData[0]$DINT := -1;
    MyResult.uiLng := 0;

    TmpRetcode := SdciIn.NewInst(pPara:=#MyPara, pResult:=#MyResult);
    
    if (TmpRetcode = ERROR) | (MyResult.uiLng = 0) | (MyResult.aData[0]$SdiasSDCIMaster::t_SDCIRetCode <> SdiasSDCIMaster::t_SDCIRetCode::SDCI_Ready_Ok) then
      ClassState := _RootError;
      LogError("@0530 (SDCIDevice::Init) Failed to login to SDCI Master class");
      return;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SDCIDevice::GetPtr2CfgTable
	VAR_OUTPUT
		pCfgTable 	: pVoid;
	END_VAR

  // overwrite this method in the derivation and return the pointer to the config table
  pCfgTable := NIL;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::GetReadPdoData
	VAR_INPUT
		pReadData 	: pVoid;
		ReadLength 	: USINT;
		ReadOffset 	: USINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR
  
  // if the pointer to the destination memory is valid
  if pReadData then
    // send the request to the master
    MyPara.uiCmd    := CMD_SIOL_DEVICE_GET_PDO_DATA;
    MyPara.aPara[0] := pReadData$DINT;
    MyPara.aPara[1] := ReadLength;
    MyPara.aPara[2] := ReadOffset;

    MyResult.uiLng := 0;
    
    SdciIn.NewInst(#MyPara, #MyResult);
    
    if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
      retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
    else
      retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
    end_if;
  else
    // invalid pointer
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidPointer;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::SetWritePdoData
	VAR_INPUT
		pWriteData 	: pVoid;
		WriteLength 	: USINT;
		WriteOffset 	: USINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // if the pointer to the source memory is valid
  if pWriteData then
    // send the request to the master
    MyPara.uiCmd    := CMD_SIOL_DEVICE_SET_PDO_DATA;
    MyPara.aPara[0] := pWriteData$DINT;
    MyPara.aPara[1] := WriteLength;
    MyPara.aPara[2] := WriteOffset;

    MyResult.uiLng  := 0;
    
    SdciIn.NewInst(#MyPara, #MyResult);
    
    if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
      retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
    else
      retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
    end_if;
  else
    // invalid pointer
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidPointer;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::GetAsyPara
	VAR_INPUT
		ParaIndex 	: UINT;
		ParaSubIndex 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // initialize command
  MyPara.uiCmd    := CMD_SIOL_DEVICE_GET_ASY_PARA;
  MyPara.aPara[0] := ParaIndex;     // parameter index
  MyPara.aPara[1] := ParaSubIndex;  // parameter subindex
  MyPara.aPara[2] := 0;             // take the port number of the connection
  MyPara.aPara[3] := 0;             // length of data
  MyPara.aPara[4] := 0;             // pdata

  MyResult.uiLng  := 0;
  
  SdciIn.NewInst(#MyPara, #MyResult);
  
  if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
    retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
  else
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::SetAsyPara
	VAR_INPUT
		ParaIndex 	: UINT;
		ParaSubIndex 	: USINT;
		WriteDataLength 	: USINT;
		pWriteData 	: pVoid;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // check write data length
  if WriteDataLength & (WriteDataLength <= SIOL_MAX_SDO_DATA_SIZE) then
    // check write data pointer
    if pWriteData then
      // initialize command
      MyPara.uiCmd    := CMD_SIOL_DEVICE_SET_ASY_PARA;
      MyPara.aPara[0] := ParaIndex;       // parameter index
      MyPara.aPara[1] := ParaSubIndex;    // parameter subindex
      MyPara.aPara[2] := 0;               // take the port number of the connection
      MyPara.aPara[3] := WriteDataLength;      // length of data
      MyPara.aPara[4] := pWriteData$DINT;      // pWriteData

      MyResult.uiLng := 0;
      
      SdciIn.NewInst(#MyPara, #MyResult);
      
      if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
        retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
      else
        retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
      end_if;
    else
      // invalid pointer
      retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidPointer;
    end_if;
  else
    // invalid length
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidLength;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::SendAsyFunctionId
	VAR_INPUT
		ParaDataLength 	: USINT;
		pParaData 	: pVoid;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // check length of the parameter stream
  if ParaDataLength & (ParaDataLength <= SIOL_MAX_SDO_DATA_SIZE) then
    // check pointer of parameter stream
    if pParaData then
      // initialize command
      MyPara.uiCmd    := CMD_SIOL_DEVICE_ASY_FUNCTION_ID;
      MyPara.aPara[0] := 0;                   // parameter index
      MyPara.aPara[1] := 0;                   // parameter subindex
      MyPara.aPara[2] := SIOL_MASTER_PORT_NO; // function IDs are sent to the master port
      MyPara.aPara[3] := ParaDataLength;      // length of data
      MyPara.aPara[4] := pParaData$DINT;      // pdata

      MyResult.uiLng := 0;
      
      SdciIn.NewInst(#MyPara, #MyResult);
      
      if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
        retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
      else
        retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
      end_if;
    else
      // invalid pointer
      retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidPointer;
    end_if;
  else
    // invalid length
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidLength;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::GetAsyState
	VAR_INPUT
		pErrorCode 	: ^HINT;(* := NIL *)
		pReadDataLength 	: ^USINT;(* := NIL *)
		ppReadData 	: ^pVoid;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // initialize command
  MyPara.uiCmd := CMD_SIOL_DEVICE_GET_ASY_STATE;

  MyResult.uiLng := 0;

  // initialize errorcode (if pointer is valid). this is only set if an application error occured
  if pErrorCode then
    pErrorCode^ := 0;
  end_if;

  SdciIn.NewInst(#MyPara, #MyResult);

  // if there is a result => evaluate the content
  if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
    retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
    
    // check if enough data for the response
    if MyResult.uiLng >= 12 then
    
      // if it was an application error, the returndata contain the errorcode
      if (retcode = SdiasSDCIMaster::t_SDCIRetCode::SDCI_MicroCtrl_ApplicationError) & pErrorCode then
      
        // store the error code to the return value
        pErrorCode^ := (MyResult.aData[8]$^HINT)^;
        
      elsif pReadDataLength & ppReadData then
        if MyResult.aData[4]$DINT & (MyResult.aData[4]$DINT <= SIOL_MAX_SDO_DATA_SIZE) & MyResult.aData[8]$DINT then
          _memcpy(ptr1:=#aReceiveData[0], ptr2:=MyResult.aData[8]$^USINT, cntr:=MyResult.aData[4]$UDINT);
          ppReadData^ := #aReceiveData[0];
          pReadDataLength^ := MyResult.aData[4]$USINT;
        else
          // pointer for returndata available, but return values indicate that something is wrong
          retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
        end_if;
      end_if;
    end_if;
  else
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL SDCIDevice::GetAsyParaBuffered
	VAR_INPUT
		ParaIndex 	: UINT;
		ParaSubIndex 	: USINT;
		pThis 	: pVirtualBase;
		pCallBackFunction 	: pVoid;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // initialize command
  MyPara.uiCmd    := CMD_SIOL_DEVICE_GET_ASY_PARA_BUFFERED;
  MyPara.aPara[0] := ParaIndex;             // parameter index
  MyPara.aPara[1] := ParaSubIndex;          // parameter subindex
  MyPara.aPara[2] := 0;                     // take the port number of the connection
  MyPara.aPara[3] := 0;                     // length of data
  MyPara.aPara[4] := 0;                     // pdata
  MyPara.aPara[5] := pThis$DINT;            // Pointer for callback object
  MyPara.aPara[6] := pCallBackFunction$DINT;// Pointer for callback function

  MyResult.uiLng  := 0;
  
  SdciIn.NewInst(#MyPara, #MyResult);
  
  if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
    retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
  else
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::SetAsyParaBuffered
	VAR_INPUT
		ParaIndex 	: UINT;
		ParaSubIndex 	: USINT;
		WriteDataLength 	: USINT;
		pWriteData 	: pVoid;
		pThis 	: pVirtualBase;
		pCallBackFunction 	: pVoid;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // check write data length
  if WriteDataLength & (WriteDataLength <= SIOL_MAX_SDO_DATA_SIZE) then
    // check write data pointer
    if pWriteData then
      // initialize command
      MyPara.uiCmd    := CMD_SIOL_DEVICE_SET_ASY_PARA_BUFFERED;
      MyPara.aPara[0] := ParaIndex;             // parameter index
      MyPara.aPara[1] := ParaSubIndex;          // parameter subindex
      MyPara.aPara[2] := 0;                     // take the port number of the connection
      MyPara.aPara[3] := WriteDataLength;       // length of data
      MyPara.aPara[4] := pWriteData$DINT;       // pWriteData
      MyPara.aPara[5] := pThis$DINT;            // Pointer for callback object
      MyPara.aPara[6] := pCallBackFunction$DINT;// Pointer for callback function

      MyResult.uiLng := 0;
      
      SdciIn.NewInst(#MyPara, #MyResult);
      
      if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
        retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
      else
        retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
      end_if;
    else
      // invalid pointer
      retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidPointer;
    end_if;
  else
    // invalid length
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidLength;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::SendAsyFunctionIdBuffered
	VAR_INPUT
		ParaDataLength 	: USINT;
		pParaData 	: pVoid;
		pThis 	: pVirtualBase;
		pCallBackFunction 	: pVoid;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // check length of the parameter stream
  if ParaDataLength & (ParaDataLength <= SIOL_MAX_SDO_DATA_SIZE) then
    // check pointer of parameter stream
    if pParaData then
      // initialize command
      MyPara.uiCmd    := CMD_SIOL_DEVICE_ASY_FUNCTION_ID_BUFFERED;
      MyPara.aPara[0] := 0;                     // parameter index
      MyPara.aPara[1] := 0;                     // parameter subindex
      MyPara.aPara[2] := SIOL_MASTER_PORT_NO;   // function IDs are sent to the master port
      MyPara.aPara[3] := ParaDataLength;        // length of data
      MyPara.aPara[4] := pParaData$DINT;        // pdata
      MyPara.aPara[5] := pThis$DINT;            // Pointer for callback object
      MyPara.aPara[6] := pCallBackFunction$DINT;// Pointer for callback function

      MyResult.uiLng := 0;
      
      SdciIn.NewInst(#MyPara, #MyResult);
      
      if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
        retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
      else
        retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
      end_if;
    else
      // invalid pointer
      retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidPointer;
    end_if;
  else
    // invalid length
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidLength;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL SDCIDevice::SetNewPortModeBuffered
	VAR_INPUT
		TargetMode 	: SdiasSDCIMaster::t_SDCIPortMode;
	  pThis 	    : pVirtualBase;
		pCallBackFunction 	: pVoid;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // forward the command to the master
  MyPara.uiCmd    := CMD_SIOL_DEVICE_SET_PORT_MODE_BUFFERED;
  MyPara.aPara[0] := TargetMode$DINT;
  MyPara.aPara[1] := pThis$DINT;            // Pointer for callback object
  MyPara.aPara[2] := pCallBackFunction$DINT;// Pointer for callback function
    
  MyResult.uiLng := 0;
  
  SdciIn.NewInst(#MyPara, #MyResult);
  
  if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
    retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
  else
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL SDCIDevice::ReconnectBuffered
	VAR_INPUT		
	  pThis 	    : pVirtualBase;
		pCallBackFunction 	: pVoid;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // forward the command to the master
  MyPara.uiCmd    := CMD_SIOL_DEVICE_RECONNECT_BUFFERED;
  MyPara.aPara[0] := pThis$DINT;            // Pointer for callback object
  MyPara.aPara[1] := pCallBackFunction$DINT;// Pointer for callback function
    
  MyResult.uiLng := 0;
  
  SdciIn.NewInst(#MyPara, #MyResult);
  
  if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
    retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
  else
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SDCIDevice::GetConfiguredPortMode
	VAR_OUTPUT
		ActPortMode 	: SdiasSDCIMaster::t_SDCIPortMode;
	END_VAR
  
  // per default it's an SDCI device
  ActPortMode := SdiasSDCIMaster::_SDCI;

END_FUNCTION


FUNCTION VIRTUAL SDCIDevice::LogError
	VAR_INPUT
		pMsg 	: ^CHAR;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // forward the command to the master
  MyPara.uiCmd    := SDIAS_CLT_CMD_LOG_MESSAGE;
  MyPara.aPara[0] := pMsg$DINT;
  SdciIn.NewInst(#MyPara, #MyResult);

END_FUNCTION


FUNCTION VIRTUAL SDCIDevice::LogValue
	VAR_INPUT
		pString 	: ^CHAR;
		udValue 	: UDINT;
		udValue2 	: UDINT;(* := 16#FFFFFFFF *)
		udValue3 	: UDINT;(* := 16#FFFFFFFF *)
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // forward the command to the master
  MyPara.uiCmd    := SDIAS_CLT_CMD_LOG_VALUE;
  MyPara.aPara[0] := pString$DINT;
  MyPara.aPara[1] := udValue$DINT;
  MyPara.aPara[2] := udValue2$DINT;
  MyPara.aPara[3] := udValue3$DINT;
  SdciIn.NewInst(#MyPara, #MyResult);
  
END_FUNCTION


FUNCTION SDCIDevice::SDCIDevice
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  // initialize the module _NotInitialized (otherwise the ClassState would be _ClassOk before starting the initialisation)
  ClassState := _NotInitialized;

	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::ClassState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR

  case pPara^.uiCmd of
//**********************************************************************************************************************************************************
    CMD_SIOL_DEVICE_INFO_UPDATE:
      // update the server values
      ClassState    := pPara^.aPara[0]$t_e_VaranErrors;
      VendorID      := pPara^.aPara[1]$UDINT;
      DeviceID      := pPara^.aPara[2]$UDINT;
      MinCycleTime  := pPara^.aPara[3]$UDINT;
      ActualMode    := pPara^.aPara[4]$SdiasSDCIMaster::t_SDCIPortMode;
      
//**********************************************************************************************************************************************************
    CMD_SIOL_DEVICE_ADD_EVENT:
      // add the event to the local buffer
      AddEventToBuffer(pPara^.aPara[0]$^SdiasSDCIMaster::t_SDCIEventDetails);

//**********************************************************************************************************************************************************
  else
    if bUnknownCmdLogged = FALSE then
      LogError("@0531 (SDCIDevice::ClassState::NewInst) [SL] Unsupported command received!");
      bUnknownCmdLogged := TRUE;
    end_if;
  end_case;

	ret_code := READY;
  
END_FUNCTION


FUNCTION VIRTUAL SDCIDevice::AddEventToBuffer
	VAR_INPUT
		pEventDetails 	: ^SdiasSDCIMaster::t_SDCIEventDetails;
	END_VAR

  PdoProtection.SectionStart();

  // always add the new event to the buffer at the write index
  EventBuffer.aEvents[EventBuffer.EventWrIndex] := pEventDetails^;
  
  EventBuffer.EventWrIndex += 1;
  
  if EventBuffer.EventWrIndex = SIOL_EVENT_BUFFER_SIZE then
    EventBuffer.EventWrIndex := 0;
  end_if;

  // if the buffer has already been full
  if NbrOfEventsAvailable = SIOL_EVENT_BUFFER_SIZE then
    // also set the read index to the write index (because that is where the oldest entry is now)
    EventBuffer.EventRdIndex := EventBuffer.EventWrIndex;
  else
    // if not => increase the number of entries
    NbrOfEventsAvailable += 1;
  end_if;

  PdoProtection.SectionStop();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::GetEvent
	VAR_OUTPUT
		OldestEventAvailable 	: SdiasSDCIMaster::t_SDCIEventDetails;
	END_VAR

  PdoProtection.SectionStart();

  // if there are events
  if NbrOfEventsAvailable then
    // get the oldest
    OldestEventAvailable := EventBuffer.aEvents[EventBuffer.EventRdIndex];
    
    // increment the read pointer of the ring buffer
    EventBuffer.EventRdIndex += 1;
    if EventBuffer.EventRdIndex = SIOL_EVENT_BUFFER_SIZE then
      EventBuffer.EventRdIndex := 0;
    end_if;

    // show that there are less events in the buffer
    NbrOfEventsAvailable -= 1;
  else
    // no event available => set the whole return variable to 0
    _memset(dest:=#OldestEventAvailable, usByte:=0, cntr:=sizeof(OldestEventAvailable));
  end_if;

  PdoProtection.SectionStop();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::SetNewPortMode
	VAR_INPUT
		TargetMode 	: SdiasSDCIMaster::t_SDCIPortMode;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // forward the command to the master
  MyPara.uiCmd   := CMD_SIOL_DEVICE_SET_PORT_MODE;
  MyPara.aPara[0]:= TargetMode$DINT;
    
  MyResult.uiLng := 0;
  
  SdciIn.NewInst(#MyPara, #MyResult);
  
  if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
    retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
  else
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::Reconnect
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  // forward the command to the master
  MyPara.uiCmd   := CMD_SIOL_DEVICE_RECONNECT;
    
  MyResult.uiLng := 0;
  
  SdciIn.NewInst(#MyPara, #MyResult);
  
  if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
    retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
  else
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::GetReadPdoByte
	VAR_INPUT
		ReadOffset 	: USINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		ReadValue 	: USINT;
	END_VAR

  LastPdoReadError := GetReadPdoData(pReadData:=#ReadValue, ReadLength:=sizeof(ReadValue), ReadOffset:=ReadOffset);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::GetReadPdoWord
	VAR_INPUT
		ReadOffset 	: USINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		ReadValue 	: UINT;
	END_VAR

  LastPdoReadError := GetReadPdoData(pReadData:=#ReadValue, ReadLength:=sizeof(ReadValue), ReadOffset:=ReadOffset);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::GetReadPdoDWord
	VAR_INPUT
		ReadOffset 	: USINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		ReadValue 	: UDINT;
	END_VAR

  LastPdoReadError := GetReadPdoData(pReadData:=#ReadValue, ReadLength:=sizeof(ReadValue), ReadOffset:=ReadOffset);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::SetWritePdoByte
	VAR_INPUT
		WriteValue 	: USINT;
		WriteOffset 	: USINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR

  retcode := SetWritePdoData(pWriteData:=#WriteValue, WriteLength:=sizeof(WriteValue), WriteOffset:=WriteOffset);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::SetWritePdoWord
	VAR_INPUT
		WriteValue 	: UINT;
		WriteOffset 	: USINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR

  retcode := SetWritePdoData(pWriteData:=#WriteValue, WriteLength:=sizeof(WriteValue), WriteOffset:=WriteOffset);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::SetWritePdoDWord
	VAR_INPUT
		WriteValue 	: UDINT;
		WriteOffset 	: USINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR

  retcode := SetWritePdoData(pWriteData:=#WriteValue, WriteLength:=sizeof(WriteValue), WriteOffset:=WriteOffset);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::GetPdoReadError
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR

  retcode := LastPdoReadError;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice::Output::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Output := result := input <> 0;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL SDCIDevice::GetReadPdoDataBit
	VAR_INPUT
		pReadData 	: pVoid;
		ReadLengthBit 	: UDINT;
		ReadOffsetBit 	: UDINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
    MyPara   : CmdStruct;
    MyResult : results;
  END_VAR
  
    // if the pointer to the destination memory is valid
  if pReadData then

    // send the request to the master
    MyPara.uiCmd    := CMD_SIOL_DEVICE_GET_PDO_DATA_BIT;
    MyPara.aPara[0] := pReadData$DINT;
    MyPara.aPara[1] := ReadLengthBit$DINT;
    MyPara.aPara[2] := ReadOffsetBit$DINT;

    MyResult.uiLng := 0;
    
    SdciIn.NewInst(#MyPara, #MyResult);
    
    if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
      retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
    else
      retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
    end_if;
  else
    // invalid pointer
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidPointer;
  end_if;

END_FUNCTION
    
FUNCTION VIRTUAL GLOBAL SDCIDevice::SetWritePdoDataBit
	VAR_INPUT
		pWriteData 	: pVoid;
		WriteLengthBit 	: UDINT;
		WriteOffsetBit 	: UDINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
    MyPara   : CmdStruct;
    MyResult : results;
  END_VAR
  
    // if the pointer to the destination memory is valid
  if pWriteData then

    // send the request to the master
    MyPara.uiCmd    := CMD_SIOL_DEVICE_SET_PDO_DATA_BIT;
    MyPara.aPara[0] := pWriteData$DINT;
    MyPara.aPara[1] := WriteLengthBit$DINT;
    MyPara.aPara[2] := WriteOffsetBit$DINT;

    MyResult.uiLng := 0;
    
    SdciIn.NewInst(#MyPara, #MyResult);
    
    if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
      retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
    else
      retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
    end_if;
  else
    // invalid pointer
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_InvalidPointer;
  end_if;

END_FUNCTION
