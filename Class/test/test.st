//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "test"
	Revision           = "0.0"
	GUID               = "{66D48A11-5733-4595-A9AB-9CC5451BD026}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
	</Channels>
	<Network Name="test">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{43893BE6-9C99-4E65-B0E9-9C0E83488468}"
				Class      = "AI043"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="AI1"/>
					<Server Name="AI2"/>
					<Server Name="AI3"/>
					<Server Name="AI4"/>
					<Server Name="CableBreak"/>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FirmwareVersion"/>
					<Server Name="FPGAVersion"/>
					<Server Name="FWErrorBits"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="Range"/>
					<Server Name="RetryCounter"/>
					<Server Name="SerialNo"/>
					<Client Name="AI1_Active" Value="1"/>
					<Client Name="AI1_Config"/>
					<Client Name="AI1_FilterFreq"/>
					<Client Name="AI1_Max"/>
					<Client Name="AI1_MeasureMethod"/>
					<Client Name="AI1_Min"/>
					<Client Name="AI2_Active" Value="1"/>
					<Client Name="AI2_Config"/>
					<Client Name="AI2_FilterFreq"/>
					<Client Name="AI2_Max"/>
					<Client Name="AI2_MeasureMethod"/>
					<Client Name="AI2_Min"/>
					<Client Name="AI3_Active" Value="1"/>
					<Client Name="AI3_Config"/>
					<Client Name="AI3_FilterFreq"/>
					<Client Name="AI3_Max"/>
					<Client Name="AI3_MeasureMethod"/>
					<Client Name="AI3_Min"/>
					<Client Name="AI4_Active" Value="1"/>
					<Client Name="AI4_Config"/>
					<Client Name="AI4_FilterFreq"/>
					<Client Name="AI4_Max"/>
					<Client Name="AI4_MeasureMethod"/>
					<Client Name="AI4_Min"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
				</Channels>
				<AdditionalData>
					<Entry Name="DeviceType" Value="AI043"/>
				</AdditionalData>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(1032,210),(860,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(1032,270),(860,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(1032,330),(860,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(1032,390),(860,390),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(1032,450),(860,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(1032,510),(860,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(1032,570),(860,570),"/>
			<Connection Source="this.FirmwareVersion" Destination="_base.FirmwareVersion" Vertices="(1032,630),(860,630),"/>
			<Connection Source="this.FWErrorBits" Destination="_base.FWErrorBits" Vertices="(1032,690),(860,690),"/>
			<Connection Source="this.AI1" Destination="_base.AI1" Vertices="(1032,750),(860,750),"/>
			<Connection Source="this.AI2" Destination="_base.AI2" Vertices="(1032,810),(860,810),"/>
			<Connection Source="this.AI3" Destination="_base.AI3" Vertices="(1032,870),(860,870),"/>
			<Connection Source="this.AI4" Destination="_base.AI4" Vertices="(1032,930),(860,930),"/>
			<Connection Source="this.CableBreak" Destination="_base.CableBreak" Vertices="(1032,990),(860,990),"/>
			<Connection Source="this.Range" Destination="_base.Range" Vertices="(1032,1050),(860,1050),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using AI043

test : CLASS
: AI043
  //Servers:
  //Clients:
  //Variables:
  //Functions:
				//! <Function Comment="Init-Methode of Class.&#13;&#10;&#13;&#10;This Methode needs to get called. In case the Methode gets overwritten, a call needs to bet installed." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
	
	FUNCTION VIRTUAL GLOBAL UpdateRtPreOp
		VAR_INPUT
			callinfo 	: t_SDIAS_UpdateRTPreOp;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
				//! <Function Comment="Cyclic Update Methode which runs in PostScan." Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
				//! <Function Comment="Methode to get this-Pointer of Object in HardwareTree." Name="GetObjectThisp"/>
	FUNCTION VIRTUAL GetObjectThisp
		VAR_INPUT
			pObjectPath 	: ^USINT;			//! <Variable Comment="Objectpath of the Module." Name="GetObjectThisp.pObjectPath"/>
		END_VAR
		VAR_OUTPUT
			pThis 	: UDINT;			//! <Variable Comment="This-Pointer of Object." Name="GetObjectThisp.pThis"/>
		END_VAR;
				//! <Function Comment="Methode to set this-Pointer of Object in HardwareTree." Name="SetObjectThisp"/>
	FUNCTION VIRTUAL SetObjectThisp
		VAR_INPUT
			pObjectPath 	: ^USINT;			//! <Variable Comment="Objectpath of the Module." Name="SetObjectThisp.pObjectPath"/>
			pThis 	: UDINT;			//! <Variable Comment="This-Pointer of Object." Name="SetObjectThisp.pThis"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="Indicates if the call of the Methode was successful." Name="SetObjectThisp.dRetcode"/>
		END_VAR;
				//! <Function Comment="Call this Methode to get the Pointer to the Objectpath of this Module." Name="GetPointer2ObjectPath"/>
	FUNCTION VIRTUAL GLOBAL GetPointer2ObjectPath
		VAR_INPUT
			pThisPointerOverride 	: pVirtualBase := NIL;
		END_VAR
		VAR_OUTPUT
			p_us_ObjectPath 	: ^USINT;			//! <Variable Comment="Pointer to Objectpath of the Module." Name="GetPointer2ObjectPath.p_us_ObjectPath"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
				//! <Function Comment="Returns the hardware time stamp.&#13;&#10;This time stamp corresponds to the Rt start point" Name="GetHWTimeStamp"/>
	FUNCTION VIRTUAL GLOBAL GetHWTimeStamp
		VAR_OUTPUT
			HWTimeStamp 	: UINT;			//! <Variable Comment="Hardware Timestamp:&#13;&#10;0 - 65535 [µs]&#13;&#10;Constantly 0 Error, Timestamp could not be determined." Name="GetHWTimeStamp.HWTimeStamp"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetFWVersion
		VAR_INPUT
			pData 	: ^CHAR;
			Length 	: UDINT;
		END_VAR;
				//! <Function Comment="Methode to set a Text with Parameters as Log-Message." Name="LogValue"/>
	FUNCTION VIRTUAL LogValue
		VAR_INPUT
			pString 	: ^CHAR;			//! <Variable Comment="Pointer to Log-Message." Name="LogValue.pString"/>
			udValue 	: UDINT;			//! <Variable Comment="ParameterValue 1 which is added to Log-Message.&#13;&#10;&#13;&#10;16#FFFFFFFF =&gt; Value is not used." Name="LogValue.udValue"/>
			udValue2 	: UDINT := 16#FFFFFFFF;			//! <Variable Comment="ParameterValue 2 which is added to Log-Message.&#13;&#10;&#13;&#10;16#FFFFFFFF =&gt; Value is not used." Name="LogValue.udValue2"/>
			udValue3 	: UDINT := 16#FFFFFFFF;			//! <Variable Comment="ParameterValue 3 which is added to Log-Message.&#13;&#10;&#13;&#10;16#FFFFFFFF =&gt; Value is not used." Name="LogValue.udValue3"/>
		END_VAR;
				//! <Function Comment="Methode to set directly a Text as Log-Message." Name="LogError"/>
	FUNCTION VIRTUAL LogError
		VAR_INPUT
			pMsg 	: ^CHAR;			//! <Variable Comment="Pointer to Log-Message." Name="LogError.pMsg"/>
		END_VAR;
	
	FUNCTION VIRTUAL MyTrace
		VAR_INPUT
			pFormat 	: ^CHAR;
			pTxt0 	: ^CHAR;
			pTxt1 	: ^CHAR;
			pTxt2 	: ^CHAR;
		END_VAR;
				//! <Function Comment="Methode to add dataobjects for spi write access. Is only needed for function WriteSPIData()." Name="SPIWriteAddAccesses"/>
	FUNCTION VIRTUAL SPIWriteAddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode to get the state of spi write." Name="SPIWriteGetState"/>
	FUNCTION VIRTUAL SPIWriteGetState
		VAR_OUTPUT
			retcode 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode to write data into spi flash of modul." Name="WriteSPIData"/>
	FUNCTION VIRTUAL WriteSPIData
		VAR_INPUT
			usSectorNumber 	: USINT;			//! <Variable Comment="Sector number in which the data should be written. One sector has a size of 64 kByte." Name="WriteSPIData.usSectorNumber"/>
			usPageNumber 	: USINT;			//! <Variable Comment="Pagenumber in which the data should be written. One sector has 256 pages." Name="WriteSPIData.usPageNumber"/>
			usPageOffset 	: USINT;			//! <Variable Comment="Page offset in which the data should be written. One page has a size of 256 Byte." Name="WriteSPIData.usPageOffset"/>
			udLength 	: UDINT;			//! <Variable Comment="Gives the length of write data." Name="WriteSPIData.udLength"/>
			pData 	: ^USINT;			//! <Variable Comment="Pointer to the write data." Name="WriteSPIData.pData"/>
			usWriteMode 	: usWriteModes := 0x00;			//! <Variable Comment="defines the write mode for spi data&#13;&#10; 0 .. read sector - erase sector - write sector&#13;&#10; 1 .. read page - erase sector - write page&#13;&#10; 2 .. erase sector - write sector&#13;&#10; 3 .. erase sector - write page" Name="WriteSPIData.usWriteMode"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="The return value of the function.&#13;&#10; 0 .. ok&#13;&#10;-1 ..  pointer to write data is not valid&#13;&#10;-2 .. the last write access is not finished&#13;&#10;-3 .. length of write data is zero&#13;&#10;-4 .. length of write data is to long&#13;&#10;-5 .. no grant for spi access&#13;&#10;-6 .. the given write mode is not supported&#13;&#10;" Name="WriteSPIData.retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL SPIWriteUpdateRt;
	
	FUNCTION VIRTUAL SPIWriteUpdateCy;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB test::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_TEST
0$UINT, 0$UINT, (SIZEOF(::test))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(4008350648), "test", //Class
TO_UDINT(1698489890), "AI043", 1$UINT, 20$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_test 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_test] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION test::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= AI043::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_test;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateRtPreOp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #GetObjectThisp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #SetObjectThisp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #GetPointer2ObjectPath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #GetHWTimeStamp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetFWVersion();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #LogValue();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #LogError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #MyTrace();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #SPIWriteAddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #SPIWriteGetState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #WriteSPIData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #SPIWriteUpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #SPIWriteUpdateCy();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#define AI043_FIRMWARE_MAX_CFG16 70000

FUNCTION VIRTUAL GLOBAL test::UpdateRt
  AI043::UpdateRt();
END_FUNCTION


FUNCTION VIRTUAL GLOBAL test::UpdateRtPreOp
	VAR_INPUT
		callinfo 	: t_SDIAS_UpdateRTPreOp;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  ret_code := AI043::U
END_FUNCTION


FUNCTION VIRTUAL GLOBAL test::UpdateCy

END_FUNCTION


FUNCTION VIRTUAL GLOBAL test::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL GLOBAL test::ConnectEvent

END_FUNCTION


FUNCTION VIRTUAL GLOBAL test::DisconnectEvent

END_FUNCTION


FUNCTION VIRTUAL GLOBAL test::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL GLOBAL test::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL GLOBAL test::GetPointer2ObjectPath
	VAR_INPUT
		pThisPointerOverride 	: pVirtualBase;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		p_us_ObjectPath 	: ^USINT;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL GLOBAL test::GetHWTimeStamp
	VAR_OUTPUT
		HWTimeStamp 	: UINT;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::GetObjectThisp
	VAR_INPUT
		pObjectPath 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pThis 	: UDINT;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::SetObjectThisp
	VAR_INPUT
		pObjectPath 	: ^USINT;
		pThis 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::GetFWVersion
	VAR_INPUT
		pData 	: ^CHAR;
		Length 	: UDINT;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::LogValue
	VAR_INPUT
		pString 	: ^CHAR;
		udValue 	: UDINT;
		udValue2 	: UDINT;(* := 16#FFFFFFFF *)
		udValue3 	: UDINT;(* := 16#FFFFFFFF *)
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::LogError
	VAR_INPUT
		pMsg 	: ^CHAR;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::MyTrace
	VAR_INPUT
		pFormat 	: ^CHAR;
		pTxt0 	: ^CHAR;
		pTxt1 	: ^CHAR;
		pTxt2 	: ^CHAR;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::SPIWriteAddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::SPIWriteGetState
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::WriteSPIData
	VAR_INPUT
		usSectorNumber 	: USINT;
		usPageNumber 	: USINT;
		usPageOffset 	: USINT;
		udLength 	: UDINT;
		pData 	: ^USINT;
		usWriteMode 	: usWriteModes;(* := 0x00 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL test::SPIWriteUpdateRt

END_FUNCTION


FUNCTION VIRTUAL test::SPIWriteUpdateCy

END_FUNCTION
