//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "HmiCanSendReceive"
	Revision           = "0.2"
	GUID               = "{4A4A05A3-6D20-4162-AF46-039740111EA9}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{5B0368AF-2D5A-4C1B-97D3-F245A26033AD}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorCnt" GUID="{6CFAB41C-A808-4F7F-97A1-C47D93AFA296}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="RxPack" GUID="{0D65C441-633A-48A3-B913-DDADA6609FA2}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="TxPack" GUID="{0FA714B1-50BF-41E0-B6D6-2915808E6575}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="TxRetry" GUID="{6528C4B3-FA0A-4451-A57D-D7F6C3F75265}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="CanInterface" Required="true" Internal="false" DefValue="1"/>
		<Client Name="CanNodeDisplay" Required="true" Internal="false" DefValue="1"/>
		<Client Name="CanRxMsgID" Required="true" Internal="false" DefValue="16#40"/>
		<Client Name="CanTxMsgID" Required="true" Internal="false" DefValue="16#20"/>
		<Client Name="CoCan" Required="false" Internal="false"/>
		<Client Name="CoCanLib" Required="false" Internal="false"/>
		<Client Name="CoSys" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.2" Date="2015-03-16" Author="kolott" Company="sigmatek" Description="SA30531: new Clients CanRxMsgID and CanTxMsgID"/>
		<Dokumentation Revision="0.1" Date="2015-01-09" Author="kolott" Company="sigmatek" Description="client CoCanLib added, InitMethod is killed and new method Start added&#13;&#10;incremental messagecount added to each single-package"/>
		<Dokumentation Revision="0.0" Date="2014-01-29" Author="kolott" Company="sigmatek" Description="release"/>
	</RevDoku>
</Class>
*)
HmiCanSendReceive : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	TxPack 	: SvrCh_UDINT;
	RxPack 	: SvrCh_UDINT;
	TxRetry 	: SvrCh_UDINT;
	ErrorCnt 	: SvrCh_UDINT;
  //Clients:
	CanNodeDisplay 	: CltCh_DINT;
	CanInterface 	: CltCh_DINT;
	CanRxMsgID 	: CltCh_DINT;
	CanTxMsgID 	: CltCh_DINT;
	CoCan 	: CltChCmd__Can;
	CoSys 	: CltChCmd_System;
	CoCanLib 	: CltChCmd__CanLib;
  //Variables:
		TimeMarkLastTx 	: UDINT;
		TimeMarkLastRx 	: UDINT;
		UserCallBackFunct 	: ^void;
		UserCallBackThis 	: ^void;
		IndexOfLastPackage 	: UDINT;
		LengthOfReceivedData 	: UDINT;
		IndexOfReceivedPackage 	: UDINT;
		Acknowledge 	: UDINT;
		RxPointer 	: ^USINT;
		RxPointerSize 	: UDINT;
		CanReady 	: BOOL;
		PackCount 	: UDINT;
		PackPattern 	: UDINT;
		AcknowledgeError 	: UDINT;
		MessageCntTx 	: USINT;
		MessageCntRx 	: USINT;
  //Functions:
	
	FUNCTION HmiCanSendReceive
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL ReceiveIRQ
		VAR_INPUT
			pcan 	: ^USINT;
			pdata 	: ^USINT;
			pthis 	: ^void;
		END_VAR;
	
	FUNCTION SendAcknowledge;
	
	FUNCTION SendPackage
		VAR_INPUT
			pdat 	: ^void;
			length 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION RxPointerPrepaire
		VAR_INPUT
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION RxPointerAdd
		VAR_INPUT
			packindex 	: UDINT;
			ppack 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SendData
		VAR_INPUT
			pdata 	: ^void;
			length 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION WaitForAcknowledge
		VAR_INPUT
			ackcrc 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetLastTimeStamp
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION SendPackageWithRetry
		VAR_INPUT
			pdat 	: ^void;
			length 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION Send8Package
		VAR_INPUT
			pdata 	: ^void;
			length 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Start
		VAR_INPUT
			fctCallBack 	: ^void;
			thisp 	: ^void;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Can
#pragma usingLtd _CanLib
#pragma usingLtd System


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiCanSendReceive::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMICANSENDRECEIVE
0$UINT, 2$UINT, (SIZEOF(::HmiCanSendReceive))$UINT, 
5$UINT, 7$UINT, 0$UINT, 
TO_UDINT(2189921946), "HmiCanSendReceive", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiCanSendReceive.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::HmiCanSendReceive.TxPack.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2930836419), "TxPack", 
(::HmiCanSendReceive.RxPack.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2028527838), "RxPack", 
(::HmiCanSendReceive.TxRetry.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3049126926), "TxRetry", 
(::HmiCanSendReceive.ErrorCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(987008716), "ErrorCnt", 
//Clients:
(::HmiCanSendReceive.CanNodeDisplay.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4066256044), "CanNodeDisplay", 
(::HmiCanSendReceive.CanInterface.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1034073295), "CanInterface", 
(::HmiCanSendReceive.CanRxMsgID.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1802155902), "CanRxMsgID", 
(::HmiCanSendReceive.CanTxMsgID.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(146440772), "CanTxMsgID", 
(::HmiCanSendReceive.CoCan.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(282901669), "CoCan", TO_UDINT(3102794146), "_Can", 0$UINT, 4$UINT, 
(::HmiCanSendReceive.CoSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3991399253), "CoSys", TO_UDINT(968218125), "System", 0$UINT, 1$UINT, 
(::HmiCanSendReceive.CoCanLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(655268246), "CoCanLib", TO_UDINT(529317953), "_CanLib", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_HmiCanSendReceive 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiCanSendReceive] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiCanSendReceive::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_HmiCanSendReceive, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HmiCanSendReceive();

END_FUNCTION

//{{LSL_IMPLEMENTATION
//#define XX_SIMULATION  // todo: always turn off
#define USE_MESSAGECOUNT

#define MSG_DATA_SIZE         7
#define PACKAGE_RETRY         3
#define ID_HEADER_MESSAGE 16#7A
#define ID_ACK_MESSAGE    16#7E
//#define CAN_TX_OBJECT    16#020
//#define CAN_RX_OBJECT    16#040

FUNCTION GLOBAL UserCallback VAR_INPUT tp : pVoid; dp : pVoid; length : UDINT; END_VAR;

FUNCTION HmiCanSendReceive::HmiCanSendReceive
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;
  
  CanReady               := false;
  TimeMarkLastTx         := 0;
  TimeMarkLastRx         := 0;
  UserCallBackFunct      := nil;
  UserCallBackThis       := nil;
  
  IndexOfLastPackage     := 0;
  IndexOfReceivedPackage := 0;
  LengthOfReceivedData   := 0;
  Acknowledge            := 0;
  
  RxPointer              := nil;
  RxPointerSize          := 0;
  
  MessageCntRx           := 0;
  MessageCntTx           := 0;
  
END_FUNCTION

FUNCTION GLOBAL HmiCanSendReceive::Start
	VAR_INPUT
		fctCallBack 	: ^void;
		thisp 	: ^void;
	END_VAR
  VAR
  	myhdl : dint;
  END_VAR
  
  UserCallBackFunct := fctCallback;
  UserCallBackThis  := thisp;

  CanNodeDisplay := CanNodeDisplay.Read();
  CanInterface   := CanInterface.Read();
  CanRxMsgID     := CanRxMsgID.Read();
  CanTxMsgID     := CanTxMsgID.Read();
 #ifdef XX_SIMULATION
  CanReady := true;
 #else
   
  if(IsClientConnected(#CoCanLib)) then
    CoCanLib := 1;
    CoCanLib.CanBus.Write(CanInterface);
    myhdl := CoCanLib.AddCanObj(CanRxMsgID$int + CanNodeDisplay$int, 8, 1, #ReceiveIRQ(), this);
  else
    CoCanLib := 0;
    myhdl := CoCan.AddCanObj(CanNr       := CanInterface$USINT,                 // Can Nr
                             ObjNr       := CanRxMsgID$int + CanNodeDisplay$int, // Objectnumber
                             length      := 8,                                  // Byteanzahl
                             mode        := 1,                                  // 1 = RX with IRQ
                             actionptr   := #ReceiveIRQ(),                      // IRQ Routine
                             thispointer := this);
  end_if;
                         
  if(myhdl >= 0) then
    CanReady := true;
    RxPointerPrepaire(256); // nice to have
  end_if;
 #endif

END_FUNCTION

FUNCTION HmiCanSendReceive::RxPointerPrepaire
	VAR_INPUT
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	ph : ^void;
  END_VAR

  retcode := true;
  size    += MSG_DATA_SIZE;
 
  if(size > RxPointerSize) then
    retcode := false;
    if(RxPointer = nil) then
      ph := CoSys.Malloc(size);
      if(ph <> nil) then
        RxPointer     := ph$^usint;
        RxPointerSize := size;
        retcode       := true;
      end_if;
    else
      ph := CoSys.ReAlloc(RxPointer, size);
      if(ph <> nil) then
        RxPointer     := ph$^usint;
        RxPointerSize := size;
        retcode       := true;
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION HmiCanSendReceive::RxPointerAdd
	VAR_INPUT
		packindex 	: UDINT;
		ppack 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	offset : udint;
  END_VAR

  retcode := false;
  offset  := (packindex + 1) * MSG_DATA_SIZE;
  if((RxPointer <> nil) & (offset < RxPointerSize)) then
    _memcpy(RxPointer + offset - MSG_DATA_SIZE, ppack, MSG_DATA_SIZE);
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION HmiCanSendReceive::SendPackage
	VAR_INPUT
		pdat 	: ^void;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  TxPack  += 1;
  retcode := Acknowledge;
  
 #ifdef XX_SIMULATION
  ReceiveIRQ(nil, pdat$^usint, this);
 #else
 
  if(CoCanLib = 1) then
    CoCanLib.CanTxObj(CanTxMsgID$int + CanNodeDisplay$int, length$usint, pdat);
  else 
    CoCan.CanTxObj(CanInterface$USINT, CanTxMsgID$int + CanNodeDisplay$int, length$usint, pdat);
  end_if;
 #endif

END_FUNCTION

FUNCTION HmiCanSendReceive::SendAcknowledge
  VAR
    txdat : array[0..1] of usint;
  END_VAR

  txdat[0] := ID_ACK_MESSAGE;
  SendPackage(#txdat[0], 1); // send acknowledge

END_FUNCTION

FUNCTION HmiCanSendReceive::SendPackageWithRetry
	VAR_INPUT
		pdat 	: ^void;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	retry : udint;
  END_VAR
  
  retry := 0;
  repeat
    retcode := WaitForAcknowledge(SendPackage(pdat, length));
    retry += 1;
  until((retcode = true) | (retry > PACKAGE_RETRY)) end_repeat;

  if(retry > 1) then
    TxRetry += 1;
  end_if;

END_FUNCTION

FUNCTION HmiCanSendReceive::WaitForAcknowledge
	VAR_INPUT
		ackcrc 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tix : udint;
  END_VAR

  tix := ops.tAbsolute;
  repeat
    if(Acknowledge <> ackcrc) then
      retcode := true;
      return;
    end_if;
  until((ops.tAbsolute - tix) >= 100) end_repeat;
  
  AcknowledgeError += 1;
  retcode := false;

END_FUNCTION

FUNCTION GLOBAL HmiCanSendReceive::ReceiveIRQ
	VAR_INPUT
		pcan 	: ^USINT;
		pdata 	: ^USINT;
		pthis 	: ^void;
	END_VAR
  VAR
    length, idx, index : udint;
    rxdat : array[0..7] of usint;
   #ifdef USE_MESSAGECOUNT
    msgcnt : usint;
   #endif
  END_VAR

  this := pthis$^HmiCanSendReceive;

  RxPack         += 1;
  TimeMarkLastRx := ops.tAbsolute;

  if(pdata^ and 16#80) then
    // got singlepack-message
    length := pdata^ and 16#07;
    _memcpy(#rxdat[0], pdata+1, MSG_DATA_SIZE);
    SendAcknowledge();
  
    if(UserCallBackFunct <> nil) then
     #ifdef USE_MESSAGECOUNT
      msgcnt := ((pdata^) shr 3) and 16#0F;
      if(msgcnt <> 0) then
        if(msgcnt <> MessageCntRx) then
          MessageCntRx := msgcnt;
          UserCallBackFunct$UserCallback(UserCallBackThis, #rxdat[0], length); // call user
        end_if;
      else
        // default=0 to keep compatibility to system without messagecount
        UserCallBackFunct$UserCallback(UserCallBackThis, #rxdat[0], length); // call user
      end_if;
     #else 
      UserCallBackFunct$UserCallback(UserCallBackThis, #rxdat[0], length); // call user
     #endif
    end_if;
    
  else
    case pdata^ of
      ID_ACK_MESSAGE    : // got acknowledge
        Acknowledge += 1;
        
      ID_HEADER_MESSAGE : // got headermessage of multipack-message
        PackCount              := 0;
        PackPattern            := 0;
        IndexOfReceivedPackage := 0;
        IndexOfLastPackage     := pdata$^udint^ shr 8;
        pdata                  += 4;
        LengthOfReceivedData   := pdata$^udint^;
        
        RxPointerPrepaire(LengthOfReceivedData);
        SendAcknowledge();
        if(IndexOfLastPackage > 0) then
          IndexOfLastPackage -= 1; // convert number into last index
        else
          ErrorCnt += 1;
        end_if;
      else                // got single datapackage of multipack-message
        idx         := (pdata^ and 16#07);
        PackPattern := PackPattern or (1 shl idx); // add pattern
        
        if(PackPattern = (16#FF shr (7 - idx))) then // check pattern
          PackCount   += 1;
          index       := IndexOfReceivedPackage + idx;
          RxPointerAdd(index, pdata+1);
   
          if(index = IndexOfLastPackage) then
            // got last package
            SendAcknowledge();
            if(UserCallBackFunct <> nil) then
              UserCallBackFunct$UserCallback(UserCallBackThis, RxPointer, LengthOfReceivedData); // call user
            end_if;
          elsif(PackCount = 8) then
            // send acknowledge each 8th package
            SendAcknowledge();
            IndexOfReceivedPackage += 8;
            PackCount   := 0;
            PackPattern := 0;
          end_if;
        else
          PackCount   := 0;
          PackPattern := 0;
          ErrorCnt += 1;
        end_if;
    end_case;
  end_if;
  
END_FUNCTION

FUNCTION HmiCanSendReceive::Send8Package
	VAR_INPUT
		pdata 	: ^void;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	txdat : array[0..8] of usint;
    ackcrc, part, len, nox, retry : udint;
    idx : usint;
  END_VAR

  retcode := false;
  retry   := 0;
  
  while(retry < PACKAGE_RETRY) do

    len := length;
    nox := (len + MSG_DATA_SIZE - 1) / MSG_DATA_SIZE;
    if(nox > 8) then
      nox := 8;
    end_if;
  
    if(nox > 0) then
      idx := 0;
      while(nox) do // send packages
        part := MSG_DATA_SIZE;
        if(len < part) then
          part := len;
        end_if;
        len -= part;
      
        txdat[0] := idx;
        _memcpy(#txdat[1], pdata + (idx * MSG_DATA_SIZE), part);
        ackcrc := SendPackage(#txdat[0], part+1);
        
        idx  += 1;
        nox  -= 1;
      end_while;  

      if(WaitForAcknowledge(ackcrc) = true) then // wait for acknowledge
        retcode := true;
        return;
      end_if;
      
      retry += 1;
    else // nothing to send
      retcode := true;
      return;
    end_if;
  end_while;

END_FUNCTION

FUNCTION GLOBAL HmiCanSendReceive::SendData
	VAR_INPUT
		pdata 	: ^void;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	txdat : array[0..8] of usint;
    part : udint;
  END_VAR
  
  retcode := CanReady;
  
  if((pdata <> nil) & (length > 0) & (CanReady = true)) then
  
    if(length <= MSG_DATA_SIZE) then
      // send singlepack-message
      txdat[0] := 16#80 or length$usint;
      
     #ifdef USE_MESSAGECOUNT 
      MessageCntTx += 1;
      if(MessageCntTx > 15) then
        MessageCntTx := 1;  // default=0 to keep compatibility to system without messagecount
      end_if;
      txdat[0] := txdat[0] or (MessageCntTx shl 3);
     #endif
     
      _memcpy(#txdat[1], pdata, length);
      if(SendPackageWithRetry(#txdat[0], length + 1) = false) then // send singlepack and wait for acknowledge
        ErrorCnt += 1;
        retcode  := false;
      end_if;
    else
      // send multipack-message
      retcode        := false;
      txdat[0]       := ID_HEADER_MESSAGE;
      txdat[1]$udint := (length + MSG_DATA_SIZE - 1) / MSG_DATA_SIZE;
      txdat[4]$udint := length;
      if(SendPackageWithRetry(#txdat[0], 8) = true) then // send headerpack and wait for acknowledge
      
        retcode := true;
        while(length) do
          if(Send8Package(pdata, length) = true) then
            part := MSG_DATA_SIZE * 8;
            if(part > length) then
              part := length;
            end_if;
            length -= part;
            pdata  += part;
          else
            length  := 0;
            retcode := false;
            ErrorCnt += 1;
          end_if;
        end_while;  
      end_if;
      
      TimeMarkLastTx := ops.tAbsolute;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiCanSendReceive::GetLastTimeStamp
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  
  retcode := TimeMarkLastTx;

END_FUNCTION
