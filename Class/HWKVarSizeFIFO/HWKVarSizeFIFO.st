//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define _HWKBUF_MEMID 16#1E3B0000
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "HWKVarSizeFIFO"
	Revision           = "1.0"
	GUID               = "{589CFDB8-59DC-4A58-AC5E-BB8DD5E9ED52}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(660,240)"
	Comment            = "FIFO Buffer with variable Data Length.&#13;&#10;Input Data (AddData, AddData2) is thread safe and may be called from different tasks.&#13;&#10;Output Data (GetData, GetData2) is not thread safe any works only if called from a single Task.&#13;&#10;Each entry in the buffer takes an additional 8Byte header information.">
	<Channels>
		<Server Name="ClassState" GUID="{12C25C14-9BED-488E-A717-970878F64CB5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of Class:&#13;&#10;1 .. Buffer enabled&#13;&#10;0 .. Buffer disabled&#13;&#10;0&gt; .. Error"/>
		<Client Name="MaxBufferSize" Required="true" Internal="false" Comment="Size of the buffer in byte. &#13;&#10;(As Init Value)"/>
		<Client Name="ToStdLib" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="LanSte"/>
		<Dokumentation Revision="1.0" Date="02.07.2019" Author="LanSte" Company="Sigmatek" Description="1st release version"/>
	</RevDoku>
</Class>
*)
HWKVarSizeFIFO : CLASS
	TYPE
	  t_p_SigClib : ^SigCLib;
	END_TYPE
  //Servers:
	ClassState 	: SvrChCmd_DINT;
  //Clients:
	ToStdLib 	: CltChCmd__StdLib;
	MaxBufferSize 	: CltCh_UDINT;
  //Variables:
		pWriteData 	: ^HDINT;
		pReadData 	: ^HDINT;
		pDataMin 	: ^HDINT;
		pDataMax 	: ^HDINT;
		buffermemused 	: UDINT;
  //Functions:
	
	FUNCTION HWKVarSizeFIFO
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Adds data to buffer.&#13;&#10;pData .. Pointer to data.&#13;&#10;size .. size of data in byte.&#13;&#10;&#13;&#10;retcode:&#13;&#10;0 .. Data successfully added&#13;&#10;-1.. Class not ready&#13;&#10;-2 .. Invalid inputs&#13;&#10;-3 .. Buffer full" Name="AddData"/>
	FUNCTION VIRTUAL GLOBAL AddData
		VAR_INPUT
			pData 	: ^HSINT;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Adds data to buffer from 2 different sources.&#13;&#10;pData .. Pointer to data source 1.&#13;&#10;size .. size of data sourece 1 in byte.&#13;&#10;pData2 .. Pointer to data source 2.&#13;&#10;size2 .. size of data source 2 in byte.&#13;&#10;&#13;&#10;retcode:&#13;&#10;0 .. Data successfully added&#13;&#10;-1.. Class not ready&#13;&#10;-2 .. Invalid inputs&#13;&#10;-3 .. Buffer full" Name="AddData2"/>
	FUNCTION VIRTUAL GLOBAL AddData2
		VAR_INPUT
			pData 	: ^HSINT;
			size 	: UDINT;
			pData2 	: ^HSINT;
			size2 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Gets data from buffer.&#13;&#10;pData .. Pointer to memory, into which the buffered data will be copied.&#13;&#10;size .. size of memory in byte, into which the buffered data will be copied.&#13;&#10;offset .. Optional, Number of bytes skipped when copying.&#13;&#10;&#13;&#10;retcode:&#13;&#10;&gt;0 .. Number of bytes copied to pData &#13;&#10;-1.. Class not ready&#13;&#10;-2 .. Invalid inputs&#13;&#10;-13, -14 .. No valid data in Buffer/Buffer empty" Name="GetData"/>
	FUNCTION VIRTUAL GLOBAL GetData
		VAR_INPUT
			pData 	: ^HSINT;
			size 	: UDINT;
			offset 	: UDINT := 0;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Gets data from buffer and copies it to seperate memory areas.&#13;&#10;pData .. Pointer to memory, into which the 1st part of the buffered data will be copied.&#13;&#10;size .. size of memory in byte, into which the 1st part buffered data will be copied.&#13;&#10;pData2 .. Pointer to memory, into which the 2nd part of the buffered data will be copied.&#13;&#10;size2 .. size of memory in byte, into which the 2nd part buffered data will be copied.&#13;&#10;&#13;&#10;retcode:&#13;&#10;&gt;0 .. Total number of bytes copied to pData and pData2&#13;&#10;         If retcode &lt;= size =&gt; No data copied to pData2&#13;&#10;&#13;&#10;-1.. Class not ready&#13;&#10;-2 .. Invalid inputs&#13;&#10;-13, -14 .. No valid data in Buffer/Buffer empty" Name="GetData2"/>
	FUNCTION VIRTUAL GLOBAL GetData2
		VAR_INPUT
			pData 	: ^HSINT;
			size 	: UDINT;
			pData2 	: ^HSINT;
			size2 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Reserves &quot;sizeinbuffer&quot; memory in buffer.&#13;&#10;Returns &quot;pLocalWrite&quot; to the start of the reserved memory.&#13;&#10;Returns NIL if memory could not be reserved.&#13;&#10;" Name="ReserveWriteMem"/>
	FUNCTION VIRTUAL ReserveWriteMem
		VAR_INPUT
			sizeinbuffer 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pLocalWrite 	: ^HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL MarkWriteBufferValid
		VAR_INPUT
			pLocalWriteStart 	: ^HDINT;
			sizeinbuffer 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL CheckValidReadData
		VAR_OUTPUT
			sizeinbuffer 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL FreeReadBuffer
		VAR_INPUT
			pLocalReadStart 	: ^HDINT;
			sizeinbuffer 	: UDINT;
		END_VAR;
				//! <Function Comment="Read data from buffer without removeing the data from the buffer.&#13;&#10;(Calling ReadData() followed by RemoveData() is equal to a call of GetData())&#13;&#10;pData .. Pointer to memory, into which the buffered data will be copied.&#13;&#10;size .. size of memory in byte, into which the buffered data will be copied.&#13;&#10;&#13;&#10;retcode:&#13;&#10;&gt;0 .. Number of bytes copied to pData &#13;&#10;-1.. Class not ready&#13;&#10;-2 .. Invalid inputs&#13;&#10;-13, -14 .. No valid data in Buffer/Buffer empty" Name="ReadData"/>
	FUNCTION VIRTUAL GLOBAL ReadData
		VAR_INPUT
			pData 	: ^HSINT;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Removes data from Buffer.&#13;&#10;(Calling ReadData() followed by RemoveData() is equal to a call of GetData())&#13;&#10;retcode:&#13;&#10;&gt;0 .. Number of bytes removed from buffer&#13;&#10;-1.. Class not ready&#13;&#10;-13, -14 .. No valid data in Buffer/Buffer empty" Name="RemoveData"/>
	FUNCTION VIRTUAL GLOBAL RemoveData
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Enables the buffer.&#13;&#10;Discards any existing data in Buffer." Name="Enable"/>
	FUNCTION VIRTUAL GLOBAL Enable;
				//! <Function Comment="Disables the buffer." Name="Disable"/>
	FUNCTION VIRTUAL GLOBAL Disable;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HWKVarSizeFIFO::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HWKVARSIZEFIFO
1$UINT, 0$UINT, (SIZEOF(::HWKVarSizeFIFO))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2647432661), "HWKVarSizeFIFO", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HWKVarSizeFIFO.ClassState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
//Clients:
(::HWKVarSizeFIFO.ToStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2501598121), "ToStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::HWKVarSizeFIFO.MaxBufferSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(194656658), "MaxBufferSize", 
END_FUNCTION


#define USER_CNT_HWKVarSizeFIFO 12

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HWKVarSizeFIFO] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HWKVarSizeFIFO::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_HWKVarSizeFIFO, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #AddData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #AddData2();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetData2();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #ReserveWriteMem();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #MarkWriteBufferValid();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #CheckValidReadData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #FreeReadBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ReadData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #RemoveData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #Enable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #Disable();

#pragma warning (default : 74)
	ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HWKVarSizeFIFO();

END_FUNCTION

#pragma usingLtd SigCLib

//{{LSL_IMPLEMENTATION

FUNCTION HWKVarSizeFIFO::HWKVarSizeFIFO
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  ClassState := -2;
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL HWKVarSizeFIFO::Init

  if _FirstScan then
    
    MaxBufferSize := MaxBufferSize.Read();
    
    if MaxBufferSize < 48 then
      MaxBufferSize := 48;  // = 48/(4 + 2*4) = 4 entries in Buffer.
    end_if;
    
    if MaxBufferSize mod 4 then
      MaxBufferSize += ( 4 - (MaxBufferSize mod 4));
    end_if;
    
    // pDataMin points to the start of the buffer
    pDataMin$pVoid := ToStdLib.Malloc(size:= MaxBufferSize);
    
    if pDataMin = NIL then
#ifdef HWC_LogError
      HWC_LogError(this, "@0535 (HWKVarSizeFIFO::Init) Failed to allocate memory for buffer.");
#endif 
      ClassState := -1;
      return;
    end_if;
    
    ToStdLib.MemSet(dest:=pDataMin, value:=0, size:=MaxBufferSize);    
    
    // pDataMax points to the end of the buffer
    pDataMax := pDataMin + MaxBufferSize;
    pWriteData := pReadData := pDataMin;
    
    ClassState := 1;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL HWKVarSizeFIFO::ReserveWriteMem
	VAR_INPUT
		sizeinbuffer 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pLocalWrite 	: ^HDINT;
	END_VAR
  VAR
    pLocalWritedataStart  : ^HDINT;
    pLocalWritedataStart2 : ^HDINT;
    pLocalWritedataEnd : ^HDINT;
    localbuffermemused : UDINT;
  END_VAR 
  
  pLocalWrite := NIL;
  
  // Check if there is space in the buffer
  localbuffermemused := sigclib_atomic_addU32(#buffermemused, sizeinbuffer);  

  if (localbuffermemused + sizeinbuffer) > MaxBufferSize then
    // Buffer full
    sigclib_atomic_subU32(#buffermemused, sizeinbuffer);    
    return;
  end_if;
  
  // Get pointer to free buffer space
  repeat
  
    pLocalWritedataStart$UDINT := sigclib_atomic_getU32((#pWriteData)$^UDINT);
    
    pLocalWritedataEnd := pLocalWritedataStart + sizeinbuffer;      
    if pLocalWritedataEnd >= pDataMax then
      pLocalWritedataEnd -= MaxBufferSize;
    end_if;
    
    pLocalWritedataStart2$UDINT := sigclib_atomic_cmpxchgU32(pValue := (#pWriteData)$^UDINT, cmpVal := pLocalWritedataStart$UDINT, newVal:= pLocalWritedataEnd$UDINT);
                  
  until (pLocalWritedataStart = pLocalWritedataStart2) end_repeat;
    
  pLocalWrite := pLocalWritedataStart;
  
END_FUNCTION

FUNCTION VIRTUAL HWKVarSizeFIFO::MarkWriteBufferValid
	VAR_INPUT
		pLocalWriteStart 	: ^HDINT;
		sizeinbuffer 	: UDINT;
	END_VAR	
  VAR
  	pLocalWriteEnd : ^HDINT;
  END_VAR
  
  pLocalWriteEnd := pLocalWriteStart + sizeinbuffer - sizeof(UDINT);
  if pLocalWriteEnd >= pDataMax then
    pLocalWriteEnd -= MaxBufferSize;
  end_if;
  
  // copy header only whenn all data is valid, valid header is checked in GetData
  pLocalWriteEnd^   := not(_HWKBUF_MEMID OR sizeinbuffer);
  pLocalWriteStart^ := _HWKBUF_MEMID OR sizeinbuffer;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL HWKVarSizeFIFO::AddData
	VAR_INPUT
		pData 	: ^HSINT;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    sizeinbuffer  : UDINT;
    datasize1     : UDINT;
    datasize2     : UDINT;
  	pLocalWritedataStart : ^HDINT;    
    pLocalWritedata : ^HDINT;
  END_VAR 
  
  retcode := -1;
  if ClassState > 0 then  // Is class ok
    retcode := -2;
    // Check inputs ok
    if pData & size &     
       (size < (MaxBufferSize - 2* sizeof(UDINT)) ) & 
       (size < (16#FFFF       - 2* sizeof(UDINT)) ) then
  
      sizeinbuffer := size;
      // align 4 Byte
      if sizeinbuffer mod 4 then
        sizeinbuffer += ( 4 - (sizeinbuffer mod 4));
      end_if;
      
      // Add 4Byte for Header , 4 Byte for endMarker
      sizeinbuffer += (sizeof(UDINT) * 2);
      
      retcode := -3;
      
      // Get Pointer to free buffer memory
      pLocalWritedataStart := ReserveWriteMem(sizeinbuffer:=sizeinbuffer);
      if pLocalWritedataStart then
        
        retcode := 0;
        
        // Skip header
        pLocalWritedata := pLocalWritedataStart + sizeof(UDINT);
        if ( (pLocalWritedata + sizeinbuffer - (sizeof(UDINT) * 2) ) <= pDataMax) then
          // Data fits in one consecutive block
          
          // copy data
          _memcpy(ptr1:=pLocalWritedata, ptr2:=pData, cntr:=size);
          
        else      
          
          datasize1 := pDataMax$UDINT - pLocalWritedata$UDINT;
          datasize2 := size - datasize1;
          
          if datasize1 then
            // copy data part 1
            _memcpy(ptr1 := pLocalWritedata, ptr2 := pData, cntr := datasize1);
          end_if;
          
          // copy data part 2
          _memcpy(ptr1 := pDataMin, ptr2 := pData+datasize1, cntr := datasize2);        

        end_if;
        
        MarkWriteBufferValid(pLocalWritedataStart, sizeinbuffer);
      
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HWKVarSizeFIFO::AddData2
	VAR_INPUT
		pData 	: ^HSINT;
		size 	: UDINT;
		pData2 	: ^HSINT;
		size2 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    sizeinbuffer  : UDINT;
    datasize1     : UDINT;
    datasize2     : UDINT;
  	pLocalWritedataStart : ^HDINT;    
    pLocalWritedata : ^HDINT;
  END_VAR 
  
  retcode := -1;
  if ClassState > 0 then  // Is class ok
    retcode := -2;
    // Check inputs ok
    if pData  & size  & 
       pData2 & size2 &
       ( (size + size2) < (MaxBufferSize - 2 * sizeof(UDINT)) ) & 
       ( (size + size2) < (16#FFFF       - 2 * sizeof(UDINT)) ) then
  
      sizeinbuffer := size + size2;
      // align 4 Byte
      if sizeinbuffer mod 4 then
        sizeinbuffer += ( 4 - (sizeinbuffer mod 4));
      end_if;
      
      // Add 4Byte for Header , 4 Byte for endMarker
      sizeinbuffer += (sizeof(UDINT) * 2);
      
      retcode := -3;
      
      // Get Pointer to free buffer memory
      pLocalWritedataStart := ReserveWriteMem(sizeinbuffer:=sizeinbuffer);
      if pLocalWritedataStart then
        
        retcode := 0;

        // Skip header
        pLocalWritedata := pLocalWritedataStart + sizeof(UDINT);
        if ( (pLocalWritedata + sizeinbuffer - (sizeof(UDINT) * 2) ) <= pDataMax) then          
          // Data 1 + Data 2 fits in one consecutive block
          
          // copy data 1
          _memcpy(ptr1:=pLocalWritedata, ptr2:=pData, cntr:=size);
          
          // copy data 2
          pLocalWritedata += size;
          _memcpy(ptr1:=pLocalWritedata, ptr2:=pData2, cntr:=size2);
          
        else        
          
          if (pLocalWritedata + size) = pDataMax then
            // Data1 fits exactly before pDataMax 
            
            // copy data 1
            _memcpy(ptr1:=pLocalWritedata, ptr2:=pData, cntr:=size);
            
            // copy data 2
            _memcpy(ptr1:=pDataMin, ptr2:=pData2, cntr:=size2);
          
          else          
            
            if pLocalWritedata + size >= pDataMax then
              // Split in data1
              datasize1 := pDataMax$UDINT - pLocalWritedata$UDINT;
              datasize2 := size - datasize1;
              
              if datasize1 then
                // copy data 1 part 1
                _memcpy(ptr1 := pLocalWritedata, ptr2 := pData, cntr := datasize1);
              end_if;
              
              // copy data 1  part 2
              _memcpy(ptr1 := pDataMin, ptr2 := pData+datasize1, cntr := datasize2);
              
              // copy data 2
              _memcpy(ptr1 := pDataMin + datasize2, ptr2 := pData2, cntr := size2);
            
            else
              // Split in data2
              
              // copy data 1
              _memcpy(ptr1 := pLocalWritedata, ptr2 := pData, cntr := size);
              
              pLocalWritedata += size;
              
              datasize1 := pDataMax$UDINT - pLocalWritedata$UDINT;
              datasize2 := size2 - datasize1;
              
              // copy data 2 Part 1
              _memcpy(ptr1:=pLocalWritedata, ptr2:=pData2, cntr:=datasize1);
              
              // copy data 2 Part 2
              _memcpy(ptr1:=pDataMin, ptr2:=pData2 + datasize1, cntr:=datasize2);
            
            end_if;
            
          end_if;
          
        end_if;
        
        MarkWriteBufferValid(pLocalWritedataStart, sizeinbuffer);
      
      end_if;    
    end_if;
  end_if;  

END_FUNCTION

FUNCTION VIRTUAL HWKVarSizeFIFO::CheckValidReadData
	VAR_OUTPUT
		sizeinbuffer 	: DINT;
	END_VAR
  VAR
    header : UDINT;    
    pLocalReaddataEnd : ^HDINT;
  END_VAR
    
  sizeinbuffer := -13;
  // Check if buffer is used and header
  header := pReadData^;
  if (buffermemused) & ((header AND 16#FFFF0000) = _HWKBUF_MEMID) then

    // Get size of data in buffer
    sizeinbuffer$UDINT  := header AND 16#FFFF;    
    
    pLocalReaddataEnd := pReadData + sizeinbuffer - sizeof(UDINT);
    if pLocalReaddataEnd >= pDataMax then
      pLocalReaddataEnd -= MaxBufferSize;
    end_if;    
    
    // Check endmarker
    if header <> not(pLocalReaddataEnd^) then
      sizeinbuffer := -14;
    end_if;
  end_if;  
  
END_FUNCTION

FUNCTION VIRTUAL HWKVarSizeFIFO::FreeReadBuffer
	VAR_INPUT
		pLocalReadStart 	: ^HDINT;
		sizeinbuffer 	: UDINT;
	END_VAR	
  VAR
  	pLocalReadEnd : ^HDINT;
  END_VAR
  
  pLocalReadEnd := pLocalReadStart + sizeinbuffer - sizeof(UDINT);
  if pLocalReadEnd >= pDataMax then
    pLocalReadEnd -= MaxBufferSize;
  end_if;
  
   // Clear Header
  pReadData^ := 0;
  pLocalReadEnd^ := 0;

  // Update read buffer pointer
  pReadData := pLocalReadEnd + sizeof(UDINT);
  if pReadData >= pDataMax then
    pReadData := pDataMin;
  end_if;
  
  // Free Buffer
  sigclib_atomic_subU32(#buffermemused, sizeinbuffer$UDINT);
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL HWKVarSizeFIFO::GetData
	VAR_INPUT
		pData 	: ^HSINT;
		size 	: UDINT;
		offset 	: UDINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	sizeinbuffer  : DINT;
    datasize      : UDINT;
    datasize1     : UDINT;
    datasize2     : UDINT;    
    pLocalReaddata : ^HDINT;
  END_VAR

  retcode := -1;
  if ClassState > 0 then  // Is class ok
    
    retcode := -2;
    // Check inputs ok
    if pdata & size then
      
      // Check for valid data in buffer
      retcode := sizeinbuffer := CheckValidReadData();
      if sizeinbuffer > 0 then
        
        datasize := sizeinbuffer$UDINT - (sizeof(UDINT) * 2);  // sizeof(UDINT) * 2 = Header + Endmarker
        
        if datasize > offset then
          datasize -= offset;
        else
          datasize := 0;
        end_if;
        
        if datasize > size then
          datasize := size;
        end_if;
        
        if datasize then  // datasize can be 0 if offset is larger then datasize
        
          // Skip header
          pLocalReaddata := pReadData + offset + sizeof(UDINT);
          if pLocalReaddata >= pDataMax then
            pLocalReaddata -= MaxBufferSize;
          end_if;
          
          if ( (pLocalReaddata + datasize) <= pDataMax) then
            
            // Copy data
            _memcpy(ptr1 := pData, ptr2 := pLocalReaddata, cntr := datasize);
            
          else
            
            datasize1 := pDataMax$UDINT - pLocalReaddata$UDINT;
            datasize2 := datasize - datasize1;
        
            if datasize1 then
              // copy data 1
              _memcpy(ptr1 := pData, ptr2 := pLocalReaddata, cntr := datasize1);
            end_if;
            
            // copy data 2
            _memcpy(ptr1 := pData+datasize1, ptr2 := pDataMin, cntr := datasize2);
            
          end_if;
        end_if;
       
        FreeReadBuffer(pReadData, sizeinbuffer$UDINT);
        
        retcode := datasize$DINT;
      
      end_if;

    end_if;
  
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HWKVarSizeFIFO::GetData2
	VAR_INPUT
		pData 	: ^HSINT;
		size 	: UDINT;
		pData2 	: ^HSINT;
		size2 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	sizeinbuffer  : DINT;
    datasize      : UDINT;
    datasize1     : UDINT;
    datasize2     : UDINT;    
    pLocalReaddata : ^HDINT;
  END_VAR

  retcode := -1;
  if ClassState > 0 then  // Is class ok
    
    retcode := -2;
    // Check inputs ok
    if pdata  & size & 
       pdata2 & size2 then       
      
      // Check for valid data in buffer
      retcode := sizeinbuffer := CheckValidReadData();
      if sizeinbuffer > 0 then
      
        datasize := sizeinbuffer$UDINT - (sizeof(UDINT) * 2); // sizeof(UDINT) * 2 = Header + Endmarker
        
        if datasize > (size + size2) then
          datasize := (size + size2);
        end_if;
        
        if size > datasize then
          size  := datasize;
          size2 := 0;
        elsif (size + size2) > datasize then
          size2 := datasize - size;
        end_if;
        
        // Skip header
        pLocalReaddata := pReadData + sizeof(UDINT);
        if pLocalReaddata >= pDataMax then
          pLocalReaddata := pDataMin;
        end_if;

        if ( (pLocalReaddata + datasize) <= pDataMax) then
          
          // Copy data 1
          _memcpy(ptr1 := pData, ptr2 := pLocalReaddata, cntr := size);
          
          // Copy data 2
          if size2 then
            _memcpy(ptr1 := pData2, ptr2 := pLocalReaddata + size, cntr := size2);
          end_if;
        
        else
        
          if (pLocalReaddata + size) = pDataMax then
            // Data1 fits exactly before pDataMax 
          
            // copy data 1
            _memcpy(ptr1:=pData, ptr2:=pLocalReaddata, cntr:=size);
            
            // copy data 2
            if size2 then
              _memcpy(ptr1:=pData2, ptr2:=pDataMin, cntr:=size2);
            end_if;
        
          else          
            
            if pLocalReaddata + size >= pDataMax then        
              // Split in data1
              datasize1 := pDataMax$UDINT - pLocalReaddata$UDINT;
              datasize2 := size - datasize1;
              
              if datasize1 then
                // copy data 1 part 1
                _memcpy(ptr1 := pData, ptr2 := pLocalReaddata, cntr := datasize1);
              end_if;
              
              // copy data 1  part 2
              _memcpy(ptr1 := pData + datasize1, pDataMin, cntr := datasize2);
              
              // copy data 2
              if size2 then
                _memcpy(ptr1 := pData2, ptr2 := pDataMin + datasize2, cntr := size2);
              end_if;              
              
            else
              // Split in data2

              // copy data 1
              _memcpy(ptr1 := pdata, ptr2 := pLocalReaddata, cntr := size);
              
              pLocalReaddata += size;
              
              if size2 then
                datasize1 := pDataMax$UDINT - pLocalReaddata$UDINT;
                datasize2 := size2 - datasize1;
                
                // copy data 2 Part 1
                if datasize1 then
                  _memcpy(ptr1:=pData2, ptr2:=pLocalReaddata, cntr:=datasize1);
                end_if;
                
                // copy data 2 Part 2
                _memcpy(ptr1:=pData2 + datasize1, ptr2:= pDataMin, cntr:=datasize2);
              end_if;
              
            end_if;
            
          end_if;          
        
        end_if;

        FreeReadBuffer(pReadData, sizeinbuffer$UDINT);
        
        retcode := datasize$DINT;
      
      end_if;

    end_if;
  
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HWKVarSizeFIFO::ReadData
	VAR_INPUT
		pData 	: ^HSINT;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	sizeinbuffer  : DINT;
    datasize      : UDINT;
    datasize1     : UDINT;
    datasize2     : UDINT;    
    pLocalReaddata : ^HDINT;
  END_VAR

  retcode := -1;
  if ClassState > 0 then  // Is class ok
    
    retcode := -2;
    // Check inputs ok
    if pdata & size then
      
      // Check inputs ok
      retcode := sizeinbuffer := CheckValidReadData();        
      if sizeinbuffer > 0 then
        
        datasize := sizeinbuffer$UDINT - (sizeof(UDINT) * 2);
        
        if datasize > size then
          datasize := size;
        end_if;
        
        // Skip header
        pLocalReaddata := pReadData + sizeof(UDINT);
        if pLocalReaddata >= pDataMax then
          pLocalReaddata := pDataMin;
        end_if;
        
        if ( (pLocalReaddata + datasize) < pDataMax) then
          
          // Copy data
          _memcpy(ptr1 := pData, ptr2 := pLocalReaddata, cntr := datasize);
          
        else
          
          datasize1 := pDataMax$UDINT - pLocalReaddata$UDINT;
          datasize2 := datasize - datasize1;
      
          if datasize1 then
            // copy data 1
            _memcpy(ptr1 := pData, ptr2 := pLocalReaddata, cntr := datasize1);
          end_if;
          
          // copy data 2
          _memcpy(ptr1 := pData+datasize1, ptr2 := pDataMin, cntr := datasize2);
          
        end_if;
        
        retcode := datasize$DINT;
      
      end_if;

    end_if;
  
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HWKVarSizeFIFO::RemoveData
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	sizeinbuffer  : DINT;
    datasize      : UDINT;
  END_VAR

  retcode := -1;
  if ClassState > 0 then   // Is class ok
      
    retcode := sizeinbuffer := CheckValidReadData();      
      
    if sizeinbuffer > 0 then
      
      datasize := sizeinbuffer$UDINT - (sizeof(UDINT) * 2);
      
      FreeReadBuffer(pReadData, sizeinbuffer$UDINT);
      
      retcode := datasize$DINT;
    
    end_if;
  
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HWKVarSizeFIFO::Enable

  if ClassState = 0 then
    
    // Buffer is reset in enable because disable may overlap with accesses to Buffer.
    
    pWriteData := pReadData := pDataMin;
    buffermemused := 0;
    ToStdLib.MemSet(dest:=pDataMin, value:=0, size:=MaxBufferSize);
    
    ClassState := 1;
  
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL HWKVarSizeFIFO::Disable
  
  if ClassState > 0 then
    // Buffer is reset in enable because disable may overlap with accesses to Buffer.
    ClassState := 0;
  end_if;  

END_FUNCTION
