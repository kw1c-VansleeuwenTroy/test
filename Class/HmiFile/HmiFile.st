//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Source\Common\hmi_nuc.h"

(*!
<Class
	Name               = "HmiFile"
	Revision           = "0.4"
	GUID               = "{D51EF911-BDC4-482F-9766-05C818CB5127}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{6A64598C-3FCA-4880-87BA-5C6580773189}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="OpSysFile" Required="false" Internal="false"/>
		<Client Name="StdLib" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\Common\hmi_nuc.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.4" Date="2018-03-06" Author="kolott" Company="sigmatek" Description="new method GetFileContent() added"/>
		<Dokumentation Revision="0.3" Date="2016-06-23" Author="kolott" Company="sigmatek" Description="new method FileCreate(), FDelete() added"/>
		<Dokumentation Revision="0.2" Date="2016-06-09" Author="kolott" Company="sigmatek" Description="sa26785: compilerversion 60, property preceding zero implemented"/>
		<Dokumentation Revision="0.1" Date="2014-02-28" Author="kolott" Company="sigmatek" Description="possibly memleak corrected"/>
	</RevDoku>
</Class>
*)
HmiFile : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	StdLib 	: CltChCmd__StdLib;
	OpSysFile 	: CltChCmd__FileSys;
  //Variables:
		Handle 	: DINT;
		Ram 	: BOOL;
		Offset 	: UDINT;
		RamSize 	: UDINT;
		FileState 	: UDINT;
		ErrorState 	: UDINT;
		RamPtr 	: ^USINT;
		HmiVer 	: UDINT;
		MpcVer 	: UDINT;
		FileSize 	: UDINT;
		ChkSum 	: UDINT;
  //Functions:
	
	FUNCTION GLOBAL FRead
		VAR_INPUT
			ptr 	: ^void;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL FClose
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL FOpen
		VAR_INPUT
			dpne 	: ^CHAR;
			state 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION SetError
		VAR_INPUT
			error 	: UDINT;
		END_VAR;
	
	FUNCTION GetError
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL FMemory
		VAR_INPUT
			ptr 	: ^pVoid;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL FChkFile
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CheckHeader
		VAR_INPUT
			ptr 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL FReadHeader
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL FLength
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL FTell
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL FSeek
		VAR_INPUT
			reloff 	: DINT;
			fromwhere 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Memory
		VAR_INPUT
			pptr 	: ^pVoid;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL FWrite
		VAR_INPUT
			ptr 	: ^void;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL DoWrongCompilerVersion
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION WriteRamData
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Read_HMI_ANYTHING
		VAR_INPUT
			ptr 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION Read_CRLF_RamFile
		VAR_INPUT
			dst 	: ^LASCII;
			maxlen 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Read_CRLF
		VAR_INPUT
			dst 	: ^LASCII;
			maxlen 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Read_HMI_CHKBIT
		VAR_INPUT
			pt 	: ^HMI_CHKBIT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Read_HMI_XY
		VAR_INPUT
			pt 	: ^HMI_XY;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Read_HMI_ROOM
		VAR_INPUT
			pt 	: ^HMI_ROOM;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetCompilerVersion
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL Read_BOOL
		VAR_INPUT
			ptb 	: ^BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Read_HMI_GFUNCT
		VAR_INPUT
			pt 	: ^HMI_GFUNCT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL FileCreate
		VAR_INPUT
			dpne 	: ^CHAR;
			data 	: ^void;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL FDelete
		VAR_INPUT
			dpne 	: ^CHAR;
		END_VAR;
				//! <Function Comment="Method will return allocated Pointer to whole content read fron given file. Do not forget to free pointer after usage with FMemory(#ptr, 0)" Name="GetFileContent"/>
	FUNCTION GLOBAL GetFileContent
		VAR_INPUT
			dpne 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^void;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiFile::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMIFILE
0$UINT, 4$UINT, (SIZEOF(::HmiFile))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2548286290), "HmiFile", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiFile.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::HmiFile.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::HmiFile.OpSysFile.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1866805256), "OpSysFile", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
END_FUNCTION


#define USER_CNT_HmiFile 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiFile] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiFile::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION

#define FILE_RDO             'r' // read only
#define FILE_RD              'R' // read only + rampuffer
#define FILE_WRO             'w' // write + create
#define FILE_WR              'W' // write + create + rampuffer
#define FILE_RDWRO    ('w'+'r')
#define FILE_RDWR     ('W'+'R')

#define FILE_RAMFILESIZE      4096

#define FILE_NOT_OPEN         0
#define FILE_NO_ERROR         1
#define FILE_WRONG_ATTRIBUTE  2
#define FILE_TOO_LESS_MEMORY  3
#define FILE_NO_READ          4
#define FILE_NO_WRITE         5
#define FILE_WRONG_LMEVERSION 6
#define FILE_WRONG_HEADER     7


FUNCTION GLOBAL HmiFile::FOpen
	VAR_INPUT
		dpne 	: ^char;
		state 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    tmpsize : dint;
    att : udint;
  end_var

  retcode := false;
  ChkSum  := 0;
  
  if(GetError() = FILE_NOT_OPEN) then

    Ram      := false;
    Offset   := 0;
    RamSize  := 0;
    FileSize := 0;
    Handle   := 0;

//    if(_memcmp(dpne, "RAM@", 4) = 0) then
//      dpne += 4;
//      Ram  := true;
//    end_if;
    
    retcode := true;
    if(state = FILE_RD) then
      att     := ATT_READ_ONLY;
      Ram     := true;
    elsif(state = FILE_RDO) then
      att     := ATT_READ_ONLY;
      state   := FILE_RD;
    elsif(state = FILE_WR) then
      att     := ATT_CREATE_ALWAYS or ATT_READ_WRITE;
      Ram     := true;
    elsif(state = FILE_WRO) then
      att     := ATT_CREATE_ALWAYS or ATT_READ_WRITE;
      state   := FILE_WR;
    elsif((state = FILE_RDWRO)|(state = FILE_RDWR)) then
      att     := ATT_CREATE or ATT_READ_WRITE;
      state   := FILE_RDWR;
    else
      retcode := false;
    end_if;
    
    if(retcode = true) then
      retcode := false;
      Handle  := OpSysFile.FileOpen(dpne, att);
    
      if(Handle >= 0) then
        SetError(FILE_NO_ERROR);
        FileState := state;

        if((FileState = FILE_RD) | (FileState = FILE_RDWR)) then
          tmpsize := OpSysFile.FileLength(Handle);
          if(tmpsize > 0) then
            FileSize := to_udint(tmpsize);
          end_if;
        end_if;

        if(Ram = true) then
          if((FileState = FILE_RD) | (FileState = FILE_RDWR)) then
            if(tmpsize > 0) then
              if(FMemory(#RamPtr$^void, to_udint(tmpsize)) = true) then
                if(OpSysFile.FileRead(Handle, RamPtr, to_udint(tmpsize)) = to_udint(tmpsize)) then
                  RamSize  := to_udint(tmpsize);
                  FileSize := to_udint(tmpsize);
                  retcode  := true;
                end_if;
              end_if;
            end_if;
          elsif(FileState = FILE_WR) then
            retcode := true;
            if(Memory(#RamPtr$^void, FILE_RAMFILESIZE) = true) then
              RamSize := FILE_RAMFILESIZE;
            else
              Ram     := false;
            end_if;
          end_if;
        
          if(retcode = false) then
            SetError(FILE_NO_ERROR);
            Ram := false;
            RamSize := 0;
            FMemory(#RamPtr$^void, 0);
          end_if;
        end_if;
    
        retcode := true;
        
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::FClose
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;

  if(Ram = true) then
    WriteRamData();
    Offset  := 0;
  end_if;

  if(GetError() = FILE_NO_ERROR) then
    retcode := true;
  end_if;

  OpSysFile.FileClose(Handle);
  ErrorState := FILE_NOT_OPEN;

END_FUNCTION

FUNCTION GLOBAL HmiFile::FDelete
	VAR_INPUT
		dpne 	: ^char;
	END_VAR
  
  OpSysFile.FileDelete(dpne);
  
END_FUNCTION

FUNCTION GLOBAL HmiFile::Memory
	VAR_INPUT
		pptr 	: ^pVoid;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    dst : ^void;
  end_var

  dst := pptr^;
  
  if(size > 0) then
    retcode := false;
    if(dst = NIL) then
      dst := StdLib.MallocV1(size, 0);
    else
      dst := StdLib.ReAllocV1(dst, size, 0);
    end_if;
    if(dst <> NIL) then
      retcode := true;
      pptr^:= dst;
    end_if;
  else
    retcode := true;
    if(dst <> NIL) then
      StdLib.Free(dst);
      pptr^ := NIL;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::FMemory
	VAR_INPUT
		ptr 	: ^pVoid;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;
  if(size = 0) then
    retcode := Memory(ptr, 0);
  else  
    if(GetError() = FILE_NO_ERROR) then
      retcode := Memory(ptr, size);
      if(retcode = false) then
        SetError(FILE_TOO_LESS_MEMORY);
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::FWrite
	VAR_INPUT
		ptr 	: ^void;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    newsize : udint;
    wrsiz : dint;
  end_var

  retcode := false;
  if(GetError() = FILE_NO_ERROR) then
    if((FileState = FILE_WR) | (FileState = FILE_RDWR)) then
      if(Ram = true) then
        if((Offset + size) <= RamSize) then
          // daten in rampuffer kopieren
          _memcpy(RamPtr + Offset, ptr, size);
          retcode := true;
        else
          newsize := ((Offset + size + FILE_RAMFILESIZE) / FILE_RAMFILESIZE) * FILE_RAMFILESIZE;
          if(Memory(#RamPtr$^void, newsize) = true) then
            // daten in neuen rampuffer kopieren
            _memcpy(RamPtr + Offset, ptr, size);
            RamSize := newsize;
            retcode := true;
          else
            // write rampuffer + daten sofort
            if(WriteRamData() = true) then
              if(OpSysFile.FileWrite(Handle, ptr, size) = to_uint(size)) then
                retcode := true;
              end_if;
            end_if;
          end_if;
        end_if;
      else
        wrsiz := OpSysFile.FileWrite(Handle, ptr, size);
        if(wrsiz = size$dint) then
          retcode := true;
        end_if;
      end_if;
      
      if(retcode = true) then
        Offset += size;
        if(Offset > FileSize) then
          FileSize := Offset;
        end_if;
      else
        SetError(FILE_NO_WRITE);
      end_if;
      
    else
      SetError(FILE_WRONG_ATTRIBUTE);
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::FRead
	VAR_INPUT
		ptr 	: ^void;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    ph : ^void;
  end_var
  
  retcode := false;

  if(ErrorState = FILE_NO_ERROR) then
    if((FileState = FILE_RD) | (FileState = FILE_RDWR)) then
      if(Ram = true) then
        if((Offset + size) <= RamSize) then
          ph := RamPtr + Offset;
          if(size = 4) then
            ptr$^udint^ := ph$^udint^;
          elsif(size = 2) then
            ptr$^uint^ := ph$^uint^;
          elsif(size = 1) then
            ptr$^usint^ := ph$^usint^;
          else
            _memcpy(ptr, ph, size);
          end_if;
          
          retcode := true;
        end_if;
      else
        if(OpSysFile.FileRead(Handle, ptr, size) = size) then
          retcode := true;
        end_if;
      end_if;
    
      if(retcode = true) then
        Offset += size;
      else
        SetError(FILE_NO_READ);
      end_if;

    else
      SetError(FILE_WRONG_ATTRIBUTE);
    end_if;
  end_if;

END_FUNCTION

FUNCTION HmiFile::SetError
	VAR_INPUT
		error 	: UDINT;
	END_VAR
  
  if((ErrorState = FILE_NO_ERROR)|(error = FILE_NO_ERROR)) then
    ErrorState := error;
  end_if;
  
END_FUNCTION

FUNCTION HmiFile::GetError
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := ErrorState;

END_FUNCTION

FUNCTION GLOBAL HmiFile::FSeek
	VAR_INPUT
		reloff 	: DINT;
		fromwhere 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    newoffset : dint; 
  end_var

  // 0 ... seek_set
  // 1 ... seek_cur
  // 2 ... seek_end

  retcode := false;

  if(GetError() = FILE_NO_ERROR) then
    if(fromwhere = 1) then
      // SEEK_CUR
      newoffset := to_dint(Offset) + reloff;
    elsif(fromwhere = 2) then
      // SEEK_END
      if(reloff < 0) then
        newoffset := to_dint(FileSize) + reloff;
      else
        newoffset := to_dint(FileSize) - reloff;
      end_if;
    else
      // SEEK_SET
      newoffset := reloff;
    end_if;

    if(Ram = true) then
      if((newoffset > 0) & (newoffset <= to_dint(RamSize))) then
        retcode := true;
      end_if;
    else
      if(OpSysFile.FileLSeekV1(Handle, reloff, fromwhere) = newoffset) then
        retcode := true;
      end_if;
    end_if;

    if(retcode = true) then
      Offset := to_udint(newoffset);
    end_if;

  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::FTell
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := -1;
  if(GetError() = FILE_NO_ERROR) then
    if(Ram = true) then
      retcode := to_dint(Offset);
    else
      retcode := OpSysFile.FileTell(Handle);
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::FLength
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := OpSysFile.FileLength(Handle);
  
END_FUNCTION

FUNCTION GLOBAL HmiFile::FReadHeader
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    head : array[0..128] of usint;
    ph : ^udint;
  end_var
  
  //   0 [4] .... chk-sum (crc32) exclusive header
  //   4 [2] .... size of header
  //   6 [8] .... "sigmatek"
  //  16 [4] .... "hort"
  //  20 [4] .... lme version
  //  24 [4] .... compiler version
  //  28 [4] .... list id
  //  32 [4] .... project id
  //  60 [2] .... day
  //  62 [2] .... month
  //  64 [2] .... year
  //  66 [2] .... sec
  //  68 [2] .... min
  //  70 [2] .... hour
  //  80 [?] .... name of Picture, Window etc. (ascii-0-string)
  //  all not defined bytes are filled with 0xFF

  retcode := false;

  if(GetError() = FILE_NO_ERROR) then
    if(FRead(#head[0]$void, 128) = true) then
      if(CheckHeader(#head[0]) = true) then
        ph      := #head[0]$udint;
        ChkSum  := ph^;
        ph      += 20;
        HmiVer  := (ph^ and 16#FFFF); ph += 4;
        MpcVer  := ph^;
        retcode := true;

        if(MpcVer > HMI_COMPILER_VERSION) then
          retcode := false;
          SetError(FILE_WRONG_LMEVERSION);
        end_if;
      else
        SetError(FILE_WRONG_HEADER);
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION HmiFile::CheckHeader
	VAR_INPUT
		ptr 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    ph : ^udint;
    ps : ^udint;
  end_var

  retcode := false;

  ph$^usint := "hort";
  ps := ptr + 16;

  if(ps^ = ph^) then
    retcode := true;
  end_if;

END_FUNCTION


FUNCTION GLOBAL HmiFile::FChkFile
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;
  if(GetError() = FILE_NO_ERROR) then
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::DoWrongCompilerVersion
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := 1;
  if(ErrorState = FILE_WRONG_LMEVERSION) then
    retcode := 0;
  elsif(MpcVer < HMI_COMPILER_VERSION_MIN) then // HMI_COMPILER_VERSION) then
    retcode := 2;
  end_if;

END_FUNCTION

FUNCTION HmiFile::WriteRamData
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;
  if(GetError() = FILE_NO_ERROR) then
    if((FileState = FILE_WR) | (FileState = FILE_RDWR)) then
      retcode := true;
      if(FileSize > 0) then
        retcode := false;
        if(OpSysFile.FileWrite(Handle, RamPtr, FileSize) = to_uint(FileSize)) then
          retcode := true;
        end_if;
      end_if;
    end_if;
  end_if;
  
  // ab jetzt kein ramfile mehr, ansonste problem mit fseek etc.
  FMemory(#RamPtr$^void, 0);
  RamSize := 0;
  Ram     := false;
  
END_FUNCTION



FUNCTION GLOBAL HmiFile::Read_HMI_ANYTHING
	VAR_INPUT
		ptr 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  // [1] .... liste
  // [4] .... value

  free_HMI_ANYTHING(ptr);

  FRead(#ptr^.ima$void, 1);
  FRead(#ptr^.value$void, 4);

  retcode := FChkFile();
  
  if(retcode = false) then
    free_HMI_ANYTHING(ptr);
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::Read_CRLF
	VAR_INPUT
		dst 	: ^LASCII;
		maxlen 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    bbyte : LASCII;
    size : uint;
    run : bool;
    rest : dint;
  end_var

  retcode := false;
  size := 0;

  if(maxlen > 0) then
    dst^ := 0;
  end_if;
  
  if(FChkFile() = true) then
    if((FileState = FILE_RD) | (FileState = FILE_RDWR)) then
      if(Ram = true) then
        retcode := Read_CRLF_RamFile(dst, maxlen);
      else
        rest := FLength() - FTell();

        repeat
          run := false;
          if(rest > 0) then
            run := FRead(#bbyte, 1);
            rest -= 1;
          end_if;

          if(run = true) then
            retcode := true;
            if((bbyte = 13)|(bbyte = 10)) then
              run := FRead(#bbyte, 1);
              if(run = true) then
                if((bbyte <> 13)&(bbyte <> 10)) then
                  FSeek(-1, 1);
                end_if;
              end_if;
              run := false;
              bbyte := 0;
            end_if;

            if(size < maxlen) then
              dst^ := bbyte;
              dst += 1;
              size += 1;
            end_if;
          end_if; 
        until(run = false) end_repeat;
        if(size < maxlen) then
          dst^ := 0;
        end_if;
      end_if;
    else
      SetError(FILE_WRONG_ATTRIBUTE);
    end_if;
  end_if;

END_FUNCTION


FUNCTION HmiFile::Read_CRLF_RamFile
	VAR_INPUT
		dst 	: ^LASCII;
		maxlen 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    rest : udint;
    len : uint;
    ps : ^uint;
    crlf : uint;
  end_var
  
  retcode := false;
  len     := 0;
  ps      := RamPtr + Offset;
  rest    := RamSize - Offset;
  if(rest > maxlen) then
    rest := maxlen;
  end_if;

  while(rest) do
    
    if(rest >= 2) then
      crlf := ps^;
    else
      len  += 1;
      crlf := 0x0A0D;
    end_if;

    rest -= 1;

    if((crlf = 0x0A0D)|(crlf = 0x0D0A)) then
      retcode := true;
      rest := 0;
      _memcpy(dst, RamPtr+Offset, len);
      Offset += (len + 2);
      dst += len;
      dst^ := 0;
    end_if;
  
    ps  += 1;
    len += 1;
  end_while;
 
END_FUNCTION

FUNCTION GLOBAL HmiFile::Read_HMI_XY
	VAR_INPUT
		pt 	: ^HMI_XY;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  FRead(#pt^.x, 2);
  retcode := FRead(#pt^.y, 2);

END_FUNCTION

FUNCTION GLOBAL HmiFile::Read_HMI_ROOM
	VAR_INPUT
		pt 	: ^HMI_ROOM;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  free_HMI_ROOM(pt);

  Read_HMI_XY(#pt^.xy1);
  retcode := Read_HMI_XY(#pt^.xy2);
  
  if(retcode = false) then
    free_HMI_ROOM(pt);
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::Read_HMI_CHKBIT
	VAR_INPUT
		pt 	: ^HMI_CHKBIT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  FRead(#pt^.invert, 1);
  retcode := FRead(#pt^.no, 2);

END_FUNCTION

FUNCTION GLOBAL HmiFile::GetCompilerVersion
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := MpcVer;
  
END_FUNCTION

FUNCTION GLOBAL HmiFile::Read_BOOL
	VAR_INPUT
		ptb 	: ^BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    btm : usint;
  end_var
  
  retcode := false;

  if(FRead(#btm, 1) = true) then
    retcode := true;
    ptb^ := false;
    if(btm <> 0) then
      ptb^ := true;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL HmiFile::Read_HMI_GFUNCT
	VAR_INPUT
		pt 	: ^HMI_GFUNCT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  free_HMI_GFUNCT(pt); 

  Read_HMI_ANYTHING(#pt^.pos_edge);
  Read_HMI_ANYTHING(#pt^.neg_edge);
  FRead(#pt^.triggertype$void, 1);

  if(MpcVer < 43) then
    if(HmiVer <> 16#1123) then // bei lse 01.01.035 nicht korrigieren
      case(pt^.triggertype) of
        1 : pt^.triggertype := 2;
        2 : pt^.triggertype := 3;
        3 : pt^.triggertype := 1;
      end_case;
    end_if;
  end_if;
  
  retcode := FChkFile();
  
  if(retcode = false) then
    free_HMI_GFUNCT(pt);
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::FileCreate
	VAR_INPUT
		dpne 	: ^char;
		data 	: ^void;
		size 	: udint;
	END_VAR
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  VAR
  	tmphdl, siz : dint;
  END_VAR

  retcode := false;

  tmphdl := OpSysFile.FileOpen(dpne, ATT_CREATE_ALWAYS or ATT_READ_WRITE);

  if(tmphdl >= 0) then
  
    siz := OpSysFile.FileWrite(tmphdl, data, size);
    if(siz = size$dint) then
      retcode := true;
    end_if;  
  
    OpSysFile.FileClose(tmphdl);
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFile::GetFileContent
	VAR_INPUT
		dpne 	: ^char;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^void;
	END_VAR
  VAR
  	size : dint;
    state : bool;
  END_VAR

  retcode := NIL;
  state   := false;
  
  if(FOpen(dpne, FILE_RDO) = true) then
    size := FLength();
    if(size > 0) then
      if(FMemory(#retcode, to_udint(size)) = true) then
        state := FRead(retcode, to_udint(size));
      end_if;
    end_if;
    FClose();
  end_if;

  if(state = false) then
    FMemory(#retcode, 0);
  end_if;

END_FUNCTION

