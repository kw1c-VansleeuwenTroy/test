//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define MAX_STEP_CNT 1000
#define MAX_ACTIVE_STEP_CNT 100

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "Sfc_StepInvoker"
	Revision           = "1.0"
	GUID               = "{1A9BAE58-517F-4C40-877C-D8022E3AE0F5}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "Handles step execution">
	<Channels>
		<Server Name="LogonItf" GUID="{A9BC4F0F-11B7-4C2F-845E-52932D111D4E}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Interface to the stepinvoker class&#13;&#10;&#13;&#10;Steps use this server to register themselves"/>
	</Channels>
</Class>
*)
Sfc_StepInvoker : CLASS
	TYPE
	  StepPtr : ^Sfc_Step_Base;
	  ActiveStepArray : ARRAY [0..MAX_ACTIVE_STEP_CNT] OF StepPtr;
	  StepArray : ARRAY [0..MAX_STEP_CNT] OF StepPtr;
	END_TYPE
  //Servers:
	LogonItf 	: SvrChCmd_pVoid;
  //Clients:
  //Variables:
		m_Steps 	: StepArray;
		m_StepCnt 	: DINT;
		m_ActiveSteps 	: ActiveStepArray;
		m_ActiveStepCnt 	: DINT;
  //Functions:
	
	FUNCTION Sfc_StepInvoker
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL Work;
	
	FUNCTION VIRTUAL GLOBAL LogonItf::Write
		VAR_INPUT
			input (EAX) 	: pVoid;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: pVoid;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Sfc_StepInvoker::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SFC_STEPINVOKER
1$UINT, 0$UINT, (SIZEOF(::Sfc_StepInvoker))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3408257381), "Sfc_StepInvoker", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Sfc_StepInvoker.LogonItf.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(608509347), "LogonItf", 
//Clients:
END_FUNCTION


#define USER_CNT_Sfc_StepInvoker 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Sfc_StepInvoker] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Sfc_StepInvoker::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Sfc_StepInvoker, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #Write();
	LogonItf.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF LogonItf.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= Sfc_StepInvoker();

END_FUNCTION

#pragma usingLtd Sfc_Step_Base

//{{LSL_IMPLEMENTATION


FUNCTION Sfc_StepInvoker::Sfc_StepInvoker
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
	  index : DINT;
  END_VAR
  
  m_StepCnt := 0;
  m_ActiveStepCnt := 0;
  
  for index := 0 to MAX_STEP_CNT - 1 by 1 do
  
    m_Steps[index] := NIL;
  
  end_for;

	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Sfc_StepInvoker::LogonItf::Write
	VAR_INPUT
		input (EAX) 	: pVoid;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: pVoid;
	END_VAR

	if m_StepCnt < (MAX_STEP_CNT-1) then
  
    m_Steps[m_StepCnt] := input$StepPtr;
    
    m_StepCnt += 1;
  
    result := input;
    
  else
  
    result := NIL;
  
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL Sfc_StepInvoker::Work
  VAR
	  index : DINT;
    pStep : ^StepPtr;
  END_VAR

  m_ActiveStepCnt := 0;

  //////////////////////////////////////////////////////////////
  // Determine list of active steps
  
  // Initialize Pointer
  pStep := #m_Steps$StepPtr;
  
  for index := 0 to m_StepCnt - 1 by 1 do
   
    if pStep^^.X then
   
      m_ActiveSteps[m_ActiveStepCnt] := pStep^;
    
      m_ActiveStepCnt += 1;
   
    end_if;
    
    // Next Element
    pStep += sizeof(StepPtr);
  
  end_for;
  
  // Determine list of active steps 
  //////////////////////////////////////////////////////////////
  
  //////////////////////////////////////////////////////////////
  // Execute work routine of active steps
  
  // Initialize Pointer
  pStep := #m_ActiveSteps$StepPtr;
  
  for index := 0 to m_ActiveStepCnt - 1 by 1 do
   
    pStep^^.Work();
    
    // Next Element
    pStep += sizeof(StepPtr);
  
  end_for;

  // Execute work routine of active steps
  //////////////////////////////////////////////////////////////
  
END_FUNCTION

