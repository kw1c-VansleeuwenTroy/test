//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Sfc_Logic_Or_Base"
	Revision           = "1.6"
	GUID               = "{87E95E79-D14F-477F-B451-92E99A05B899}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Sfc_Logic_Or_Base\Tools.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "Baseclass for Logic OR class ">
	<Channels>
		<Server Name="Result" GUID="{CC27E662-6ECC-47B7-AE98-DAA92371E988}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="result of the calculation"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="LesMax"/>
		<Dokumentation Revision="1.6" Date="2013-08-19" Author="LesMax" Company="Sigmatek" Description="Rework of the mechanism that finds the correct class header on construction"/>
		<Dokumentation Revision="1.5" Date="2013-06-04" Author="spimar" Company="Sigmatek" Description="Bugfix:&#13;&#10;-In case of target architecture X86 the read method of the connected clients wasn&apos;t called;&#13;&#10;-In case of target architecture ARM all clients were read, also if there was already a agreement found;"/>
		<Dokumentation Revision="1.4" Date="30.04.09" Author="hötant" Company="Sigmatek" Description="Changed LSL_TARGETARCH_ARM to _LSL_TARGETARCH_ARM"/>
		<Dokumentation Revision="1.3" Date="04.02.09" Author="hötant" Company="Sigmatek" Description="AWL to ST (to guarantee compatibility for other processors) "/>
	</RevDoku>
</Class>
*)
Sfc_Logic_Or_Base : CLASS
  //Servers:
	Result 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		m_pDerivedLogicOrClsHdr 	: ^ClsHdr;
  //Functions:
	
	FUNCTION Sfc_Logic_Or_Base
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION Or_Logic
		VAR_INPUT
			pChn 	: ^CltCh;
			numbers 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Result::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Sfc_Logic_Or_Base::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SFC_LOGIC_OR_BASE
1$UINT, 6$UINT, (SIZEOF(::Sfc_Logic_Or_Base))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(179462401), "Sfc_Logic_Or_Base", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Sfc_Logic_Or_Base.Result.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3817997973), "Result", 
//Clients:
END_FUNCTION


#define USER_CNT_Sfc_Logic_Or_Base 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Sfc_Logic_Or_Base] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Sfc_Logic_Or_Base::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Sfc_Logic_Or_Base, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Read		:= #Read();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	Result.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Result.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= Sfc_Logic_Or_Base();

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION Sfc_Logic_Or_Base::Sfc_Logic_Or_Base
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
	  pObj			: ^Obj;
  END_VAR

  // Get the first class header
  pObj		                  := LSL_GetHdr(THIS);
	m_pDerivedLogicOrClsHdr		:= pObj^.pClsHdr;
  
  // Find the Class Header of the derived logic OR class
  // (It is always the second class in the class hierarchy)
  while (m_pDerivedLogicOrClsHdr <> NIL) & (m_pDerivedLogicOrClsHdr^.pBaseCls <> NIL) & (m_pDerivedLogicOrClsHdr^.pBaseCls^.pBaseCls <> NIL) do
    
    m_pDerivedLogicOrClsHdr := m_pDerivedLogicOrClsHdr^.pBaseCls;
 
  end_while;

	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Sfc_Logic_Or_Base::Result::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  VAR
  	pChn          : ^CltCh;
  END_VAR

	// At first get a pointer to the current object.
	pChn := THIS$^CltCh;

  // Add the size of the base class and of all servers of 
  // the derived logic OR class in order to get the first client.
  pChn := (pChn$UDINT + SIZEOF(Sfc_Logic_Or_Base) + SIZEOF(SvrCh) * TO_UDINT(m_pDerivedLogicOrClsHdr^.pDsc^.nSvrChs))$^CltCh;
  
  // Execute OR Logic on the clients of the derived logic or class.
	Result.dData := Or_Logic(pChn, m_pDerivedLogicOrClsHdr^.pDsc^.nCltChs);

  // Write the end result to the output register.
	output := result.dData;

END_FUNCTION

 
FUNCTION Sfc_Logic_Or_Base::Or_Logic
	VAR_INPUT
		pChn 	    : ^CltCh;
		numbers 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result 	  : DINT;
	END_VAR
  VAR
    iCnt      : UDINT;
  END_VAR

  // Initialize variables.
  result  := 0;
  iCnt    := 0;
  
  // Loop through all clients of the derived 
  // logic OR class and evaluate the read method.
  while iCnt < numbers do 
    
    // Call the read method for the current client.
    // If the result is true, the or logic is already 
    // finished, otherwise continue with the next client.
    if (RD(pChn^.pCh) <> 0) then
    
      result := 1;
      exit;
      
    end_if;
    
    // Process the next client.
    pChn += SIZEOF(CltCh);
    iCnt +=1 ;
    
  end_while;

END_FUNCTION

