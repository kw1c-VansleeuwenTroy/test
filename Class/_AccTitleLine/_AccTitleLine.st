//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES


// Eigenschaften des UDCs
//----------------------------------------------------------------------------------------------------------------------------
#define   TitleLine_UDCVersion                2           // Version des aktuellen UDCs (sprdie v1.4 changed from 1 -> 2)
#define   TitleLine_VariableNo                8           // Anzahl der Variablen, die dem UDC mitgegeben werden (sprdie v1.4 changed from 6 -> 8)
#define   TitleLine_BoolNo                    1           // Anzahl der Boolschen-Variablen, die dem UDC mitgegeben werden
#define   TitleLine_TextschemeNo              1           // Anzahl der Textschemen, die dem UDC mitgegeben werden
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_AccTitleLine"
	Revision           = "1.6"
	GUID               = "{3E7C1D71-0C37-476D-A28B-2CD638F8C288}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(536,120)"
	Comment            = "draw the title line for the access control">
	<Channels>
		<Client Name="ccSystemLogging" Required="false" Internal="false" Comment="command channel to SystemLogging (optional)"/>
		<Client Name="ColumnChoice" Required="true" Internal="false" Comment="Bit pattern to enable the display of display items (columns)&#13;&#10;Bit 0: Username&#13;&#10;Bit 1: Password&#13;&#10;Bit 2: Level&#13;&#10;Bit 3: Timeout&#13;&#10;Bit 4: USB&#13;&#10;Bit 5: Info&#13;&#10;Bit 6: Login Info&#13;&#10;Bit 7: Logout Info&#13;&#10;"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\TitleLine\Title.UDC"/>
			<File Path=".\Class\_AccTitleLine\_AccTitleLine_de.pdf"/>
			<File Path=".\Class\_AccTitleLine\_AccTitleLine_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.6" Date="2022-03-07" Author="KaiAnd" Company="Sigmatek" Description="--&gt; added documentation files&#13;&#10;--&gt; added comment for class client &quot;ColumnChoice&quot;"/>
		<Dokumentation Revision="1.5" Date="2018-04-03" Author="SprDie" Company="Sigmatek" Description="--&gt; class is now compatible with other UDC-Versions"/>
		<Dokumentation Revision="1.4" Date="2018-01-26" Author="SprDie" Company="Sigmatek" Description="1: changed defines because of changes in UDC&#13;&#10;2: draw table-lines &amp; header for the new columns (last login &amp; logout of user)"/>
		<Dokumentation Revision="1.3" Date="2016-10-10" Author="Hubchr" Company="Sigmatek" Description="Added documentation pdfs."/>
		<Dokumentation Revision="1.2" Date="2016-10-05" Author="KaiAnd" Company="Sigmatek" Description="1: CLASS CREATED - code was taken from TitleLine V.1.1 &#13;&#10;2: changed object channel for SystemLogging to a command channel; new help function LogMyText() for logging"/>
	</RevDoku>
	<Network Name="_AccTitleLine">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{6FECDB30-EDE4-42B8-8649-D401B06D2735}"
				Class      = "_MyIO"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="Graphic"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(690,270),(518,270),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _MyIO

_AccTitleLine : CLASS
: _MyIO
	TYPE
#pragma pack(push, 1)
	  T_S_EXTVISPARA : STRUCT  //! <Type Public="true" Name="T_S_EXTVISPARA"/>
	    bParaVar : BOOL;
	    ParaTextscheme : _ANYTHING;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
  //Clients:
	ColumnChoice 	: CltCh_BDINT;
	ccSystemLogging 	: CltChCmd_DINT;
  //Variables:
		bFirstRun 	: BOOL;
		ScrollOffset 	: _KOORD;
		ExtVisPara 	: T_S_EXTVISPARA;
		bGetTheurgeData 	: BOOL;
		aColumnWidths : ARRAY [0..TitleLine_VariableNo-1] OF DINT;

		aVarSingle : ARRAY [0..TitleLine_VariableNo-1] OF _VARSINGLE;

		bInitialized 	: BOOL;
		IsCon_ccSystemLogging 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION _AccTitleLine
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="this method is called everytime when system wants to redraw the io" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... &#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
	
	FUNCTION VIRTUAL TableLines
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL DrawHeader
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL setActLineBegin
		VAR_INPUT
			NewScrollOffset 	: _KOORD;
		END_VAR;
	
	FUNCTION GLOBAL GetTitleTxtScheme
		VAR_INPUT
			pTxtScheme 	: ^_ANYTHING;
		END_VAR
		VAR_OUTPUT
			RetCode 	: BOOL;
		END_VAR;
	
	FUNCTION GetTheUrge
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION GetTheUrgeValues
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
				//! <Function Comment="help function to log a text via command channel to SystemLogging" Name="LogMyText"/>
	FUNCTION LogMyText
		VAR_INPUT
			pLogTxt 	: ^CHAR;			//! <Variable Comment="pointer to the text which should be logged" Name="LogMyText.pLogTxt"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _AccTitleLine::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__ACCTITLELINE
1$UINT, 6$UINT, (SIZEOF(::_AccTitleLine))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1356137340), "_AccTitleLine", //Class
TO_UDINT(2980745877), "_MyIO", 0$UINT, 3$UINT, //Baseclass
//Servers:
//Clients:
(::_AccTitleLine.ColumnChoice.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3823519998), "ColumnChoice", 
(::_AccTitleLine.ccSystemLogging.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1000190998), "ccSystemLogging", 
END_FUNCTION


#define USER_CNT__AccTitleLine 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__AccTitleLine] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _AccTitleLine::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _MyIO::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__AccTitleLine;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #TableLines();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #DrawHeader();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _AccTitleLine();

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL _AccTitleLine::Init

  if (_FirstScan) then

    //-------------------------------------------------------------------------
    //  check client-connnections and set flags                   KaiAnd 
    //-------------------------------------------------------------------------
    if (IsClientConnected(#ccSystemLogging)) then
      IsCon_ccSystemLogging := TRUE;
    else
      IsCon_ccSystemLogging := FALSE;
    end_if;
    //-------------------------------------------------------------------------
  end_if;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _AccTitleLine::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  
  // Basisklasse aufrufen
  _MyIO::IF_Start(pio:=pio, firsttime:=firsttime);
  
  bInitialized := GetTheUrge(pio:=pio);
  
  // Erster Aufruf
  //--------------------------------------------------------------------------------------------
  if bFirstRun = false then

    // erster Start ist vorbei
    bFirstRun := true;
    
    // Kein Scroll-Offset
    ScrollOffset := pio^.space.xy1.x + 1;  // HubChr v1.1 use pio^.space instead of pio^.room
    
  end_if;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _AccTitleLine::Draw
	VAR_INPUT
		pio 	: ^_IO;
		pr 	: ^_RESULT;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  
  // UDC-Parameter schon geholt?
  if bInitialized then
  
    // Parameter vom UDC holen
    GetTheUrgeValues(pio:=pio);
  
    // Konfiguration der Spalten lesen
    ColumnChoice := ColumnChoice.Read();
    
    // Rahmen zeichnen
    DrawButton(#pio^.space, T_FILL or T_COPY or T_SOLID, pio^.frametype, pio^.colback, pio^.colframe); // HubChr v1.1 use pio^.space instead of pio^.room

    
    // Zeilenunterteilung zeichnen
    //-----------------------------------------------------------------------------------------
    if ExtVisPara.bParaVar = true then
      
      if TableLines(pio:=pio) = false then
        if (IsCon_ccSystemLogging = True) then    // KaiAnd
          LogMyText("_AccTitleLine::Draw(): Zeichnen der Kopfzeile fehlgeschlagen");
        end_if;
      end_if;
    
    end_if;

    // Texte in Spalten ausgeben
    //-----------------------------------------------------------------------------------------
    if DrawHeader(pio:=pio) = false then
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::Draw(): Zeichnen der Kopfzeile fehlgeschlagen");
      end_if;
    end_if;
    
    
    // Rahmen erneut zeichnen, falls Scrollliste horizontal verschoben wurde
    DrawButton(#pio^.space, T_FILL or T_COPY or T_SOLID, pio^.frametype, INVISIBLE, pio^.colframe); // HubChr v1.1 use pio^.space instead of pio^.room

    // Rückgabewert setzen
    retcode := _IDIDIT;
  
  else
    retcode := _IFAILED;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL _AccTitleLine::TableLines
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpRoom   : _ROOM;
  END_VAR
  
  // Übergabeparameter prüfen
  if pio = NIL then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
  
  // Bereich definieren
  tmpRoom.xy1.x := ScrollOffset;
  tmpRoom.xy1.y := pio^.space.xy1.y; // HubChr v1.1 use pio^.space instead of pio^.room
  tmpRoom.xy2.x := ScrollOffset;
  tmpRoom.xy2.y := pio^.space.xy2.y; // HubChr v1.1 use pio^.space instead of pio^.room
  
  
  // Trennline zwischen Spalte1 und Spalte2
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#00000001 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x + to_int(aColumnWidths[0]);
    tmpRoom.xy2.x := tmpRoom.xy1.x;

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := pio^.colframe);
  end_if;
  
  
  // Trennline zwischen Spalte2 und Spalte3
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#00000010 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x + to_int(aColumnWidths[1]);
    tmpRoom.xy2.x := tmpRoom.xy1.x;

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := pio^.colframe);
  end_if;   
  
  
  // Trennline zwischen Spalte3 und Spalte4
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#00000100 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x + to_int(aColumnWidths[2]);
    tmpRoom.xy2.x := tmpRoom.xy1.x;

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := pio^.colframe);
  end_if;              
   
   
  // Trennline zwischen Spalte4 und Spalte5
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#00001000 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x + to_int(aColumnWidths[3]);
    tmpRoom.xy2.x := tmpRoom.xy1.x;

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := pio^.colframe);
  end_if;  
    
    
  // Trennline zwischen Spalte5 und Spalte6
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#00010000 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x + to_int(aColumnWidths[4]);
    tmpRoom.xy2.x := tmpRoom.xy1.x;

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := pio^.colframe);
  end_if;  
  
  // sprdie v1.4 - added columns for AccTitle >>>
  // Trennline zwischen Spalte6 und Spalte7
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#00100000 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x + to_int(aColumnWidths[5]);
    tmpRoom.xy2.x := tmpRoom.xy1.x;

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := pio^.colframe);
  end_if;  
  
  // Trennline zwischen Spalte7 und Spalte8
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#01000000 then
    // Koordinaten bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x + to_int(aColumnWidths[6]);
    tmpRoom.xy2.x := tmpRoom.xy1.x;

    Graphic.Line( x1      := tmpRoom.xy1.x, 
                  y1      := tmpRoom.xy1.y, 
                  x2      := tmpRoom.xy2.x, 
                  y2      := tmpRoom.xy2.y, 
                  attrib  := T_SOLID, 
                  color   := pio^.colframe);
  end_if;  
  // sprdie v1.4 <<<

END_FUNCTION


FUNCTION VIRTUAL _AccTitleLine::DrawHeader
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    pString     : ^_CHAR;
    tmpRoom     : _ROOM;
    fieldHight  : INT;
    fontWidth   : UINT;
    fontHight   : UINT;
  END_VAR

  // Übergabeparameter prüfen
  if pio = NIL then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
  
  // Bestimmen der Position des Texts (Zentriert im Feld)
  fieldHight := pio^.space.xy2.y - pio^.space.xy1.y;    // HubChr v1.1 use pio^.space instead of pio^.room
  font_size(x0:=pio^.font, p1:=#fontWidth, p2:=#fontHight);

  tmpRoom.xy1.x := ScrollOffset - 1;
  tmpRoom.xy1.y := pio^.space.xy1.y + ((fieldHight / 2) - (fontHight$INT / 2)); // HubChr v1.1 use pio^.space instead of pio^.room
  tmpRoom.xy2.x := ScrollOffset-1;
  tmpRoom.xy2.y := tmpRoom.xy1.y + fontHight$INT; 

  // Prüfen ob Text der Spalte1 dargestellt werden soll
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#000001 & aColumnWidths[0] > 0 then

    // Text aus Textschema holen
    pString$^void := NewDoScheme(x0 := TEXTSCHEME, 
                                 x1 := 0, 
                                 x2 := ExtVisPara.ParaTextscheme.no);            
    if pString = NIL then
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::DrawHeader(): Keinen Text (Eventzeit) gefunden");
      end_if;
    else
      // Koordinaten bestimmen
      tmpRoom.xy1.x := tmpRoom.xy1.x + 5;
      tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[0]) - 5;
      
      // Text ausgeben
      OutTextAlign( p0 := pString, 
                    x1 := 0,
                    p1 := #tmpRoom, 
                    x2 := pio^.font, 
                    x3 := pio^.attrib, 
                    x9 := _DEFFRAME, 
                    x4 := pio^.coltxt, 
                    x5 := INVISIBLE, 
                    x6 := NIL$_COLOR, 
                    x7 := sizeof(_CHAR));
    end_if;
    
  end_if;
  
  
  // Prüfen ob Text der Spalte2 dargestellt werden soll
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#000010 & aColumnWidths[1] > 0 then

    // Text aus Textschema holen
    pString$^void := NewDoScheme(x0 := TEXTSCHEME, 
                                 x1 := 1, 
                                 x2 := ExtVisPara.ParaTextscheme.no);            
    if pString = NIL then
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::DrawHeader(): Keinen Text (Eventzeit) gefunden");
      end_if;
    else
      // Koordinaten bestimmen
      tmpRoom.xy1.x := tmpRoom.xy2.x + 5;
      tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[1]) - 5;
      
      // Text ausgeben
      OutTextAlign( p0 := pString, 
                    x1 := 0,
                    p1 := #tmpRoom, 
                    x2 := pio^.font, 
                    x3 := pio^.attrib, 
                    x9 := _DEFFRAME, 
                    x4 := pio^.coltxt, 
                    x5 := INVISIBLE, 
                    x6 := NIL$_COLOR, 
                    x7 := sizeof(_CHAR));
    end_if;
    
  end_if;
  
  
  // Prüfen ob Text der Spalte3 dargestellt werden soll
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#000100 & aColumnWidths[2] > 0 then
  
    //Text aus Textschema holen
    pString$^void := NewDoScheme(x0 := TEXTSCHEME, 
                                 x1 := 2, 
                                 x2 := ExtVisPara.ParaTextscheme.no);            
    if pString = NIL then
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::DrawHeader(): Keinen Text (Alarmnummer) gefunden");
      end_if;
    else
      // Koordinaten bestimmen
      tmpRoom.xy1.x := tmpRoom.xy2.x + 5;
      tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[2]) - 5;
      
      // Text ausgeben
      OutTextAlign( p0 := pString, 
                    x1 := 0,
                    p1 := #tmpRoom, 
                    x2 := pio^.font, 
                    x3 := pio^.attrib, 
                    x9 := _DEFFRAME, 
                    x4 := pio^.coltxt, 
                    x5 := INVISIBLE, 
                    x6 := NIL$_COLOR, 
                    x7 := sizeof(_CHAR));
      
    end_if;
 
  end_if;
  
  
  // Prüfen ob Text der Spalte4 dargestellt werden soll
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#001000 & aColumnWidths[3] > 0 then
  
    // Text aus Textschema holen
    pString$^void := NewDoScheme(x0 := TEXTSCHEME, 
                                 x1 := 3, 
                                 x2 := ExtVisPara.ParaTextscheme.no);            
    if pString = NIL then
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::DrawHeader(): Keinen Text (Accesslevel) gefunden");
      end_if;
    else
      // Koordinaten bestimmen
      tmpRoom.xy1.x := tmpRoom.xy2.x + 5;
      tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[3]) - 5;
      
      
      // Text ausgeben
      OutTextAlign( p0 := pString, 
                    x1 := 0,
                    p1 := #tmpRoom, 
                    x2 := pio^.font, 
                    x3 := pio^.attrib, 
                    x9 := _DEFFRAME, 
                    x4 := pio^.coltxt, 
                    x5 := INVISIBLE, 
                    x6 := NIL$_COLOR, 
                    x7 := sizeof(_CHAR));
    end_if;
    
  end_if;
  
  
  // Prüfen ob Text der Spalte5 dargestellt werden soll
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#010000 & aColumnWidths[4] > 0 then
  
    // Text aus Textschema holen
    pString$^void := NewDoScheme(x0 := TEXTSCHEME, 
                                 x1 := 4, 
                                 x2 := ExtVisPara.ParaTextscheme.no);            
    if pString = NIL then
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::DrawHeader(): Keinen Text (Beschreibung) gefunden");
      end_if;
    else
      // Koordinaten bestimmen
      tmpRoom.xy1.x := tmpRoom.xy2.x + 5;
      tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[4]) - 5;
      
      // Text ausgeben
      OutTextAlign( p0 := pString, 
                    x1 := 0,
                    p1 := #tmpRoom, 
                    x2 := pio^.font, 
                    x3 := pio^.attrib, 
                    x9 := _DEFFRAME, 
                    x4 := pio^.coltxt, 
                    x5 := INVISIBLE, 
                    x6 := NIL$_COLOR, 
                    x7 := sizeof(_CHAR));
    end_if;
    
  end_if;
  
  
  // Prüfen ob Text der Spalte6 dargestellt werden soll
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#100000 & aColumnWidths[5] > 0 then
  
    // Text aus Textschema holen
    pString$^void := NewDoScheme(x0 := TEXTSCHEME, 
                                 x1 := 5, 
                                 x2 := ExtVisPara.ParaTextscheme.no);            
    if pString = NIL then
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::DrawHeader(): Keinen Text (Beschreibung) gefunden");
      end_if;
    else
      // Koordinaten bestimmen
      tmpRoom.xy1.x := tmpRoom.xy2.x + 5;
      tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[5]) - 5;
      
      // Text ausgeben
      OutTextAlign( p0 := pString, 
                    x1 := 0,
                    p1 := #tmpRoom, 
                    x2 := pio^.font, 
                    x3 := pio^.attrib, 
                    x9 := _DEFFRAME, 
                    x4 := pio^.coltxt, 
                    x5 := INVISIBLE, 
                    x6 := NIL$_COLOR, 
                    x7 := sizeof(_CHAR));
    end_if;
    
  end_if;
  
  // sprdie v1.4 - added columns for AccTitle >>>
  // Prüfen ob Text der Spalte7 dargestellt werden soll
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#01000000 & aColumnWidths[6] > 0 then
  
    // Text aus Textschema holen
    pString$^void := NewDoScheme(x0 := TEXTSCHEME, 
                                 x1 := 6, 
                                 x2 := ExtVisPara.ParaTextscheme.no);            
    if pString = NIL then
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::DrawHeader(): Keinen Text (Beschreibung) gefunden");
      end_if;
    else
      // Koordinaten bestimmen
      tmpRoom.xy1.x := tmpRoom.xy2.x + 5;
      tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[6]) - 5;
      
      // Text ausgeben
      OutTextAlign( p0 := pString, 
                    x1 := 0,
                    p1 := #tmpRoom, 
                    x2 := pio^.font, 
                    x3 := pio^.attrib, 
                    x9 := _DEFFRAME, 
                    x4 := pio^.coltxt, 
                    x5 := INVISIBLE, 
                    x6 := NIL$_COLOR, 
                    x7 := sizeof(_CHAR));
    end_if;
    
  end_if;
  
  // Prüfen ob Text der Spalte8 dargestellt werden soll
  //-----------------------------------------------------------------------------------------
  if ColumnChoice AND 2#10000000 & aColumnWidths[7] > 0 then
  
    // Text aus Textschema holen
    pString$^void := NewDoScheme(x0 := TEXTSCHEME, 
                                 x1 := 7, 
                                 x2 := ExtVisPara.ParaTextscheme.no);            
    if pString = NIL then
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::DrawHeader(): Keinen Text (Beschreibung) gefunden");
      end_if;
    else
      // Koordinaten bestimmen
      tmpRoom.xy1.x := tmpRoom.xy2.x + 5;
      tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[7]) - 5;
      
      // Text ausgeben
      OutTextAlign( p0 := pString, 
                    x1 := 0,
                    p1 := #tmpRoom, 
                    x2 := pio^.font, 
                    x3 := T_LEFTBOUND or T_SOLID or T_PROP or T_COPY or T_MIDBOUND, 
                    x9 := _DEFFRAME, 
                    x4 := pio^.coltxt, 
                    x5 := INVISIBLE, 
                    x6 := NIL$_COLOR, 
                    x7 := sizeof(_CHAR));
    end_if;
    
  end_if;
  // sprdie v1.4 <<<
    
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _AccTitleLine::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR
  
  // Spalten ab/angewählt?
  //-----------------------------------------------------------------------------------------
  if ColumnChoice <> ColumnChoice.Read() then
  
    // Neue Konfiguration speichern
    ColumnChoice := ColumnChoice.Read();
    
    // Kopfzeile neu zeichnen
    Refresh.Write(1);
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _AccTitleLine::setActLineBegin
	VAR_INPUT
		NewScrollOffset 	: _KOORD;
	END_VAR
  
  // Hat sich der Offset verändert?
  //-----------------------------------------------------------------------------------------
  if ScrollOffset <> NewScrollOffset then
    
    // Neuen Offset speichern
    ScrollOffset := NewScrollOffset;
    
    // Kopfzeile neu zeichnen
    Refresh.Write(1);
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _AccTitleLine::GetTitleTxtScheme
	VAR_INPUT
		pTxtScheme 	: ^_ANYTHING;
	END_VAR
	VAR_OUTPUT
		RetCode 	: BOOL;
	END_VAR
  
  RetCode := false;
  
  if pTxtScheme <> NIL then
  
    if bGetTheurgeData = true then
      pTxtScheme^ := ExtVisPara.ParaTextscheme;
      RetCode := true;
    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION _AccTitleLine::GetTheUrge
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpCounter      : UINT;
    pBool           : ^BOOL;
    pHelpAnyThing   : ^_ANYTHING;
	  pVarLabel       : ^_VARLABEL;
    varCount        : UINT;
    arraySize       : UINT;
  END_VAR
    
  // Gültiger Übergabeparameter?
  if (pio <> NIL) & (pio^.theurge <> NIL) then
  
    // Richtige Version des UDCs?
    if (pio^.theurge^.info = TitleLine_UDCVersion) then
      
      bSuccessful := true;
      
      // Boolparameter holen
      //-----------------------------------------------------------------------------------------
      if pio^.theurge^.membool.no = TitleLine_BoolNo then
      
        pBool := pio^.theurge^.membool.ptr;
        ExtVisPara.bParaVar := pBool^$USINT;
        
      else
        bSuccessful := false;
      end_if;
      
      
      // Index des Textschemas holen
      //-----------------------------------------------------------------------------------------
      if (pio^.theurge^.memanything.no = TitleLine_TextschemeNo) then
        
        pHelpAnyThing := pio^.theurge^.memanything.ptr;
        
        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          ExtVisPara.ParaTextscheme.list := pHelpAnyThing^.list;
          ExtVisPara.ParaTextscheme.no   := pHelpAnyThing^.no;
        else
          ExtVisPara.ParaTextscheme.list := DEFLST;
          ExtVisPara.ParaTextscheme.no   := DEFSCOPE;
          if (IsCon_ccSystemLogging = True) then    // KaiAnd
            LogMyText("_AccTitleLine::GetFirstTheUrge(): Verweis auf Textliste konnte nicht bestimmt werden");
          end_if;
        end_if;
        
      else
        bSuccessful := false;
      end_if;

      
      // variable informations
      //--------------------------------------------------------------
      // check number of variables
//      if pio^.theurge^.memvarlabel.no = TitleLine_VariableNo then
        
        // pointer to variable informations
        pVarLabel := pio^.theurge^.memvarlabel.ptr;
        
        // sprdie v1.5 -------------------------------------------
        arraySize := sizeof(aVarSingle) / sizeof(aVarSingle[0]);
        
        if pio^.theurge^.memvarlabel.no > arraySize then
          varCount := arraySize;
        else
          varCount := pio^.theurge^.memvarlabel.no;
        end_if;
        // -------------------------------------------------------
        
        // loop to store all parameter
        for tmpCounter:=0 to varCount - 1 do
        
          // save variable informations
          aVarSingle[tmpCounter] := pVarLabel^.info[0];
          
          // check for constant
          if aVarSingle[tmpCounter].state = CONST_VAL then
            aColumnWidths[tmpCounter] := aVarSingle[tmpCounter].value;
          end_if;

          // step to next variable
          pVarLabel += sizeof(_VARLABEL);
          
        end_for;

//      else
//        bSuccessful := false;
//      end_if;

      bGetTheurgeData := true; // RauAnd : es wurden das erste mal die Einträge aus dem UDC geholt.
      
    else
      bSuccessful := false;
      if (IsCon_ccSystemLogging = True) then    // KaiAnd
        LogMyText("_AccTitleLine::GetTheUrge(): Falsche Version des UDCs");
      end_if;
    end_if;
  
  else
    bSuccessful := false;
   if (IsCon_ccSystemLogging = True) then    // KaiAnd
      LogMyText("_AccTitleLine::GetTheUrge(): Ungültiger Übergabeparameter");
   end_if;
  end_if;

END_FUNCTION


FUNCTION _AccTitleLine::GetTheUrgeValues
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpCounter  : USINT;
    tmpResult   : _RESULT;
    tmpVariable : _VARIABLE;
    tmpVarLabel : _VARLABEL;
  END_VAR
  
  bSuccessful := true;

  // loop to check all variables
  for tmpCounter := 0 to sizeof(aVarSingle) / sizeof(aVarSingle[0]) - 1 do
  
    // check if variable is a dataserver
    if aVarSingle[tmpCounter].state = VAR_VAL then
      
      // build varlabel
      tmpVarLabel.no      := 1;
      tmpVarLabel.info[0] := aVarSingle[tmpCounter];
    
      // get server-value
      if VarList_GetSystemData( p0  := #tmpResult, 
                                p1  := #tmpVariable, 
                                p2  := #tmpVarLabel, 
                                x3  := false) = true then
        
        // save the new value + change checksum
        aColumnWidths[tmpCounter] := tmpResult.value;
      
      else
        bSuccessful := false;
      end_if;

    end_if;

  end_for;  
    
END_FUNCTION


FUNCTION _AccTitleLine::_AccTitleLine
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;

END_FUNCTION



FUNCTION _AccTitleLine::LogMyText
VAR_INPUT
		pLogTxt 	: ^CHAR;
	END_VAR

  VAR
    NiGive	  : CmdStruct;
    NiGet     : Results;
  END_VAR

  if ((IsCon_ccSystemLogging = True) & (pLogTxt <> NIL)) then

    NiGive.uiCmd    := 0;               // Command
    NiGive.aPara[0] := (pLogTxt)$DINT;  // pointer to text

    ccSystemLogging.NewInst(#NiGive, #NiGet);

  end_if;


END_FUNCTION
