//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
//"no usb stick is found" value

#define NO_USB 16#FFFF
#define AccessControlUSB_MaxUSBSNLength                127                                     // Maximale Anzahl der Zeichen in der USB-Seriennummer

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_AccContUSBDetection"
	Revision           = "1.4"
	GUID               = "{639F2997-5235-4D88-A9A6-9FC5AF0A9796}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,240)"
	Comment            = "This class detects USB-activity.&#13;&#10;Override global-methods USBDeviceIN and USBDeviceOUT for user-defined action on usb-event&#13;&#10;">
	<Channels>
		<Client Name="cFileSys" Required="false" Internal="false" Comment="object channel to FileOp (don&apos;t connect!)"/>
		<Client Name="coAccessControl" Required="true" Internal="false" Comment="object channel - Connect to AccessControlMain object"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_AccContUSBDetection\_AccContUSBDetection_de.pdf"/>
			<File Path=".\Class\_AccContUSBDetection\_AccContUSBDetection_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.4" Date="2019-09-04" Author="dacpat" Company="Sigmatek" Description="- Adjusted the size of the SerNumArray to fit larger number."/>
		<Dokumentation Revision="1.3" Date="2017-06-23" Author="HubChr" Company="Sigmatek" Description="Added methods USBDeviceINExt() and USBDeviceOUTExt() to provide drive letter information."/>
		<Dokumentation Revision="1.2" Date="2016-10-10" Author="HubChr" Company="Sigmatek" Description="Added documentation pdfs."/>
		<Dokumentation Revision="1.1" Date="2015-09-22" Company="Sigmatek" Description="Creation."/>
	</RevDoku>
	<Network Name="_AccContUSBDetection">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{56E9436D-D72C-443B-9EF7-926E2A8F6D47}"
				Class      = "_Global"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Global

_AccContUSBDetection : CLASS
: _Global
	TYPE
	  Letters :
	  (
	    _A,
	    _B,
	    _C,
	    _D,
	    _E,
	    _F,
	    _G,
	    _H,
	    _I,
	    _J,
	    _K,
	    _L,
	    _M,
	    _N,
	    _O,
	    _P,
	    _Q,
	    _R,
	    _S,
	    _T,
	    _U,
	    _V,
	    _W,
	    _X,
	    _Y,
	    _Z
	  )$UDINT;
	  T_SerNum : ARRAY [0..AccessControlUSB_MaxUSBSNLength] OF CHAR;
	END_TYPE
  //Servers:
  //Clients:
	cFileSys 	: CltChCmd__FileSys;
	coAccessControl 	: CltChCmd__AccContMain;
  //Variables:
		DriveList : ARRAY [0..25] OF CHAR;

		OldDriveList : ARRAY [0..25] OF CHAR;

		SerNumArray : ARRAY [0..25] OF T_SerNum;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowRun
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="Will be called when a usb-stick is plugged in or out. It checks if a serial number of the usb-stick is available." Name="CheckSerNum"/>
	FUNCTION CheckSerNum
		VAR_INPUT
			INorOUT 	: DINT;			//! <Variable Comment="1..usb-stick is plugged in&#13;&#10;2..usb-stick is plugged out" Name="CheckSerNum.INorOUT"/>
		END_VAR;
				//! <Function Comment="Will be called when a usb-stick is plugged in." Name="USBDeviceIN"/>
	FUNCTION VIRTUAL GLOBAL USBDeviceIN
		VAR_INPUT
			pSerNum 	: ^void;			//! <Variable Comment="Pointer to the serial number of the usb-stick." Name="USBDeviceIN.pSerNum"/>
		END_VAR;
				//! <Function Comment="Will be called if a plugged in usb-stick is unplugged." Name="USBDeviceOUT"/>
	FUNCTION VIRTUAL GLOBAL USBDeviceOUT
		VAR_INPUT
			pSerNum 	: ^void;			//! <Variable Comment="Pointer to the serial number of the usb-stick." Name="USBDeviceOUT.pSerNum"/>
		END_VAR;
				//! <Function Comment="Works in the same way as USBDeviceIN(), but providing the drive as parameter." Name="USBDeviceINExt"/>
	FUNCTION VIRTUAL GLOBAL USBDeviceINExt
		VAR_INPUT
			pSerNum 	: ^void;
			Drive 	: CHAR;
		END_VAR;
				//! <Function Comment="Works in the same way as USBDeviceIN(), but providing the drive as parameter." Name="USBDeviceOUTExt"/>
	FUNCTION VIRTUAL GLOBAL USBDeviceOUTExt
		VAR_INPUT
			pSerNum 	: ^void;
			Drive 	: CHAR;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _AccContMain
#pragma usingLtd _FileSys


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _AccContUSBDetection::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__ACCCONTUSBDETECTION
1$UINT, 4$UINT, (SIZEOF(::_AccContUSBDetection))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3483934912), "_AccContUSBDetection", //Class
TO_UDINT(3788417926), "_Global", 0$UINT, 15$UINT, //Baseclass
//Servers:
//Clients:
(::_AccContUSBDetection.cFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(194275965), "cFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::_AccContUSBDetection.coAccessControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3559082873), "coAccessControl", TO_UDINT(4110908185), "_AccContMain", 2$UINT, 31$UINT, 
END_FUNCTION


#define USER_CNT__AccContUSBDetection 49

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__AccContUSBDetection] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _AccContUSBDetection::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Global::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Global::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Global::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__AccContUSBDetection;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IF_WindowRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #USBDeviceIN();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #USBDeviceOUT();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #USBDeviceINExt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[48]		:= #USBDeviceOUTExt();

#pragma warning (default : 74)
	_Global::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Global::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include " lsl_st_syssernum.h"

FUNCTION VIRTUAL GLOBAL _AccContUSBDetection::IF_WindowRun
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
		event 	: ^_EVENT;
	END_VAR
    
  //call method from baseclass
  _Global::IF_WindowRun(whoami, pic, event);
  
  if event^.ftype <> _EVENT_NONE then
    //Check if there is some action on the usb-port
    if ( event^.ftype = _EVENT_LASALOS ) & ( event^.scancode = 8 )then
      
      
      //Check if usb stick was pluged or draged
      if event^.modifier = 1 | event^.modifier = 2 then
        
        cFileSys.GetDriveListShort(drivelist:= #DriveList$CHAR); //Get DriveList
        
        CheckSerNum(INorOUT:=event^.modifier); //check which device was plugged | unplugged
                
      end_if;
    end_if;
  end_if;
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContUSBDetection::Init
  
  //call method from base class
  _Global::init();
  
  if _firstscan then
   _memset(#OldDriveList, 0, sizeof(OldDriveList));
   
  end_if;
  
END_FUNCTION


FUNCTION _AccContUSBDetection::CheckSerNum
	VAR_INPUT
		INorOUT 	: DINT;
	END_VAR
  VAR
    counter : DINT;
    PISysSernum : ^LSL_ISYSSERNUM;
    Drive : USINT;
    pChar   : ^CHAR;
    retcode : DINT;
    Found : BOOL;
  END_VAR
  
  //search for all changed USb drives
  for counter := 0 to 25 do
    
    //if the drive is a UsbDevice, the device has changed since last UsbEvent and the device is plugged in
    if DriveList[counter] = 16#0B & DriveList[counter] <> OldDriveList[counter] & INorOUT = 1 then 
    
      //check if serial number available and not zero
      if OS_CILGET("ISYSSERNUM", #pISysSernum) then
      else
      
         Drive := 'a' + to_usint(counter);
         _memset(#SerNumArray[counter], 0, sizeof(T_SerNum));
         retcode := ISYSSERNUM_SERNUMGETPLCDRIVE( Drive, #SerNumArray[counter], AccessControlUSB_MaxUSBSNLength );  //V1.4, dacpat, new size for extended serial number
         pChar := #SerNumArray[counter][0];
         Found := FALSE;
         while pChar^ <> 0 do
           if (pChar^ = ' ') | (pChar^ = '0') then
             pChar += sizeof(CHAR);
           else
             Found := TRUE;
             exit;
           end_if;
         end_while;
      end_if;
      
      if Found then
      
        USBDeviceIN(#SerNumArray[counter][0]); //call the user definable IN-Method
        USBDeviceINExt(pSerNum:=#SerNumArray[counter][0], Drive:=Drive); // HubChr v1.3 also call extended method with drive Parameter
      
      
      end_if;
      
    //...if the device is unplugged
    elsif OldDriveList[counter] = 16#0B &  DriveList[counter] <> OldDriveList[counter] & INorOUT = 2 then
      
      USBDeviceOUT(#SerNumArray[counter][0]); //call the user definable OUT-Method
      
      // HubChr v1.3 also call extended method with drive Parameter
      Drive := 'a' + to_usint(counter);
      USBDeviceOUTExt(pSerNum:=#SerNumArray[counter][0], Drive:=Drive);      
      
      _memset(#SerNumArray[counter], 0, sizeof(T_SerNum)); //clear SerNum
      

    end_if;

  end_for;

  //copy the actual DriveList
  _memcpy(#OldDriveList, #DriveList, sizeof(OldDriveList));

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContUSBDetection::USBDeviceIN
	VAR_INPUT
		pSerNum 	: ^void;
	END_VAR
#pragma warning(default:73)
  
  coAccessControl.NewStick(pSerNum);
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContUSBDetection::USBDeviceOUT
	VAR_INPUT
		pSerNum 	: ^void;
	END_VAR
#pragma warning(default:73)

  coAccessControl.StickRemoved(pSerNum);
  
END_FUNCTION

#pragma warning(disable:73);
FUNCTION VIRTUAL GLOBAL _AccContUSBDetection::USBDeviceINExt
	VAR_INPUT
		pSerNum 	: ^void;
		Drive 	: CHAR;
	END_VAR
#pragma warning(default:73)

END_FUNCTION

#pragma warning(disable:73);
FUNCTION VIRTUAL GLOBAL _AccContUSBDetection::USBDeviceOUTExt
	VAR_INPUT
		pSerNum 	: ^void;
		Drive 	: CHAR;
	END_VAR
#pragma warning(default:73)

END_FUNCTION
