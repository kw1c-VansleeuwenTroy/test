//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "GetBroadCastData"
	Revision           = "0.10"
	GUID               = "{8A625AE8-567D-11D5-AB3A-00106092052D}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "RxObject For Canbus Data">
	<Channels>
		<Server Name="Connection" GUID="{53903426-CCDE-48A4-A386-5E8FE1FC2875}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0= Intern 1=CAN 2= wait for TCPIP 3= connected TCPIP"/>
		<Server Name="Server0" GUID="{8A625AE9-567D-11D5-AB3A-00106092052D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="CANBusNr" Required="true" Internal="false"/>
		<Client Name="CanObjNr" Required="true" Internal="false"/>
		<Client Name="GotAlarm" Required="true" Internal="false"/>
		<Client Name="GotPDE" Required="true" Internal="false"/>
		<Client Name="GotRtGraph" Required="true" Internal="false"/>
		<Client Name="IPAdresse" Required="false" Internal="false" Comment="0 = no ip Connect  IPadr www.xxx.yyy.zzz must be in format (zzyyxxww) (CAN must be 0!!!)"/>
		<Client Name="OS_Graphic" Required="false" Internal="false"/>
		<Client Name="PlcNo" Required="false" Internal="false"/>
		<Client Name="TcpConnectTimeOut" Required="true" Internal="false" DefValue="1000"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\GetBroadCastData\GetBroadcastData.pdf"/>
			<File Path=".\Class\GetBroadCastData\GetBroadcastData_eng.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.10" Date="2014-01-23" Author="FesGue" Company="sigmatek" Description="Wrong calculation of the  index of the RXBuffer if it is compiled for ARM "/>
		<Dokumentation Revision="0.6" Date="2013-02-25" Author="kolott" Company="sigmatek" Description="ARM-Ready"/>
		<Dokumentation Revision="0.5" Date="24.02.2011" Author="ZoePat" Company="Sigmatek" Description="corrected error with tcp-receive,&#13;&#10;and speed up the tcp-receive functionality"/>
	</RevDoku>
</Class>
*)
GetBroadCastData : CLASS
	TYPE
	  RxObj : ARRAY [0..7] OF USINT;
	  TcpipHeader : STRUCT
	    Command : UINT;
	    Length : UINT;
	  END_STRUCT;
#pragma pack(push, 1)
	  TcpRxFrame : STRUCT
	    Header : TcpipHeader;
	    Data : RxObj;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Server0 	: SvrChCmd_DINT;
	Connection 	: SvrCh_DINT;
  //Clients:
	CanObjNr 	: CltCh_DINT;
	GotAlarm 	: CltCh_DINT;
	GotPDE 	: CltCh_DINT;
	GotRtGraph 	: CltCh_DINT;
	OS_Graphic 	: CltChCmd_Graphic;
	IPAdresse 	: CltCh_HDINT;
	TcpConnectTimeOut 	: CltCh_DINT;
	PlcNo 	: CltCh_UDINT;
	CANBusNr 	: CltCh_DINT;
  //Variables:
		RxBuffer : ARRAY [0..2000] OF RxObj;

		MaxIndex 	: DINT;
		WrIndex 	: DINT;
		RdIndex 	: DINT;
		cancom 	: BOOL;			//! <Variable Comment="can comunication?" Name="cancom"/>
		tcpcom 	: BOOL;			//! <Variable Comment="TCP connection " Name="tcpcom"/>
		tcpssw 	: UINT;
		FirstScan 	: UINT;
		tcp_AlarmHandle 	: DINT;
		IPaddr : ARRAY [0..15] OF CHAR;

		LokalPort 	: UDINT;
		lsl_tcp_user 	: ^LSL_TCP_USER;
		TcpRxData 	: TcpRxFrame;
		timeout 	: UDINT;
		LogInTimeMark 	: UDINT;
		IGotAlarm 	: UINT;
  //Functions:
	
	FUNCTION GetBroadCastData
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION AWL RxIrq
		VAR_INPUT
			CanPtr 	: ^SINT;
			RxPtr 	: ^SINT;
			ThisP 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetLostAlarms
		VAR_INPUT
			pcd 	: ^_COMDEF;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION CloseMySocket;
	
	FUNCTION VIRTUAL GLOBAL Server0::Kill
		VAR_OUTPUT
			ret_code (EAX) 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Server0::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION AWL VIRTUAL GLOBAL Server0::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd Graphic


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB GetBroadCastData::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_GETBROADCASTDATA
0$UINT, 10$UINT, (SIZEOF(::GetBroadCastData))$UINT, 
2$UINT, 9$UINT, 0$UINT, 
TO_UDINT(4194672191), "GetBroadCastData", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::GetBroadCastData.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
(::GetBroadCastData.Connection.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(577269337), "Connection", 
//Clients:
(::GetBroadCastData.CanObjNr.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1748110045), "CanObjNr", 
(::GetBroadCastData.GotAlarm.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(651110556), "GotAlarm", 
(::GetBroadCastData.GotPDE.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3276594612), "GotPDE", 
(::GetBroadCastData.GotRtGraph.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1422772043), "GotRtGraph", 
(::GetBroadCastData.OS_Graphic.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2507214028), "OS_Graphic", TO_UDINT(1140816688), "Graphic", 0$UINT, 1$UINT, 
(::GetBroadCastData.IPAdresse.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2691201862), "IPAdresse", 
(::GetBroadCastData.TcpConnectTimeOut.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3994949278), "TcpConnectTimeOut", 
(::GetBroadCastData.PlcNo.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3585528384), "PlcNo", 
(::GetBroadCastData.CANBusNr.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1318795701), "CANBusNr", 
END_FUNCTION


#define USER_CNT_GetBroadCastData 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_GetBroadCastData] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION GetBroadCastData::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_GetBroadCastData, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Kill		:= #Kill();
	vmt.CmdTable.Read		:= #Read();
	vmt.CmdTable.Write		:= #Write();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetLostAlarms();

#pragma warning (default : 74)
	Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= GetBroadCastData();

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\GetBroadCastData\GetBroadCastData_00_00.st*********************
// 23.04.2003	Franz	Aschl
// added the TCP/IP	connection
// careful the IP	adress has zu	be put turned	into the server	IPadress

#define	COMLINK_LASAL

#define	AlarmPort	1957
#define	MyLokalPort	2

#include <Lsl_st_ifssr.h>

// das sind	die	headers, welche	für	das	"LASAL Interpreter System" benötigt	werden...
#include <Comlink.h>
#include <ComTypes.h>
#include <RTOS_IprIntern.h>
#include <Rtos_interpreter.h>

// diese wird	fuer TCP/IP	benötigt
#include <lsl_st_tcp_user.h>


FUNCTION VIRTUAL GLOBAL	GetBroadCastData::Init

  CanObjNr  := CanObjNr.read();
  IPAdresse := IPAdresse.read();
  CANBusNr := CANBusNr.Read();	//SJXXX

  If((CanObjNr > 0) & (CanobjNr < 2020)) then
    if(FirstScan = 0) then
      FirstScan  := 1;
      cancom       := true;
      connection   :=1;
      OS_SSR_ADDCANOBJ((CANBusNr)$USINT, CanObjNr, 8, 1, #RxIrq(), this);
    end_if;
  elsif(IPAdresse <> 0) then
    if(FirstScan = 0) then
      FirstScan  := 1;
      connection := 2;

      if(OS_CILGET("TCP_USER", #lsl_tcp_user)) then
        TRACE("TCP Stack not Present");
      else
        tcpcom := true;
        tcpssw := 1;
        // convert IP adresse to string	
        OS_TCP_USER_TOIP(#IPaddr[0], sizeof(IPaddr), 
                         IPAdresse and 16#ff,	
                         (IPAdresse shr 8) and 16#ff, 
                         (IPAdresse shr 16) and 16#ff,	
                         IPAdresse shr 24);

        LokalPort := OS_TCP_USER_GETCOMLINKPORT() + MyLokalPort; // damit sich auch mit gleicher IP 2 login möglich sind
      end_if;
    end_if;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL	GetBroadCastData::Init
FUNCTION VIRTUAL GLOBAL	GetBroadCastData::CyWork
VAR_INPUT
	EAX		:	UDINT;
END_VAR
VAR_OUTPUT
	state  : UDINT;
END_VAR
VAR
  Pt      : ^usint;
  ObjType : USINT;
  retval  : DINT;	
  BytesAvaliable  : DINT;	
  alacell : _ALACELL;
END_VAR

// do always...
  while(RdIndex <> WrIndex) do

    pt := #Rxbuffer[RdIndex]$USINT;	
    ObjType := ((Pt+1)^) SHR 3;	 
    Case(ObjType) Of
      0:  // -- RealtimeTrend
        GotRtGraph.Write(pt$DINT);
      1:  // PdeDaten
        GotPDE.Write(pt$DINT);	
      2:  // Alarm
	   #ifdef USER_BILLION
	    IGotAlarm := 1; // RamAnd für billion
       #endif
	    if(PlcNo < 255) then
	      alacell := pt^$_ALACELL;
          alacell.kennung := alacell.kennung and 3;
		  alacell.kennung := to_usint((PlcNo shl 2) or alacell.kennung);
          GotAlarm.Write((#alacell)$dint);
		else
          GotAlarm.Write(pt$DINT);
        end_if;
	   #ifdef USER_BILLION
	    IGotAlarm := 0; // RamAnd für billion
       #endif
      3:	
    end_case;			
    RdIndex+=1;
    If RdIndex >= MaxIndex then
      RdIndex := 0;
    end_if;
  end_while;

  if(tcpcom = true) then
    case tcpssw of
      0: // do nothing no stack !!

      1: // wait till we get the start form the software 
        tcpssw += 1;	

      2: // wait till someone wants to start 
        // 100 ms max time
        tcp_AlarmHandle:=OS_TCP_USER_SOCKET();
        timeout := to_udint(TcpConnectTimeOut);
        if(timeout = 0) then
          timeout := 1000;
        end_if;
        //retval := OS_TCP_USER_CONNECT(tcp_AlarmHandle, LokalPort, #IPaddr[0], AlarmPort, timeout);
        retval := OS_TCP_USER_CONNECT(tcp_AlarmHandle, LokalPort, #IPaddr[0], AlarmPort, 0);
        LoginTimeMark := ops.tAbsolute;
        tcpssw +=1;
      
      3:
        if ops.tAbsolute - LoginTimeMark >= timeout then
          OS_TCP_USER_CLOSESOCKET(tcp_AlarmHandle, 0);
          tcpssw -= 1;
        else
          retval := OS_TCP_USER_CONNECT(tcp_AlarmHandle, LokalPort, #IPaddr[0], AlarmPort, 0);
          if (retval >= 0) then
            tcpssw +=1;
            connection :=3;
          end_if;
        end_if;

      4: // now we are waiting for some receive and find the Data 
        BytesAvaliable := OS_TCP_USER_NREAD_AVAILABLE(tcp_AlarmHandle);

        if(BytesAvaliable <= 0) then
          // the only state allowed is TCP_NOT_READY 
          if(BytesAvaliable <> TCP_NOT_READY) then
            CloseMySocket();
          end_if;
        end_if;

        // the code is following byte0,1 is command = 0	
        // byte2,3 is size in sizes of RxObj		
        while (BytesAvaliable >= sizeof(TcpRxData)) do

          retval := OS_TCP_USER_RECV(tcp_AlarmHandle, #TcpRxData$char, sizeof(TcpRxData), 0, 0);
          if (retval <> sizeof(TcpRxData)) then
            CloseMySocket();
            exit;
          else 
            if ((TcpRxData.Header.Command = 0) & (TcpRxData.Header.Length = sizeof(RxObj))) then
              // this is a trick to avoid code (fast assembler) 
              RxIrq(NIL, #TcpRxData.Data[0]$SINT, this$UDINT); // we use the same function as can
            else	
              // unknown command in the moment	
              // we just receive and do nothing
            end_if;
            BytesAvaliable -= retval;
          end_if;
        end_while;

    end_case;
  end_if;

  State := 0;

END_FUNCTION //VIRTUAL GLOBAL	GetBroadCastData::CyWork

#ifdef _LSL_TARGETARCH_ARM
FUNCTION GetBroadCastData::RxIrq
VAR_INPUT
	CanPtr		:	^Sint;
	RxPtr		:	^Sint;
	ThisP		:	UDINT;
END_VAR
VAR
	src, dst : ^RxObj;
  tmp : dint;
END_VAR

  this := ThisP$^GetBroadCastData;
  src  := RxPtr$^RxObj;
  //dst  := #RxBuffer[WrIndex*sizeof(RxObj)]$RxObj; FesGue 2014-01-23
  dst  := #RxBuffer[WrIndex]$RxObj;
  dst^ := src^;

  tmp  := WrIndex + 1;
  if(tmp >= MaxIndex) then
    tmp := 0;
  end_if;
  WrIndex := tmp;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL GetBroadCastData::Server0::Write
VAR_INPUT
	input		:	DINT;
END_VAR
VAR_OUTPUT
	result		:	DINT;
END_VAR
VAR
	src, dst : ^RxObj;
  tmp : dint;
END_VAR

  result := input;
  src    := input$^RxObj;
  //dst    := #RxBuffer[WrIndex*sizeof(RxObj)]$RxObj; // FesGue 2014-01-23
  dst    := #RxBuffer[WrIndex]$RxObj;
  dst^   := src^;

  tmp  := WrIndex + 1;
  if(tmp >= MaxIndex) then
    tmp := 0;
  end_if;
  WrIndex := tmp;

END_FUNCTION

#else
FUNCTION	AWL	GetBroadCastData::RxIrq
VAR_INPUT
	CanPtr		:	^Sint;
	RxPtr		:	^Sint;
	ThisP		:	UDINT;
END_VAR

	L.ESI		ThisP
	IMUL.EBX	WrIndex,sizeof(RxObj)
	LEA.EDI		RxBuffer
	L.EDX		RxPtr
	L.EAX		(EDX)
		S.EAX		(EDI+EBX)
	L.EAX		(EDX+4)
	S.EAX		(EDI+EBX+4)

	L.EAX		WrIndex
	INC			EAX
	CMP.EAX		MaxIndex
	JB			RxIrqX
	CLR			EAX
RxIrqX
	S.EAX		WrIndex

END_FUNCTION //	GetBroadCastData::RxIrq

FUNCTION	AWL	VIRTUAL	GLOBAL GetBroadCastData::Server0::Write
VAR_INPUT
	input		:	DINT;
END_VAR
VAR_OUTPUT
	result		:	DINT;
END_VAR
	L.EDX		EAX

	IMUL.EBX	WrIndex,sizeof(RxObj)
	LEA.EDI		RxBuffer
	L.EAX		(EDX)
		S.EAX		(EDI+EBX)
	L.EAX		(EDX+4)
	S.EAX		(EDI+EBX+4)

	L.EAX		WrIndex
	INC			EAX
	CMP.EAX		MaxIndex
	JB			RxWrxX
	CLR			EAX
RxWrxX
	S.EAX		WrIndex

END_FUNCTION //VIRTUAL GLOBAL	GetBroadCastData::Server0::Write
#endif
FUNCTION VIRTUAL GLOBAL	GetBroadCastData::Server0::Kill
VAR_OUTPUT
	ret_code		:	iprStates;
END_VAR

  ret_code := READY;

END_FUNCTION //VIRTUAL GLOBAL	GetBroadCastData::Server0::Kill
FUNCTION VIRTUAL GLOBAL	GetBroadCastData::GetLostAlarms
VAR_INPUT
	pcd	:	^_COMDEF;
END_VAR
VAR_OUTPUT
	retcode : UDINT;
END_VAR
VAR
	lid  : UDINT;
	pres : ^USINT;
	tmp  : ARRAY[0..19] of USINT;
	i    : UINT;
END_VAR

  retcode := 0;

  // vorsicht: diese methode wird vom objekt lse aufgerufen. die anzahl der aufrufe wird 
  // durch die anzahl der externen kommunikationskanäle bestimmt. es dürfen daher keine 
  // privaten daten in dieser methode verwendet werden. das objekt lse sorgt dafür dass nur 
  // externe kommunikatopnskanäle übergeben werden.

//  if((cancom = true) | (tcpcom = true)) then

    if(pcd <> NIL) then
      pres := NIL;
      if(TXCOMMAND(I_GET_OBJ$UDINT, 15, "BroadCastData0", pcd$^Comdef, #pres$udint) = READY) then
        _memcpy(#lid, pres+2, sizeof(UDINT));
        if(lid <> 0) then
          tmp[0]$udint := lid;     // seine LASALID
          tmp[4]$uint  := 2;       // NewInstr. number -> send no of alarmentries
          tmp[6]       := P_EOL;   // Postfix

          pres := NIL;
          if(TXCOMMAND(I_CMD$UDINT, 7, #tmp[0], pcd$^Comdef, #pres$udint) = READY) then
            retcode := to_udint((pres + 2)^);
            if(retcode > 0) then  // wenn alarme vorhanden, dann holen...
              tmp[4]$uint   := 3; // NewInstr. number -> sendsinglealarm
              tmp[6]        := P_IMMED; // Präfix: es folgt die eintragsnummer
              tmp[11]       := P_COMMA; // Präfix: es folgt das stopsending command
              tmp[12]       := P_IMMED; // Präfix: es folgt das stopsending command
              tmp[13]$udint := 1;       // stopsending := true; => sender ausschalten
              tmp[17]       := P_EOL;   // Postfix

              i := 0;
              while(i < retcode) do
                tmp[7]$udint := to_udint(i);  // entrynumber
                if(i = (retcode-1)) then
                  tmp[13]$bool := false; // stopsending := false; => sender einschalten
                end_if;
                pres := NIL;
                if(TXCOMMAND(I_CMD$UDINT, 18, #tmp[0], pcd$^Comdef, #pres$udint) = READY) then
                  (pres+3)^ := (pres+3)^ or 16#02;  //_ALACELL.kennung = für GetLostAlarms
                  RxIrq(NIL, (pres+2)$^sint, this$udint);
                end_if;
                i += 1;
              end_while;

              // delete alarms from PLC
              tmp[0]$udint := lid;  // seine LASALID
              tmp[4]$uint  := 4;  // NewInstr. number -> send no of alarmentries
              tmp[6]       := P_EOL;  // Postfix
              pres         := NIL;
              TXCOMMAND(I_CMD$UDINT, 7, #tmp[0], pcd$^Comdef, #pres$udint);

              //  startreceive := true;
            end_if;
          end_if;
        end_if;
      end_if;
    end_if;
//  end_if;

END_FUNCTION //VIRTUAL GLOBAL	GetBroadCastData::GetLostAlarms
FUNCTION	GetBroadCastData::GetBroadCastData
VAR_OUTPUT
	ret_code  :  CONFSTATES;
END_VAR

  MaxIndex        := Sizeof(Rxbuffer)/Sizeof(RxObj);
  WrIndex         := RdIndex	:= 0;
  cancom          := false;
  tcp_AlarmHandle := -1;
  Connection      := 0;
  ret_code        := C_OK;

END_FUNCTION //	 GetBroadCastData::GetBroadCastData
FUNCTION	GetBroadCastData::CloseMySocket

  OS_TCP_USER_CLOSESOCKET(tcp_AlarmHandle, 0); // and delete my send buffer
  tcpssw := 2; // try to open again
  TRACE("Alarm Socket closed");
  connection := 2;

END_FUNCTION //	GetBroadCastData::CloseMySocket

FUNCTION VIRTUAL GLOBAL GetBroadCastData::Server0::Read
 VAR_OUTPUT
  output (EAX)  : DINT;
 END_VAR

 #ifdef USER_BILLION
  // return true only if i got an alarm now, and if i have a connection to other cpu
  if IGotAlarm & (cancom | tcpcom) then
    output := 1;
  else
    output := 0;
  end_if;
 #else
  output := Server0;
 #endif

END_FUNCTION




