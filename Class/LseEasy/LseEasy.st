//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Source\Common\hmi_nuc.h"

(*!
<Class
	Name               = "LseEasy"
	Revision           = "1.32"
	GUID               = "{5FCBCDE3-7B64-4E45-A0C9-AB973A52D664}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "always"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(474,120)"
	Comment            = "Class is used to operate LSE-Easy Visualization&#13;&#10;LSE-CompilerVersion: 60">
	<Channels>
		<Server Name="AccessLevel" GUID="{A4279337-DEEF-4100-9F9E-5F6EB57C89A3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="server is used to disable/enable access to several inputs and buttons&#13;&#10;virtual method HmiAccess() is responsible for algorithm."/>
		<Server Name="ActHumidity" GUID="{D785F671-84FB-4549-AC18-D0F1317D998E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual humidity"/>
		<Server Name="ActLanguage" GUID="{4B11AFCB-2104-4EBB-9A45-8AC81ACE9DF6}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="SRam" Comment="Server is used to select language&#13;&#10;use index or accurate language designator to switch over"/>
		<Server Name="ActScreen" GUID="{180C461B-0B2C-458F-A3FD-C3E6B0C805C1}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="server is used to show number of actual screen on hmi&#13;&#10;call write-method with accurate screennumber given by lse to force hmi to view new screen&#13;&#10;call writemethode with -2 to get screenshot from hmi (C:\hmi35.bmp)"/>
		<Server Name="ActTemperature" GUID="{C096D0B9-0267-4E71-82AA-95213FDA31FA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual temperature"/>
		<Server Name="BacklightDim" GUID="{1E364785-F003-4A69-A1AA-F029ADA7F43B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="server is used to dim backlight of hmi&#13;&#10;call writemethode with any value from 0 to 100 to dim backlight&#13;&#10;0 .... next to dark&#13;&#10;100 .. bright"/>
		<Server Name="BacklightOnOff" GUID="{52D07226-041C-490B-9B4F-6B991D923F99}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="server is used to turn on/off backlight of hmi&#13;&#10;call writemethode with 0 to turn off backlight&#13;&#10;on the oter hand call writemethode with 1 to turn on backlight"/>
		<Server Name="ClassSvr" GUID="{B9BA2456-41FB-442C-A599-DFB5D8906BF5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorSvr" GUID="{28DAA1BC-22CC-4D2A-B9EF-B7B2379E0006}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="HmiHwVersion" GUID="{8EB76FC6-5272-4697-BDD5-AAD58569F570}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="is used to view hardwareversion of hmi"/>
		<Server Name="HmiOnline" GUID="{053C40F6-952F-424C-BC63-F2B627A0EAE7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 ... hmi is offline&#13;&#10;1 ... hmi is online"/>
		<Server Name="HmiSwVersion" GUID="{E81C8F21-E47B-4D91-AC14-74CBEF133002}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="is used to view softwareversion (firmware) of hmi"/>
		<Server Name="LastUsage" GUID="{94CC8433-71E4-4E3D-B190-08D2CCC44D78}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="server is used to display timestamp (ops.tabsolute) of last usage of hmi"/>
		<Server Name="ListVal0" GUID="{853FAEA6-7B80-4AD8-BBE0-CD673968D0DA}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="server is used to display arbitrary scrolllist on display&#13;&#10;actual selection in list will be shown on server"/>
		<Server Name="ListVal1" GUID="{6355C924-D2A7-40AA-B5CD-439BC28CF709}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="LseProjectRevision" GUID="{0487CADA-D9A9-4EF8-BBFB-31DFE280BA57}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="PixMap" GUID="{597B8858-F8FE-44F0-A5C8-42983E73317F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="StateSvr" GUID="{4C01FDE5-287B-461C-BE2F-D3BAEC735BB9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="actual state of program"/>
		<Server Name="TrendVal0" GUID="{093975D3-F47B-4E36-B010-CDD2E932500A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="server is used to display trend0 on hmi&#13;&#10;call writemethod with any value from 0 to 255 to add value"/>
		<Server Name="TrendVal1" GUID="{03574F6E-2B94-4BC7-ACFB-2B29F43B7F82}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="server is used to display trend1 on hmi&#13;&#10;call writemethod with any value from 0 to 255 to add value"/>
		<Client Name="AutoFirmwareUpdate" Required="true" Internal="false" DefValue="0" Comment="Client is used to ensure automatic update of firmware and bootloader at hmi after poweron of connected plc.&#13;&#10;Set client to 1 or 2 to enable automatic update otherwirse, when client is set to 0, automatic update is disabled.&#13;&#10;NOTE: &#13;&#10;If client is set to 1, updatefiles will be deleted after update of hmi. &#13;&#10;When client is set to 2, updatefiles will NOT be deleted after automatic update. In that case user has to disconnect device otherwise update will be performed each time after poweron.&#13;&#10;User has to place updatefiles at correct device (eg.: C:\, E:\, ...}. When updatefiles should be deleted after success make sure that device and updatefiles are not writeprotected.&#13;&#10;Use virtual methods GetUpdatePath(), GetFirmwareUpdate() and GetBootLoaderUpdate() to customize device, directory and name of updatefiles."/>
		<Client Name="BackLightOff" Required="true" Internal="false" DefValue="300000" Comment="client is used to set duration till backlight will be turned off when display is not in use&#13;&#10;timebase is milliseconds&#13;&#10;0 ... backlight is always on"/>
		<Client Name="ComPort" Required="true" Internal="false" Comment="client is used to communicate with hmi&#13;&#10;eg: connect instance of class HmiComPortCan to communicate vie canbus"/>
		<Client Name="File" Required="true" Internal="true"/>
		<Client Name="HmiChkBitList" Required="true" Internal="true"/>
		<Client Name="HmiColorMap" Required="true" Internal="true"/>
		<Client Name="HmiFont35" Required="true" Internal="true"/>
		<Client Name="HmiFontList" Required="true" Internal="true"/>
		<Client Name="HmiFontShemeList" Required="true" Internal="true"/>
		<Client Name="HmiFunctionList" Required="true" Internal="true"/>
		<Client Name="HmiFunctionList35" Required="true" Internal="true"/>
		<Client Name="HmiImage35" Required="true" Internal="true"/>
		<Client Name="HmiImageList" Required="true" Internal="true"/>
		<Client Name="HmiImageShemeList" Required="true" Internal="true"/>
		<Client Name="HmiMapFile" Required="true" Internal="true"/>
		<Client Name="HmiProject35" Required="true" Internal="true"/>
		<Client Name="HmiProjectList" Required="true" Internal="true"/>
		<Client Name="HmiScreen" Required="true" Internal="true"/>
		<Client Name="HmiSetUpList" Required="true" Internal="true"/>
		<Client Name="HmiSetupList35" Required="true" Internal="true"/>
		<Client Name="HmiShemeList35" Required="true" Internal="true"/>
		<Client Name="HmiStateBit35" Required="true" Internal="true"/>
		<Client Name="HmiT9Config" Required="true" Internal="true"/>
		<Client Name="HmiTextList" Required="true" Internal="true"/>
		<Client Name="HmiTextList35" Required="true" Internal="true"/>
		<Client Name="HmiTextShemeList" Required="true" Internal="true"/>
		<Client Name="HmiUtils" Required="true" Internal="true"/>
		<Client Name="HmiVarList" Required="true" Internal="true"/>
		<Client Name="HmiVarList35" Required="true" Internal="true"/>
		<Client Name="OverloadLight" Required="true" Internal="false" DefValue="-1" Comment="client is used to ensure overload&#13;&#10;if client is set to equal or bigger 0 all occurences of &quot;XX&quot; in variablename done with LSE will be xchanged with adequateness number of client"/>
		<Client Name="ProjectPath" Required="true" Internal="false" DefValue="0" Comment="selector for different projectpath&#13;&#10;0: C:\MPC\&#13;&#10;&gt;0: C:\Easy[Value]\ (eg.: C:\Easy123\)&#13;&#10;-1: C:\[ObjextName]\ (eg.: C:\LSEEASY1\)&#13;&#10;"/>
		<Client Name="StringLib" Required="true" Internal="true"/>
		<Client Name="TempInterval" Required="true" Internal="false" DefValue="1000" Comment="client is used to define interval of retrieving act.temperature from hmi&#13;&#10;timebase is milliseconds&#13;&#10;0 ... do not update act.temperature"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\Common\hmi_nuc.h" Include="true"/>
			<File Path=".\Class\LseEasy\MiniSrcData.h" Include="false"/>
			<File Path=".\Class\LseEasy\Create.h" Include="false"/>
			<File Path=".\Class\LseEasy\CreateScreen.c"/>
			<File Path=".\Class\LseEasy\CreateUtils.c"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="1.32" Date="2021-02-26" Author="kolott" Company="sigmatek" Description="Method LseEasy::ListSetup() by parameter &apos;bottom_up&apos; expanded&#13;&#10;8D-1972: Extended size of textpuffer"/>
		<Dokumentation Revision="1.31" Date="2020-04-28" Author="kolott" Company="sigmatek" Description="New method GetLseProjectName() added&#13;&#10;DEVVIS-40, sa57116: New method T9KeyboardConfig() added"/>
		<Dokumentation Revision="1.30" Date="2019-01-24" Author="kolott" Company="sigmatek" Description="Support of HZS-251-1 and HZS352-1 incl. Humidity"/>
		<Dokumentation Revision="1.29" Date="2019-01-09" Author="kolott" Company="sigmatek" Description="Virtual method HmiOverloadLight() added to ensure userspecific change of Objectname"/>
		<Dokumentation Revision="1.28" Date="2018-10-18" Author="kolott" Company="sigmatek" Description="sa42417: more than 6 different projectpath implemented in virtual method LseEasy::GetPrjPath()"/>
		<Dokumentation Revision="1.27" Date="2018-08-27" Author="kolott" Company="sigmatek" Description="Problem &quot;Out Of Memory&quot; will end in Error &quot;Can&apos;t load LSE-Project&quot;&#13;&#10;Variable Limits at Variables will work. Overwrite Method LseEasy::VariableLimitsInUse() to enable feature"/>
		<Dokumentation Revision="1.26" Date="2018-05-24" Author="kolott" Company="sigmatek" Description="sa41119, DEVSW502: Send individual StandardFonts given by LSE to HMI as well. Fonts are used in Standard Keypads"/>
		<Dokumentation Revision="1.25" Date="2018-04-18" Author="kolott" Company="sigmatek" Description="sa40364: userspecific xchange of images done by LSE.&#13;&#10;DEVSW440: Server ActTemperature is set to 16#80000010 when HMI is offline and TemperatureValue is needed"/>
		<Dokumentation Revision="1.24" Date="2018-01-17" Author="kolott" Company="sigmatek" Description="TextList done wilt LSE will be accessible by user during runtime&#13;&#10;new virtual method HmiProjectBegin(), AddVariableByName() and AddStateBitByName() added"/>
		<Dokumentation Revision="1.23" Date="2016-09-07" Author="kolott" Company="sigmatek" Description="sa35391: new method GetLseProjectNotice() and Server LseProjectRevision added&#13;&#10;sa35411: correction in entire bytesizecomputation of HMI-project-data"/>
		<Dokumentation Revision="1.22" Date="2016-07-08" Author="kolott" Company="sigmatek" Description="new Client AutoFirmwareUpdate added to enable automatic update of firmware and bootloader at hmi after poweron"/>
		<Dokumentation Revision="1.21" Date="2016-06-22" Author="kolott" Company="sigmatek" Description="Functionality to Update BootLoader in HMI added"/>
		<Dokumentation Revision="1.20" Date="2016-05-03" Author="kolott" Company="sigmatek" Description="Betterment in rounding result at method Calc().&#13;&#10;Set and resetvalue at button will work. Firmwareversion 1.35 or higher is necessary at HMI.&#13;&#10;sa26785: compilerversion 60, property preceding zero implemented&#13;&#10;Methode UpdateString35() is done virtual"/>
		<Dokumentation Revision="1.19" Date="2016-04-23" Author="kolott" Company="sigmatek" Description="sa34276: new methode Recalculate() added to ensure recalculation from binary to physical values"/>
		<Dokumentation Revision="1.18" Date="2016-03-12" Author="kolott" Company="sigmatek" Description="functionality to display pixmap (barcode, qr code,...) on hmi added. use method SendPixMap() to view data&#13;&#10;correction of server ActLanguage when actual selection doesn&apos;t fit to loaded project (sa33823)"/>
		<Dokumentation Revision="1.17" Date="2016-02-04" Author="kolott" Company="sigmatek" Description="new virtual method IsProjectUpLoadNecessary() to customize project-upload added"/>
		<Dokumentation Revision="1.16" Date="2015-11-30" Author="kolott" Company="sigmatek" Description="new Server &quot;ListVal1&quot; to ensure use of second scrolllist on HMI"/>
		<Dokumentation Revision="1.15" Date="2015-03-17" Author="kolott" Company="sigmatek" Description="method UpdateValue35() is done &quot;virtual&quot;"/>
		<Dokumentation Revision="1.14" Date="2014-11-26" Author="kolott" Company="sigmatek" Description="new method HmiVariableExtention() used to ensure userextended modifications done in firmware of hmi&#13;&#10;view Passwordcharacter at String will work"/>
		<Dokumentation Revision="1.13" Date="2014-10-15" Author="kolott" Company="sigmatek" Description="Ability to customise HmiProject added (HmiProjectCreate(), CreateAddText(), CreateAddImage(), ListSetup(), ListCmd(), ListAddItem())"/>
		<Dokumentation Revision="1.12" Date="2014-08-13" Author="kolott" Company="sigmatek" Description="Server &quot;ListVal0&quot; is added to ensure scrollist on HMI&#13;&#10;Function &quot;UserCall&quot; added&#13;&#10;Retry added at filetransfer to HMI"/>
		<Dokumentation Revision="1.11" Date="2014-08-07" Author="kolott" Company="sigmatek" Description="Server of type ENUM will work as well"/>
		<Dokumentation Revision="1.10" Date="2014-06-02" Author="kolott" Company="sigmatek" Description="Method &quot;UpdateTemperature35&quot; is virtual to ensure correction of actual HMI-Temperature&#13;&#10;Correction: Display of Unicode-String always started with character &apos;?&apos;"/>
		<Dokumentation Revision="1.9" Date="2014-04-28" Author="kolott" Company="sigmatek" Description="call of function &quot;Function Block&quot; activated&#13;&#10;view of Circle + Pie added"/>
		<Dokumentation Revision="1.8" Date="2014-04-14" Author="kolott" Company="sigmatek" Description="betterment in Offline-Mode when HMI (display) is not connected&#13;&#10;new virtual method GetFirmwareUpdate() to customize drive and name of firmwareupdatefile&#13;&#10;reduce of memoryrequirement in plc"/>
		<Dokumentation Revision="1.7" Date="2014-03-26" Author="kolott" Company="sigmatek" Description="attribute bold at text will work as well when firmwareversion &gt;= 1.24 is in use&#13;&#10;DownloadOnTheFly will work with accurate LSE-Version"/>
		<Dokumentation Revision="1.6" Date="2014-03-06" Author="kolott" Company="sigmatek" Description="accesslevel and chkbits will work&#13;&#10;new Server AccessLevel&#13;&#10;EasyMap.xml instead of EasyMap.txt will be generated"/>
		<Dokumentation Revision="1.5" Date="2014-02-27" Author="kolott" Company="sigmatek" Description="more than one hmi with different lse-projects are possible"/>
		<Dokumentation Revision="1.4" Date="2014-02-27" Author="kolott" Company="sigmatek" Description="variable limits at bar (hmi-firmware 1.22)&#13;&#10;slider (bar + writeprotect = false) (hmi-firmware 1.22)&#13;&#10;zoomable imagescheme"/>
		<Dokumentation Revision="1.3" Date="2014-02-13" Author="kolott" Company="sigmatek" Description="Server ErrorSvr to view errordetails added"/>
		<Dokumentation Revision="1.2" Date="2014-02-12" Author="kolott" Company="sigmatek" Description="server LastUsage added"/>
		<Dokumentation Revision="1.1" Date="2014-01-16" Author="kolott" Company="sigmatek" Description="Trend added"/>
		<Dokumentation Revision="1.0" Date="2013-12-19" Author="kolott" Company="sigmatek" Description="release"/>
	</RevDoku>
	<Network Name="LseEasy">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "File"
				GUID       = "{CCB3B670-FB7E-41DA-8934-EA5F5061F075}"
				Class      = "HmiFile"
				Position   = "(90,720)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="OpSysFile"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiChkBitList"
				GUID       = "{E80D16A2-9782-4D6C-BD13-7901FFE76A78}"
				Class      = "HmiChkBitList"
				Position   = "(1050,330)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
					<Client Name="StringLib"/>
					<Client Name="VarList"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiColorMap"
				GUID       = "{00C39C16-F5C1-48DE-BB2D-BDF182971860}"
				Class      = "HmiColorMap"
				Position   = "(540,390)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiFont35"
				GUID       = "{D5D552B0-CBDE-4C07-B266-87C4C51B8F1C}"
				Class      = "HmiFont35"
				Position   = "(1530,1620)"
				Visualized = "false">
				<Channels>
					<Server Name="ByteSize"/>
					<Server Name="ClassSvr"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiFontList"
				GUID       = "{7E347A47-968D-4B28-A339-CA8B56538122}"
				Class      = "HmiFontList"
				Position   = "(540,1050)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
					<Client Name="StringLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiFontShemeList"
				GUID       = "{476BB558-3520-47BA-8792-1A7C1783EB0D}"
				Class      = "HmiShemeList"
				Position   = "(540,540)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiFunctionList"
				GUID       = "{D111BA5F-86A2-4514-B7D2-AEF7985A0AE9}"
				Class      = "HmiFunctionList"
				Position   = "(540,900)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiFunctionList35"
				GUID       = "{077FC13D-EFA6-4DBA-9E45-940D6C17D00C}"
				Class      = "HmiFunctionList35"
				Position   = "(1050,1830)"
				Visualized = "false">
				<Channels>
					<Server Name="ByteSize"/>
					<Server Name="ClassSvr"/>
					<Client Name="HmiVarList"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiImage35"
				GUID       = "{435CBA3A-69C7-421C-9A95-6F15A9DA5CB5}"
				Class      = "HmiImage35"
				Position   = "(1530,1830)"
				Visualized = "false">
				<Channels>
					<Server Name="ByteSize"/>
					<Server Name="ClassSvr"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiImageList"
				GUID       = "{53921F94-6298-4DFB-8797-94D07E95592F}"
				Class      = "HmiImageList"
				Position   = "(540,690)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
					<Client Name="StringLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiImageShemeList"
				GUID       = "{B92F32B2-C989-4657-A0E2-3A4A5E178CBF}"
				Class      = "HmiShemeList"
				Position   = "(1530,660)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiMapFile"
				GUID       = "{226B143E-BBE5-45BE-A330-AAF2698342AA}"
				Class      = "HmiMapFile"
				Position   = "(1530,1050)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
					<Client Name="StateBit"/>
					<Client Name="StringLib"/>
					<Client Name="VarList"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiProject35"
				GUID       = "{605B623B-AE7B-42EC-86A6-18A40707CE77}"
				Class      = "HmiProject35"
				Position   = "(90,1560)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="TotalByteSize"/>
					<Server Name="TotalFileNo"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiProjectList"
				GUID       = "{523B5DEE-1F32-4BCD-AFBA-F502CD027A0C}"
				Class      = "HmiProjectList"
				Position   = "(540,180)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
					<Client Name="StringLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiScreen"
				GUID       = "{75C46C92-F39D-4229-81DF-1FDCBD728A73}"
				Class      = "HmiScreen"
				Position   = "(1530,180)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiSetUpList"
				GUID       = "{4929C689-66C0-4FDA-8DF0-C0B161572721}"
				Class      = "HmiSetUpList"
				Position   = "(1050,180)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiSetupList35"
				GUID       = "{9E70FCCC-7DBB-4AD1-A2BA-1F270A0F9C9B}"
				Class      = "HmiSetupList35"
				Position   = "(90,1830)"
				Visualized = "false">
				<Channels>
					<Server Name="ByteSize"/>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiShemeList35"
				GUID       = "{67329C51-C204-4C46-9E38-47EBC27287F5}"
				Class      = "HmiShemeList35"
				Position   = "(540,1830)"
				Visualized = "false">
				<Channels>
					<Server Name="ByteSize"/>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiStateBit35"
				GUID       = "{2C155A17-86F2-4CCA-8EC7-3B962F37CF10}"
				Class      = "HmiStateBit35"
				Position   = "(1050,1050)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="ChkBit"/>
					<Client Name="ComPort"/>
					<Client Name="StringLib"/>
					<Client Name="VarList"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiT9Config"
				GUID       = "{8AED453D-4650-456F-A661-8CED12DAFFA8}"
				Class      = "HmiT9Config35"
				Position   = "(540,1410)"
				Visualized = "false">
				<Channels>
					<Server Name="ByteSize"/>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiTextList"
				GUID       = "{5484FB91-4C51-41CF-8F3A-158999B1F5B2}"
				Class      = "HmiTextList"
				Position   = "(1530,330)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
					<Client Name="HmiTextList35"/>
					<Client Name="HmiVarList"/>
					<Client Name="StringLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiTextList35"
				GUID       = "{57CD4C7B-9157-485E-B032-AB0799DBC106}"
				Class      = "HmiTextList35"
				Position   = "(1050,1620)"
				Visualized = "false">
				<Channels>
					<Server Name="ByteSize"/>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiTextShemeList"
				GUID       = "{CD85887A-BE32-4594-BC07-5CEB4DF5FBE9}"
				Class      = "HmiShemeList"
				Position   = "(1530,810)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiUtils"
				GUID       = "{E0A77BB4-C44F-4A93-8113-30DFF4E63E38}"
				Class      = "HmiUtils"
				Position   = "(90,570)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiVarList"
				GUID       = "{6A0C3576-CB1F-416A-BCA8-889B05C0F116}"
				Class      = "HmiVarList"
				Position   = "(1050,630)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="ComPort"/>
					<Client Name="File"/>
					<Client Name="HmiVarList35"/>
					<Client Name="StringLib"/>
					<Client Name="TextList"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiVarList35"
				GUID       = "{D04BD39E-FC05-4DFB-9836-C633FC5A82F9}"
				Class      = "HmiVarList35"
				Position   = "(540,1620)"
				Visualized = "false">
				<Channels>
					<Server Name="ByteSize"/>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "StringLib"
				GUID       = "{E030510C-EA6D-43D9-8D9A-61A160910D29}"
				Class      = "HmiStrLib"
				Position   = "(90,930)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.HmiImageList" Destination="HmiImageList.ClassSvr"/>
			<Connection Source="this.File" Destination="File.ClassSvr"/>
			<Connection Source="this.HmiVarList" Destination="HmiVarList.ClassSvr"/>
			<Connection Source="HmiProjectList.File" Destination="File.ClassSvr" Vertices="(540,270),(450,270),(450,810),(390,810),"/>
			<Connection Source="this.HmiFunctionList" Destination="HmiFunctionList.ClassSvr"/>
			<Connection Source="HmiColorMap.File" Destination="File.ClassSvr" Vertices="(540,480),(450,480),(450,810),(390,810),"/>
			<Connection Source="this.StringLib" Destination="StringLib.ClassSvr"/>
			<Connection Source="this.HmiScreen" Destination="HmiScreen.ClassSvr"/>
			<Connection Source="HmiFontShemeList.File" Destination="File.ClassSvr" Vertices="(540,630),(450,630),(450,810),(390,810),"/>
			<Connection Source="this.HmiTextList" Destination="HmiTextList.ClassSvr"/>
			<Connection Source="HmiImageList.File" Destination="File.ClassSvr" Vertices="(540,780),(450,780),(450,810),(390,810),"/>
			<Connection Source="HmiFunctionList.File" Destination="File.ClassSvr" Vertices="(540,990),(450,990),(450,810),(390,810),"/>
			<Connection Source="this.HmiImageShemeList" Destination="HmiImageShemeList.ClassSvr"/>
			<Connection Source="this.HmiTextShemeList" Destination="HmiTextShemeList.ClassSvr"/>
			<Connection Source="HmiFontList.File" Destination="File.ClassSvr" Vertices="(540,1140),(450,1140),(450,810),(390,810),"/>
			<Connection Source="HmiSetUpList.File" Destination="File.ClassSvr" Vertices="(1050,270),(930,270),(930,120),(450,120),(450,810),(390,810),"/>
			<Connection Source="this.HmiFontShemeList" Destination="HmiFontShemeList.ClassSvr"/>
			<Connection Source="HmiScreen.File" Destination="File.ClassSvr" Vertices="(1530,270),(1470,270),(1470,120),(450,120),(450,810),(390,810),"/>
			<Connection Source="this.HmiFontList" Destination="HmiFontList.ClassSvr"/>
			<Connection Source="HmiTextList.File" Destination="File.ClassSvr" Vertices="(1530,420),(1470,420),(1470,120),(450,120),(450,810),(390,810),"/>
			<Connection Source="HmiImageShemeList.File" Destination="File.ClassSvr" Vertices="(1530,750),(1470,750),(1470,120),(450,120),(450,810),(390,810),"/>
			<Connection Source="this.HmiColorMap" Destination="HmiColorMap.ClassSvr"/>
			<Connection Source="HmiTextShemeList.File" Destination="File.ClassSvr" Vertices="(1530,900),(1470,900),(1470,120),(450,120),(450,810),(390,810),"/>
			<Connection Source="this.HmiProjectList" Destination="HmiProjectList.ClassSvr"/>
			<Connection Source="HmiVarList.File" Destination="File.ClassSvr" Vertices="(1050,720),(930,720),(930,120),(450,120),(450,810),(390,810),"/>
			<Connection Source="HmiTextList.StringLib" Destination="StringLib.ClassSvr" Vertices="(1530,480),(1440,480),(1440,150),(480,150),(480,1020),(390,1020),"/>
			<Connection Source="HmiVarList.TextList" Destination="HmiTextList.ClassSvr" Vertices="(1050,840),(1830,420),"/>
			<Connection Source="this.HmiProject35" Destination="HmiProject35.ClassSvr"/>
			<Connection Source="this.HmiVarList35" Destination="HmiVarList35.ClassSvr"/>
			<Connection Source="HmiVarList.HmiVarList35" Destination="HmiVarList35.ClassSvr" Vertices="(1050,900),(930,900),(930,1710),(840,1710),"/>
			<Connection Source="this.HmiFont35" Destination="HmiFont35.ClassSvr"/>
			<Connection Source="HmiTextList.HmiVarList" Destination="HmiVarList.ClassSvr" Vertices="(1530,540),(1380,540),(1380,720),(1350,720),"/>
			<Connection Source="this.HmiImage35" Destination="HmiImage35.ClassSvr"/>
			<Connection Source="this.HmiSetUpList" Destination="HmiSetUpList.ClassSvr"/>
			<Connection Source="HmiProjectList.StringLib" Destination="StringLib.ClassSvr" Vertices="(540,330),(480,330),(480,1020),(390,1020),"/>
			<Connection Source="this.HmiFunctionList35" Destination="HmiFunctionList35.ClassSvr"/>
			<Connection Source="HmiFunctionList35.HmiVarList" Destination="HmiVarList.ClassSvr" Vertices="(1050,1920),(990,1920),(990,1470),(1380,1470),(1380,720),(1350,720),"/>
			<Connection Source="this.HmiShemeList35" Destination="HmiShemeList35.ClassSvr"/>
			<Connection Source="HmiVarList.ComPort" Destination="this.ComPort" Vertices="(1050,960),(38,210),"/>
			<Connection Source="this.HmiSetupList35" Destination="HmiSetupList35.ClassSvr"/>
			<Connection Source="HmiImageList.StringLib" Destination="StringLib.ClassSvr" Vertices="(540,840),(480,840),(480,1020),(390,1020),"/>
			<Connection Source="HmiFontList.StringLib" Destination="StringLib.ClassSvr" Vertices="(540,1200),(480,1200),(480,1020),(390,1020),"/>
			<Connection Source="HmiVarList.StringLib" Destination="StringLib.ClassSvr" Vertices="(1050,780),(960,780),(960,150),(480,150),(480,1020),(390,1020),"/>
			<Connection Source="this.HmiUtils" Destination="HmiUtils.ClassSvr"/>
			<Connection Source="this.HmiTextList35" Destination="HmiTextList35.ClassSvr"/>
			<Connection Source="HmiTextList.HmiTextList35" Destination="HmiTextList35.ClassSvr" Vertices="(1530,600),(1410,600),(1410,1710),(1350,1710),"/>
			<Connection Source="this.HmiChkBitList" Destination="HmiChkBitList.ClassSvr"/>
			<Connection Source="HmiChkBitList.File" Destination="File.ClassSvr" Vertices="(1050,420),(930,420),(930,120),(450,120),(450,810),(390,810),"/>
			<Connection Source="HmiChkBitList.VarList" Destination="HmiVarList.ClassSvr" Vertices="(1050,480),(990,480),(990,600),(1380,600),(1380,720),(1350,720),"/>
			<Connection Source="this.HmiStateBit35" Destination="HmiStateBit35.ClassSvr"/>
			<Connection Source="HmiStateBit35.ChkBit" Destination="HmiChkBitList.ClassSvr" Vertices="(1050,1140),(1350,420),"/>
			<Connection Source="HmiStateBit35.ComPort" Destination="this.ComPort" Vertices="(1050,1200),(38,210),"/>
			<Connection Source="HmiStateBit35.VarList" Destination="HmiVarList.ClassSvr" Vertices="(1050,1260),(990,1260),(990,1020),(1380,1020),(1380,720),(1350,720),"/>
			<Connection Source="this.HmiMapFile" Destination="HmiMapFile.ClassSvr"/>
			<Connection Source="HmiMapFile.File" Destination="File.ClassSvr" Vertices="(1530,1140),(1470,1140),(1470,120),(450,120),(450,810),(390,810),"/>
			<Connection Source="HmiMapFile.VarList" Destination="HmiVarList.ClassSvr" Vertices="(1530,1200),(1380,1200),(1380,720),(1350,720),"/>
			<Connection Source="HmiMapFile.StateBit" Destination="HmiStateBit35.ClassSvr" Vertices="(1530,1260),(1350,1140),"/>
			<Connection Source="HmiMapFile.StringLib" Destination="StringLib.ClassSvr" Vertices="(1530,1320),(1440,1320),(1440,150),(480,150),(480,1020),(390,1020),"/>
			<Connection Source="HmiStateBit35.StringLib" Destination="StringLib.ClassSvr" Vertices="(1050,1320),(960,1320),(960,150),(480,150),(480,1020),(390,1020),"/>
			<Connection Source="HmiChkBitList.StringLib" Destination="StringLib.ClassSvr" Vertices="(1050,540),(960,540),(960,150),(480,150),(480,1020),(390,1020),"/>
			<Connection Source="this.HmiT9Config" Destination="HmiT9Config.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
LseEasy : CLASS
	TYPE
	  TErrorSvr :  //! <Type Public="true" Name="TErrorSvr"/>
	  (
	    ErrNone,
	    ErrCreateHmiProject,
	    ErrLseCompilerVersion,
	    ErrLoadLseProject,
	    ErrSizeLseProject,
	    ErrUploadHmiProject,
	    ErrHmiCommunication
	  )$UDINT;
	  TStateSvr :  //! <Type Public="true" Name="TStateSvr"/>
	  (
	    TStart,
	    TUpLoad,
	    TRun,
	    TError,
	    TFirmwareUpdate,
	    TSleep,
	    TChkCrc,
	    TGetScreenShot,
	    TReboot,
	    TBootLoaderUpdate,
	    TCheckUpdateBootloader,
	    TCheckUpdateFirmware
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	StateSvr 	: SvrCh_TStateSvr_PTofCls_LseEasy;
	ErrorSvr 	: SvrCh_TErrorSvr_PTofCls_LseEasy;
	HmiOnline 	: SvrCh_DINT;
	ActTemperature 	: SvrCh_DINT;
	ActLanguage 	: SvrCh_UDINT;
	ActScreen 	: SvrCh_DINT;
	BacklightOnOff 	: SvrCh_DINT;
	BacklightDim 	: SvrCh_DINT;
	TrendVal0 	: SvrCh_DINT;
	TrendVal1 	: SvrCh_DINT;
	LastUsage 	: SvrCh_UDINT;
	HmiSwVersion 	: SvrCh_UDINT;
	HmiHwVersion 	: SvrCh_UDINT;
	AccessLevel 	: SvrCh_UDINT;
	ListVal0 	: SvrCh_DINT;
	ListVal1 	: SvrCh_DINT;
	PixMap 	: SvrCh_DINT;
	LseProjectRevision 	: SvrCh_HDINT;
	ActHumidity 	: SvrCh_DINT;
  //Clients:
	ComPort 	: CltChCmd_HmiComPort;
	HmiImageList 	: CltChCmd_HmiImageList;
	HmiFunctionList 	: CltChCmd_HmiFunctionList;
	HmiScreen 	: CltChCmd_HmiScreen;
	HmiFontList 	: CltChCmd_HmiFontList;
	HmiVarList 	: CltChCmd_HmiVarList;
	HmiColorMap 	: CltChCmd_HmiColorMap;
	HmiProjectList 	: CltChCmd_HmiProjectList;
	HmiProject35 	: CltChCmd_HmiProject35;
	HmiTextList 	: CltChCmd_HmiTextList;
	HmiVarList35 	: CltChCmd_HmiVarList35;
	HmiFont35 	: CltChCmd_HmiFont35;
	HmiImage35 	: CltChCmd_HmiImage35;
	HmiSetUpList 	: CltChCmd_HmiSetUpList;
	HmiFunctionList35 	: CltChCmd_HmiFunctionList35;
	HmiShemeList35 	: CltChCmd_HmiShemeList35;
	HmiFontShemeList 	: CltChCmd_HmiShemeList;
	ProjectPath 	: CltCh_DINT;
	TempInterval 	: CltCh_UDINT;
	BackLightOff 	: CltCh_UDINT;
	HmiTextShemeList 	: CltChCmd_HmiShemeList;
	HmiImageShemeList 	: CltChCmd_HmiShemeList;
	HmiSetupList35 	: CltChCmd_HmiSetupList35;
	StringLib 	: CltChCmd_HmiStrLib;
	File 	: CltChCmd_HmiFile;
	HmiUtils 	: CltChCmd_HmiUtils;
	OverloadLight 	: CltCh_DINT;
	HmiTextList35 	: CltChCmd_HmiTextList35;
	HmiChkBitList 	: CltChCmd_HmiChkBitList;
	HmiStateBit35 	: CltChCmd_HmiStateBit35;
	HmiMapFile 	: CltChCmd_HmiMapFile;
	AutoFirmwareUpdate 	: CltCh_DINT;
	HmiT9Config 	: CltChCmd_HmiT9Config35;
  //Variables:
		ProjectBox 	: ^void;
		AliveTix35Cntr 	: UDINT;
		AliveTix35CntrOld 	: UDINT;
		AliveTix35 	: UDINT;
		AliveTix 	: UDINT;
		HmiPrjCrc 	: UDINT;
		Hmi35PrjCrc 	: UDINT;
		RefreshTix 	: UDINT;
		StateNext 	: TStateSvr;
		TrendVal0Lid 	: UDINT;
		TrendVal1Lid 	: UDINT;
		TryToRestart 	: BOOL;
		CallScreen 	: DINT;
		NeedUpdateAll 	: UDINT;
		CantGetCrc 	: UDINT;
		SleepStart 	: UDINT;
		SleepDuration 	: UDINT;
		BacklightDimLid 	: UDINT;
		HmiSwVersionLid 	: UDINT;
		HmiHwVersionLid 	: UDINT;
		ListVal0Lid 	: UDINT;
		ListVal1Lid 	: UDINT;
		CreateAdd 	: BOOL;
		PixMapLid 	: UDINT;
		TmpData : ARRAY [0..3000] OF USINT;

		UpdateFileDPNE : ARRAY [0..255] OF CHAR;

		AutoFwUpdateDisabled 	: BOOL;
		LseProjectPath : ARRAY [0..32] OF CHAR;

  //Functions:
	
	FUNCTION LseEasy
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION LoadFile
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to serve projectpath" Name="GetPrjPath"/>
	FUNCTION VIRTUAL GLOBAL GetPrjPath
		VAR_OUTPUT
			retcode 	: ^LASCII;
		END_VAR;
	
	FUNCTION MakePrjFileName
		VAR_INPUT
			dst 	: ^LASCII;
			name 	: ^LASCII;
		END_VAR;
	
	FUNCTION Free;
	
	FUNCTION LoadProjectEntries
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ScreenCreate
		VAR_INPUT
			screennumber 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ScreenStart
		VAR_INPUT
			screennumber 	: UDINT;
			startfunct 	: UINT;
			endfunct 	: UINT;
		END_VAR;
	
	FUNCTION ScreenStop
		VAR_INPUT
			screennumber 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ScreenAddRectangle
		VAR_INPUT
			ptr 	: ^HMI_CTRL_RECTANGLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ScreenAddLine
		VAR_INPUT
			ptr 	: ^HMI_CTRL_LINE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ScreenAddCtrlImage
		VAR_INPUT
			ptr 	: ^HMI_CTRL_IMAGE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ScreenAddCtrlText
		VAR_INPUT
			ptr 	: ^HMI_CTRL_TEXT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CreateAttrib
		VAR_INPUT
			att32 	: UDINT;
			fontindex 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
	
	FUNCTION ScreenAddCtrlIO
		VAR_INPUT
			ptr 	: ^HMI_CTRL_IO;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION AddVariableByName
		VAR_INPUT
			name 	: ^CHAR;
			station 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION AddVariable
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION AddFont
		VAR_INPUT
			index 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
	
	FUNCTION AddText
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION AddImage
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION ScreenAddCtrlRectangle
		VAR_INPUT
			ptr 	: ^HMI_CTRL_RECTANGLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ScreenAddCtrlLine
		VAR_INPUT
			ptr 	: ^HMI_CTRL_LINE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION Create
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION SendProject
		VAR_INPUT
			ptr 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CreateColor
		VAR_INPUT
			colindex 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION CreateFrame
		VAR_INPUT
			frameindex 	: USINT;
			attrib 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
	
	FUNCTION AddFunctionBlockIO
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION CreateMomStat
		VAR_INPUT
			pio 	: ^HMI_CTRL_IO;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL AddAnything
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION AddSheme
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL AddFunctionBlock
		VAR_INPUT
			functindex 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION Run;
	
	FUNCTION GetFontInfo
		VAR_INPUT
			fontindex 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^HMI_FONTINFO;
		END_VAR;
	
	FUNCTION AddImageByIndex
		VAR_INPUT
			index 	: UDINT;
			bootimage 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateValue35
		VAR_INPUT
			varno 	: UINT;
			value 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateTemperature35
		VAR_INPUT
			value 	: DINT;
		END_VAR;
				//! <Function Comment="method is used to define name of bootimage" Name="GetBootImage"/>
	FUNCTION VIRTUAL GLOBAL GetBootImage
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION UpLoadProject
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GetVariable
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^HMI_VARINFO;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateString35
		VAR_INPUT
			varno 	: UINT;
			pstr 	: ^void;
			chrsize 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL UpdateAliveSignal35;
	
	FUNCTION GLOBAL UpdateBacklight35
		VAR_INPUT
			state 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL UpdateScreenshot
		VAR_INPUT
			pscrshot 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL UpdateActScreen
		VAR_INPUT
			scrno 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL UpdateInUse;
				//! <Function Comment="method is used to update firmware in hmi. E:\EasyFirmware.bin&#10; will be used as updatefile." Name="SendNewFirmware"/>
	FUNCTION GLOBAL SendNewFirmware
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL OutMessage
		VAR_INPUT
			txt 	: ^CHAR;
		END_VAR;
	
	FUNCTION GetBacklightDim
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
	
	FUNCTION OutMessageValue
		VAR_INPUT
			txt 	: ^CHAR;
			value 	: UDINT;
		END_VAR;
	
	FUNCTION ErrorStateSvr
		VAR_INPUT
			restart 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to define drive and path of several updatefiles&#13;&#10;note: &quot;E:\&quot; is used as default" Name="GetUpdatePath"/>
	FUNCTION VIRTUAL GLOBAL GetUpdatePath
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
				//! <Function Comment="method is used to define name and location of firmwareupdatefile" Name="GetFirmwareUpdate"/>
	FUNCTION VIRTUAL GLOBAL GetFirmwareUpdate
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
				//! <Function Comment="method is used to define name and location of bootloaderupdatefile" Name="GetBootLoaderUpdate"/>
	FUNCTION VIRTUAL GLOBAL GetBootLoaderUpdate
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
				//! <Function Comment="method will be called once after hmi has (re)started successfully" Name="HmiReady"/>
	FUNCTION VIRTUAL GLOBAL HmiReady;
				//! <Function Comment="methode will be called cyclic when hmi is running" Name="HmiRun"/>
	FUNCTION VIRTUAL GLOBAL HmiRun;
	
	FUNCTION GetLasalId
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION CreateBarState
		VAR_INPUT
			attrib 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
				//! <Function Comment="method can be used to send multiple data shown in trend at hmi.&#13;&#10;id ....... trendid (0, 1)&#13;&#10;pdata .... pointer to array of trenddata (0 to 255)&#13;&#10;length ... number of valid data in array or 0 to delete actual trenddata in hmi " Name="SendTrend"/>
	FUNCTION GLOBAL SendTrend
		VAR_INPUT
			id 	: UDINT;
			pdata 	: ^USINT;
			length 	: UDINT;
		END_VAR;
				//! <Function Comment="method is used to send pixmap (eg.barcode, qr code) shown at hmi.&#13;&#10;pdata ...... pointer to array of pixmapdata (pitwise pixel)&#13;&#10;width ...... width of pixmap&#13;&#10;height ..... height of pixmap&#13;&#10;padding .... padding (blank) of pixmap&#13;&#10;method will return true on success&#13;&#10;&#13;&#10;to erase pixmap from hmi call methode like SendPixMap(nil, 0, 0, 0);" Name="SendPixMap"/>
	FUNCTION GLOBAL SendPixMap
		VAR_INPUT
			pdata 	: ^void;
			width 	: USINT;
			height 	: USINT;
			padding 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL UpdateAll
		VAR_INPUT
			act_hmi_crc 	: UDINT;
		END_VAR;
	
	FUNCTION CheckCrc;
	
	FUNCTION SleepNext
		VAR_INPUT
			next 	: TStateSvr;
			sleep 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: TStateSvr;
		END_VAR;
	
	FUNCTION SetErrorSvr
		VAR_INPUT
			err 	: TErrorSvr;
		END_VAR;
	
	FUNCTION CreateVarConst
		VAR_INPUT
			vstate 	: ^USINT;
			pany 	: ^HMI_ANYTHING;
			pdata 	: ^HMI_ANYTHING;
			isog 	: BOOL;
			defval 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="methode is used to ask for actual access by using accesslevel" Name="HmiAccess"/>
	FUNCTION VIRTUAL GLOBAL HmiAccess
		VAR_INPUT
			level 	: UDINT;			//! <Variable Comment="accesslevel" Name="HmiAccess.level"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="return true if access is given&#13;&#10;on the other hand return false (writeprotected)" Name="HmiAccess.retcode"/>
		END_VAR;
	
	FUNCTION GLOBAL SoftResetAll;
	
	FUNCTION GLOBAL SoftReset;
	
	FUNCTION ScreenAddCtrlCircle
		VAR_INPUT
			ptr 	: ^HMI_CTRL_CIRCLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GetEnumSchemeIndex
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
				//! <Function Comment="method is used to perform defined &quot;UserCall&quot;. overwrite method to implement userspecific code by using parameter" Name="UserCall"/>
	FUNCTION VIRTUAL GLOBAL UserCall
		VAR_INPUT
			fktno 	: UDINT;
			para 	: DINT;
		END_VAR;
	
	FUNCTION CheckProjectCrc
		VAR_INPUT
			ptr 	: ^void;
			hmiver 	: UDINT;
			chkold 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to add some text, image, variables, etc. to project sent to hmi before lse-project is added" Name="HmiProjectBegin"/>
	FUNCTION VIRTUAL GLOBAL HmiProjectBegin;
				//! <Function Comment="method is used to add some text, image, etc. to project sent to hmi" Name="HmiProjectCreate"/>
	FUNCTION VIRTUAL GLOBAL HmiProjectCreate;
				//! <Function Comment="method can be used to add userdefined text to project sent to hmi.&#13;&#10;the id of added text will be returned.&#13;&#10;note: method has to be called in overwritten virtual method HmiProjectCreate()" Name="CreateAddText"/>
	FUNCTION CreateAddText
		VAR_INPUT
			txt 	: ^void;
			chrsize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
				//! <Function Comment="method can be used to add new image to project sent to hmi.&#13;&#10;the id of added image will be returned.&#13;&#10;note: method has to be called in oerwritten virtual method HmiProjectCreate()" Name="CreateAddImage"/>
	FUNCTION CreateAddImage
		VAR_INPUT
			txt 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
				//! <Function Comment="method is used to customise listcontrol at hmi&#13;&#10;listid ............ id of list to customise (0)&#13;&#10;lineno_max ........ max. number of lstitems in list&#13;&#10;line_height ....... height of listitem in pixel&#13;&#10;items_per_line .... number of listitems shown in each line&#13;&#10;datim2line ........ view date and time next(false) or on top(true) to each other&#13;&#10;bottom_up ...... view last line always on top (Firmwareversion &gt;= 1.48 needed)&#13;&#10;&#13;&#10;" Name="ListSetup"/>
	FUNCTION GLOBAL ListSetup
		VAR_INPUT
			listid 	: UDINT;
			lineno_max 	: UDINT;
			line_height 	: UDINT;
			items_per_line 	: UDINT;
			datim2line 	: BOOL;
			bottom_up 	: BOOL := false;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to send some commands to listcontrol at hmi&#13;&#10;listid ............ id of list to customise (0)&#13;&#10;cmd ............... 0...delete all items of listcontrol&#13;&#10;                    1...deselect actual selected item&#13;&#10;                    2...delete single item in list &#13;&#10;item_index ........ is used to address item&#13;&#10;&#13;&#10;" Name="ListCmd"/>
	FUNCTION GLOBAL ListCmd
		VAR_INPUT
			listid 	: UDINT;
			cmd 	: UDINT;
			item_index 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to add item to listcontrol at hmi. listcontrol will act as ringbuffer with 200 entries.&#13;&#10;listid ............ id of list to customise (0)&#13;&#10;item_type ......... 2...text&#13;&#10;                    3...image&#13;&#10;item_val ........... index of text or image&#13;&#10;item_date ......... date of itementry or 0&#13;&#10;item_time ......... time of itementry or 0&#13;&#10;if &quot;item_date&quot; and &quot;item_time&quot; are set to 0, no information about date and time will be shown at item in hmi.&#13;&#10;" Name="ListAddEntry"/>
	FUNCTION GLOBAL ListAddEntry
		VAR_INPUT
			listid 	: UDINT;
			item_type 	: UDINT;
			item_val 	: UDINT;
			item_date 	: UDINT;
			item_time 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to add some deeds to actual processed screen sent to hmi&#13;&#10;screenno .... number of screen in process" Name="HmiScreenCreate"/>
	FUNCTION VIRTUAL GLOBAL HmiScreenCreate
		VAR_INPUT
			screenno 	: UDINT;
		END_VAR;
				//! <Function Comment="method is used to indicate if english format of date (&quot;month/day/year&quot;) and time (&quot;01:30.10pm&quot;) is in use (retcode:=true).&#13;&#10;otherwise (retcode:=false) date will be represented as &quot;day.month.year&quot; and time as &quot;13:30:10&quot;" Name="EnglishFormatDateTime"/>
	FUNCTION VIRTUAL GLOBAL EnglishFormatDateTime
		VAR_INPUT
			languageid 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to define number of &quot;userextended variables&quot; done in firmware of hmi" Name="HmiVariableExtention"/>
	FUNCTION VIRTUAL GLOBAL HmiVariableExtention
		VAR_INPUT
			varname 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL IsProjectUpLoadNecessary
		VAR_INPUT
			preselect 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to create crc including all dynamic parts (without ststic data) from hmi-project.&#13;&#10;call method (get crc) in derived method IsProjectUpLoadNecessary() " Name="GetMapCrc"/>
	FUNCTION GetMapCrc
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdatePixMap
		VAR_INPUT
			value 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateTrendVal
		VAR_INPUT
			id 	: UDINT;
			value 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="method is used to recalculate binary-values to physical-values in both directions&#13;&#10;value ....... actual value&#13;&#10;formula ..... information about used physcal formula&#13;&#10;dezpoint .... number of digits on right side of decimalpoint&#13;&#10;direction ... true = sps--&gt;hmi (binary to physic), false = hmi--&gt;sps (physic to binary)" Name="Recalculate"/>
	FUNCTION VIRTUAL GLOBAL Recalculate
		VAR_INPUT
			value 	: DINT;
			formula 	: UDINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL IsProjectUpLoadNecessaryEx
		VAR_INPUT
			preselect 	: BOOL;
			crc_hmi 	: UDINT;			//! <Variable Comment="actual crc got from HMI. 0 ... no connection to HMI, 0xFFFFFFFF ... no project in HMI, any other value is valid crc" Name="IsProjectUpLoadNecessaryEx.crc_hmi"/>
			crc_prj 	: UDINT;			//! <Variable Comment="actual crc computed in plc" Name="IsProjectUpLoadNecessaryEx.crc_prj"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="return &apos;true&apos; to upload project to HMI, on the other hand return &apos;false&apos;" Name="IsProjectUpLoadNecessaryEx.retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Stroke2mm
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Stroke2inch
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION Recalculate_MulDiv
		VAR_INPUT
			einheit 	: UDINT;
			posdezpt 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Temp2Celsius
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Temp2Fahrenheit
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Weight2Kilogram
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Weight2Pound
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Pressure2Bar
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Pressure2Psi
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Time2Second
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Time2Minute
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Time2Hour
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL Recalculate_Force2KN
		VAR_INPUT
			value 	: DINT;
			dezpoint 	: DINT;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION Recalculate_Calc
		VAR_INPUT
			rval 	: REAL;
			rmul 	: REAL;
			rdiv 	: REAL;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="method is used to add some customized text to list&#13;&#10;listid ............ id of list to customise (0/1)&#13;&#10;item_date ......... date of itementry or 0&#13;&#10;item_time ......... time of itementry or 0&#13;&#10;ptxt ..... Pointer to userspezific text&#13;&#10;chrsize ..... Format of userspezific text (1 ... ASCII, 2 ... Unicode)&#13;&#10;item_id ..... individual id of text&#13;&#10;&#13;&#10;" Name="ListAddText"/>
	FUNCTION GLOBAL ListAddText
		VAR_INPUT
			listid 	: UDINT;
			item_date 	: UDINT;
			item_time 	: UDINT;
			ptxt 	: ^void;
			chrsize 	: UDINT;
			item_id 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SoftResetIn
		VAR_INPUT
			milliseconds 	: UDINT;
		END_VAR;
				//! <Function Comment="method will be called each time when ir-code is detected on hmi.&#13;&#10;code ... detected code&#13;&#10;note: functionality is just given when hmi supports ir-detection" Name="UpdateIrCode"/>
	FUNCTION VIRTUAL UpdateIrCode
		VAR_INPUT
			code 	: UDINT;
		END_VAR;
	
	FUNCTION SendUpdateToHmi
		VAR_INPUT
			dpne 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SendNewBootLoader
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CheckUpdate
		VAR_INPUT
			dpne 	: ^CHAR;
			nextstep 	: TStateSvr;
			defaultstep 	: TStateSvr;
			sleep 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: TStateSvr;
		END_VAR;
				//! <Function Comment="Get NoticeText from lse-project. &#13;&#10;Method will return pointer to ascii-0-string or NIL if NoticeText is empty." Name="GetLseProjectNotice"/>
	FUNCTION GLOBAL GetLseProjectNotice
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
				//! <Function Comment="User is able to set RevisionNumber of HMI-Software by using this method." Name="UserProjectRevision"/>
	FUNCTION VIRTUAL GLOBAL UserProjectRevision
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION AddStateBitByName
		VAR_INPUT
			name 	: ^CHAR;
			invert 	: BOOL;
			access 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION SaveFile
		VAR_INPUT
			dp 	: ^CHAR;
			fileid 	: UDINT;
			size 	: UDINT;
			ptr 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION SaveProject
		VAR_INPUT
			dp 	: ^CHAR;
			prj 	: ^void;
		END_VAR;
				//! <Function Comment="use methode to enable variable Limits at HMI.&#13;&#10;retcode = false .... limits at Variables are static&#13;&#10;retcode = true .... variable limits at Variables will work&#13;&#10;" Name="VariableLimitsInUse"/>
	FUNCTION VIRTUAL GLOBAL VariableLimitsInUse
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GetObjectName
		VAR_INPUT
			pthis 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateHumidity35
		VAR_INPUT
			value 	: DINT;
		END_VAR;
				//! <Function Comment="Method can be used (overwrite) to change name of individual Object or use OverloadLight mechanism at default" Name="HmiOverloadLight"/>
	FUNCTION VIRTUAL GLOBAL HmiOverloadLight;
	
	FUNCTION ListAddEntryIntern
		VAR_INPUT
			listid 	: UDINT;
			item_type 	: UDINT;
			item_val 	: UDINT;
			item_date 	: UDINT;
			item_time 	: UDINT;
			ptxt 	: ^void;
			chrsize 	: UDINT;
			item_id 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Get copy of Lse-project-name. " Name="GetLseProjectName"/>
	FUNCTION GLOBAL GetLseProjectName
		VAR_INPUT
			pdst 	: ^void;			//! <Variable Comment="Pointer to destination where projectname should be filed" Name="GetLseProjectName.pdst"/>
			dchrsize 	: UDINT;			//! <Variable Comment="Bytesize of single character to be filed (1..Ascii, 2..Unicode)" Name="GetLseProjectName.dchrsize"/>
			bytesize_dst 	: UDINT;			//! <Variable Comment="Bytesize of destination. Note: Destination has to be big enought to cover name, otherwise name will be truncated." Name="GetLseProjectName.bytesize_dst"/>
		END_VAR;
				//! <Function Comment="Method can be used to configurate T9-Keypad at HMI.&#13;&#10;Note: Firmware 1.46 or greater is needed at HMI, otherwise configuration will be ignored." Name="T9KeyboardConfig"/>
	FUNCTION VIRTUAL GLOBAL T9KeyboardConfig;
	
	FUNCTION VIRTUAL GLOBAL ClassSvr::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StateSvr::Write
		VAR_INPUT
			input (EAX) 	: LseEasy::TStateSvr;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: LseEasy::TStateSvr;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActLanguage::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActScreen::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BacklightOnOff::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BacklightDim::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using HmiChkBitList
#pragma using HmiColorMap
#pragma using HmiFile
#pragma using HmiFont35
#pragma using HmiFontList
#pragma using HmiFunctionList
#pragma using HmiFunctionList35
#pragma using HmiImage35
#pragma using HmiImageList
#pragma using HmiMapFile
#pragma using HmiProject35
#pragma using HmiProjectList
#pragma using HmiScreen
#pragma using HmiSetUpList
#pragma using HmiSetupList35
#pragma using HmiShemeList
#pragma using HmiShemeList35
#pragma using HmiStateBit35
#pragma using HmiStrLib
#pragma using HmiT9Config35
#pragma using HmiTextList
#pragma using HmiTextList35
#pragma using HmiUtils
#pragma using HmiVarList
#pragma using HmiVarList35
#pragma usingLtd HmiComPort


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB LseEasy::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_LSEEASY
1$UINT, 32$UINT, (SIZEOF(::LseEasy))$UINT, 
20$UINT, 33$UINT, 0$UINT, 
TO_UDINT(1518191916), "LseEasy", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::LseEasy.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::LseEasy.StateSvr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3409093830), "StateSvr", 
(::LseEasy.ErrorSvr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1300893904), "ErrorSvr", 
(::LseEasy.HmiOnline.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1061194472), "HmiOnline", 
(::LseEasy.ActTemperature.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1795029566), "ActTemperature", 
(::LseEasy.ActLanguage.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1371072906), "ActLanguage", 
(::LseEasy.ActScreen.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3239971925), "ActScreen", 
(::LseEasy.BacklightOnOff.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1975858986), "BacklightOnOff", 
(::LseEasy.BacklightDim.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1448391306), "BacklightDim", 
(::LseEasy.TrendVal0.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3045963784), "TrendVal0", 
(::LseEasy.TrendVal1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3263858846), "TrendVal1", 
(::LseEasy.LastUsage.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1596454104), "LastUsage", 
(::LseEasy.HmiSwVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1002441256), "HmiSwVersion", 
(::LseEasy.HmiHwVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(357947012), "HmiHwVersion", 
(::LseEasy.AccessLevel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3155511526), "AccessLevel", 
(::LseEasy.ListVal0.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1747037215), "ListVal0", 
(::LseEasy.ListVal1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(522624137), "ListVal1", 
(::LseEasy.PixMap.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(475890946), "PixMap", 
(::LseEasy.LseProjectRevision.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3083793750), "LseProjectRevision", 
(::LseEasy.ActHumidity.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3969904637), "ActHumidity", 
//Clients:
(::LseEasy.ComPort.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(3802332095), "ComPort", TO_UDINT(136722037), "HmiComPort", 0$UINT, 16$UINT, 
(::LseEasy.HmiImageList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3242935315), "HmiImageList", TO_UDINT(3242935315), "HmiImageList", 0$UINT, 3$UINT, 
(::LseEasy.HmiFunctionList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3842677476), "HmiFunctionList", TO_UDINT(3842677476), "HmiFunctionList", 0$UINT, 2$UINT, 
(::LseEasy.HmiScreen.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2118014258), "HmiScreen", TO_UDINT(2118014258), "HmiScreen", 0$UINT, 1$UINT, 
(::LseEasy.HmiFontList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3893392983), "HmiFontList", TO_UDINT(3893392983), "HmiFontList", 0$UINT, 3$UINT, 
(::LseEasy.HmiVarList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3793961451), "HmiVarList", TO_UDINT(3793961451), "HmiVarList", 0$UINT, 17$UINT, 
(::LseEasy.HmiColorMap.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(845038353), "HmiColorMap", TO_UDINT(845038353), "HmiColorMap", 0$UINT, 0$UINT, 
(::LseEasy.HmiProjectList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2305619121), "HmiProjectList", TO_UDINT(2305619121), "HmiProjectList", 0$UINT, 2$UINT, 
(::LseEasy.HmiProject35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2613567777), "HmiProject35", TO_UDINT(2613567777), "HmiProject35", 0$UINT, 7$UINT, 
(::LseEasy.HmiTextList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2809265865), "HmiTextList", TO_UDINT(2809265865), "HmiTextList", 0$UINT, 4$UINT, 
(::LseEasy.HmiVarList35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1599081198), "HmiVarList35", TO_UDINT(1599081198), "HmiVarList35", 0$UINT, 5$UINT, 
(::LseEasy.HmiFont35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1363967167), "HmiFont35", TO_UDINT(1363967167), "HmiFont35", 0$UINT, 2$UINT, 
(::LseEasy.HmiImage35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2724513001), "HmiImage35", TO_UDINT(2724513001), "HmiImage35", 0$UINT, 4$UINT, 
(::LseEasy.HmiSetUpList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4172848962), "HmiSetUpList", TO_UDINT(4172848962), "HmiSetUpList", 0$UINT, 2$UINT, 
(::LseEasy.HmiFunctionList35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3385399892), "HmiFunctionList35", TO_UDINT(3385399892), "HmiFunctionList35", 0$UINT, 4$UINT, 
(::LseEasy.HmiShemeList35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2500045939), "HmiShemeList35", TO_UDINT(2500045939), "HmiShemeList35", 0$UINT, 4$UINT, 
(::LseEasy.HmiFontShemeList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3570051842), "HmiFontShemeList", TO_UDINT(3851519469), "HmiShemeList", 0$UINT, 3$UINT, 
(::LseEasy.ProjectPath.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1497881342), "ProjectPath", 
(::LseEasy.TempInterval.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1081504569), "TempInterval", 
(::LseEasy.BackLightOff.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1246468140), "BackLightOff", 
(::LseEasy.HmiTextShemeList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2900713082), "HmiTextShemeList", TO_UDINT(3851519469), "HmiShemeList", 0$UINT, 3$UINT, 
(::LseEasy.HmiImageShemeList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(120863515), "HmiImageShemeList", TO_UDINT(3851519469), "HmiShemeList", 0$UINT, 3$UINT, 
(::LseEasy.HmiSetupList35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1107224582), "HmiSetupList35", TO_UDINT(1107224582), "HmiSetupList35", 0$UINT, 3$UINT, 
(::LseEasy.StringLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3243119075), "StringLib", TO_UDINT(103556616), "HmiStrLib", 0$UINT, 2$UINT, 
(::LseEasy.File.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3121273764), "File", TO_UDINT(2548286290), "HmiFile", 0$UINT, 4$UINT, 
(::LseEasy.HmiUtils.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4154992490), "HmiUtils", TO_UDINT(4154992490), "HmiUtils", 0$UINT, 2$UINT, 
(::LseEasy.OverloadLight.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3102957975), "OverloadLight", 
(::LseEasy.HmiTextList35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2738661249), "HmiTextList35", TO_UDINT(2738661249), "HmiTextList35", 0$UINT, 3$UINT, 
(::LseEasy.HmiChkBitList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3930770040), "HmiChkBitList", TO_UDINT(3930770040), "HmiChkBitList", 0$UINT, 2$UINT, 
(::LseEasy.HmiStateBit35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4141094888), "HmiStateBit35", TO_UDINT(4141094888), "HmiStateBit35", 0$UINT, 5$UINT, 
(::LseEasy.HmiMapFile.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(896341175), "HmiMapFile", TO_UDINT(896341175), "HmiMapFile", 0$UINT, 0$UINT, 
(::LseEasy.AutoFirmwareUpdate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(177726968), "AutoFirmwareUpdate", 
(::LseEasy.HmiT9Config.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1734223086), "HmiT9Config", TO_UDINT(536866305), "HmiT9Config35", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_LseEasy 42

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_LseEasy] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION LseEasy::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_LseEasy, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetPrjPath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateValue35();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateTemperature35();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetBootImage();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #UpdateString35();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #GetUpdatePath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #GetFirmwareUpdate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #GetBootLoaderUpdate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #HmiReady();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #HmiRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #HmiAccess();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #UserCall();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #HmiProjectBegin();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #HmiProjectCreate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #HmiScreenCreate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #EnglishFormatDateTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #HmiVariableExtention();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #IsProjectUpLoadNecessary();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #UpdatePixMap();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #UpdateTrendVal();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #Recalculate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #IsProjectUpLoadNecessaryEx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #Recalculate_Stroke2mm();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #Recalculate_Stroke2inch();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #Recalculate_Temp2Celsius();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #Recalculate_Temp2Fahrenheit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #Recalculate_Weight2Kilogram();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #Recalculate_Weight2Pound();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #Recalculate_Pressure2Bar();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #Recalculate_Pressure2Psi();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #Recalculate_Time2Second();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #Recalculate_Time2Minute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #Recalculate_Time2Hour();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #Recalculate_Force2KN();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #UpdateIrCode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #CheckUpdate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #UserProjectRevision();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #VariableLimitsInUse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #UpdateHumidity35();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #HmiOverloadLight();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #T9KeyboardConfig();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StateSvr.pMeth			:= StoreMethod( #M_RD_DIRECT(), #StateSvr::Write() );
	IF StateSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActLanguage.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ActLanguage::Write() );
	IF ActLanguage.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActScreen.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ActScreen::Write() );
	IF ActScreen.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BacklightOnOff.pMeth			:= StoreMethod( #M_RD_DIRECT(), #BacklightOnOff::Write() );
	IF BacklightOnOff.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BacklightDim.pMeth			:= StoreMethod( #M_RD_DIRECT(), #BacklightDim::Write() );
	IF BacklightDim.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TrendVal0.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF TrendVal0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TrendVal1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF TrendVal1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AccessLevel.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF AccessLevel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ListVal0.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ListVal0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ListVal1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ListVal1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PixMap.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF PixMap.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= LseEasy();

END_FUNCTION

//{{LSL_IMPLEMENTATION

#includeC "..\LseEasy\Create.h"

#define DEFAULT_VALUE_HUMIDITY    -32768
#define DEFAULT_VALUE_TEMPERATURE -32768
#define FUEHLERBRUCH              16#80000010

var_private
  InstanceCnt : UDINT;
  InstancePtr : Array[0..31] of ^LseEasy;
end_var

FUNCTION LseEasy::LseEasy
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  InstanceCnt   := 0; 
	ret_code      := C_OK;
  StateSvr      := TStart;
  ProjectBox    := nil;
  HmiPrjCrc     := 1; // has to be set to 1 !!
  Hmi35PrjCrc   := 0; // has to be set to 0 !!
  TryToRestart  := false;
  CallScreen    := -1;
  ActScreen     := -1;
  TrendVal0     := -1;
  TrendVal1     := -1;
  ListVal0      := -1;
  ListVal1      := -1;
  PixMap        := -1;
  NeedUpdateAll := 0;
  AutoFwUpdateDisabled := false;
  ActTemperature := DEFAULT_VALUE_TEMPERATURE;  
  ActHumidity    := DEFAULT_VALUE_HUMIDITY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::Init
  VAR
  	ph : ^dint;
  END_VAR

  ph := (#ListVal0) - 4;
  ListVal0Lid := ph$udint;
  ph := (#ListVal1) - 4;
  ListVal1Lid := ph$udint;
  ph := (#TrendVal0) - 4;
  TrendVal0Lid := ph$udint;
  ph := (#TrendVal1) - 4;
  TrendVal1Lid := ph$udint;
  ph := (#BacklightDim) - 4;
  BacklightDimLid := ph$udint;
  ph := (#HmiSwVersion) - 4;
  HmiSwVersionLid := ph$udint;
  ph := (#HmiHwVersion) - 4;
  HmiHwVersionLid := ph$udint;
  ph := (#PixMap) - 4;
  PixMapLid       := ph$udint;

  if(_FirstScan) then
    if(InstanceCnt < (sizeof(InstancePtr) / sizeof(InstancePtr[0]))) then
      InstancePtr[InstanceCnt] := this;
      InstanceCnt += 1;
    end_if;
    ComPort.Start(this);
    HmiVarList.SetSuper(this);
  end_if;

END_FUNCTION

FUNCTION LseEasy::Free

  HmiPrjCrc     := 1; // has to be set to 1 !!
  Hmi35PrjCrc   := 0; // has to be set to 0 !!
  ProjectBox    := nil;
  RefreshTix    := 0;
  TrendVal0     := -1;
  TrendVal1     := -1;
  ListVal0      := -1;
  ListVal1      := -1;
  PixMap        := -1;
  LastUsage     := 0;
  NeedUpdateAll := 1;
  HmiOnline     := 0; // hmi is offline
  CantGetCrc    := 0;
  ErrorSvr      := ErrNone;
  HmiSwVersion  := 0;
  HmiHwVersion  := 0;
  ActTemperature := DEFAULT_VALUE_TEMPERATURE;  
  ActHumidity    := DEFAULT_VALUE_HUMIDITY;

END_FUNCTION

FUNCTION LseEasy::SetErrorSvr
	VAR_INPUT
		err 	: TErrorSvr;
	END_VAR

  if(ErrorSvr = ErrNone) then
    ErrorSvr := err;
  end_if;

END_FUNCTION

FUNCTION LseEasy::GetObjectName
	VAR_INPUT
    pthis : ^void;
  END_VAR
  VAR_OUTPUT
    retcode : ^char;
  END_VAR
  VAR
  	pobj : ^OBJ;
  END_VAR

  pobj$^void := pthis;
  pobj -= sizeof(OBJ);
  retcode$^CLexem := #pobj^.pObjDsc^.SymName;
  retcode += 4;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::GetPrjPath
	VAR_OUTPUT
		retcode 	: ^LASCII;
	END_VAR

  ProjectPath := ProjectPath.Read();

  if(ProjectPath > 0) then // SA42417
    StringLib.StrCpy(#LseProjectPath[0], 1, "C:\Easy", 1);
    StringLib.DintToStr(#LseProjectPath[7], ProjectPath, 16#800, 1);
    StringLib.StrCat(#LseProjectPath[0], 1, "\", 1);
  elsif(ProjectPath = -1) then // SA42417
    StringLib.StrCpy(#LseProjectPath[0], 1, "C:\", 1);
    StringLib.StrCat(#LseProjectPath[0], 1, GetObjectName(this), 1);
    StringLib.StrCat(#LseProjectPath[0], 1, "\", 1);
  else
    StringLib.StrCpy(#LseProjectPath[0], 1, "C:\MPC\", 1);
  end_if;
  
  retcode := #LseProjectPath[0];
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::GetBootImage
	VAR_OUTPUT
		retcode 	: ^CHAR;
	END_VAR

  retcode := "bootimage"; // name of bootimage

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::GetUpdatePath
	VAR_OUTPUT
		retcode 	: ^CHAR;
	END_VAR

  retcode := "E:\";

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::GetFirmwareUpdate
	VAR_OUTPUT
		retcode 	: ^CHAR;
	END_VAR

  StringLib.StrCpy(#UpdateFileDPNE[0], 1, GetUpdatePath(), 1);
  StringLib.StrCat(#UpdateFileDPNE[0], 1, "EasyFirmware.bin", 1);
  retcode := #UpdateFileDPNE[0]; // drive:\path\name.extention of firmwareupdatefile

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::GetBootLoaderUpdate
	VAR_OUTPUT
		retcode 	: ^CHAR;
	END_VAR

  StringLib.StrCpy(#UpdateFileDPNE[0], 1, GetUpdatePath(), 1);
  StringLib.StrCat(#UpdateFileDPNE[0], 1, "BootKiller.bin", 1);
  retcode := #UpdateFileDPNE[0]; // drive:\path\name.extention of bootloaderupdatefile

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::HmiReady


END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::HmiRun
//  VAR
//  	vno : udint;
//    txt : array[0..100] of char;
//  END_VAR
//
//  vno := HmiVarList.GetVarNoByName("Dummy.Server2", 0);
//  HmiVarList.GetServerName(#txt[0], vno);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::HmiOverloadLight
  VAR
  	ovl : dint;
  END_VAR

  ovl := OverloadLight.Read();
  HmiVarList.OverloadLight(ovl);

//  case ovl of
//    1 : HmiVarList.RenameRootObject("Dummy", "LivingRoom");
//    2 : HmiVarList.RenameRootObject("Dummy", "BathRoom");
//    3 : HmiVarList.RenameRootObject("Dummy", "Office");
//  end_case;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::VariableLimitsInUse
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  retcode := false; // don't use variable limits at Server

END_FUNCTION

FUNCTION LseEasy::ErrorStateSvr
  VAR_INPUT
    restart : bool;
  END_VAR

  StateSvr          := TError;
  AliveTix35CntrOld := AliveTix35Cntr;
  TryToRestart      := restart;

END_FUNCTION

FUNCTION LseEasy::SleepNext
	VAR_INPUT
		next 	: TStateSvr;
		sleep 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: TStateSvr;
	END_VAR  

  StateSvr      := TSleep;
  StateNext     := next;
  SleepStart    := ops.tAbsolute;
  SleepDuration := sleep;
  retcode       := StateSvr;

END_FUNCTION

FUNCTION LseEasy::MakePrjFileName
	VAR_INPUT
		dst 	: ^LASCII;
		name 	: ^LASCII;
	END_VAR

  StringLib.StrCpy(dst, sizeof(char), GetPrjPath(), sizeof(char));
  StringLib.StrCat(dst, sizeof(char), name, sizeof(char));
  
END_FUNCTION

FUNCTION LseEasy::UpLoadProject
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;

  if(ProjectBox <> NIL) then
    if(SendProject(ProjectBox) = true) then
      retcode := true;
    else
      ErrorStateSvr(true);
    end_if;
  end_if;

END_FUNCTION

FUNCTION LseEasy::CreateAddText
	VAR_INPUT
    txt : ^void;
    chrsize : udint;
	END_VAR
	VAR_OUTPUT
		retcode 	: udint;
	END_VAR
  VAR
  	tmp : array[0..255] of uint;
    pa : ^usint;
    pu : ^uint;
  END_VAR

  retcode := 16#FFFFFFFF;
  if((CreateAdd = true) & (txt <> NIL)) then
    if(chrsize = 1) then
      pa := txt$^usint;
      pu := #tmp[0];
      while(pa^) do
        pu^ := pa^;
        pu += 2;
        pa += 1;
      end_while;
      
      pu^ := 0;
      txt$^uint := #tmp[0];
    end_if;
    retcode := HmiTextList35.AddEntry(txt$^uint);
  end_if;

END_FUNCTION

FUNCTION LseEasy::CreateAddImage
	VAR_INPUT
    txt : ^char;
	END_VAR
	VAR_OUTPUT
		retcode 	: udint;
	END_VAR

  retcode := 16#FFFFFFFF;
  if((CreateAdd = true) & (txt <> NIL)) then
    retcode := AddImageByIndex(HmiImageList.GetIndexByName(txt), false);
  end_if;

END_FUNCTION

FUNCTION GLOBAL LseEasy::ListSetup
	VAR_INPUT
		listid 	: UDINT;
		lineno_max 	: UDINT;
		line_height 	: UDINT;
		items_per_line 	: UDINT;
		datim2line 	: BOOL;
		bottom_up 	: BOOL;(* := false *)
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    tmp : array[0..6] of usint;
  end_var

  if(lineno_max > 255) then
    lineno_max := 255;
   end_if;
   
  retcode := false;
  tmp[0] := ComCMD_UPDATELIST0_CMD;
  if(listid = 0) then // sonderfall, aus kompatibilittsgrnden zu lterer firmware beibehalten
    tmp[1] := 16#FF; // setup
  else
    tmp[1] := (listid$usint shl 4) or 16#0F; // listid + setup
  end_if;
  
  tmp[2] := items_per_line$usint;
  tmp[3] := line_height$usint;
  tmp[4] := 0;
  if(datim2line = true) then
    tmp[4] := tmp[4] or 1;
  end_if;
  
  if(HmiSwVersion >= 148) then
    if(bottom_up = true) then
      tmp[4] := tmp[4] or 2;
    end_if;
  end_if;
  
  tmp[5] := lineno_max$usint;
  tmp[6] := 0; // nc
  retcode := ComPort.SendData(#tmp[0], 7);
  
END_FUNCTION

FUNCTION GLOBAL LseEasy::ListCmd
	VAR_INPUT
		listid 	: UDINT;
		cmd 	: UDINT;
		item_index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    tmp : array[0..6] of usint;
  end_var

  tmp[0]       := ComCMD_UPDATELIST0_CMD;
  tmp[1]       := (listid$usint shl 4) or cmd$usint;
  tmp[2]$udint := item_index;
  tmp[6]       := 0; // nc
  retcode      := ComPort.SendData(#tmp[0], 7);
  
END_FUNCTION

FUNCTION LseEasy::ListAddEntryIntern
	VAR_INPUT
		listid 	: UDINT;
		item_type 	: UDINT;
		item_val 	: UDINT;
		item_date 	: UDINT;
		item_time 	: UDINT;
		ptxt 	: ^void;
		chrsize 	: UDINT;
		item_id 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    tmp : array[0..99] of usint;
    datim, tmp32 : udint;
    len, nox : udint;
  end_var

  // -----------TTTTTTOOOOSSSSSMMMMMM
  //                           ||||||
  //                           ++++++ ----- minuten (6 bit)
  //                      +++++ ----------- stunden (5 bit)
  //                  ++++ ---------------- monat (4 bit)
  //            ++++++ -------------------- tag (6 bit)
  // +++++++++++ -------------------------- 0


  // itemtype  1...variable, 2...text, 3...image
  retcode := false;
  if(listid < 2) then
  
    datim := 0;
    if((item_date <> 0) | (item_time <> 0)) then
      // YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW
      // HHHHHHHHNNNNNNNNSSSSSSSSxxxxxxxx
      datim := (item_time shr 16) and 16#3F;
      tmp32 := (item_time shr 24) and 16#1F;
      datim := datim or (tmp32 shl 6);
      tmp32 := (item_date shr 12) and 16#0F;
      datim := datim or (tmp32 shl (6+5));
      tmp32 := (item_date shr 4) and 16#3F;
      datim := datim or (tmp32 shl (6+5+4));
    end_if;
  
    tmp[0]       := ComCMD_UPDATELIST0_ADD;
    if(listid = 1) then
      tmp[0]     := ComCMD_UPDATELIST1_ADD;
    end_if;
    tmp[1]$uint  := item_val$uint;
    tmp[3]       := item_type$usint;
    tmp[4]$udint := datim;
    
    len := 7;
    
    if((item_id <> 16#FFFFFFFF) | (ptxt <> nil)) then
      tmp[7]$udint := item_id;
      len := 11;
    end_if;
    
    if(ptxt <> nil) then
      if(chrsize > 1) then
        nox := StringLib.StrLen(ptxt, 2);
        if(nox >= 40) then
          nox := 39;
        end_if;
        nox := nox * 2;
        _memcpy(#tmp[len], ptxt, nox);
        len += nox;
        tmp[len]$uint := 0;
        len += 2;
      else
        nox := StringLib.StrLen(ptxt, 1);
        if(nox >= 80) then
          nox := 79;
        end_if;
        _memcpy(#tmp[len], ptxt, nox);
        len += nox;
        tmp[len] := 0;
        len += 1;
      end_if;
    end_if;
    
    retcode := ComPort.SendData(#tmp[0], len);
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL LseEasy::ListAddEntry
	VAR_INPUT
		listid 	: UDINT;
		item_type 	: UDINT;
		item_val 	: UDINT;
		item_date 	: UDINT;
		item_time 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := ListAddEntryIntern(listid, item_type, item_val, item_date, item_time, nil, 0, 16#FFFFFFFF);
  
END_FUNCTION

FUNCTION GLOBAL LseEasy::ListAddText
	VAR_INPUT
		listid 	: UDINT;
		item_date 	: UDINT;
		item_time 	: UDINT;
		ptxt 	: ^void;
		chrsize 	: UDINT;
		item_id 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	item_type : udint;
  END_VAR

  item_type := 4;
  if(chrsize > 1) then
    item_type := 5;
    chrsize := 2;
  end_if;

  retcode := ListAddEntryIntern(listid, item_type, 0, item_date, item_time, ptxt, chrsize, item_id);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::HmiProjectBegin

// AddVariableByName("Objekt.Server", 0); // fix variablennumber in hmi
// AddStateBitByName("CheckBit2", false, 0); // fix statebitnumber in hmi

//  HmiImageList.XChange("spiderman", "E:\Image0.bmp");


END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::HmiProjectCreate

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::UserProjectRevision
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  
  retcode := 0;
  
END_FUNCTION

#pragma warning (disable : 73)
FUNCTION VIRTUAL GLOBAL LseEasy::HmiScreenCreate
	VAR_INPUT
		screenno 	: UDINT;
	END_VAR

END_FUNCTION
#pragma warning (default : 73)

FUNCTION VIRTUAL GLOBAL LseEasy::EnglishFormatDateTime
	VAR_INPUT
		languageid 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  //  LOCAL_UNKNOWN             = 0x00,
  //  LOCAL_ARABIC              = 0x01,
  //  LOCAL_BULGARIAN           = 0x02,
  //  LOCAL_CATALAN             = 0x03,
  //  LOCAL_CHINESE             = 0x04,
  //  LOCAL_CZECH               = 0x05,
  //  LOCAL_DANISH              = 0x06,
  //  LOCAL_GERMAN              = 0x07,
  //  LOCAL_GREEK               = 0x08,
  //  LOCAL_ENGLISH             = 0x09,
  //  LOCAL_SPANISH             = 0x0A,
  //  LOCAL_FINNISH             = 0x0B,
  //  LOCAL_FRENCH              = 0x0C,
  //  LOCAL_HEBREW              = 0x0D,
  //  LOCAL_HUNGARIAN           = 0x0E, 
  //  LOCAL_ICELANDIC           = 0x0F,
  //  LOCAL_ITALIAN             = 0x10,
  //  LOCAL_JAPANESE            = 0x11,
  //  LOCAL_KOREAN              = 0x12,
  //  LOCAL_DUTCH               = 0x13,
  //  LOCAL_NORWEGIAN           = 0x14,
  //  LOCAL_POLISH              = 0x15,
  //  LOCAL_PORTUGESE           = 0x16,
  //  LOCAL_ROMANIAN            = 0x18,
  //  LOCAL_RUSSIAN             = 0x19,
  //  LOCAL_CROATIA_SERBIAN     = 0x1A,
  //  LOCAL_SLOVAK              = 0x1B,
  //  LOCAL_ALBANIAN_MACEDONIAN = 0x1C,
  //  LOCAL_SWEDISH             = 0x1D,
  //  LOCAL_THAI                = 0x1E,
  //  LOCAL_TURKISH             = 0x1F,
  //  LOCAL_URDU                = 0x20,
  //  LOCAL_INDONESIAN          = 0x21,
  //  LOCAL_UKRAINIAN           = 0x22,
  //  LOCAL_BYELORUSSIAN        = 0x23,
  //  LOCAL_SLOVENIAN           = 0x24,
  //  LOCAL_ESTONIAN            = 0x25,
  //  LOCAL_LATVIAN             = 0x26,
  //  LOCAL_LITHUANIAN          = 0x27,
  //  LOCAL_FARSI               = 0x29,
  //  LOCAL_VIETNAMESE          = 0x2A,
  //  LOCAL_PASQUE              = 0x2D,
  //  LOCAL_AFRICAANS           = 0x36,
  //  LOCAL_GEORGIAN            = 0x37,
  //  LOCAL_FAEROESE            = 0x38,
  //  LOCAL_HINDI               = 0x39
  
  retcode := false;
  case(languageid and 16#FF) of
    16#00 : retcode := false; // unknown
//    16#09 : retcode := true; // english
  end_case;

END_FUNCTION

FUNCTION LseEasy::Create
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    anz  : udint;
    pline  : ^HMI_PRJINFO;
    dpne : array[0..80] of char;
  	pbox, fbox : ^void;
    pprj : ^_BOX_PROJECTLIST;
  end_var

  retcode := true; //false;

  // check actual selection of language
  if(HmiTextList.GetLanguageIndex(ActLanguage.Read()) = 16#FFFFFFFF) then
    ActLanguage.Write(0); // correct actual language
  end_if;

  HmiProject35.Start();

  HmiStateBit35.Start(this);  
  HmiFunctionList35.Start();
  HmiShemeList35.Start(this);
  HmiVarList35.Start();
  HmiSetUpList35.Start();
  HmiTextList35.Start();
  HmiFont35.Start();
  HmiImage35.Start();
  HmiT9Config.Start();
  
  HmiProjectBegin(); // userinterface to add entries to div.list before lse-project is added

  // bootimage
  AddImageByIndex(HmiImageList.GetIndexByName(GetBootImage()), true);

  anz := HmiProjectList.GetNo();
  while(anz) do
    anz -= 1;
    pline := HmiProjectList.Get(anz);

    if(pline^.ima.ima = HMI_IMA_SCREEN) then
      MakePrjFileName(#dpne[0], #pline^.name[0]);
      if(HmiScreen.LoadFile(#dpne[0]) = true) then
        if(ScreenCreate(to_udint(pline^.ima.value)) = false) then
          retcode := false;
          OutMessageValue("ERROR: Create Screen ", to_udint(pline^.ima.value));
        end_if;
      else
        retcode := false;
        OutMessageValue("ERROR: Load Screen ", to_udint(pline^.ima.value));
      end_if;
    end_if;
    pline += sizeof(HMI_PRJINFO);
  end_while;

  HmiSetupList35.Create(CreateColor(HmiSetUpList.GetButColBack()),
                        CreateColor(HmiSetUpList.GetButColText()),
                        CreateColor(HmiSetUpList.GetTitleCol()),
                        CreateColor(HmiSetUpList.GetLimitCol()),
                        CreateColor(HmiSetUpList.GetWindowCol()),
                        CreateFrame(HmiSetUpList.GetButtonFrame(), 0),
                        CreateFrame(HmiSetUpList.GetWindowFrame(), 0), 
                        UserProjectRevision(), 
                        AddFont(HmiSetUpList.GetFontSchemeStandard()),
                        AddFont(HmiSetUpList.GetFontSchemeStandardSmall()));

  CreateAdd := true;
  HmiProjectCreate(); // userinterface to add entries to div.list
  CreateAdd := false;

  fbox := HmiFunctionList35.End(this); // functionlist als erstes machen weil ggf. Funktionsblcke und Variablen noch addiert werden

  pbox := HmiVarList35.End();
  HmiProject35.AddEntry(BIGBOX_VARLIST, 0, pbox, false, false);
  
  pbox := HmiTextList35.End();
  HmiProject35.AddEntry(BIGBOX_TEXTLIST, 0, pbox, false, false);

  HmiProject35.AddEntry(BIGBOX_FUNCTIONLIST, 0, fbox, false, false);

  pbox := HmiShemeList35.End();
  HmiProject35.AddEntry(BIGBOX_SHEMELIST, 0, pbox, false, false);

  pbox := HmiSetupList35.End();
  HmiProject35.AddEntry(BIGBOX_SETUPLIST, 0, pbox, false, false);

  T9KeyboardConfig();
  pbox := HmiT9Config.End();
  if(pbox <> nil) then
    HmiProject35.AddEntry(BIGBOX_KEYBRD_T9, 0, pbox, false, false);
  end_if;

  if(HmiTextList35.GetErrorCnt() > 0) then
    OutMessage("ERROR: Maximum size of textlist reached");
    retcode := false;
  end_if;

  if(retcode = true) then

    ProjectBox := HmiProject35.End(HmiProjectList.GetStartScreen(), BackLightOff.Read(), TempInterval.Read());
  
    if(ProjectBox <> NIL) then
      pprj$^void := ProjectBox;
      HmiPrjCrc  := pprj^.boxhdr.crc32;
    
      // free furthermore unused memory
      HmiImageList.FreeMem();
      HmiFontList.FreeMem();
      // HmiTextList.FreeMem(); // xcomment: wunsch applikation 14.11.2017
      HmiFunctionList.FreeMem();
      HmiFontShemeList.FreeMem();
      HmiTextShemeList.FreeMem();
      HmiImageShemeList.FreeMem();
      HmiScreen.FreeMem();
    else
      retcode := false;
    end_if;
  end_if;
  
  if(retcode = false) then
    OutMessage("ERROR: Can't Create HMI-Project");
    SetErrorSvr(ErrCreateHmiProject);
  end_if;
  
//  SendProject(ProjectBox); 
//  HmiProject35.Free();
  
END_FUNCTION

FUNCTION LseEasy::LoadProjectEntries
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    anz  : udint;
    pline  : ^HMI_PRJINFO;
    dpne : array[0..80] of char;
    state : bool;
  end_var
  
  retcode := true;
  anz     := HmiProjectList.GetNo();
  
  while(anz) do
    anz   -= 1;
    pline := HmiProjectList.Get(anz);
    state := true;
    
    case(pline^.ima.ima) of
      HMI_IMA_IMAGELIST      : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiImageList.LoadFile(#dpne[0]);
      HMI_IMA_SERVERLIST     : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiVarList.LoadFile(#dpne[0]);
                               HmiOverloadLight();
      HMI_IMA_FUNCTIONLIST   : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiFunctionList.LoadFile(#dpne[0]);
      HMI_IMA_GUIDEPOSTLIST  : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiTextList.LoadFile(#dpne[0], GetPrjPath(), ActLanguage.Read());
      HMI_IMA_TEXTSCHEMA     : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiTextShemeList.LoadFile(#dpne[0]);
      HMI_IMA_IMAGESCHEMA    : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiImageShemeList.LoadFile(#dpne[0]);
      HMI_IMA_FONTSCHEMA     : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiFontShemeList.LoadFile(#dpne[0]);
      HMI_IMA_UNITSCHEMA     : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiVarList.LoadUnitScheme(#dpne[0]);
      HMI_IMA_FONTLIST       : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiFontList.LoadFile(#dpne[0], GetPrjPath());
      HMI_IMA_COLORMAP       : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiColorMap.LoadFile(#dpne[0]);
      HMI_IMA_SETUPLIST      : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiSetUpList.LoadFile(#dpne[0]);
      HMI_IMA_CHKBITLIST     : MakePrjFileName(#dpne[0], #pline^.name[0]);
                               state := HmiChkBitList.LoadFile(#dpne[0]);
                               
//      HMI_IMA_KEYPADLIST     : MakePrjFileName(#dpne[0], #pline^.name[0]);
//                           //GlobalKeypad.LoadFile(#dpne[0]);
    end_case;
    pline += sizeof(HMI_PRJINFO);
    
    if(state = false) then
      OutMessage("ERROR: Can't Load LSE-ProjectEntry");
      retcode := false;
      anz     := 0;
    end_if;
    
  end_while;


END_FUNCTION

FUNCTION LseEasy::LoadFile
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR    
  var
    dpne : array[0..80] of char;
    st : udint;
  end_var

  Free();

  retcode := false;
  
  MakePrjFileName(#dpne[0], HMI_PRJNAME);
  st := HmiProjectList.LoadFile(#dpne[0]);
  if(st = 1) then
    retcode := LoadProjectEntries();
  elsif(st = 2) then
    OutMessage("ERROR: Wrong LSE-Compiler Version");
    SetErrorSvr(ErrLseCompilerVersion);
  end_if;

  LseProjectRevision := HmiProjectList.GetLseProjectRevision();

  if(st <> 2) then
    if(retcode = false) then
      OutMessage("ERROR: Can't Load LSE-Project");
      SetErrorSvr(ErrLoadLseProject);
    end_if;
  end_if;

  if(retcode = true) then
    HmiVarList.SetLid(BacklightDimLid, HmiSwVersionLid, HmiHwVersionLid);
  end_if;

END_FUNCTION

FUNCTION LseEasy::ScreenCreate
	VAR_INPUT
		screennumber 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	anz, idx : udint;
    pany : ^HMI_ANYTHING;
    pctr : ^void;
    fct1, fct2 : uint;
  END_VAR
  
  fct1 := AddFunctionBlock(HmiScreen.GetStartFunct());
  fct2 := AddFunctionBlock(HmiScreen.GetEndFunct());
  
  ScreenStart(screennumber, fct1, fct2);
  
  anz := HmiScreen.GetZorderNo();
  idx := 0;
  while(anz) do
    pany := HmiScreen.GetZorder(idx);
    pctr := HmiScreen.GetControl(pany);
    
    if(pctr <> nil) then
      case pany^.ima of
        HMI_IMA_V_RECTANGLE : ScreenAddCtrlRectangle(pctr$^HMI_CTRL_RECTANGLE);
        HMI_IMA_V_LINE      : ScreenAddCtrlLine(pctr$^HMI_CTRL_LINE);
        HMI_IMA_V_CIRCLE    : ScreenAddCtrlCircle(pctr$^HMI_CTRL_CIRCLE);
        HMI_IMA_V_TEXT      : ScreenAddCtrlText(pctr$^HMI_CTRL_TEXT);
        HMI_IMA_V_IMAGE     : ScreenAddCtrlImage(pctr$^HMI_CTRL_IMAGE);
        HMI_IMA_V_IO        : ScreenAddCtrlIO(pctr$^HMI_CTRL_IO);
      end_case;
    end_if;
    
    anz -= 1;
    idx += 1;
  end_while;
  
  HmiScreenCreate(screennumber);
  
  retcode := ScreenStop(screennumber);

END_FUNCTION

FUNCTION LseEasy::GetFontInfo
	VAR_INPUT
		fontindex 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^HMI_FONTINFO;
	END_VAR
  VAR
  	pany : ^HMI_ANYTHING;
    lang : dint;
  END_VAR

  retcode := NIL;
  lang    := to_dint(HmiTextList.GetLanguageId(ActLanguage.Read()));
  pany    := HmiFontShemeList.GetResult(fontindex, lang);
  
  if(pany <> NIL) then
    if(pany^.ima = HMI_IMA_V_FONT) then
      retcode := HmiFontList.Get(pany^.value$udint);
    end_if;
  end_if;

END_FUNCTION

#define AttLEFT                   0x00 // horizontal alignment  
#define AttCENTER                 0x10 // horizontal alignment
#define AttRIGHT                  0x20 // horizontal alignment
#define AttUP                     0x00 // vertical alignment
#define AttMID                    0x40 // vertical alignment
#define AttDOWN                   0x80 // vertical alignment
#define Att3D                     0x08 // used to display shade at each glyph
#define AttZOOM                   0x04 // zoom image
#define AttBOLD                   0x02 // used to display shade at each glyph

FUNCTION LseEasy::CreateAttrib
	VAR_INPUT
		att32 	: UDINT;
		fontindex 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR
  VAR
    pfnt : ^HMI_FONTINFO;
  END_VAR

  retcode := 0;

  pfnt := GetFontInfo(fontindex);
  if(pfnt <> NIL) then
    if(pfnt^.attrib and T_STRIKEOUT) then
      retcode := retcode or ATT3D;
    end_if;
    if(pfnt^.attrib and T_BOLD) then
      retcode := retcode or AttBOLD;
    end_if;
  end_if;

  if(att32 and T_LEFTBOUND) then
    retcode := retcode or AttLEFT;
  end_if;
  if(att32 and T_CENTERBOUND) then
    retcode := retcode or AttCENTER;
  end_if;
  if(att32 and T_RIGHTBOUND) then
    retcode := retcode or AttRIGHT;
  end_if;
  if(att32 and T_UPBOUND) then
    retcode := retcode or AttUP;
  end_if;
  if(att32 and T_MIDBOUND) then
    retcode := retcode or AttMID;
  end_if;
  if(att32 and T_DOWNBOUND) then
    retcode := retcode or AttDOWN;
  end_if;

END_FUNCTION

FUNCTION LseEasy::CreateColor
	VAR_INPUT
		colindex 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := HmiColorMap.Get(colindex);

END_FUNCTION

FUNCTION LseEasy::CreateFrame
	VAR_INPUT
		frameindex 	: USINT;
		attrib 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR

  retcode := frameindex;
  if(attrib and 16#20) then
    retcode := retcode or 16#80;
  end_if;

END_FUNCTION

FUNCTION LseEasy::CreateBarState
	VAR_INPUT
		attrib 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR

  retcode := to_usint((attrib shr 24) and 7);
//    0 : // down->up
//    1 : // up->down
//    2 : // left->right
//    3 : // right->left
//    4 : // mid vertical
//    5 : // mid horizontal 

END_FUNCTION
FUNCTION LseEasy::CreateMomStat
	VAR_INPUT
		pio 	: ^HMI_CTRL_IO;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := AddVariable(#pio^.server);
  if(retcode <> 16#FFFF) then
    if(pio^.act_momntry) then
      retcode := retcode or 16#8000;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL LseEasy::AddFunctionBlock
	VAR_INPUT
		functindex 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  VAR
  	pfcb : ^HMI_FCTBLOCK;
  END_VAR

  retcode := 16#FFFF;
  
  pfcb$^void := HmiFunctionList.Get(functindex);
  if(pfcb <> NIL) then
    if(pfcb^.index35 <> HMI_DEFSCOPE) then
      retcode := pfcb^.index35$uint;
      return;
    end_if;
    
    retcode       := to_uint(HMIFunctionList35.AddEntry(pfcb));
    pfcb^.index35 := retcode;
  end_if;
  
END_FUNCTION

FUNCTION LseEasy::AddFunctionBlockIO
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := 16#FFFF;
  if(pany^.ima = HMI_IMA_V_FUNCTIONLIST) then
    retcode := AddFunctionBlock(pany^.value$udint);
  end_if;
  
END_FUNCTION

FUNCTION LseEasy::AddVariable
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := 16#FFFF;
  if(pany^.ima = HMI_IMA_V_SERVERLIST) then
    retcode := to_uint(HmiVarList.GetAdd35(pany^.value$udint));
  end_if;

END_FUNCTION

FUNCTION LseEasy::AddStateBitByName
	VAR_INPUT
		name 	: ^CHAR;
		invert 	: bool;
		access 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	chkbit : HMI_CHKBIT;
    cno : udint;
    state : bool;
  END_VAR

  retcode := false;
  state   := (access <> 0);

  chkbit.no     := 16#FFFF;
  chkbit.invert := 0;
  
  cno := HmiChkBitList.GetChkBitIndex(name);
  if(cno < 16#FFFF) then
    chkbit.no := cno$uint;
    if(invert = true) then
      chkbit.invert := 1;
    end_if;
    state := true;
  end_if;
  
  if(state = true) then
    HmiStateBit35.AddEntry(#chkbit, access, NIL);
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION LseEasy::AddVariableByName
  var_input
    name : ^char;
    station : udint;
  end_var
  var_output
    retcode : bool;
  end_var
  VAR
  	any : HMI_ANYTHING;
  END_VAR

  retcode := false;

  init_HMI_ANYTHING(#any);
  any.ima         := HMI_IMA_V_SERVERLIST;
  any.value$udint := HmiVarList.GetVarNoByName(name, station);
  if(AddVariable(#any) <> 16#FFFF) then
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION LseEasy::GetLasalId
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := 0;
  if(pany^.ima = HMI_IMA_V_SERVERLIST) then
    retcode := HmiVarList.GetLasalId(pany^.value$udint);
  end_if;

END_FUNCTION

FUNCTION LseEasy::GetVariable
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^HMI_VARINFO;
	END_VAR
 
  retcode := nil;
  if(pany^.ima = HMI_IMA_V_SERVERLIST) then
    retcode := HmiVarList.Get(pany^.value$udint);
  end_if;

END_FUNCTION

FUNCTION LseEasy::AddSheme
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := 16#FFFF;
  if(pany^.ima = HMI_IMA_V_IMAGESCHEMA) then
    retcode := HmiShemeList35.AddEntry(HmiImageShemeList.Get(to_udint(pany^.value)));
  elsif(pany^.ima = HMI_IMA_V_TEXTSCHEMA) then
    retcode := HmiShemeList35.AddEntry(HmiTextShemeList.Get(to_udint(pany^.value)));
  end_if;
  
END_FUNCTION

FUNCTION LseEasy::AddFont
	VAR_INPUT
		index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR
  VAR
    pfnt : ^HMI_FONTINFO;
    pbox : ^void;
  END_VAR

  retcode := 16#FF;
  
  pfnt := GetFontInfo(index);
  if(pfnt <> NIL) then
    if(pfnt^.index35 <> HMI_DEFSCOPE) then
      retcode := pfnt^.index35$usint;
      return;
    end_if;

    pbox := HmiFont35.CreateList(pfnt^.ptr, pfnt^.size);
    if(pbox <> NIL) then
      HmiFontList.SetIndex35(pfnt, HmiFontList.IncNumber());
      HmiProject35.AddEntry(BIGBOX_FONT, pfnt^.index35, pbox, false, true);
      retcode := pfnt^.index35$usint;
    end_if;
  end_if;

END_FUNCTION

FUNCTION LseEasy::AddText
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := to_uint(HmiTextList.GetAdd35(pany));

END_FUNCTION

FUNCTION LseEasy::AddImageByIndex
	VAR_INPUT
		index 	: UDINT;
		bootimage 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  VAR
  	pi : ^HMI_IMAGEINFO;
    pbox : ^void;
  END_VAR

  retcode := 16#FFFF;
  
  pi := HmiImageList.Get(index);
  if(pi <> NIL) then
    if(pi^.index35 <> HMI_DEFSCOPE) then
      retcode := pi^.index35$uint;
      return;
    end_if;

    pbox := HmiImage35.CreateList(pi^.width, pi^.height, pi^.transparent, pi^.state, pi^.datano, pi^.ptr);
    if(pbox <> NIL) then
      pi^.index35 := HmiImageList.IncNumber();
      if(bootimage = true) then
        HmiProject35.AddEntry(BIGBOX_BOOTIMAGE, pi^.index35, pbox, false, true);
      else
        HmiProject35.AddEntry(BIGBOX_IMAGE, pi^.index35, pbox, false, true);
      end_if;
      retcode := pi^.index35$uint;
    end_if;
  end_if;

END_FUNCTION

FUNCTION LseEasy::AddImage
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := 16#FFFF;
  
  if(pany^.ima = HMI_IMA_V_IMAGELIST) then
    retcode := AddImageByIndex(pany^.value$udint, false);
  end_if;

END_FUNCTION

FUNCTION LseEasy::ScreenStart
	VAR_INPUT
		screennumber 	: UDINT;
		startfunct 	: UINT;
		endfunct 	: UINT;
	END_VAR

  StartScreen(to_uint(screennumber), startfunct, endfunct, CreateColor(HmiSetUpList.GetScreenColorBack()));

END_FUNCTION

FUNCTION LseEasy::ScreenAddCtrlRectangle
	VAR_INPUT
		ptr 	: ^HMI_CTRL_RECTANGLE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	sbit : usint;
  END_VAR

  retcode := false;
  
  sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, 0, nil);
  if(AddScreen_CTRL_FRAME(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, CreateColor(ptr^.color), CreateFrame(ptr^.frame, ptr^.attrib), sbit) <> 0) then
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION LseEasy::ScreenAddCtrlCircle
	VAR_INPUT
		ptr 	: ^HMI_CTRL_CIRCLE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	angle, arc : dint;
    xm, ym, rx, ry, r, a, ar : real;
    act, old : _XY;
    cdata : array[0..363] of _XY;
    cno : uint;
  	sbit : usint;
    pie : bool;
  END_VAR

  retcode := true;
  angle   := ptr^.angle / 10;
  arc     := ptr^.arc / 10;
  
  if(arc <> 0) then
    xm  := (to_real(ptr^.room.xy1.x + ptr^.room.xy2.x)) / 2;
    ym  := (to_real(ptr^.room.xy1.y + ptr^.room.xy2.y)) / 2;
    rx  := (to_real(ptr^.room.xy2.x - ptr^.room.xy1.x)) / 2;
    ry  := (to_real(ptr^.room.xy2.y - ptr^.room.xy1.y)) / 2;
    cno := 0;
    pie := true;
    
    if(arc >= 360) then
      arc := 360;
      pie := false;
    end_if;
    
    r := rx;
    if(ry > rx) then
      r  := ry;
    end_if;

    if(arc < 0) then
      angle += arc;
      arc   := -arc;
    end_if;
    
    a     := angle;
    old.x := -32768;
    old.y := -32768;
    arc   += 1;
    
    while(arc) do
      ar    := (a * 3.1416) / 180;
      act.x := to_int((COS(ar)    * rx) + xm + 0.5);
      act.y := to_int((-(SIN(ar)) * ry) + ym + 0.5);

      if((act.x <> old.x) | (act.y <> old.y)) then
        old := act;
        if(cno <= 360) then
          cdata[cno] := act;
          cno        += 1;
        end_if;
      end_if;
      
      a   += 1;
      arc -= 1;
    end_while;
   
    if(cno > 0) then
      if(pie = true) then
        cdata[cno].x := to_int(xm + 0.5);
        cdata[cno].y := to_int(ym + 0.5);
        cno += 1;
        cdata[cno] := cdata[0];
        cno += 1;
      end_if;
      
      sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, 0, nil);
      if(AddScreen_CTRL_POLYLINE(#cdata[0], cno, CreateColor(ptr^.color), sbit) = 0) then
        retcode := false;
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION LseEasy::ScreenAddCtrlLine
	VAR_INPUT
		ptr 	: ^HMI_CTRL_LINE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	sbit : usint;
  END_VAR

  retcode := false; 
  sbit    := HmiStateBit35.AddEntry(#ptr^.chkbit, 0, nil);
  if(AddScreen_CTRL_POLYLINE(ptr^.ptxy$^_XY, ptr^.no, CreateColor(ptr^.color), sbit) <> 0) then
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION LseEasy::ScreenAddCtrlImage
	VAR_INPUT
		ptr 	: ^HMI_CTRL_IMAGE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	sbit : usint;
  END_VAR

  retcode := false;
  sbit    := HmiStateBit35.AddEntry(#ptr^.chkbit, 0, nil);
  if(AddScreen_CTRL_IMAGE(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, AttMID or AttCENTER or AttZOOM, AddImage(#ptr^.any), sbit) <> 0) then
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION LseEasy::ScreenAddCtrlText
	VAR_INPUT
		ptr 	: ^HMI_CTRL_TEXT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	txtidx : uint;
    sbit : usint;
  END_VAR

  retcode := false;
  
  if((ptr^.anything.ima = HMI_IMA_V_SERVERTEXT00) | (ptr^.anything.ima = HMI_IMA_V_SERVERUNITTEXT)) then
    if(HmiVarList.GetLasalId(ptr^.anything.value$udint) = 0) then
      return; // no valid lasalid --> do not add control
    end_if;
  end_if;
  
  sbit   := HmiStateBit35.AddEntry(#ptr^.chkbit, 0, #ptr^.anything);
  txtidx := AddText(#ptr^.anything);
  if(AddScreen_CTRL_TEXT(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, 
                         CreateColor(ptr^.colorback), CreateColor(ptr^.colortext), 
                         AddFont(ptr^.font), CreateAttrib(ptr^.attrib, ptr^.font), 
                         CreateFrame(ptr^.frame, ptr^.attrib), txtidx, sbit) <> 0) then
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION LseEasy::CreateVarConst
	VAR_INPUT
		vstate 	: ^USINT;
		pany 	: ^HMI_ANYTHING;
		pdata 	: ^HMI_ANYTHING;
		isog 	: BOOL;
		defval 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	varno : uint;
    pvar : ^HMI_VARINFO;
  END_VAR
  
  retcode := defval;
  vstate^ := 0;
  
  if(pany^.ima = HMI_IMA_V_SERVERLIST) then
    varno := AddVariable(pany);
    if(varno <> 0xFFFF) then
      retcode := varno;
      vstate^ := 1;
    end_if;
  elsif(pany^.ima = HMI_IMA_DINT_CONSTANT) then
    retcode := pany^.value;
  elsif(pdata <> NIL) then
    if(pdata^.ima = HMI_IMA_V_SERVERLIST) then
      pvar := HmiVarList.Get(pdata^.value$udint);
      if(pvar <> NIL) then
        pany := #pvar^.limit_lo;
        if(isog = true) then
          pany := #pvar^.limit_hi;
        end_if;
        retcode := CreateVarConst(vstate, pany, NIL, isog, defval);
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION LseEasy::ScreenAddCtrlIO
	VAR_INPUT
		ptr 	: ^HMI_CTRL_IO;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	st, lid  : udint;
    pvi : ^HMI_VARINFO;
    iot, dig, vugstate, vogstate, sbit : usint;
    vog, vug : dint;
    access, scmidx : uint;
  END_VAR

  retcode := false; 
  st      := 1;
  
  access  := ptr^.access;
  if(ptr^.writeprotect = true) then
    access := 0;
  end_if;
  
  // todo: wenn access = 0 dann access von server holen
  
  case ptr^.iotype of
    HMI_IOT_NUMERIC:
      pvi := GetVariable(#ptr^.server);
      if(pvi <> nil) then
      
        lid  := GetLasalId(#ptr^.server);
        sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, access, #ptr^.server);
        
        if((lid = TrendVal0Lid) | (lid = TrendVal1Lid)) then
          dig := 0;
          if(lid = TrendVal1Lid) then
            dig := 1;
          end_if;
          
          st := AddScreen_CTRL_OSZI(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y,
                                    CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                                    CreateAttrib(ptr^.attrib, ptr^.font), 
                                    CreateFrame(ptr^.frame, ptr^.attrib),
                                    dig, sbit);
        elsif((lid = ListVal0Lid) | (lid = ListVal1Lid)) then
          dig := 0;
          if(lid = ListVal1Lid) then
            dig := 1;
          end_if;
          st := AddScreen_CTRL_LIST(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y,
                                    AddVariable(#ptr^.server),
                                    CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), CreateColor(9), 
                                    AddFont(ptr^.font),
                                    CreateAttrib(ptr^.attrib, ptr^.font), 
                                    CreateFrame(ptr^.frame, ptr^.attrib),
                                    dig, sbit);
        elsif(lid = PixMapLid) then
          st := AddScreen_CTRL_PIXMAP(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y,
                                    CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 0, sbit);
        else
      
          case pvi^.vartype of
            HMI_DATE : iot := IOTYPE_DATE;
                       dig := DATEFORMAT_DDMMYYYY;
                       if(pvi^.subtype = 0) then
                         dig := DATEFORMAT_DDMM;
                       elsif(pvi^.subtype = 1) then
                         dig := DATEFORMAT_DDMMYY;
                       end_if;
                       if(EnglishFormatDateTime(HmiTextList.GetLanguageId(ActLanguage.Read())) = true) then
                         dig := dig or DATIM_USA;
                       end_if;
            HMI_TIME : iot := IOTYPE_TIME;
                       dig := TIMEFORMAT_HHMMSS;
                       if(pvi^.subtype = 0) then
                         dig := TIMEFORMAT_HHMM;
                       elsif(pvi^.subtype = 2) then
                         dig := TIMEFORMAT_MMSS;
                       end_if;
                       if(EnglishFormatDateTime(HmiTextList.GetLanguageId(ActLanguage.Read())) = true) then
                         dig := dig or DATIM_USA;
                       end_if;
            else       iot := IOTYPE_NUMERIC;
                       dig := HmiVarList.GetDigits(#ptr^.server, true);
          end_case;
        
          st := AddScreen_CTRL_IO(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, 
                                  AddVariable(#ptr^.server), 
                                  CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                                  CreateFrame(ptr^.frame, ptr^.attrib), 
                                  AddFont(ptr^.font), CreateAttrib(ptr^.attrib, ptr^.font), 
                                  iot, dig, ptr^.writeprotect, sbit);
        end_if;
      end_if;
      
    HMI_IOT_NUMERIC_HIDE:
      sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, access, #ptr^.server); 
      st := AddScreen_CTRL_IO(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, 
                              AddVariable(#ptr^.server), 
                              CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                              CreateFrame(ptr^.frame, ptr^.attrib), 
                              AddFont(ptr^.font), CreateAttrib(ptr^.attrib, ptr^.font), IOTYPE_NUMERIC_HIDE, 0, ptr^.writeprotect, sbit);
                              
    HMI_IOT_STRING,
    HMI_IOT_STRING_HIDE:
      iot := IOTYPE_STRING;
      if(ptr^.iotype = HMI_IOT_STRING_HIDE) then
        iot := IOTYPE_STRING_HIDE;
      end_if;
      sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, 0, #ptr^.server); 
      st := AddScreen_CTRL_IO(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, 
                              AddVariable(#ptr^.server), 
                              CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                              CreateFrame(ptr^.frame, ptr^.attrib),
                              AddFont(ptr^.font), CreateAttrib(ptr^.attrib, ptr^.font), iot, 0, ptr^.writeprotect, sbit); //ptr^.writeprotect);
                              // todo !! writeprotected flag auf true setzen
//                              AddFont(ptr^.font), CreateAttrib(ptr^.attrib, ptr^.font), IOTYPE_STRING, 0, true, sbit); //ptr^.writeprotect);
                              
    HMI_IOT_IPADDRESS:
      sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, access, #ptr^.server);
      st := AddScreen_CTRL_IO(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, 
                              AddVariable(#ptr^.server), 
                              CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                              CreateFrame(ptr^.frame, ptr^.attrib),
                              AddFont(ptr^.font), CreateAttrib(ptr^.attrib, ptr^.font), IOTYPE_IP, 0, ptr^.writeprotect, sbit);
    HMI_IOT_BAR:
      sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, access, #ptr^.server);
      vug := CreateVarConst(#vugstate, #ptr^.anything2, #ptr^.server, false,   0);
      vog := CreateVarConst(#vogstate, #ptr^.anything3, #ptr^.server, true, 100);
      st := AddScreen_CTRL_IOBAR(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, 
                              AddVariable(#ptr^.server), 
                              CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                              CreateFrame(ptr^.frame, ptr^.attrib), CreateBarState(ptr^.attrib), ptr^.writeprotect, 
                              vog, vogstate, vug, vugstate, sbit);
    HMI_IOT_BUTTON:
      sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, access, #ptr^.server); 
      st := AddScreen_CTRL_BUTTON(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, 
                              CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                              CreateFrame(ptr^.frame, ptr^.attrib),
                              AddFont(ptr^.font), CreateAttrib(ptr^.attrib, ptr^.font), // or ATTZOOM,
                              AddImage(#ptr^.anything3), AddImage(#ptr^.anything4), 
                              AddText(#ptr^.anything1), AddText(#ptr^.anything2),
                              AddFunctionBlockIO(#ptr^.gfunct.pos_edge), AddFunctionBlockIO(#ptr^.gfunct.neg_edge),
                              CreateMomStat(ptr),
                              ptr^.gfunct.triggertype, sbit,
                              to_int(ptr^.resetval), to_int(ptr^.setval));
    HMI_IOT_CHKBOX ,
    HMI_IOT_RADIOBUTTON :     
      sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, access, #ptr^.server);
      st := AddScreen_CTRL_IO(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y, 
                              AddVariable(#ptr^.server), 
                              CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                              CreateFrame(ptr^.frame, ptr^.attrib), 
                              16#FF, AttCENTER or AttMID, IOTYPE_CHKBOX, 0, ptr^.writeprotect, sbit);

    HMI_IOT_SCHEMA : // textschema, imageschema
      sbit := HmiStateBit35.AddEntry(#ptr^.chkbit, 0, #ptr^.server);
      if(ptr^.anything1.ima = HMI_IMA_V_IMAGESCHEMA) then
        st := AddScreen_CTRL_IMAGESCM(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y,
                                      16#FFFE, //CreateColor(ptr^.color_back),
                                      CreateFrame(ptr^.frame, ptr^.attrib),
                                      CreateAttrib(ptr^.attrib, 16#FFFFFFFF) or AttZOOM,
                                      AddVariable(#ptr^.server),
                                      AddSheme(#ptr^.anything1), sbit);
      else
        st := AddScreen_CTRL_TEXTSCM(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y,
                                     CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                                     AddFont(ptr^.font), CreateAttrib(ptr^.attrib, ptr^.font), 
                                     CreateFrame(ptr^.frame, ptr^.attrib), 
                                     AddVariable(#ptr^.server),
                                     AddSheme(#ptr^.anything1), sbit);
      end_if;
    
    HMI_IOT_ENUMERATION :  // display io as enumeration
      sbit   := HmiStateBit35.AddEntry(#ptr^.chkbit, 0, #ptr^.server);
      scmidx := to_uint(GetEnumSchemeIndex(#ptr^.server));
      st := AddScreen_CTRL_TEXTSCM(ptr^.room.xy1.x, ptr^.room.xy1.y, ptr^.room.xy2.x, ptr^.room.xy2.y,
                                   CreateColor(ptr^.color_back), CreateColor(ptr^.color_text), 
                                   AddFont(ptr^.font), CreateAttrib(ptr^.attrib, ptr^.font), 
                                   CreateFrame(ptr^.frame, ptr^.attrib), 
                                   AddVariable(#ptr^.server),
                                   scmidx, sbit);
  end_case;
  
  if(st <> 0) then
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION LseEasy::GetEnumSchemeIndex
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	pvi : ^HMI_VARINFO;
  END_VAR

  retcode := HMI_DEFSCOPE;
  if(pany^.ima = HMI_IMA_V_SERVERLIST) then

    pvi := HmiVarList.Get(pany^.value$udint);
    if(pvi <> nil) then
      if(pvi^.escm_index35 < HmiShemeList35.GetNo()) then
        retcode := pvi^.escm_index35; // sheme already exists
      else
        retcode := HmiShemeList35.AddEntry(HmiVarList.CreateShemeFromEnum(pany));
        pvi^.escm_index35 := retcode; // memorize schemeindex
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL LseEasy::AddAnything
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := 16#FFFF;

  if(pany <> NIL) then
    if(pany^.ima = HMI_IMA_V_IMAGELIST) then
      retcode := AddImage(pany);
    else      
      retcode := AddText(pany);
    end_if;
  end_if;

END_FUNCTION

FUNCTION LseEasy::ScreenStop
	VAR_INPUT
		screennumber 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pbox : ^void;
  END_VAR

  pbox := EndScreen();
  retcode := HmiProject35.AddEntry(BIGBOX_SCREEN, screennumber, pbox, true, true);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::ActScreen::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	CallScreen := input;
	result := input;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::BacklightOnOff::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	BacklightOnOff := input;
  
  if(input = 0) then
    ComPort.SendBacklightOnOff(0);
  else
    ComPort.SendBacklightOnOff(1);
  end_if;  
   
	result := BacklightOnOff;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::BacklightDim::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if(input < 0) then
    input := 0;
    result := ACCESS_DENIED;
  elsif(input > 100) then
    input := 100;
    result := ACCESS_DENIED;
  else
	  result := input;
  end_if;  

  ComPort.SendBacklightDim(input$usint);
	BacklightDim := input;

END_FUNCTION

FUNCTION LseEasy::GetBacklightDim
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR
  
  retcode := ComPort.GetBacklightInfo();
  if(retcode <> 0xFF) then
    BacklightDim := retcode and 0x7F;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL LseEasy::UpdateScreenshot
	VAR_INPUT
		pscrshot 	: ^void;
	END_VAR

  if(ComPort.SaveScreenshot("C:\hmi35.bmp", pscrshot) = true) then
    OutMessage("SCREENSHOT ...Ready (C:\hmi35.bmp)");
  else
    OutMessage("ERROR: Can't save Screenshot (C:\hmi35.bmp)");
  end_if;
  
  if(StateSvr = TGetScreenShot) then
    StateSvr := TRun;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::UpdateValue35
	VAR_INPUT
		varno 	: UINT;
		value 	: DINT;
	END_VAR

  if(HmiPrjCrc = Hmi35PrjCrc) then // check crc of project with crc of hmi
  
    if(varno = VARNO_IRCODE) then
      UpdateIrCode(value$udint);
    end_if;
  
    HmiVarList.UpdateValue(varno, value);
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::UpdateString35
	VAR_INPUT
		varno 	: UINT;
		pstr 	: ^void;
		chrsize 	: UDINT;
	END_VAR

  if(HmiPrjCrc = Hmi35PrjCrc) then // check crc of project with crc of hmi
    HmiVarList.UpdateString(varno, pstr, chrsize);
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::UpdateTemperature35
	VAR_INPUT
		value 	: DINT;
	END_VAR

  if(value = DEFAULT_VALUE_TEMPERATURE) then
    value$udint := FUEHLERBRUCH;
  end_if;
  ActTemperature := value;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::UpdateHumidity35
	VAR_INPUT
		value 	: DINT;
	END_VAR

  if(value = DEFAULT_VALUE_TEMPERATURE) then
    value$udint := FUEHLERBRUCH;
  end_if;
  ActHumidity := value;

END_FUNCTION

FUNCTION GLOBAL LseEasy::UpdateActScreen
	VAR_INPUT
		scrno 	: DINT;
	END_VAR

  ActScreen := scrno;

END_FUNCTION

FUNCTION GLOBAL LseEasy::UpdateInUse

  LastUsage := ops.tAbsolute;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::ActLanguage::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  if(input <> ActLanguage) then
    if(HmiTextList.GetLanguageIndex(input) <> 16#FFFFFFFF) then
	    ActLanguage := input;
      if(StateSvr = TRun) then
        StateSvr := TStart;
      end_if;
    end_if;
  end_if;
  
	result := ActLanguage;

END_FUNCTION

FUNCTION GLOBAL LseEasy::SendNewBootLoader
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  
  retcode := SendUpdateToHmi(GetBootLoaderUpdate());
  
END_FUNCTION

FUNCTION GLOBAL LseEasy::SendNewFirmware
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  
  retcode := SendUpdateToHmi(GetFirmwareUpdate());
  
END_FUNCTION

FUNCTION LseEasy::SendUpdateToHmi
	VAR_INPUT
		dpne 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	length : udint;
    pbin : ^void;
    tmp : array[0..300] of char;
  END_VAR

  retcode := false;
  pbin    := NIL;
  
  ComPort.SendBacklightOnOff(1); // turn on backlight
  
  
  StringLib.StrCpy(#tmp, 1, "FIRMWARE-UPDATE: Start...[", 1);
  StringLib.StrCat(#tmp, 1, dpne, 1);
  StringLib.StrCat(#tmp, 1, "]", 1);
  OutMessage(#tmp[0]);
  
  if(File.FOpen(dpne, 'r') = true) then
    length$dint := File.FLength();
    if(length$dint > 0) then
      if(File.FMemory(#pbin, length + 4) = true) then
        if(File.FRead(pbin+4, length) = true) then
          pbin$^udint^ := CRC32_Buffer(pbin+4, length);
          retcode := ComPort.SendNewFirmware(pbin, length+4);
          if(retcode = false) then
            StringLib.StrCpy(#tmp[0], sizeof(char), "ERROR: can't upload ", sizeof(char));
            StringLib.StrCat(#tmp[0], sizeof(char), dpne, sizeof(char));
            OutMessage(#tmp[0]);
          end_if;
        end_if;
        File.FMemory(#pbin, 0);
      end_if;
    end_if;
  else
    StringLib.StrCpy(#tmp[0], sizeof(char), "ERROR: can't open ", sizeof(char));
    StringLib.StrCat(#tmp[0], sizeof(char), dpne, sizeof(char));
    OutMessage(#tmp[0]);
  end_if;
  
  File.FClose();
  
  if(retcode = true) then
    OutMessage("FIRMWARE-UPDATE: ...Ready");
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL LseEasy::SendTrend
	VAR_INPUT
		id 	: UDINT;
		pdata 	: ^USINT;
		length 	: UDINT;
	END_VAR

  ComPort.SendTrendValue(id, pdata, length);

END_FUNCTION

FUNCTION GLOBAL LseEasy::SendPixMap
	VAR_INPUT
		pdata 	: ^void;
		width 	: USINT;
		height 	: USINT;
		padding 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	size : udint;
  END_VAR

  retcode := false;
  size    := ((width * height) + 7) / 8;
  size    += 5; // headerdaten
  
  // [] ..... command
  // [] ..... version = 1
  // [] ..... width
  // [] ..... height
  // [] ..... padding
  // [ ...... bitdata
  
  if(size <= sizeof(TmpData)) then
    TmpData[0] := ComCMD_UPDATEPIXMAP;
    TmpData[1] := 1;
    TmpData[2] := width;
    TmpData[3] := height;
    TmpData[4] := padding;
    MemCpy3(#TmpData[5], pdata, size-5);    
    retcode := ComPort.SendData(#TmpData[0], size);
  end_if;

END_FUNCTION

FUNCTION GLOBAL LseEasy::OutMessage
	VAR_INPUT
		txt 	: ^CHAR;
	END_VAR
  VAR
  	tmp : array[0..300] of char;
  END_VAR

  tmp[0] := '[';
  tmp[1] := 'N';
  tmp[2] := 'o';
  tmp[3] := 'd';
  tmp[4] := 'e';
  tmp[5] := ' ';
  StringLib.DintToStr(#tmp[6], to_int(ComPort.GetNode()), 16#0800, 1);
  StringLib.StrCat(#tmp[6], 1, "] ", 1);
  StringLib.StrCat(#tmp[6], 1, txt, 1);
  TRACE(#tmp[0]);

END_FUNCTION

FUNCTION LseEasy::OutMessageValue
	VAR_INPUT
		txt 	: ^CHAR;
    value : udint;
	END_VAR
  VAR
  	msg : array[0..128] of char;
  END_VAR
  
  StringLib.StrCpy(#msg[0], 1, txt, 1);
  StringLib.DintToStr(#msg[StringLib.StrLen(#msg[0], 1)], to_dint(value), 0x800, 1);
  OutMessage(#msg[0]);

END_FUNCTION

FUNCTION GLOBAL LseEasy::UpdateAll
	VAR_INPUT
		act_hmi_crc 	: UDINT;
	END_VAR

  Hmi35PrjCrc   := act_hmi_crc;
  NeedUpdateAll += 1;

END_FUNCTION

FUNCTION LseEasy::CheckCrc
VAR
	crc : udint;
END_VAR

  crc := ComPort.GetFileCrc(0);
  if(crc = 16#FFFFFFFF) then
    // there is no valid project in hmi
    StateSvr := TStart; // restart
  elsif(crc <> 0) then
    CantGetCrc := 0;
    if(crc = HmiPrjCrc) then
      // same project detected in hmi
      UpdateAll(crc); // force update of all data
      StateSvr := TRun;
    else
      // different project detected in hmi
      StateSvr := TStart; // restart
    end_if;
  else
  
    SleepNext(StateSvr, 100); // sleep 100ms
    
    CantGetCrc += 1;
    if(CantGetCrc > 100) then
      CantGetCrc := 0;
      ErrorStateSvr(true);
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL LseEasy::UpdateAliveSignal35

  AliveTix35     := ops.tAbsolute;
  HmiOnline      := 1;
  AliveTix35Cntr += 1;

END_FUNCTION

FUNCTION GLOBAL LseEasy::UpdateBacklight35
	VAR_INPUT
		state 	: DINT;
	END_VAR

//  if(state and 0x80) then
//    BacklightOnOff := 1;
//  else
//    BacklightOnOff := 0;
//  end_if;
  
  BacklightDim := state and 0x7F;

END_FUNCTION

FUNCTION LseEasy::CheckProjectCrc
	VAR_INPUT
		ptr 	: ^void;
		hmiver 	: UDINT;
		chkold 	: bool;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pprj : ^_BOX_PROJECTLIST; 
  	phlp : ^_BOX_PROJECTLIST_ENTRY; 
    no, index : udint;
		pbox	: ^_BIGBOX_HEADER;
    upload : bool;
    tcrc : udint;
  END_VAR

  retcode    := true;
  upload     := true;
  pbox$^void := ptr;
  tcrc       := ComPort.GetFileCrc(0);
  
  if(tcrc = pbox^.crc32) then

    upload := false;
    
    if((chkold = true) & (hmiver < 127)) then
      // einzelne crc's im hmi berprfen
      // erst ab hmi-version 1.27 werden die crc's mit GetFileCrc(0) direkt im hmi berprft
      pprj$^void := pbox;
      no         := pprj^.no;
      phlp       := #pprj^.data[0];
      index      := 0;
  
      while(no) do
        no    -= 1;
        pbox$^void := HmiProject35.GetBox(index);
          
        if(ComPort.GetFileCrc(phlp^.filename) <> pbox^.crc32) then
          upload := true;
          no     := 0;
        end_if;
        
        phlp  += sizeof(_BOX_PROJECTLIST_ENTRY);
        index += 1;
      end_while;
    end_if;
  end_if;

  if(IsProjectUpLoadNecessaryEx(upload, tcrc, pbox^.crc32) = true) then
    retcode := false; // upload
  end_if;

END_FUNCTION

FUNCTION LseEasy::SaveFile
  VAR_INPUT
    dp : ^char;
    fileid 	: UDINT;
    size 	: UDINT;
    ptr 	: ^void;
  END_VAR
  VAR_OUTPUT
    retcode 	: bool;
  END_VAR
  VAR
    dpne : array[0..64] of char;
    ne : array[0..16] of char;
  END_VAR

  StringLib.StrCpy(#dpne[0], 1, dp, 1);
  StringLib.DintToStr(#ne[0], to_dint(fileid), 16#0106, 1);
  StringLib.StrCat(#dpne[0], 1, #ne[0], 1);
  StringLib.StrCat(#dpne[0], 1, ".bin", 1);
  
  File.FOpen(#dpne[0], 'w');
  retcode := File.FWrite(ptr, size);
  File.FClose();

END_FUNCTION

FUNCTION LseEasy::SaveProject
  VAR_INPUT
    dp : ^char;
    prj : ^void;
  END_VAR
  VAR
  	pprj : ^_BOX_PROJECTLIST; 
    no, index : udint;
  	phlp : ^_BOX_PROJECTLIST_ENTRY; 
    pbox : ^_BIGBOX_HEADER;
  END_VAR

  pprj$^void := prj;
  no         := pprj^.no;
  phlp       := #pprj^.data[0];
  index      := 0;
  
  while(no) do
    no    -= 1;
    pbox$^void := HmiProject35.GetBox(index);
    SaveFile(dp, phlp^.filename, pbox^.size, pbox);
    phlp  += sizeof(_BOX_PROJECTLIST_ENTRY);
    index += 1;
  end_while;

  pbox$^void := prj;
  SaveFile(dp, 0, pbox^.size, pbox);

END_FUNCTION

FUNCTION LseEasy::SendProject
	VAR_INPUT
		ptr 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pprj : ^_BOX_PROJECTLIST; 
  	phlp : ^_BOX_PROJECTLIST_ENTRY; 
    no, index, tix, nox, sizeram, sizeflash : udint;
    pbox : ^_BIGBOX_HEADER;
    upload : bool;
  END_VAR
  
  retcode := false;
  upload  := false;
  tix     := ops.tAbsolute;
    
  if(ComPort.SendReset() = true) then

//    HmiSwVersion := ComPort.GetSwVersion();
//    HmiHwVersion := ComPort.GetHwVersion();
    
    GetBacklightDim();

    pbox$^void := ptr;
    retcode    := true;
  
    // nur wenn projektcrc unterschiedlich
    if(CheckProjectCrc(ptr, HmiSwVersion, false) = false) then
      
//      SaveProject("C:\bin\", ptr); // project als binary speichern
      
      retcode := false; // wunsch: svepau
      if(ComPort.GetHardwareData(nil, #sizeram, #sizeflash) = true) then
        sizeflash := sizeflash - (24 + 512*16); // flashheader + fatgrsse abziehen
        if((HmiProject35.TotalByteSize > sizeflash) | (HmiProject35.TotalFileNo > 256)) then
          OutMessage("ERROR: Size of LSE-Project is too big");
          OutMessageValue("...PrjSize[byte] = ", HmiProject35.TotalByteSize);
          OutMessageValue("...MaxSize[byte] = ", sizeflash);
          SetErrorSvr(ErrSizeLseProject);
        else  
          retcode := true;
        end_if;
      end_if;
      
      if(retcode = true) then
      
        // clear flash
        if(ComPort.SendFormatFlash() = true) then

          OutMessage("HMI-UPDATE: Start...");
  
          // send projectentries
          pprj$^void := ptr;
          no         := pprj^.no;
          phlp       := #pprj^.data[0];
          index      := 0;
//          totalsize  := 0;
  
          while(no) do
            ComPort.ShowProgressBar(to_usint((index * 100) / pprj^.no));
      
            no    -= 1;
            pbox$^void := HmiProject35.GetBox(index);
        
            if(ComPort.SendFile(phlp^.filename, pbox^.size, pbox) = false) then
              OutMessageValue("ERROR: Upload ProjectEntry of Bytesize = ", pbox^.size);
              retcode := false;
              no      := 0;
            end_if;
//            totalsize += HmiProject35.AlignU32(pbox^.size);
            phlp  += sizeof(_BOX_PROJECTLIST_ENTRY);
            index += 1;
          end_while;

          if(retcode = true) then
            // send projektlist
            ComPort.ShowProgressBar(100);
            pbox$^void := ptr;
            retcode    := ComPort.SendFile(0, pbox^.size, pbox);
//            totalsize  += HmiProject35.AlignU32(pbox^.size);
              
            if(retcode = true) then
              HmiMapFile.Create(GetPrjPath(), pbox^.crc32);
              OutMessageValue("HMI-UPDATE: ...Ready, TotalSize[byte] = ", HmiProject35.TotalByteSize); //totalsize);
              // vorsicht: projekt ist jetzt im hmi-ram, noch nicht auf flash
              retcode := ComPort.Ping(); // send ping to ensure alive-hmi and update alivetrigger
            end_if;
            upload := true;
          end_if;
            
        else
          retcode := false;
        end_if;
      end_if;
    end_if;

    if(retcode = true) then
      UpdateAll(HmiPrjCrc); // force updateall
      nox := ops.tAbsolute;
      repeat
        if(ComPort.SendRun() = true) then
          exit;
        end_if;
      until((ops.tAbsolute - nox) > 1000) end_repeat;


      if(upload = true) then
        // after performing projectupload, sleep a while to ensure flash of whole project-data in hmi
        nox := ops.tAbsolute;
        while((ops.tAbsolute - nox) < 1000) do
        end_while;
        ComPort.Ping(); // send ping to keep hmi happy
      end_if;
        
      OutMessageValue("HMI-RUN: UpdateTime[ms] = ", ops.tAbsolute - tix);
    else
      OutMessage("ERROR: Upload HMI-Project");
      SetErrorSvr(ErrUploadHmiProject);
      ComPort.SendChkTraceView(); // display message on hmi
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION LseEasy::Run

  // alivesignal
  if((ops.tabsolute - AliveTix) > 1003) then
    AliveTix := ops.tabsolute;
    ComPort.SendAliveTrigger(); // send alive trigger to hmi
  end_if;
  
  // onlinewatchdog
  if((ops.tabsolute - AliveTix35) > 4000) then
    HmiOnline := 0; // offline
    if(TempInterval <> 0) then
      if(ActTemperature <> DEFAULT_VALUE_TEMPERATURE) then
        ActTemperature$UDINT := FUEHLERBRUCH; // fhlerbruch
      end_if;
      if(ActHumidity <> DEFAULT_VALUE_HUMIDITY) then
        ActHumidity$UDINT := FUEHLERBRUCH; // fhlerbruch
      end_if;  
    end_if;    
  end_if;

  if(HmiOnline) then
  
    if(HmiPrjCrc = Hmi35PrjCrc) then // check crc of project with crc of hmi
  
      if(NeedUpdateAll) then
        NeedUpdateAll := 0;
        GetBacklightDim();
        HmiVarList.RefreshAll();
        HmiStateBit35.RefreshAll();
        HmiReady();
      end_if;

      HmiRun();

      if((ops.tabsolute - RefreshTix) > 6) then
        RefreshTix := ops.tAbsolute;
        HmiVarList.RefreshRun();
        HmiStateBit35.RefreshRun();
      end_if;
      
      if(TrendVal0 <> -1) then
        TrendVal0 := UpdateTrendVal(0, TrendVal0);
      end_if;
  
      if(TrendVal1 <> -1) then
        TrendVal1 := UpdateTrendVal(1, TrendVal1);
      end_if;
      
      if(PixMap <> -1) then
        PixMap := UpdatePixMap(PixMap);
      end_if;
      
    else
      // just in this moment we're back online with hmi
      SleepNext(TChkCrc, 1000); // wait a while and afterwards check project
    end_if;
  else
    Hmi35PrjCrc := 0; // destroy hmicrc
    CantGetCrc  := 0;
  end_if;

  if(CallScreen <> -1) then
    if(CallScreen = -2) then
      OutMessage("SCREENSHOT: Start...");
      if(ComPort.GetScreenShot() = false) then
        OutMessage("ERROR: Screenshot not done");
      else
        StateSvr := TGetScreenShot;
      end_if;
    else
      ComPort.SendGotoScreen(CallScreen);
    end_if;
    CallScreen := -1;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

	state := READY;
  
  case StateSvr of
    TStart :
      AutoFirmwareUpdate := AutoFirmwareUpdate.Read();
      if(ComPort.Ping() = true) then // ask for hmi
        if(LoadFile() = true) then // load lse-project
        
          HmiSwVersion := ComPort.GetSwVersion(); // ask for sw-version
          HmiHwVersion := ComPort.GetHwVersion(); // ask for hw-version

          if(Create() = true) then // create hmi-projectdata
            StateSvr := TUpload;
          end_if;
        end_if;
  
        if(StateSvr <> TUpload) then
          ErrorStateSvr(false);
        else 
          if(AutoFirmwareUpdate <> 0) then
            if(AutoFwUpdateDisabled = false) then
              AutoFwUpdateDisabled := true; // no further auto-update of firmware possible
              StateSvr := TCheckUpdateBootloader;
            end_if;
          end_if;
        end_if;
      else
        OutMessage("ERROR: Can't communicate with HMI");
        SetErrorSvr(ErrHmiCommunication);
        ErrorStateSvr(true);
      end_if;

    TCheckUpdateBootLoader :
      StateSvr := CheckUpdate(GetBootloaderUpdate(), TCheckUpdateFirmware, TCheckUpdateFirmware, 15000);

    TCheckUpdateFirmware :
      StateSvr := CheckUpdate(GetFirmwareUpdate(), TStart, TUpLoad, 17000);

    TUpLoad : 
      if(UpLoadProject() = true) then
        HmiProject35.Free();
        ProjectBox := NIL;
        StateSvr := TRun;
      end_if;
      
    TGetScreenShot :
      Run();
      
    TRun :
      Run();
   
    TFirmwareUpdate :
      if(SendNewFirmware() = true) then
        SleepNext(TRun, 10000);
      else
        ErrorStateSvr(false);
      end_if;

    TBootLoaderUpdate :  
      if(SendNewBootLoader() = true) then
        SleepNext(TRun, 10000);
      else
        ErrorStateSvr(false);
      end_if;
      
    TChkCrc :
      CheckCrc();
      
    TSleep : 
      if((ops.tAbsolute - SleepStart) >= SleepDuration) then
        StateSvr := StateNext;
      end_if;

    TReboot :
      ComPort.SendReboot();
      SleepNext(TStart, 3000);

    TError :
      if(TryToRestart = true) then
        if(AliveTix35Cntr <> AliveTix35CntrOld) then
          // try to restart after hmi sent alivesignal
          StateSvr     := TStart;
          TryToRestart := false;
        end_if;
      end_if;
      
  end_case;

  ComPort.Run();  

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::StateSvr::Write
	VAR_INPUT
		input (EAX) 	: LseEasy::TStateSvr;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: LseEasy::TStateSvr;
	END_VAR

  if(input = TGetScreenShot) then
    result$udint := ACCESS_DENIED;
    if(StateSvr = TRun) then
      CallScreen := -2;
	    result     := StateSvr;
    end_if;
  else
	  StateSvr := input;
	  result := StateSvr;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::HmiAccess
	VAR_INPUT
		level 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := true;
  if(level > AccessLevel) then
    retcode := false;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL LseEasy::SoftReset

  StateSvr := TStart;

END_FUNCTION

FUNCTION GLOBAL LseEasy::SoftResetAll
  VAR
  	nox : udint;
    pth : ^LseEasy;
  END_VAR

  pth := InstancePtr[0];
  nox := InstanceCnt;
  while(nox) do
    pth^.SoftReset();
    nox -= 1;
    pth += sizeof(InstancePtr[0]);
  end_while;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::ClassSvr::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR

	ret_code := READY;

	case pPara^.uiCmd of

		0 : // start download on the fly
        pResult^.aData[0]$UDINT := 16#46544F44; // DOTF-id
        pResult^.uiLng          := 6; // success
        
		1 : // end download on the fly
        pResult^.aData[0]$UDINT := 16#46544F44; // DOTF-id
        pResult^.uiLng          := 6; // success
        SoftResetAll();
  end_case;
  
END_FUNCTION

#pragma warning (disable : 73)
FUNCTION VIRTUAL GLOBAL LseEasy::UserCall
	VAR_INPUT
		fktno 	: UDINT;
		para 	: DINT;
	END_VAR

END_FUNCTION
#pragma warning (default : 73)

#pragma warning (disable : 73)
FUNCTION VIRTUAL GLOBAL LseEasy::HmiVariableExtention
	VAR_INPUT
		varname 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := 16#FFFFFFFF;
  
//  if(StringLib.StrCmp(varname, sizeof(char), "Dummy.Server7", sizeof(char)) = 0) then
//    retcode := VARNO_TEST_NUM1;
//  end_if;

END_FUNCTION
#pragma warning (default : 73)

FUNCTION LseEasy::GetMapCrc
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := HmiVarList.GetMapCrc();
  retcode := (retcode rol 1) xor HmiStateBit35.GetMapCrc();
  
END_FUNCTION

FUNCTION VIRTUAL LseEasy::IsProjectUpLoadNecessary
	VAR_INPUT
		preselect 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

//  if(GetMapCrc() <> oldmapcrc) then
    // unconditional upload necessary, otherwise weak functionality of hmi
//  end_if;

  retcode := preselect;

END_FUNCTION

#pragma warning (disable : 73)
FUNCTION VIRTUAL LseEasy::IsProjectUpLoadNecessaryEx
	VAR_INPUT
		preselect 	: BOOL;
    crc_hmi : UDINT;
    crc_prj : UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := IsProjectUpLoadNecessary(preselect);

END_FUNCTION
#pragma warning (default : 73)

FUNCTION VIRTUAL GLOBAL LseEasy::UpdatePixMap
	VAR_INPUT
		value 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := value;
  if(SendPixMap(#value, 32, 1, 0) = true) then
    retcode := -1;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::UpdateTrendVal
	VAR_INPUT
    id : UDINT;
		value 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := value;
  if(ComPort.SendTrendValue(id, #(value$usint), 1) = true) then
    retcode := -1;
  end_if;

END_FUNCTION

FUNCTION LseEasy::Recalculate_MulDiv
	VAR_INPUT
		einheit 	: UDINT;
		posdezpt 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  var
    dekade : dint;
  end_var

  retcode := 1; 
  dekade  := 0;
  
  case(einheit) of
    1000000000 : dekade := 9;
    100000000  : dekade := 8;
    10000000   : dekade := 7;
    1000000    : dekade := 6;
    100000     : dekade := 5;
    10000      : dekade := 4;
    1000       : dekade := 3;
    100        : dekade := 2;
    10         : dekade := 1;
  end_case;

  case(dekade - posdezpt) of 
    9 : retcode := 1000000000;  
    8 : retcode :=  100000000;  
    7 : retcode :=   10000000;  
    6 : retcode :=    1000000;  
    5 : retcode :=     100000;  
    4 : retcode :=      10000;  
    3 : retcode :=       1000; 
    2 : retcode :=        100;  
    1 : retcode :=         10;  
  end_case;   

END_FUNCTION

FUNCTION LseEasy::Recalculate_Calc
	VAR_INPUT
		rval 	: real;
    rmul  : real;
		rdiv 	: real;
		direction 	: bool;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  if(direction = true) then
    rval := (rval * rmul) / rdiv;
  else
    rval := (rval * rdiv) / rmul;
  end_if;

  retcode := to_dint(rval);

//  if(rval < 0) then
//    retcode := to_dint(rval - 0.5);
//  else
//    retcode := to_dint(rval + 0.5);
//  end_if;

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Stroke2mm 
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR
  VAR
  	rdiv : real;
  END_VAR

  rdiv    := Recalculate_MulDiv(1mm, dezpoint);
  retcode := Recalculate_Calc(value, 1.0, rdiv, direction);

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Stroke2inch 
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR
  VAR
  	rdiv : real;
  END_VAR

  rdiv    := Recalculate_MulDiv(1mm, dezpoint); 
  retcode := Recalculate_Calc(value, 1.0, rdiv * 25.4, direction);

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Temp2Celsius
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR
  VAR
  	rdiv : real;
  END_VAR
  
  rdiv    := Recalculate_MulDiv(10, dezpoint);
  retcode := Recalculate_Calc(value, 1.0, rdiv, direction);

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Temp2Fahrenheit
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR

  if(direction = true) then
    if(value < 0) then
      retcode := ((value * 18 - 5) / 10) + 320;
    else
      retcode := ((value * 18 + 5) / 10) + 320;
    end_if;
    
    if(dezpoint = 0) then
      if(value < 0) then
        retcode := (retcode - 5) / 10;
      else
        retcode := (retcode + 5) / 10;
      end_if;
    elsif(dezpoint = 2) then
      retcode := retcode * 10;
    end_if;
  else
    if(dezpoint = 0) then
      value := value * 10;
    elsif(dezpoint = 2) then
      if(value < 0) then
        value := (value - 5) / 10;
      else
        value := (value + 5) / 10;
      end_if;
    end_if;
  
    if(value < 0) then
      retcode := (((value - 320) * 10) - 9) / 18;
    else
      retcode := (((value - 320) * 10) + 9) / 18;
    end_if;
    
  end_if;

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Weight2Kilogram
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR
  VAR
  	rdiv : real;
  END_VAR

  rdiv    := Recalculate_MulDiv(10000, dezpoint);
  retcode := Recalculate_Calc(value, 1.0, rdiv, direction);

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Weight2Pound
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR
  VAR
  	rdiv : real;
  END_VAR

  rdiv    := Recalculate_MulDiv(10000, dezpoint);
  retcode := Recalculate_Calc(value, 2.204622, rdiv, direction);
  
END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Pressure2Bar
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR
  VAR
  	rdiv : real;
  END_VAR

  rdiv    := Recalculate_MulDiv(1bar, dezpoint); 
  retcode := Recalculate_Calc(value, 1.0, rdiv, direction);

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Pressure2Psi
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR
  VAR
  	rdiv : real;
  END_VAR

  rdiv    := Recalculate_MulDiv(1bar, dezpoint); 
  retcode := Recalculate_Calc(value, 14.50376808, rdiv, direction);

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Time2Second
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR

  retcode := Recalculate_MulDiv(1sec, dezpoint);

  if(direction = true) then
    if(value < 0) then
      retcode := (value - (retcode / 2)) / retcode; 
    else
      retcode := (value + (retcode / 2)) / retcode; 
    end_if;
  else
    retcode := value * retcode; 
  end_if; 

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Time2Minute
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR

  if(direction = true) then
    if(value < 0) then
      retcode := Recalculate_Time2Second((value - 30) / 60, dezpoint, true);
    else
      retcode := Recalculate_Time2Second((value + 30) / 60, dezpoint, true);
    end_if;
  else
    retcode := Recalculate_Time2Second(value * 60, dezpoint, false);
  end_if;

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Time2Hour
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR

  if(direction = true) then
    if(value < 0) then
      retcode := Recalculate_Time2Minute((value - 30) / 60, dezpoint, true); 
    else
      retcode := Recalculate_Time2Minute((value + 30) / 60, dezpoint, true); 
    end_if;
  else
    retcode := Recalculate_Time2Minute(value * 60, dezpoint, false); 
  end_if;

END_FUNCTION

FUNCTION VIRTUAL LseEasy::Recalculate_Force2KN
  VAR_INPUT 
    value : DINT;
    dezpoint : DINT;
    direction : BOOL;
  END_VAR 
  VAR_OUTPUT 
    retcode : DINT; 
  END_VAR
  VAR
  	rdiv : real;
  END_VAR

  rdiv    := Recalculate_MulDiv(1kn, dezpoint);
  retcode := Recalculate_Calc(value, 1.0, rdiv, direction);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::Recalculate
	VAR_INPUT
		value 	: DINT;
		formula 	: UDINT;
		dezpoint 	: DINT;
		direction 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  retcode := value;
  
  case formula of
    3  : retcode := Recalculate_Stroke2mm(value, dezpoint, direction);
    4  : retcode := Recalculate_Stroke2inch(value, dezpoint, direction);
    5  : retcode := Recalculate_Temp2Celsius(value, dezpoint, direction);
    6  : retcode := Recalculate_Temp2Fahrenheit(value, dezpoint, direction);
    7  : retcode := Recalculate_Weight2Kilogram(value, dezpoint, direction);
    8  : retcode := Recalculate_Weight2Pound(value, dezpoint, direction);
    9  : retcode := Recalculate_Pressure2Bar(value, dezpoint, direction);
    10 : retcode := Recalculate_Pressure2Psi(value, dezpoint, direction);
    11 : retcode := Recalculate_Time2Second(value, dezpoint, direction);
    12 : retcode := Recalculate_Time2Minute(value, dezpoint, direction);
    13 : retcode := Recalculate_Time2Hour(value, dezpoint, direction);
    14 : retcode := Recalculate_Force2KN(value, dezpoint, direction);
  end_case;

END_FUNCTION

FUNCTION GLOBAL LseEasy::SoftResetIn
	VAR_INPUT
		milliseconds 	: UDINT;
	END_VAR

  SleepNext(TStart, milliseconds);

END_FUNCTION

#pragma warning (disable : 73)
FUNCTION VIRTUAL LseEasy::UpdateIrCode
	VAR_INPUT
		code 	: UDINT;
	END_VAR

END_FUNCTION
#pragma warning (default : 73)


FUNCTION VIRTUAL GLOBAL LseEasy::CheckUpdate
	VAR_INPUT
		dpne 	: ^CHAR;
		nextstep 	: TStateSvr;
		defaultstep 	: TStateSvr;
		sleep 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: TStateSvr;
	END_VAR

  retcode := defaultstep;
  
  if(File.FOpen(dpne, 'r') = true) then // is updatefile present
    File.FClose();
    if(SendUpdateToHmi(dpne) = true) then
      if(AutoFirmwareUpdate = 1) then
        File.FDelete(dpne); // delete file
      end_if;
      retcode := SleepNext(nextstep, sleep);
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL LseEasy::GetLseProjectNotice
	VAR_OUTPUT
		retcode 	: ^char;
	END_VAR
  
  retcode := HmiSetUpList.GetLseProjectNotice();

END_FUNCTION


FUNCTION GLOBAL LseEasy::GetLseProjectName
	VAR_INPUT
		pdst 	: ^void;
		dchrsize 	: UDINT;
		bytesize_dst 	: UDINT;
	END_VAR
  VAR
  	tmp : array[0..64] of uint;
  END_VAR
  
  if(dchrsize = 1) then
    HmiProjectList.GetLseProjectName(#tmp[0], sizeof(tmp));
    StringLib.StrCpy(pdst, 1, #tmp[0], 2);
  else
    HmiProjectList.GetLseProjectName(pdst$^uint, bytesize_dst);
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL LseEasy::T9KeyboardConfig

// NOTE: Firmware 1.46 or greater is needed at HMI to ensure functionality, otherwise configuration will be ignored.

// actual mask                  idx
// +--------+--------+--------+
// |  *!?1  |  abc2  |  def3  | 0  1  2
// +--------+--------+--------+ 
// |  ghi4  |  jkl5  |  mno6  | 3  4  5 
// +--------+--------+--------+
// |  pqrs7 |  tuv8  |  wxyz9 | 6  7  8 
// +--------+--------+--------+
// |  .,:;# |  __-0  |  [BIG] | 9 10 11
// +--------+--------+--------+

//  HmiT9Config.SetKey(0, "*!?1");
//  HmiT9Config.SetKey(1, "abc2");
//  HmiT9Config.SetKey(2, "def3");
//  HmiT9Config.SetKey(3, "ghi4");
//  HmiT9Config.SetKey(4, "jkl5");
//  HmiT9Config.SetKey(5, "mno6");
//  HmiT9Config.SetKey(6, "pqrs7");
//  HmiT9Config.SetKey(7, "tuv8");
//  HmiT9Config.SetKey(8, "wxyz9");
//  HmiT9Config.SetKey(9, ".,:;#");
//  HmiT9Config.SetKey(10," _-0");
//  HmiT9Config.SetKeyBig(11);

END_FUNCTION
