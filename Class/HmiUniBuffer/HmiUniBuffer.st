//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "HmiUniBuffer"
	Revision           = "0.0"
	GUID               = "{2DAED158-1506-46CE-8DFB-5491C3D0CFF1}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{18AF3866-FEEB-4D01-A02A-95850A618085}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="File" Required="true" Internal="false"/>
		<Client Name="StringLib" Required="true" Internal="false"/>
	</Channels>
</Class>
*)
HmiUniBuffer : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	File 	: CltChCmd_HmiFile;
	StringLib 	: CltChCmd_HmiStrLib;
  //Variables:
		Default 	: UINT;
		No 	: UDINT;
		Ptr 	: ^UINT;
		Size 	: UDINT;
		GuidePost 	: ^UDINT;
  //Functions:
	
	FUNCTION HmiUniBuffer
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL GetText
		VAR_INPUT
			txtno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^LCHAR;
		END_VAR;
	
	FUNCTION GLOBAL Free;
	
	FUNCTION GLOBAL Load
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL AddText
		VAR_INPUT
			src 	: ^LCHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION KillGuidePost;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd HmiFile
#pragma usingLtd HmiStrLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiUniBuffer::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMIUNIBUFFER
0$UINT, 0$UINT, (SIZEOF(::HmiUniBuffer))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2548567416), "HmiUniBuffer", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiUniBuffer.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::HmiUniBuffer.File.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3121273764), "File", TO_UDINT(2548286290), "HmiFile", 0$UINT, 4$UINT, 
(::HmiUniBuffer.StringLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3243119075), "StringLib", TO_UDINT(103556616), "HmiStrLib", 0$UINT, 2$UINT, 
END_FUNCTION


#define USER_CNT_HmiUniBuffer 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiUniBuffer] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiUniBuffer::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_HmiUniBuffer, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HmiUniBuffer();

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION HmiUniBuffer::HmiUniBuffer
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code:= C_OK;
  Default := 0;
  No := 0;
  Ptr := NIL;
  Size := 0;
  GuidePost := NIL;

END_FUNCTION

FUNCTION GLOBAL HmiUniBuffer::GetText
	VAR_INPUT
		txtno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^LCHAR;
	END_VAR
  var
    ph : ^udint;
  end_var

  retcode := #Default$LCHAR;

  if(Ptr <> NIL) then
    if(txtno < No) then
      retcode := Ptr;
      if(GuidePost <> NIL) then
        ph      := GuidePost + txtno * 4;
        retcode += (ph^);
      else
        while(txtno) do
          txtno   -= 1;
          retcode += ((StringLib.StrLen(retcode, sizeof(LCHAR)) + 1) * sizeof(LCHAR));
        end_while;
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiUniBuffer::Free

  StringLib.XMemory(#GuidePost, 0);
  StringLib.XMemory(#Ptr, 0);
  Ptr := NIL;
  No := 0;
  Default := 0;
  Size := 0;
  ClassSvr := 0;

END_FUNCTION

FUNCTION GLOBAL HmiUniBuffer::Load
	VAR_OUTPUT
		retcode 	: bool;
	END_VAR
  var
    chrsize : usint; 
    txtno : udint; 
    chrno : udint; 
    txtsize : udint; 
    ptmp : ^uint; 
    chis : int; 
  end_var

	// [] .......... sizeof character
	// [][][][] .... no of text (ab compiler version 32 4byte, vorher 2byte)
	// [][][][] .... no of characters
	// [ ........... text

  retcode := false; 
  Free(); 

  File.FRead(#chrsize$void, 1);
  File.FRead(#txtno$void, 4);
  File.FRead(#chrno$void, 4);

  if(File.FChkFile() = true) then
    txtsize := chrno * chrsize;
    File.FMemory(#Ptr, txtsize);
    File.FRead(Ptr, txtsize);
    chis := sizeof(uint);
    
    if((chrsize = 1) & (chis = 2)) then
      // aus ASCII muss UNI gemacht werden
      ptmp := NIL;
      txtsize := chrno * sizeof(uint);
      if(File.FMemory(#ptmp, txtsize) = true) then
        StringLib.AsciiToUni(ptmp$^uint, Ptr$^char, chrno);
        StringLib.XMemory(#Ptr, 0);
        Ptr := ptmp;
        retcode := true;
      end_if;
    elsif((chrsize = 2) & (chis = 1)) then
      // aus UNI muss ASCII gemacht werden
      ptmp := NIL;
      txtsize := chrno;
      if(File.FMemory(#ptmp, txtsize) = true) then
        StringLib.UniToAscii(ptmp$^char, Ptr$^uint, chrno);
        StringLib.XMemory(#Ptr, 0);
        Ptr := ptmp;
        retcode := true;
      end_if;
    else
      // text bleibt wie er ist
      retcode := true;
    end_if;
    
    if(File.FChkFile() = true) then
      Size := txtsize;
      No   := txtno;
    else
      Free();
    end_if;
  end_if;
  
  ClassSvr := to_dint(No);

  StringLib.MakeGuidePost(#GuidePost, Ptr, No, sizeof(uint));

END_FUNCTION

FUNCTION GLOBAL HmiUniBuffer::AddText
	VAR_INPUT
		src 	: ^LCHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    len : udint;
    tmp : udint; 
  end_var;   

  retcode := false; 
  len     := (StringLib.StrLen(src, sizeof(uint)) + 1) * sizeof(uint);
  tmp     := Size + len;

  if(StringLib.XMemory(#Ptr, tmp) = true) then
 	  StringLib.StrCpy(Ptr + Size, sizeof(uint), src, sizeof(char));
	  No      += 1;
	  Size    := tmp;
    retcode := true;
    KillGuidePost();
  end_if; 

END_FUNCTION

FUNCTION HmiUniBuffer::KillGuidePost

  StringLib.XMemory(#GuidePost, 0);

END_FUNCTION
