//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_AI040                 1048

#define AI040_SDO_RESPONSE_TIMEOUT      SDIAS_SDO_TIMEOUT * 2

#define AI040_ADDR_ADCCONTROL_REGISTER  16#204
#define AI040_ADDR_HWCONTROL_REGISTER   16#206
#define AI040_ADDR_CALIB_REGISTER       16#240

#define AI040_ADC_MIN_CONVERSION_TIME   5    //time of adc to convert one channel as 탎
#define AI040_ADC_MAX_CONVERSION_TIME   250  //max time of adc to convert one channel as 탎

#define AI040_ERROR_DELAYTIME           1000 //1 second delaytime for cablebreak and shortcircuit

#define AI040_1S_TO_MICROSECOND         (1000*1000) //1 second as microsecond
#define AI040_INPUT_RAW_VALUE_PLACE     (0*sizeof(uint))  //select array entry of fifo buffer to display on AIx server

#define AI040_NR_GAIN_CALIB_SETTINGS    6  //amount of calib data for each channel
#define AI040_NUMBER_OF_ANALOG_IN       4
#define AI040_INVALID_VALUE             16#80000010$DINT

#define AI040_SIZE_ONE_VALUE            sizeof(INT)
#define AI040_MAX_LENGTH_ONE_READ       16#80    //max length for one pdo read object  = 128byte
#define AI040_FULL_FIFO_BUFFERSIZE      16#400   //max buffersize fifo
#define AI040_CALIB_PMB_DATA            16       //size of raw data from the calibration component

#define AI040_MAX_VALUES_PER_CYCLE      (AI040_FULL_FIFO_BUFFERSIZE/AI040_SIZE_ONE_VALUE) //max possible values per cycle for one channel
#define AI040_MAX_BUFFER_ACCESSES       (AI040_FULL_FIFO_BUFFERSIZE/AI040_MAX_LENGTH_ONE_READ)  //max pdo accesses for one channel
#define AI040_MAX_ARRAY_ENTRYS          (AI040_MAX_BUFFER_ACCESSES * AI040_NUMBER_OF_ANALOG_IN) //max possible pdo accesse if every channel is activated

//pll settings
#define AI040_SYNC_OUT_ID               16#03
#define AI040_PLL_OFFSET                16#140
#define AI040_PLL_CONTROL               (AI040_PLL_OFFSET+8)
//
#define AI040_RAW_VALUE_MAXIMUM         16#FFFF // +/-30000 are equal to +/- 5,5V
#define AI040_FIRMWARE_MAX              (AI040_RAW_VALUE_MAXIMUM/2)  //  32767
#define AI040_FIRMWARE_MIN              (-AI040_RAW_VALUE_MAXIMUM/2) // -32767
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Source\BusInterface.h"

(*!
<Class
	Name               = "AI040"
	Revision           = "1.16"
	GUID               = "{61AA7289-2B26-4F5C-8022-583BF9B4AB27}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(626,120)"
	Comment            = "Class for AI040 hardware module (4x analog inputs, 4x fifo buffer)&#13;&#10;to analyse values from fifo buffer the AI040Bandpassfilter class&#13;&#10;can be used.">
	<Channels>
		<Server Name="AI1" GUID="{874924FD-DD33-4193-8EEE-C70ED7F7C139}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input, shows the first value from buffer.&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010.&#13;&#10;Value is shown according to property settings of &#13;&#10;AIxMaxValue, AIxMinValue and state AIxGain.&#13;&#10;&#13;&#10;"/>
		<Server Name="AI1CableBreak" GUID="{F008C851-E812-422B-90CC-B4876144F2B5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show a cable break of analog input&#13;&#10;0..ok, 1..cable break&#13;&#10;"/>
		<Server Name="AI1ConfigValid" GUID="{29A5E6C2-972A-4805-8F87-A913CD0E3CEF}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server shows the config valid state of analog input&#13;&#10; 1..configuration of the ADCs is valid&#13;&#10; 0..configuration of the ADCs is not valid&#13;&#10;-1..failed to send configuration to ADC"/>
		<Server Name="AI1CurrentSource" GUID="{E165E77E-3470-4417-B1B5-E87710563F48}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="The channel current source can be set with this client.&#13;&#10; 0 = 0mA &#13;&#10; 1 = 4mA (Default)&#13;&#10; 2 = 8mA&#13;&#10; 3 = 12mA&#13;&#10;&#13;&#10;&#13;&#10;"/>
		<Server Name="AI1Gain" GUID="{E642FFE0-73D0-491C-8D6A-735D3B8DA74B}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="The channel gain can be set with this client.&#13;&#10;this setting multiplies the analog input value with gain factor&#13;&#10; 0 = Gain of +1 (Default)&#13;&#10; 1 = Gain of +2&#13;&#10; 2 = Gain of +4&#13;&#10; 4 = Gain of +8&#13;&#10; 6 = Gain of +16&#13;&#10; 7 = Gain of +32"/>
		<Server Name="AI1ShortCircuit" GUID="{420A3B41-0E69-4D1A-AE22-04BF2110CDBC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show a short circuit of analog input&#13;&#10;0..ok, 1..short circuit"/>
		<Server Name="AI2" GUID="{FE734F54-2DBC-4A0F-B14A-2A3FC40DFCB4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input, shows the first value from buffer.&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010.&#13;&#10;Value is shown according to property settings of &#13;&#10;AIxMaxValue, AIxMinValue and state AIxGain.&#13;&#10;&#13;&#10;"/>
		<Server Name="AI2CableBreak" GUID="{2EFC820F-0CC2-4CC2-A890-2E9765D123BE}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show a cable break of analog input&#13;&#10;0..ok, 1..cable break&#13;&#10;"/>
		<Server Name="AI2ConfigValid" GUID="{A656232A-220C-4499-8740-306AD28984DB}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server shows the config valid state of analog input&#13;&#10; 1..configuration of the ADCs is valid&#13;&#10; 0..configuration of the ADCs is not valid&#13;&#10;-1..failed to send configuration to ADC"/>
		<Server Name="AI2CurrentSource" GUID="{EEE47653-BF59-4E89-BF6F-9F100944CCFD}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="The channel current source can be set with this client.&#13;&#10; 0 = 0mA &#13;&#10; 1 = 4mA (Default)&#13;&#10; 2 = 8mA&#13;&#10; 3 = 12mA&#13;&#10;&#13;&#10;&#13;&#10;"/>
		<Server Name="AI2Gain" GUID="{A79011BA-164A-4DDA-8EE4-11D6CC1F4C03}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="The channel gain can be set with this client.&#13;&#10;this setting multiplies the analog input value with gain factor&#13;&#10; 0 = Gain of +1 (Default)&#13;&#10; 1 = Gain of +2&#13;&#10; 2 = Gain of +4&#13;&#10; 4 = Gain of +8&#13;&#10; 6 = Gain of +16&#13;&#10; 7 = Gain of +32"/>
		<Server Name="AI2ShortCircuit" GUID="{BF651C1F-C327-42F3-8C9A-18DC20172686}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show a short circuit of analog input&#13;&#10;0..ok, 1..short circuit"/>
		<Server Name="AI3" GUID="{05022067-5153-4075-87C8-C2C7438460C7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input, shows the first value from buffer.&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010.&#13;&#10;Value is shown according to property settings of &#13;&#10;AIxMaxValue, AIxMinValue and state AIxGain.&#13;&#10;&#13;&#10;"/>
		<Server Name="AI3CableBreak" GUID="{EFD413A8-C698-4018-BD1D-5D85CACDF05F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show a cable break of analog input&#13;&#10;0..ok, 1..cable break&#13;&#10;"/>
		<Server Name="AI3ConfigValid" GUID="{9CD32DB5-1AD9-48DD-A497-BF2467C7AE65}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server shows the config valid state of analog input&#13;&#10; 1..configuration of the ADCs is valid&#13;&#10; 0..configuration of the ADCs is not valid&#13;&#10;-1..failed to send configuration to ADC"/>
		<Server Name="AI3CurrentSource" GUID="{9BDDB84E-B721-4469-9EB6-25A1F5B31A3E}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="The channel current source can be set with this client.&#13;&#10; 0 = 0mA &#13;&#10; 1 = 4mA (Default)&#13;&#10; 2 = 8mA&#13;&#10; 3 = 12mA&#13;&#10;&#13;&#10;&#13;&#10;"/>
		<Server Name="AI3Gain" GUID="{4718982B-B4AE-4164-981B-1F04AB1A531B}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="The channel gain can be set with this client.&#13;&#10;this setting multiplies the analog input value with gain factor&#13;&#10; 0 = Gain of +1 (Default)&#13;&#10; 1 = Gain of +2&#13;&#10; 2 = Gain of +4&#13;&#10; 4 = Gain of +8&#13;&#10; 6 = Gain of +16&#13;&#10; 7 = Gain of +32"/>
		<Server Name="AI3ShortCircuit" GUID="{311A2B4F-BA1B-4CAE-AEAB-1AFB7969B7D7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show a short circuit of analog input&#13;&#10;0..ok, 1..short circuit"/>
		<Server Name="AI4" GUID="{A5E331A9-063F-44A6-BE9A-FA66BD352C37}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input, shows the first value from buffer.&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010.&#13;&#10;Value is shown according to property settings of &#13;&#10;AIxMaxValue, AIxMinValue and state AIxGain.&#13;&#10;&#13;&#10;"/>
		<Server Name="AI4CableBreak" GUID="{80AC4FB7-8DC4-4312-B907-1617A54F8B64}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show a cable break of analog input&#13;&#10;0..ok, 1..cable break&#13;&#10;"/>
		<Server Name="AI4ConfigValid" GUID="{4D5BB1DA-B792-42E2-B486-F27913FB142D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server shows the config valid state of analog input&#13;&#10; 1..configuration of the ADCs is valid&#13;&#10; 0..configuration of the ADCs is not valid&#13;&#10;-1..failed to send configuration to ADC"/>
		<Server Name="AI4CurrentSource" GUID="{1FE36E8B-1FDB-4B04-A88E-8ED57E4FA6B7}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="The channel current source can be set with this client.&#13;&#10; 0 = 0mA &#13;&#10; 1 = 4mA (Default)&#13;&#10; 2 = 8mA&#13;&#10; 3 = 12mA&#13;&#10;&#13;&#10;&#13;&#10;"/>
		<Server Name="AI4Gain" GUID="{A61FA95E-972D-4AB5-A0F6-3E4378A58B83}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="The channel gain can be set with this client.&#13;&#10;this setting multiplies the analog input value with gain factor&#13;&#10; 0 = Gain of +1 (Default)&#13;&#10; 1 = Gain of +2&#13;&#10; 2 = Gain of +4&#13;&#10; 4 = Gain of +8&#13;&#10; 6 = Gain of +16&#13;&#10; 7 = Gain of +32"/>
		<Server Name="AI4ShortCircuit" GUID="{00614831-D693-4963-AA10-D370FDC144E3}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show a short circuit of analog input&#13;&#10;0..ok, 1..short circuit"/>
		<Server Name="ClassState">
		</Server>
		<Server Name="Voltage24V" GUID="{0C93A368-8E52-4786-989A-B8D926698D1D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show state of Voltage supply.&#13;&#10;0..Voltage not ok&#13;&#10;1..Voltage ok"/>
		<Server Name="Voltage5V" GUID="{5FAE9156-E6C2-4451-B0F1-2A84E25BCB28}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show state of Voltage supply.&#13;&#10;0..Voltage not ok&#13;&#10;1..Voltage ok"/>
		<Client Name="AI1Active" Required="false" Internal="false" DefValue="1" Comment="The channel can be activated/ deactived with this client as init value.&#13;&#10;&#13;&#10;0 = Channel is deactivated. &#13;&#10;1 = Channel is activated. "/>
		<Client Name="AI1MaxValue" Required="true" Internal="false" DefValue="32767" Comment="The channel scale of AIx can be set with this property as init value.&#13;&#10;The value must be in the range of -327675000 to +327675000."/>
		<Client Name="AI1MinValue" Required="true" Internal="false" DefValue="-32767" Comment="The channel scale of AIx can be set with this property as init value.&#13;&#10;The value must be in the range of -327675000 to +327675000."/>
		<Client Name="AI2Active" Required="false" Internal="false" DefValue="1" Comment="The channel can be activated/ deactived with this client as init value.&#13;&#10;&#13;&#10;0 = Channel is deactivated. &#13;&#10;1 = Channel is activated. "/>
		<Client Name="AI2MaxValue" Required="true" Internal="false" DefValue="32767" Comment="The channel scale of AIx can be set with this property as init value.&#13;&#10;The value must be in the range of -327675000 to +327675000."/>
		<Client Name="AI2MinValue" Required="true" Internal="false" DefValue="-32767" Comment="The channel scale of AIx can be set with this property as init value.&#13;&#10;The value must be in the range of -327675000 to +327675000."/>
		<Client Name="AI3Active" Required="false" Internal="false" DefValue="1" Comment="The channel can be activated/ deactived with this client as init value.&#13;&#10;&#13;&#10;0 = Channel is deactivated. &#13;&#10;1 = Channel is activated. "/>
		<Client Name="AI3MaxValue" Required="true" Internal="false" DefValue="32767" Comment="The channel scale of AIx can be set with this property as init value.&#13;&#10;The value must be in the range of -327675000 to +327675000."/>
		<Client Name="AI3MinValue" Required="true" Internal="false" DefValue="-32767" Comment="The channel scale of AIx can be set with this property as init value.&#13;&#10;The value must be in the range of -327675000 to +327675000."/>
		<Client Name="AI4Active" Required="false" Internal="false" DefValue="1" Comment="The channel can be activated/ deactived with this client as init value.&#13;&#10;&#13;&#10;0 = Channel is deactivated. &#13;&#10;1 = Channel is activated. "/>
		<Client Name="AI4MaxValue" Required="true" Internal="false" DefValue="32767" Comment="The channel scale of AIx can be set with this property as init value.&#13;&#10;The value must be in the range of -327675000 to +327675000."/>
		<Client Name="AI4MinValue" Required="true" Internal="false" DefValue="-32767" Comment="The channel scale of AIx can be set with this property as init value.&#13;&#10;The value must be in the range of -327675000 to +327675000."/>
		<Client Name="ValuesPerCycle" Required="true" Internal="false" DefValue="0" Comment="this client set amount of values per cycle for each channel as init value!&#13;&#10;Minimum conversion time of one analog input is 5 탎.&#13;&#10;e.g. calculation of max values per cycle:&#13;&#10;cycle time 1000탎 and conversion of all 4 inputs activated&#13;&#10;cycle time /(AnalogInputs*Conversion time) = ValuesPerCycle&#13;&#10;1000탎 /(4*5탎) = 50&#13;&#10;&#13;&#10;0..maximum of possible values is set automatically (default value)&#13;&#10;"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\BusInterface.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="Pieste"/>
		<Dokumentation Revision="1.16" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.15" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.14" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.13" Date="23.02.2018" Author="ZoePat&#13;&#10;PieSte" Company="Sigmatek" Description="Implemented NewInst command SDIAS_CLT_GET_ANALOG_DATA_BUFFER.&#13;&#10;Add numbers for the assignment of the log messages."/>
		<Dokumentation Revision="1.12" Date="22.01.2018&#13;&#10;01.02.2018" Author="RamAnd&#13;&#10;PieSte" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl.&#13;&#10;If an error occurs in AddAccesses (), it is triggered in ConnectEvent (). An unnecessary mutex has been removed."/>
		<Dokumentation Revision="1.11" Date="11.10.2017" Author="FurDom" Company="Sigmatek" Description="Added Flag &quot;ScaleAIx&quot; for check if a new calculation is necessary for AI1-4 -&gt; Realtime optimization. &#13;&#10;New calculation if Client AI_Min or AI_Max is not default."/>
		<Dokumentation Revision="1.10" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.9" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.8" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.7" Date="23.02.2016" Author="PieSte" Company="Sigmatek" Description="Add support for min range greater max range."/>
		<Dokumentation Revision="1.6" Date="08.10.2015" Author="EisMic" Company="Sigmatek" Description="Input values are now assumed after start. Corrected handling that no boundExceed error can be caused."/>
		<Dokumentation Revision="1.5" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.4" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.3" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.2" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.1" Date="03.02.2015" Author="PieSte" Company="Sigmatek" Description="Set ClassState to _InvalidConfiguration and avoid division by zero if no Channel is activated."/>
		<Dokumentation Revision="1.0" Date="24.11.2014" Author="PieSte" Company="Sigmatek" Description="Initial Version."/>
	</RevDoku>
	<Network Name="AI040">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{ED983A1E-9E60-4DF4-91E2-8E314598303A}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

AI040 : CLASS
: SdiasBase
	TYPE
#pragma pack(push, 1)
	  t_PDOReadModulInfo : STRUCT
	    BufferState : BSINT
	    [
	      1 Ch1Full,
	      2 Ch2Full,
	      3 Ch3Full,
	      4 Ch4Full,
	      5 Ch1Empty,
	      6 Ch2Empty,
	      7 Ch3Empty,
	      8 Ch4Empty,
	    ];
	    DcOkState : BSINT
	    [
	      1 DC5VOk,
	      2 DC24VOk,
	      3 DC5VLatched,
	      4 DC24VLatched,
	    ];
	    HardwareState : BINT
	    [
	      1 Ch1Shortcircuit,
	      2 Ch1Cablebreak,
	      3 Ch2Shortcircuit,
	      4 Ch2Cablebreak,
	      5 Ch3Shortcircuit,
	      6 Ch3Cablebreak,
	      7 Ch4Shortcircuit,
	      8 Ch4Cablebreak,
	      9 Ch1ShortcircuitLatch,
	      10 Ch1CablebreakLatch,
	      11 Ch2ShortcircuitLatch,
	      12 Ch2CablebreakLatch,
	      13 Ch3ShortcircuitLatch,
	      14 Ch3CablebreakLatch,
	      15 Ch4ShortcircuitLatch,
	      16 Ch4CablebreakLatch,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AccessReadData : STRUCT
	    pStateByte : t_SDIAS_pStateByte;
	    pControlByte : t_SDIAS_pControlByte;
	    AccessHandle : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AccessData : STRUCT
	    pReadFifoBuffer : ARRAY [0..AI040_MAX_ARRAY_ENTRYS-1] OF ^INT;
	    pReadDefaultAccess : ^t_PDOReadModulInfo;
	    ReadAccessFifoBuffer : ARRAY [0..AI040_MAX_ARRAY_ENTRYS-1] OF t_AccessReadData;
	    usReadFifoDOActive : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_bChannels : STRUCT
	    Channel1 : BOOL;
	    Channel2 : BOOL;
	    Channel3 : BOOL;
	    Channel4 : BOOL;
	  END_STRUCT;
#pragma pack(pop)
	  t_bsBufferState : BSINT
	  [
	    1 Ch1Full,
	    2 Ch2Full,
	    3 Ch3Full,
	    4 Ch4Full,
	    5 Ch1Empty,
	    6 Ch2Empty,
	    7 Ch3Empty,
	    8 Ch4Empty,
	  ];
#pragma pack(push, 1)
	  t_SPICalibDataOneCh : STRUCT
	    Offset : UINT;
	    Multiplier : UINT;
	    Divisor : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPICalibData : STRUCT
	    NrCalibCh : DINT;
	    Channel1 : ARRAY [0..AI040_NR_GAIN_CALIB_SETTINGS-1] OF t_SPICalibDataOneCh;
	    Channel2 : ARRAY [0..AI040_NR_GAIN_CALIB_SETTINGS-1] OF t_SPICalibDataOneCh;
	    Channel3 : ARRAY [0..AI040_NR_GAIN_CALIB_SETTINGS-1] OF t_SPICalibDataOneCh;
	    Channel4 : ARRAY [0..AI040_NR_GAIN_CALIB_SETTINGS-1] OF t_SPICalibDataOneCh;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ChkSumData : STRUCT
	    SPIHeader : t_SPI_ListHeader;
	    SPIData : t_SPICalibData;
	  END_STRUCT;
#pragma pack(pop)
	  t_ConfigSSW :
	  (
	    _ConfigIdle,
	    _DeactivateConversion,
	    _WriteCalibData,
	    _WriteConfigSDO,
	    _ActivateConversion,
	    _FinishConfig,
	    _ErrorConfig
	  )$UDINT;
#pragma pack(push, 1)
	  t_Counter : STRUCT
	    ReadCnt : USINT;
	    WriteCnt : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_dChannels : STRUCT
	    Channel1 : DINT;
	    Channel2 : DINT;
	    Channel3 : DINT;
	    Channel4 : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_HWControlReg : BSINT
	  [
	    1 CurrentGain1,
	    2 CurrentGain2,
	    3 CurrentGain3,
	    4 reserved1,
	    5 CurrentSource1,
	    6 CurrentSource2,
	    7 reserved2,
	    8 reserved3,
	  ];
	  t_InitSSW :
	  (
	    _InitVariables,
	    _ReadSPIData,
	    _DisablePll,
	    _CheckChecksum,
	    _ReadPll,
	    _SetPll,
	    _Finish,
	    _InitError
	  )$UDINT;
#pragma pack(push, 1)
	  t_usChannels : STRUCT
	    Channel1 : USINT;
	    Channel2 : USINT;
	    Channel3 : USINT;
	    Channel4 : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_MeasureControl : STRUCT
	    MeasureActive : t_bChannels;
	    ArrayAssignment : STRUCT
	      ChArrayNr : t_usChannels;
	      ChArrayActivated : BSINT
	      [
	        1 Channel1,
	        2 Channel2,
	        3 Channel3,
	        4 Channel4,
	      ];
	      ChActivated : USINT;
	    END_STRUCT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SyncOut : STRUCT
	    uiOffset : UINT;
	    usPeriodMulti : USINT;
	    bsSyncStartDelay : BSINT
	    [
	      1 SyncStartDelay1,
	      2 SyncStartDelay2,
	      3 SyncStartDelay3,
	      4 SyncStartDelay4,
	    ];
	    hsSyncOutID : HSINT;
	    bsControlState : BSINT
	    [
	      1 SyncEnable,
	      2 StartDelayEnable,
	      3 SyncSelector,
	    ];
	    uiReserved : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PllRegister : STRUCT
	    udSystemPerTime : UDINT;
	    udSystemPerTimeMeasure : UDINT;
	    bsStateControlReg : BSINT
	    [
	      1 locked_res1,
	      2 unlocked_res2,
	      3 Soft_enable,
	      4 res3,
	      5 res4,
	      6 res5,
	      7 res6,
	      8 res7,
	    ];
	    usSystemPeriodeDividier : USINT;
	    bsCompDelay : BSINT
	    [
	    ];
	    usReserved : USINT;
	    SyncOut0 : t_SyncOut;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
#pragma pack(push, 1)
	  t_ScaleSetting : STRUCT
	    Divider : t_dChannels;
	    Multiplier : t_dChannels;
	    Offset : t_dChannels;
	    bRawValue : t_bChannels;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_uiChannels : STRUCT
	    Channel1 : UINT;
	    Channel2 : UINT;
	    Channel3 : UINT;
	    Channel4 : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SDOCalibData : STRUCT
	    CalibratedData : t_uiChannels;
	    BinaryData : t_uiChannels;
	    Offset : t_uiChannels;
	    Multiplier : t_uiChannels;
	    Divisor : t_uiChannels;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SDOHardwareControl : STRUCT
	    ConversionTime : USINT;
	    HWControlCh1 : t_HWControlReg;
	    HWControlCh2 : t_HWControlReg;
	    HWControlCh3 : t_HWControlReg;
	    HWControlCh4 : t_HWControlReg;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPIReadData : STRUCT
	    IDHeader : t_SPI_ListHeader;
	    udMaxDataLength : UDINT;
	    udActReadLength : UDINT;
	    udReadLength : UDINT;
	    udReadOffset : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPIWriteData : STRUCT
	    usBytesToWrite : USINT;
	    usBytesActWrite : USINT;
	    usWriteOffset : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_WriteControlCh : STRUCT
	    ControlCh : BSINT
	    [
	      1 EnableCh1,
	      2 EnableCh2,
	      3 EnableCh3,
	      4 EnableCh4,
	    ];
	    StartCh : BSINT
	    [
	      1 StartCh1,
	      2 StartCh2,
	      3 StartCh3,
	      4 StartCh4,
	      5 StartSynchronCh1,
	      6 StartSynchronCh2,
	      7 StartSynchronCh3,
	      8 StartSynchronCh4,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	AI1 	: SvrCh_DINT;
	AI1ConfigValid 	: SvrCh_DINT;
	AI1CableBreak 	: SvrCh_DINT;
	AI1ShortCircuit 	: SvrCh_DINT;
	AI1Gain 	: SvrCh_DINT;
	AI1CurrentSource 	: SvrCh_DINT;
	AI2 	: SvrCh_DINT;
	AI2ConfigValid 	: SvrCh_DINT;
	AI2CableBreak 	: SvrCh_DINT;
	AI2ShortCircuit 	: SvrCh_DINT;
	AI2Gain 	: SvrCh_DINT;
	AI2CurrentSource 	: SvrCh_DINT;
	AI3 	: SvrCh_DINT;
	AI3ConfigValid 	: SvrCh_DINT;
	AI3CableBreak 	: SvrCh_DINT;
	AI3ShortCircuit 	: SvrCh_DINT;
	AI3Gain 	: SvrCh_DINT;
	AI3CurrentSource 	: SvrCh_DINT;
	AI4 	: SvrCh_DINT;
	AI4ConfigValid 	: SvrCh_DINT;
	AI4CableBreak 	: SvrCh_DINT;
	AI4ShortCircuit 	: SvrCh_DINT;
	AI4Gain 	: SvrCh_DINT;
	AI4CurrentSource 	: SvrCh_DINT;
	Voltage5V 	: SvrCh_DINT;
	Voltage24V 	: SvrCh_DINT;
  //Clients:
	AI1Active 	: CltCh_DINT;
	AI1MaxValue 	: CltCh_DINT;
	AI1MinValue 	: CltCh_DINT;
	AI2Active 	: CltCh_DINT;
	AI2MaxValue 	: CltCh_DINT;
	AI2MinValue 	: CltCh_DINT;
	AI3Active 	: CltCh_DINT;
	AI3MaxValue 	: CltCh_DINT;
	AI3MinValue 	: CltCh_DINT;
	AI4Active 	: CltCh_DINT;
	AI4MaxValue 	: CltCh_DINT;
	AI4MinValue 	: CltCh_DINT;
	ValuesPerCycle 	: CltCh_DINT;
  //Variables:
		sAccesses 	: t_AccessData;
		sMeasureControl 	: t_MeasureControl;
		sWriteCalibData 	: t_SDOCalibData;
		sReadCalibData 	: t_SPICalibData;
		sSPIReadData 	: t_SPIReadData;
		sSPIWriteData 	: t_SPIWriteData;
		sHWControl 	: t_SDOHardwareControl;
		sWriteADCStart 	: t_WriteControlCh;
		sPLLRegister 	: t_PllRegister;
		eInitSSW 	: t_InitSSW;
		eInitSSWErrorStep 	: t_InitSSW;
		eConfigSSW 	: t_ConfigSSW;
		eConfigSSWErrorStep 	: t_ConfigSSW;
		eResponseState 	: t_ResponseState;
		udSDOTimeout 	: UDINT;
		uiMaxValuesCycle 	: UINT;
		bsConfigChanged : BSINT
		[
		  1 Channel1,
		  2 Channel2,
		  3 Channel3,
		  4 Channel4,
		];

		bInitADCBuffer 	: BOOL;
		udBusCycleTimeMicroSec 	: UDINT;
		sScaleSettings 	: t_ScaleSetting;
		aErrorDelay : ARRAY [0..AI040_NUMBER_OF_ANALOG_IN-1] OF UDINT;

		sErrorOccured 	: t_bChannels;
		ScaleAI1 	: BOOL;
		ScaleAI2 	: BOOL;
		ScaleAI3 	: BOOL;
		ScaleAI4 	: BOOL;
  //Functions:
				//! <Function Comment="Init-Methode of Class.&#13;&#10;&#13;&#10;This Methode needs to get called. In case the Methode gets overwritten, a call needs to bet installed." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION AI040
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Cyclic Update Methode which runs in PostScan." Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION StartMeasure
		VAR_INPUT
			bStartStop 	: BOOL;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="methode is called to get data from fifo buffer." Name="GetData"/>
	FUNCTION GLOBAL GetData
		VAR_INPUT
			usChannelNr 	: USINT;			//! <Variable Comment="select analog input channel to read data" Name="GetData.usChannelNr"/>
			uiDataLength 	: UINT;			//! <Variable Comment="length of requested data in bytes&#13;&#10;e.g. 10 requested values = 20bytes" Name="GetData.uiDataLength"/>
			pBufferData 	: ^INT;			//! <Variable Comment="pointer to databuffer" Name="GetData.pBufferData"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment=" 0..data is valid&#13;&#10;-1..requested channel is not activated&#13;&#10;-2..requested channel is not available&#13;&#10;-3..requested datalength is to long&#13;&#10;-4..data from channel is not valid" Name="GetData.dRetcode"/>
		END_VAR;
				//! <Function Comment="methode is called to get settings." Name="GetSettings"/>
	FUNCTION GLOBAL GetSettings
		VAR_INPUT
			usChannelNr 	: USINT;			//! <Variable Comment="select analog input channel to read data" Name="GetSettings.usChannelNr"/>
			pSampleRate 	: ^LREAL := NIL;			//! <Variable Comment="pointer to calculated samplerate of channel" Name="GetSettings.pSampleRate"/>
			pMaxValuesCycle 	: ^UINT := NIL;			//! <Variable Comment="pointer to maximal possible values per cycle" Name="GetSettings.pMaxValuesCycle"/>
			pConversionTime 	: ^USINT := NIL;			//! <Variable Comment="pointer to conversion time of adc [탎]" Name="GetSettings.pConversionTime"/>
			pChannelsActive 	: ^USINT := NIL;			//! <Variable Comment="pointer to amount of activated channels" Name="GetSettings.pChannelsActive"/>
			pBusCycleTime 	: ^UDINT := NIL;			//! <Variable Comment="pointer to bus cycle time [ns]" Name="GetSettings.pBusCycleTime"/>
			pMultiplier 	: ^DINT := NIL;			//! <Variable Comment="pointer to multiplier of selected channel." Name="GetSettings.pMultiplier"/>
			pDivisor 	: ^DINT := NIL;			//! <Variable Comment="pointer to divisor of selected channel." Name="GetSettings.pDivisor"/>
			pOffset 	: ^DINT := NIL;			//! <Variable Comment="pointer to offset of selected channel." Name="GetSettings.pOffset"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment=" 0..data is valid&#13;&#10;-2..requested channel is not available" Name="GetSettings.dRetCode"/>
		END_VAR;
				//! <Function Comment="Methode reset all Server-Values." Name="ResetServer"/>
	FUNCTION ResetServer;
	
	FUNCTION HWConfigModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
	
	FUNCTION CalibDataHW;
	
	FUNCTION SetScale
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI1Gain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI1CurrentSource::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI2Gain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI2CurrentSource::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI3Gain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI3CurrentSource::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI4Gain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI4CurrentSource::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AI040::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_AI040
1$UINT, 16$UINT, (SIZEOF(::AI040))$UINT, 
26$UINT, 13$UINT, 0$UINT, 
TO_UDINT(4231378840), "AI040", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::AI040.AI1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4269591187), "AI1", 
(::AI040.AI1ConfigValid.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(530560120), "AI1ConfigValid", 
(::AI040.AI1CableBreak.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(497653955), "AI1CableBreak", 
(::AI040.AI1ShortCircuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3855152412), "AI1ShortCircuit", 
(::AI040.AI1Gain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(205681801), "AI1Gain", 
(::AI040.AI1CurrentSource.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3194570082), "AI1CurrentSource", 
(::AI040.AI2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1735760681), "AI2", 
(::AI040.AI2ConfigValid.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1744922248), "AI2ConfigValid", 
(::AI040.AI2CableBreak.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2219572930), "AI2CableBreak", 
(::AI040.AI2ShortCircuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1476565458), "AI2ShortCircuit", 
(::AI040.AI2Gain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1273106009), "AI2Gain", 
(::AI040.AI2CurrentSource.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3255328953), "AI2CurrentSource", 
(::AI040.AI3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(275950527), "AI3", 
(::AI040.AI3ConfigValid.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4087622375), "AI3ConfigValid", 
(::AI040.AI3CableBreak.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1170546946), "AI3CableBreak", 
(::AI040.AI3ShortCircuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2241085527), "AI3ShortCircuit", 
(::AI040.AI3Gain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1988241385), "AI3Gain", 
(::AI040.AI3CurrentSource.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1594327503), "AI3CurrentSource", 
(::AI040.AI4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2383822364), "AI4", 
(::AI040.AI4ConfigValid.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2268906344), "AI4ConfigValid", 
(::AI040.AI4CableBreak.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1828598913), "AI4CableBreak", 
(::AI040.AI4ShortCircuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4175906319), "AI4ShortCircuit", 
(::AI040.AI4Gain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3299015673), "AI4Gain", 
(::AI040.AI4CurrentSource.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(986327823), "AI4CurrentSource", 
(::AI040.Voltage5V.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(913359326), "Voltage5V", 
(::AI040.Voltage24V.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1674808318), "Voltage24V", 
//Clients:
(::AI040.AI1Active.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(486731501), "AI1Active", 
(::AI040.AI1MaxValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3147612618), "AI1MaxValue", 
(::AI040.AI1MinValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1576824363), "AI1MinValue", 
(::AI040.AI2Active.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(753595504), "AI2Active", 
(::AI040.AI2MaxValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2182216975), "AI2MaxValue", 
(::AI040.AI2MinValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1685148398), "AI2MinValue", 
(::AI040.AI3Active.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2325610436), "AI3Active", 
(::AI040.AI3MaxValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2506811724), "AI3MaxValue", 
(::AI040.AI3MinValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1930053293), "AI3MinValue", 
(::AI040.AI4Active.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1329250634), "AI4Active", 
(::AI040.AI4MaxValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4044063877), "AI4MaxValue", 
(::AI040.AI4MinValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(392899428), "AI4MinValue", 
(::AI040.ValuesPerCycle.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3792072536), "ValuesPerCycle", 
END_FUNCTION


#define USER_CNT_AI040 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AI040] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AI040::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AI040;
	vmt.CmdTable.NewInstr		:= #ClassState::NewInst();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI1Gain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI1Gain::Write() );
	IF AI1Gain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI1CurrentSource.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI1CurrentSource::Write() );
	IF AI1CurrentSource.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI2Gain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI2Gain::Write() );
	IF AI2Gain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI2CurrentSource.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI2CurrentSource::Write() );
	IF AI2CurrentSource.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI3Gain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI3Gain::Write() );
	IF AI3Gain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI3CurrentSource.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI3CurrentSource::Write() );
	IF AI3CurrentSource.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI4Gain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI4Gain::Write() );
	IF AI4Gain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI4CurrentSource.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI4CurrentSource::Write() );
	IF AI4CurrentSource.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AI040();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL AI040::Init
  VAR	
    tempCmd         : CmdStruct;
    _result         : results;
  END_VAR

  SdiasBase::Init();

  if usInitCounter = 11 then
    // Get bus cycle time
    tempCmd.uiCmd := _BUS_IF_GET_BUSCYCLE_TIME;
    SdiasBase::NewInst(pPara:=#tempCmd, pResult:=#_result);    
    if _result.aData[0]$t_GetBusCycleTime.retcode <> _BUS_IF_RETVAL_OK then
      LogError("@0134 (AI040::Init) Failed to get bus cycle time via BusInterface.");    
      eInitState := _InvalidConfguration;
      return;    
    end_if;     
    udBusCycleTimeMicroSec := _result.aData[0]$t_GetBusCycleTime.udBusCycleTime/1000;  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::UpdateRt
  VAR
    sHardwareState : t_PDOReadModulInfo;
    dTempAnalogIn : DINT;
  END_VAR

  if ClassState = _ClassOk then
    sHardwareState := sAccesses.pReadDefaultAccess^;
    Voltage24V     := sHardwareState.DcOkState.DC24VOk;
    Voltage5V      := sHardwareState.DcOkState.DC5VOk;
    //check Voltage supply
    if Voltage24V & Voltage5V then 
      // No update of adc values and states, while configuration isn't confirmed
      if AI1ConfigValid = 1 then
        if sWriteADCStart.ControlCh.EnableCh1 = TRUE then
          if ScaleAI1 then
            dTempAnalogIn := (((sAccesses.pReadFifoBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel1]+AI040_INPUT_RAW_VALUE_PLACE)^+sScaleSettings.Offset.Channel1) 
            * sScaleSettings.Multiplier.Channel1)/sScaleSettings.Divider.Channel1;          
          else
            dTempAnalogIn := (sAccesses.pReadFifoBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel1])^;
          end_if;
            if sHardwareState.HardwareState.Ch1Cablebreak
            | sHardwareState.HardwareState.Ch1Shortcircuit then
              if sErrorOccured.Channel1 = FALSE then 
                aErrorDelay[0] := ops.tAbsolute;  
                sErrorOccured.Channel1 := TRUE;
              end_if;
              if (ops.tAbsolute - aErrorDelay[0]) > AI040_ERROR_DELAYTIME then
                AI1CableBreak   := sHardwareState.HardwareState.Ch1Cablebreak;
                AI1ShortCircuit := sHardwareState.HardwareState.Ch1Shortcircuit;
                dTempAnalogIn := AI040_INVALID_VALUE;
              end_if;
            else
              sErrorOccured.Channel1 := FALSE;
              AI1CableBreak   := sHardwareState.HardwareState.Ch1Cablebreak;
              AI1ShortCircuit := sHardwareState.HardwareState.Ch1Shortcircuit;   
            end_if;
          AI1 := dTempAnalogIn;
        else
          AI1 := AI040_INVALID_VALUE;
        end_if;
      else
        AI1 := AI040_INVALID_VALUE;
      end_if;  
        
      // No update of adc values and states, while configuration isn't confirmed
      if AI2ConfigValid = 1 then
        if sWriteADCStart.ControlCh.EnableCh2 = TRUE then
          if ScaleAI2 then
            dTempAnalogIn := (((sAccesses.pReadFifoBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel2]+AI040_INPUT_RAW_VALUE_PLACE)^+sScaleSettings.Offset.Channel2) 
            *sScaleSettings.Multiplier.Channel2)/sScaleSettings.Divider.Channel2;          
          else
            dTempAnalogIn := (sAccesses.pReadFifoBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel2]^);
          end_if;         
            if sHardwareState.HardwareState.Ch2Cablebreak
            | sHardwareState.HardwareState.Ch2Shortcircuit then
              if sErrorOccured.Channel2 = FALSE then 
                aErrorDelay[1] := ops.tAbsolute;  
                sErrorOccured.Channel2 := TRUE;
              end_if;
              if (ops.tAbsolute - aErrorDelay[1]) > AI040_ERROR_DELAYTIME then
                AI2CableBreak   := sHardwareState.HardwareState.Ch2Cablebreak;
                AI2ShortCircuit := sHardwareState.HardwareState.Ch2Shortcircuit;
                dTempAnalogIn := AI040_INVALID_VALUE;
              end_if;
            else
              sErrorOccured.Channel2 := FALSE;
              AI2CableBreak   := sHardwareState.HardwareState.Ch2Cablebreak;
              AI2ShortCircuit := sHardwareState.HardwareState.Ch2Shortcircuit;   
            end_if;
          AI2 := dTempAnalogIn;
        end_if;
      else
        AI2 := AI040_INVALID_VALUE;
      end_if;  
      
      // No update of adc values and states, while configuration isn't confirmed
      if AI3ConfigValid = 1 then
        if sWriteADCStart.ControlCh.EnableCh3 = TRUE then
          if ScaleAI3 then
            dTempAnalogIn := (((sAccesses.pReadFifoBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel3]+AI040_INPUT_RAW_VALUE_PLACE)^+sScaleSettings.Offset.Channel3) 
            *sScaleSettings.Multiplier.Channel3)/sScaleSettings.Divider.Channel3;          
          else
            dTempAnalogIn := (sAccesses.pReadFifoBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel3]^);
          end_if;        
            if sHardwareState.HardwareState.Ch3Cablebreak
            | sHardwareState.HardwareState.Ch3Shortcircuit then
              if sErrorOccured.Channel3 = FALSE then 
                aErrorDelay[2] := ops.tAbsolute;  
                sErrorOccured.Channel3 := TRUE;
              end_if;
              if (ops.tAbsolute - aErrorDelay[2]) > AI040_ERROR_DELAYTIME then
                AI3CableBreak   := sHardwareState.HardwareState.Ch3Cablebreak;
                AI3ShortCircuit := sHardwareState.HardwareState.Ch3Shortcircuit;
                dTempAnalogIn := AI040_INVALID_VALUE;
              end_if;
            else
              sErrorOccured.Channel3 := FALSE;
              AI3CableBreak   := sHardwareState.HardwareState.Ch3Cablebreak;
              AI3ShortCircuit := sHardwareState.HardwareState.Ch3Shortcircuit;   
            end_if;
          AI3 := dTempAnalogIn;
        end_if;
      else
        AI3 := AI040_INVALID_VALUE;
      end_if;  

      // No update of adc values and states, while configuration isn't confirmed
      if AI4ConfigValid = 1 then
        if sWriteADCStart.ControlCh.EnableCh4 = TRUE then
          if ScaleAI4 then
            dTempAnalogIn := (((sAccesses.pReadFifoBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel4]+AI040_INPUT_RAW_VALUE_PLACE)^+sScaleSettings.Offset.Channel4) 
            *sScaleSettings.Multiplier.Channel4)/sScaleSettings.Divider.Channel4;          
          else
            dTempAnalogIn := (sAccesses.pReadFifoBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel4]^);
          end_if;         
            if sHardwareState.HardwareState.Ch4Cablebreak
            | sHardwareState.HardwareState.Ch4Shortcircuit then
              if sErrorOccured.Channel4 = FALSE then 
                aErrorDelay[3] := ops.tAbsolute;  
                sErrorOccured.Channel4 := TRUE;
              end_if;
              if (ops.tAbsolute - aErrorDelay[3]) > AI040_ERROR_DELAYTIME then
                AI4CableBreak   := sHardwareState.HardwareState.Ch4Cablebreak;
                AI4ShortCircuit := sHardwareState.HardwareState.Ch4Shortcircuit;
                dTempAnalogIn := AI040_INVALID_VALUE;
              end_if;
            else
              sErrorOccured.Channel4 := FALSE;
              AI4CableBreak   := sHardwareState.HardwareState.Ch4Cablebreak;
              AI4ShortCircuit := sHardwareState.HardwareState.Ch4Shortcircuit;   
            end_if;
          AI4 := dTempAnalogIn;
        end_if; 
      else
        AI4 := AI040_INVALID_VALUE;
      end_if; 
    else      
      ResetServer();
      //init adc
      bsConfigChanged := 16#0F;
      bInitADCBuffer  := TRUE;
    end_if;    
  end_if;  
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::UpdateCy
VAR
	dRetCode : iprStates;
END_VAR

  if ClassState = _ClassOk 
  & Voltage24V & Voltage5V then
    if bsConfigChanged <> 0
    | eConfigSSW <> _ConfigIdle then
      dRetCode := HWConfigModule();
      if dRetCode = Ready then
        AI1ConfigValid := TRUE;
        AI2ConfigValid := TRUE;
        AI3ConfigValid := TRUE;
        AI4ConfigValid := TRUE;
      end_if;
    end_if;    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	usCnt           : USINT;
    usDOCnt         : USINT;
    pHelp           : ^USINT;
    uiActDoLength   : UINT;
    uiNextDoLength  : UINT;
    usOddValue      : USINT;
    uiConversionTime      : UINT;
    uiTotalValuesPerCycle : UINT;
  END_VAR 
  
  //error if get bus time at init() fails
  if eInitState = _InvalidConfguration then        
    eModuleInitState := ERROR;
    eInitState       := _InvalidConfguration;
    return;
  end_if;
  
  usDOCnt := 0;
  
  //read clients
  AI1Active := AI1Active.Read();
  AI2Active := AI2Active.Read();
  AI3Active := AI3Active.Read();
  AI4Active := AI4Active.Read();  
  
  //analog input 1
  //*************************************************************************************************************
  if AI1Active then
    sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 := 1;
    sMeasureControl.ArrayAssignment.ChActivated += 1;
  end_if;
  
  //analog input 2
  //*************************************************************************************************************
  if AI2Active then
    sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 := 1;
    sMeasureControl.ArrayAssignment.ChActivated += 1;
  end_if;
  
  //analog input 3
  //*************************************************************************************************************
  if AI3Active then
    sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 := 1;
    sMeasureControl.ArrayAssignment.ChActivated += 1;
  end_if;
  
  //analog input 4
  //*************************************************************************************************************
  if AI4Active then
    sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 := 1;
    sMeasureControl.ArrayAssignment.ChActivated += 1;
  end_if; 
  
  if sMeasureControl.ArrayAssignment.ChActivated = 0 then  
    LogError("@0135 (AI040::AddAccesses) There is no channel activated.");    
    eModuleInitState := ERROR;
    eInitState       := _InvalidConfguration;
    return;    
  end_if;  
  
  ValuesPerCycle := ValuesPerCycle.Read();
  
  if ValuesPerCycle = 0 then
    uiConversionTime := AI040_ADC_MIN_CONVERSION_TIME;    
  else 
    uiTotalValuesPerCycle := ValuesPerCycle$UINT*sMeasureControl.ArrayAssignment.ChActivated;
    if (udBusCycleTimeMicroSec mod uiTotalValuesPerCycle) <> 0 then
      if uiTotalValuesPerCycle < (udBusCycleTimeMicroSec/AI040_ADC_MIN_CONVERSION_TIME) then
        while udBusCycleTimeMicroSec mod uiTotalValuesPerCycle do
          uiTotalValuesPerCycle += 1;
        end_while; 
        uiConversionTime := (udBusCycleTimeMicroSec/uiTotalValuesPerCycle)$USINT; //conversion time as 탎
        
      end_if; 
      if ValuesPerCycle <> uiTotalValuesPerCycle/sMeasureControl.ArrayAssignment.ChActivated then
        ValuesPerCycle   := uiTotalValuesPerCycle/sMeasureControl.ArrayAssignment.ChActivated;
        LogError("@0136 (AI040::AddAccesses) Bus cycle time is not a multiple of ValuesPerCycle! ValuesPerCycle is set to next divisible value.");
      end_if;      
    end_if;
  
    uiConversionTime := (udBusCycleTimeMicroSec/uiTotalValuesPerCycle)$UINT; //default conversion time as 탎
    if uiConversionTime < 5 then
      uiConversionTime := AI040_ADC_MIN_CONVERSION_TIME;
    elsif uiConversionTime > AI040_ADC_MAX_CONVERSION_TIME then
      uiConversionTime := AI040_ADC_MAX_CONVERSION_TIME;
    end_if;
  end_if; 
  
  // get maximal filtervalues per cycle
  uiMaxValuesCycle := (udBusCycleTimeMicroSec$UINT)/(uiConversionTime*sMeasureControl.ArrayAssignment.ChActivated);  
  
  if uiMaxValuesCycle > AI040_MAX_VALUES_PER_CYCLE then
    uiMaxValuesCycle := AI040_MAX_VALUES_PER_CYCLE;
  end_if;
  
  if ValuesPerCycle > uiMaxValuesCycle then
    ValuesPerCycle := uiMaxValuesCycle;    
    LogError("@0137 (AI040::AddAccesses) Client ValuesPerCycle is set to high! Value is set to next possible values per cycle.");
  elsif ValuesPerCycle < uiMaxValuesCycle 
   & ValuesPerCycle <> 0 then
    ValuesPerCycle := uiMaxValuesCycle;    
    LogError("@0138 (AI040::AddAccesses) Client ValuesPerCycle is set to low! Value is set to next possible values per cycle.");
  elsif ValuesPerCycle = 0 then
    ValuesPerCycle := uiMaxValuesCycle; 
  end_if; 
  
  usOddValue := 0;
  if (udBusCycleTimeMicroSec mod (uiMaxValuesCycle*sMeasureControl.ArrayAssignment.ChActivated)) <> 0 then
  //add one extra value to readout from buffer
    usOddValue := 1;  
    LogError("@0139 (AI040::AddAccesses)Setting for measured values is false. Bus cycle time is not a multiple of values of all channels. Correct settings!");
  end_if;
  
  usDOCnt := 0;
  pHelp := #sMeasureControl.ArrayAssignment.ChArrayNr.Channel1;
  for usCnt := 0 to AI040_NUMBER_OF_ANALOG_IN - 1 do 
    if ((sMeasureControl.ArrayAssignment.ChArrayActivated$USINT shr usCnt)AND 2#1 = TRUE) then
    
      pHelp^  := usDOCnt;
      pHelp   += sizeof(pHelp^);
      uiNextDoLength := (to_uint(uiMaxValuesCycle)+usOddValue) * AI040_SIZE_ONE_VALUE;
      while uiNextDoLength do
        if (uiNextDoLength) > AI040_MAX_LENGTH_ONE_READ then
          uiActDoLength := AI040_MAX_LENGTH_ONE_READ; 
        else  
          uiActDoLength := uiNextDoLength;
        end_if;
        
        eModuleInitState := AddRdAccess(hOffset := AI040_MAX_LENGTH_ONE_READ * usCnt
                                      , uLength := uiActDoLength
                                      , ppData  := #sAccesses.pReadFifoBuffer[usDOCnt]
                                      , ppStateByte   := #sAccesses.ReadAccessFifoBuffer[usDOCnt].pStateByte
                                      , ppControlByte := #sAccesses.ReadAccessFifoBuffer[usDOCnt].pControlByte
                                      , pAccessHandle := #sAccesses.ReadAccessFifoBuffer[usDOCnt].AccessHandle);
                                       
        if eModuleInitState <> READY then
          LogError("@013A (AI040::AddAccesses) Failed to add iso read access for SDIAS module.");          
          eModuleInitState := ERROR;
          eInitState       := _InvalidConfguration;
          return;
        end_if;
        uiNextDoLength -= uiActDoLength;
        usDOCnt += 1;
      end_while;        
    else
      pHelp^ := 16#FF;
      pHelp  += sizeof(pHelp^);
    end_if;
  end_for;
  sAccesses.usReadFifoDOActive := usDOCnt;
  sHWControl.ConversionTime := uiConversionTime$USINT;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::ConnectEvent
  VAR
  	usCnt : USINT;
  END_VAR

  //start the access for read fifo buffer
  if sAccesses.usReadFifoDOActive then
    for usCnt := 0 to sAccesses.usReadFifoDOActive - 1 do  
      if sAccesses.ReadAccessFifoBuffer[usCnt].pControlByte  then
        sAccesses.ReadAccessFifoBuffer[usCnt].pControlByte^.EnableDO := TRUE;
      else    
        eInitState := _DOHandleInvalid;
        return;
      end_if;
    end_for; 
  else  
    //if any channel is activated and no data object is active it is a error
    if AI1Active | AI2Active | AI3Active | AI4Active then
      eInitState := _DOHandleInvalid;
      return;      
    end_if;
  end_if;
  
//   start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  if DefaultAccesses.ReadAccess.pControlByte then
    sAccesses.pReadDefaultAccess := DefaultAccesses.ReadAccess.pData$^t_PDOReadModulInfo;
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
 
  //init adc
  bsConfigChanged := 16#0F;
  bInitADCBuffer  := TRUE;
  
  //Set Config to -1 so that the input values will be assumed
  AI1ConfigValid := -1;
  AI2ConfigValid := -1;
  AI3ConfigValid := -1;
  AI4ConfigValid := -1;
   
  //set gain and current for first start
  AI1Gain.Write(input:=AI1Gain);
  AI2Gain.Write(input:=AI2Gain);
  AI3Gain.Write(input:=AI3Gain);
  AI4Gain.Write(input:=AI4Gain);
  AI1CurrentSource.Write(input:=AI1CurrentSource);
  AI2CurrentSource.Write(input:=AI2CurrentSource);
  AI3CurrentSource.Write(input:=AI3CurrentSource);
  AI4CurrentSource.Write(input:=AI4CurrentSource);
  
  //Set eInitState due to Plug&Play behaviour
  eInitState := _NotInitialized;  
  eInitSSW        := _InitVariables; 
  eResponseState  := _idle;

END_FUNCTION


FUNCTION AI040::StartMeasure
	VAR_INPUT
		bStartStop 	: BOOL;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  VAR
  	bChannelAvailable : BOOL;
  END_VAR
  
  dRetcode := 0;  
  bChannelAvailable := FALSE;
  
  //analog input 1
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 = TRUE then
    sWriteADCStart.StartCh.StartSynchronCh1 := bStartStop;
    sWriteADCStart.ControlCh.EnableCh1      := bStartStop;
    sMeasureControl.MeasureActive.Channel1  := bStartStop;
    bChannelAvailable := TRUE;
  end_if;

  //analog input 2
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 = TRUE then
    sWriteADCStart.StartCh.StartSynchronCh2 := bStartStop;
    sWriteADCStart.ControlCh.EnableCh2      := bStartStop;
    sMeasureControl.MeasureActive.Channel2  := bStartStop;
    bChannelAvailable := TRUE;
  end_if;
  
  //analog input 3
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 = TRUE then
    sWriteADCStart.StartCh.StartSynchronCh3 := bStartStop;
    sWriteADCStart.ControlCh.EnableCh3      := bStartStop;
    sMeasureControl.MeasureActive.Channel3  := bStartStop;
    bChannelAvailable := TRUE;
  end_if;

  //analog input 4
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 = TRUE then
    sWriteADCStart.StartCh.StartSynchronCh4 := bStartStop;
    sWriteADCStart.ControlCh.EnableCh4      := bStartStop;    
    sMeasureControl.MeasureActive.Channel4  := bStartStop;
    bChannelAvailable := TRUE;
  end_if; 
  
  if bChannelAvailable = FALSE then
    dRetcode := -1;     //channel is not activated
    return;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL AI040::GetData
	VAR_INPUT
		usChannelNr 	: USINT;
		uiDataLength 	: UINT;
		pBufferData 	: ^INT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  VAR
  	uiTempBufferIndex : UINT;
    usDoCnt : USINT;
    uiActReadData : UINT;
    uiNextReadData : UINT;
    uiReadOffset : UINT;
  END_VAR
  
  dRetcode := 0;
  
  case usChannelNr of  
  
  //analog input 1
  //*************************************************************************************************************
    1: 
      if sMeasureControl.MeasureActive.Channel1 then
        if AI1 <> AI040_INVALID_VALUE then
          uiTempBufferIndex := sMeasureControl.ArrayAssignment.ChArrayNr.Channel1;
        else
          dRetcode := -4;  //data of analog input is not valid
        end_if;        
      else
        dRetcode := -1;   //channel is not activated
      end_if;        
    
  //analog input 2
  //*************************************************************************************************************
    2:  
      if sMeasureControl.MeasureActive.Channel2 then
        if AI2 <> AI040_INVALID_VALUE then
          uiTempBufferIndex := sMeasureControl.ArrayAssignment.ChArrayNr.Channel2;
        else
          dRetcode := -4;  //data of analog input is not valid
        end_if;        
      else
        dRetcode := -1;   //channel is not activated
      end_if;
    
  //analog input 3
  //*************************************************************************************************************
    3: 
      if sMeasureControl.MeasureActive.Channel3 then
        if AI3 <> AI040_INVALID_VALUE then
          uiTempBufferIndex := sMeasureControl.ArrayAssignment.ChArrayNr.Channel3;
        else
          dRetcode := -4;  //data of analog input is not valid
        end_if;        
      else
        dRetcode := -1;   //channel is not activated
      end_if; 
    
  //analog input 4
  //*************************************************************************************************************
    4:  
      if sMeasureControl.MeasureActive.Channel4 then
        if AI4 <> AI040_INVALID_VALUE then
          uiTempBufferIndex := sMeasureControl.ArrayAssignment.ChArrayNr.Channel4;
        else
          dRetcode := -4;  //data of analog input is not valid
        end_if;        
      else
        dRetcode := -1;   //channel is not activated
      end_if;
    
    else
    
      dRetcode := -2;  //channel number is not available;
      return;
  end_case;
  
  if uiDataLength > (uiMaxValuesCycle*AI040_SIZE_ONE_VALUE) then
    dRetcode := -3;  //requested datalength is to long
    return;
  end_if;
   
  if dRetcode = 0 then
    usDoCnt := 0;
    uiReadOffset := 0;
    uiNextReadData := uiDataLength;
    while uiNextReadData do
      uiActReadData := uiNextReadData;
      if uiActReadData > AI040_MAX_LENGTH_ONE_READ then
        uiActReadData := AI040_MAX_LENGTH_ONE_READ;
      end_if;
      
      _memcpy(ptr1:=pBufferData+uiReadOffset, ptr2:=sAccesses.pReadFifoBuffer[uiTempBufferIndex+usDoCnt], cntr:=uiActReadData);

      uiNextReadData -= uiActReadData;
      uiReadOffset += uiActReadData;
      usDoCnt += 1;
    end_while;
  end_if;
 
END_FUNCTION

FUNCTION VIRTUAL GLOBAL AI040::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
    TmpChecksum     : UDINT;
    pHelpPointer    : ^CHAR;
    bIDFound        : Bool;
    ChecksumData    : t_ChkSumData;
  END_VAR
  
  eModuleInitState := BUSY;

  case eInitSSW of
//**********************************************************************************************************************************************************
    _InitVariables:
    
      TmpRetcode := SetScale(); 
      if TmpRetcode = ERROR then
        eInitSSWErrorStep := eInitSSW;
        eInitSSW          := _InitError;
        return;
      end_if;  
      
      sSPIReadData.udMaxDataLength := sizeof(sReadCalibData);
      sSPIReadData.udActReadLength := sSPIReadData.udMaxDataLength;      
      udSDOTimeout  := ops.tAbsolute;
      eInitSSW      :=  _ReadSPIData;   
      
//**********************************************************************************************************************************************************
    _ReadSPIData: 
      pHelpPointer := #sReadCalibData$CHAR;
      pHelpPointer := pHelpPointer + sSPIReadData.udReadOffset;
        
      TmpRetcode := GetSPIDataFromID(usListID         :=SDIAS_SPI_CALIB_DATA_ID
                                    , pData           :=pHelpPointer
                                    , RequDataLength  :=sSPIReadData.udActReadLength
                                    , pIDHeader       :=#sSPIReadData.IDHeader
                                    , pReadLen        :=#sSPIReadData.udReadLength
                                    , udReadOffset    :=sSPIReadData.udReadOffset 
                                    , bIDFound        := #bIDFound ); 
                                    
      if TmpRetcode = READY then        
        if bIDFound = true then           
          if sSPIReadData.udReadLength >= sSPIReadData.udActReadLength then 
            udSDOTimeout              := ops.tAbsolute;
            sSPIReadData.udReadOffset := 0;
            eInitSSW                  := _CheckChecksum; 
          end_if;
        else          
          eModuleInitState := ERROR;
          eInitState       := _NoCalibDataFound; 
          LogError("@013B (AI040::InitModule) Read SPI flash from ID 16#0A for calib data failed!");
          udSDOTimeout      := ops.tAbsolute;
          eInitSSWErrorStep := eInitSSW;
          eInitSSW          := _InitError;
        end_if;
      elsif TmpRetcode = ERROR then
        eModuleInitState := ERROR;
        LogError("@013C (AI040::InitModule) Failed to add read SPI SDO for calib configuration.");
        eInitState := _NoCalibDataFound;  
      // wait for response
      elsif ((ops.tAbsolute - udSDOTimeout) > (AI040_SDO_RESPONSE_TIMEOUT)) then
        LogError("@013D (AI040::InitModule) SDO Response timeout calib configuration.");
        eInitSSWErrorStep := eInitSSW;
        eInitSSW := _InitError;
      end_if;   


//**********************************************************************************************************************************************************
   _CheckChecksum:   
     ChecksumData.SPIHeader := sSPIReadData.IDHeader;
     ChecksumData.SPIData   := sReadCalibData;
     
     TmpChecksum := Checksum_SPI(pData          :=#ChecksumData$USINT+sizeof(sSPIReadData.IDHeader.CheckSum)
                                , uiDataLength  :=sizeof(ChecksumData)-sizeof(sSPIReadData.IDHeader.CheckSum)
                                );
                                
     if TmpChecksum = ChecksumData.SPIHeader.CheckSum then
       eInitSSW := _DisablePll;
     else   
        eModuleInitState := ERROR;
        LogError("@013E (AI040::InitModule) CRC check of spi calib data failed.");
        eInitState := _SPIChksumError;  
     end_if;
   
                 
//**********************************************************************************************************************************************************
    _DisablePll:    
      case eResponseState of
        //*****************************************************
        _idle:
          sPllRegister.bsStateControlReg := 0;
          TmpRetcode  := StartWriteSDO(hOffset  := AI040_PLL_CONTROL
                                      , usLength:= sizeof(sPllRegister.bsStateControlReg)
                                      , pWriteBuffer:=#sPllRegister.bsStateControlReg$USINT
                                      , eCommand:= SDIAS_SDO_CMD_CTRL_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@013F (AI040::InitModule) Failed to add write SDO for channel configuration, step DisablePll.");
            eInitState := _ClientNotready;
          end_if; 
       //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI040_SDO_RESPONSE_TIMEOUT) then
            LogError("@0140 (AI040::InitModule) SDO Response timeout, step DisablePll.");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          eInitSSW        := _ReadPll;
          eResponseState  := _idle;
        //*****************************************************
      end_case;
      
         
//**********************************************************************************************************************************************************
    _ReadPll:
      case eResponseState of
        _idle:
          // 
          if sSPIReadData.udReadOffset < sizeof(sPllRegister) then          
            sSPIReadData.udReadLength := sizeof(sPllRegister) - sSPIReadData.udReadOffset;
            if sSPIReadData.udReadLength > SDIAS_MAX_SDO_READ_LENGTH then              
              sSPIReadData.udReadLength := SDIAS_MAX_SDO_READ_LENGTH;
            end_if;           
            TmpRetcode  := StartReadSDO(hOffset   :=AI040_PLL_OFFSET + sSPIReadData.udReadOffset$HINT
                                        , usLength:=sSPIReadData.udReadLength$USINT
                                        , eCommand:=SDIAS_SDO_CMD_CTRL_READ);   
            if TmpRetcode = READY then
              udSDOTimeout      := ops.tAbsolute;
              eResponseState    := _wait; 
            elsif TmpRetcode = ERROR then
              eModuleInitState := ERROR;
              LogError("@0141 (AI040::InitModule) Failed to add read SDO to read pll.");
              eInitState := _PllError;
            end_if; 
          else
            sSPIReadData.udReadOffset := 0;
            eInitSSW := _Finish;             
          end_if;
          
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > SDIAS_SDO_TIMEOUT*2) then
            LogError("@0142 (AI040::InitModule) SDO Response timeout read pll.");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW      := _InitError;
          end_if;
          
        //*****************************************************
        _valid:
          sSPIReadData.udReadOffset += sSPIReadData.udReadLength$USINT;
          eResponseState    := _idle;
          eInitSSW          := _SetPll;
      end_case;          
 
         
//**********************************************************************************************************************************************************
    _SetPll:
      case eResponseState of
        _idle:                
          sSPIWriteData.usWriteOffset         := 0; 
          sPllRegister.udSystemPerTime        := udBusTime / 10;            // convert to 10*ns
          sPllRegister.bsStateControlReg      := 0;
          sPllRegister.bsStateControlReg.Soft_enable  := 1;
          sPllRegister.usSystemPeriodeDividier        := 1;
          //sPllRegister.CompensationDelay // Keep value
          sPllRegister.SyncOut0.uiOffset         := 0;
          sPllRegister.SyncOut0.usPeriodMulti    := 1; (*SetPllMultiplier();*)
          sPllRegister.SyncOut0.bsSyncStartDelay := 0;
          sPllRegister.SyncOut0.bsControlState.SyncEnable       := 1;
          sPllRegister.SyncOut0.bsControlState.StartDelayEnable := 0;
          sPllRegister.SyncOut0.bsControlState.SyncSelector     := 1;
          
          TmpRetcode  := StartWriteSDO(hOffset      :=AI040_PLL_OFFSET + sSPIWriteData.usWriteOffset
                                      , usLength    :=sizeof(sPLLRegister)
                                      , pWriteBuffer:=(#sPLLRegister+sSPIWriteData.usWriteOffset)$^USINT
                                      , eCommand    :=SDIAS_SDO_CMD_CTRL_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0143 (AI040::InitModule) Failed to add write SDO in step SetPll.");
            eInitState := _PllError;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI040_SDO_RESPONSE_TIMEOUT) then
            LogError("@0144 (AI040::InitModule) SDO Response timeout SetPll.");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          sSPIReadData.udReadOffset := 0;
          eInitSSW        := _Finish;
          eResponseState  := _idle;

        //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _Finish:
      eInitSSW         := _InitVariables;
      eModuleInitState := READY;
      eInitState       := _ClassOk;
      
//**********************************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      if (eInitState <> _InvalidConfguration) then
        eInitState  := _ClientNotready;
      end_if;  
  
  end_case;


END_FUNCTION


FUNCTION AI040::HWConfigModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
  END_VAR
  
  eModuleInitState := BUSY;

  case eConfigSSW of
//**********************************************************************************************************************************************************
    _ConfigIdle: 
      // actual config is now invalid
      AI1ConfigValid := NOT(bsConfigChanged.Channel1); 
      AI2ConfigValid := NOT(bsConfigChanged.Channel2); 
      AI3ConfigValid := NOT(bsConfigChanged.Channel3); 
      AI4ConfigValid := NOT(bsConfigChanged.Channel4); 
      // reset the value so we get every change done in rt after this line is passed (no changes get lost due to different task priorities)
      bsConfigChanged := 0;
     
      //set hardware config calib data for each channel
      CalibDataHW();
      sSPIWriteData.usWriteOffset   := AI040_CALIB_PMB_DATA;
      sSPIWriteData.usBytesToWrite  := sizeof(t_SDOCalibData)-AI040_CALIB_PMB_DATA;
      
      //switch off adc if first run
      if bInitADCBuffer then
        eConfigSSW := _DeactivateConversion;
        bInitADCBuffer := FALSE;
      else
        eConfigSSW := _WriteCalibData;
      end_if;
      
         
//**********************************************************************************************************************************************************
    _DeactivateConversion: 
      
      case eResponseState of
        _idle:          
          //stop measure of module 
          StartMeasure(bStartStop:=FALSE);
          
          TmpRetcode  := StartWriteSDO(hOffset      :=AI040_ADDR_ADCCONTROL_REGISTER
                                      , usLength    :=sizeof(sWriteADCStart)
                                      , pWriteBuffer:=#sWriteADCStart$USINT
                                      , eCommand    :=SDIAS_SDO_CMD_MEM_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0145 (AI040::HWConfigModule) Failed to add write SDO for hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;
          
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI040_SDO_RESPONSE_TIMEOUT) then
            LogError("@0146 (AI040::HWConfigModule) SDO Response timeout for write hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;
          
        //*****************************************************
        _valid:          
          eConfigSSW                    := _WriteCalibData;       
          eResponseState                := _idle;         
         
        //*****************************************************
      end_case;
    
        
//**********************************************************************************************************************************************************
    _WriteCalibData:
      case eResponseState of
        _idle:        
          sSPIWriteData.usBytesActWrite := sSPIWriteData.usBytesToWrite;
          if sSPIWriteData.usBytesActWrite > SDIAS_MAX_SDO_WRITE_LENGTH then
            sSPIWriteData.usBytesActWrite := SDIAS_MAX_SDO_WRITE_LENGTH;
          end_if;
          
          TmpRetcode  := StartWriteSDO(hOffset      :=AI040_ADDR_CALIB_REGISTER + sSPIWriteData.usWriteOffset
                                      , usLength    :=sSPIWriteData.usBytesActWrite
                                      , pWriteBuffer:=(#sWriteCalibData+sSPIWriteData.usWriteOffset)$^USINT
                                      , eCommand    :=SDIAS_SDO_CMD_MEM_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0145 (AI040::HWConfigModule) Failed to add write SDO for hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;
          
        //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI040_SDO_RESPONSE_TIMEOUT) then
            LogError("@0146 (AI040::HWConfigModule) SDO Response timeout for write hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;
          
        //*****************************************************
        _valid:
          sSPIWriteData.usBytesToWrite -= sSPIWriteData.usBytesActWrite;
          if sSPIWriteData.usBytesToWrite = 0 then  
            sSPIReadData.udReadOffset := 0;
            eConfigSSW        := _WriteConfigSDO;
            eResponseState  := _idle;
          else
            sSPIWriteData.usWriteOffset += sSPIWriteData.usBytesActWrite;
            eResponseState  := _idle;
            eConfigSSW        := _WriteCalibData;
          end_if;
      end_case;
      
    
    
//**********************************************************************************************************************************************************
    _WriteConfigSDO:
      case eResponseState of
        _idle:     
          TmpRetcode  := StartWriteSDO(hOffset      :=AI040_ADDR_HWCONTROL_REGISTER
                                      , usLength    :=sizeof(sHWControl)
                                      , pWriteBuffer:=#sHWControl$USINT
                                      , eCommand    :=SDIAS_SDO_CMD_MEM_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0145 (AI040::HWConfigModule) Failed to add write SDO for hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;
          
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI040_SDO_RESPONSE_TIMEOUT) then
            LogError("@0146 (AI040::HWConfigModule) SDO Response timeout for write hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;
          
        //*****************************************************
        _valid:          
          eConfigSSW     := _ActivateConversion;
          eResponseState := _idle;         
         
        //*****************************************************
      end_case;

      
//**********************************************************************************************************************************************************
    _ActivateConversion:   
          
      case eResponseState of
        _idle:    
          //start measure of module
          StartMeasure(bStartStop:=True);   
          TmpRetcode  := StartWriteSDO(hOffset      :=AI040_ADDR_ADCCONTROL_REGISTER
                                      , usLength    :=sizeof(sWriteADCStart)
                                      , pWriteBuffer:=#sWriteADCStart$USINT
                                      , eCommand    :=SDIAS_SDO_CMD_MEM_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0145 (AI040::HWConfigModule) Failed to add write SDO for hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;
          
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI040_SDO_RESPONSE_TIMEOUT) then
            LogError("@0146 (AI040::HWConfigModule) SDO Response timeout for write hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;
          
        //*****************************************************
        _valid:          
          eConfigSSW      := _FinishConfig;         
          eResponseState  := _idle;         
         
        //*****************************************************
      end_case;

      
//**********************************************************************************************************************************************************
    _FinishConfig:
      eConfigSSW       := _ConfigIdle;
      eModuleInitState := READY;
      
//**********************************************************************************************************************************************************
    _ErrorConfig:
      if AI1ConfigValid = 0 then
        AI1ConfigValid := -1;
      end_if;      
      if AI2ConfigValid = 0 then
        AI2ConfigValid := -1;
      end_if;      
      if AI3ConfigValid = 0 then
        AI3ConfigValid := -1;
      end_if;      
      if AI4ConfigValid = 0 then
        AI4ConfigValid := -1;
      end_if;
      eModuleInitState := ERROR; 
      eConfigSSW       := _ConfigIdle;
  
  end_case;


END_FUNCTION


FUNCTION VIRTUAL AI040::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);
   
 // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;    
  
  if eResult = READY then
    
    case eCommand of                
//**********************************************************************************************************************************************************
      //Memory Write
      SDIAS_SDO_CMD_MEM_WRITE:
        if eResponseState = _wait then
          eResponseState := _valid;
        end_if;                 
                
//**********************************************************************************************************************************************************
      //Memory Read
      SDIAS_SDO_CMD_MEM_READ:       
        if eResponseState = _wait then
          eResponseState := _valid;
        end_if;
          
//**********************************************************************************************************************************************************
      //Control Read
      SDIAS_SDO_CMD_CTRL_READ:
       
        if hOffset >= AI040_PLL_OFFSET 
         & hOffset < (AI040_PLL_OFFSET+sizeof(sPllRegister)) then          
          if eResponseState = _wait then
            eResponseState := _valid;
            _memcpy(ptr1:= (#sPllRegister + sSPIReadData.udReadOffset), ptr2:=pResponseBuffer, cntr:=sSPIReadData.udReadLength);
          end_if;            
        end_if;
        
//**********************************************************************************************************************************************************
      //Control write
      SDIAS_SDO_CMD_CTRL_WRITE:        
        if eResponseState = _wait then
          eResponseState := _valid;
        end_if;
        
    end_case;
    
    if eResponseState <> _valid then
      LogError("@0147 (AI040::ReceiveSDOResponse) Error in response data of SDO.");
      eInitSSW := _InitError;      
    end_if;
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@0148 (AI040::ReceiveSDOResponse) Error while writing configuration over sdo.");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@0149 (AI040::ReceiveSDOResponse) Error while reading configuration over sdo.");
      SDIAS_SDO_CMD_CTRL_READ:  
        LogError("@014A (AI040::ReceiveSDOResponse) Error while reading the pll configuration.");
      SDIAS_SDO_CMD_CTRL_WRITE:  
        LogError("@014B (AI040::ReceiveSDOResponse) Error while writing the pll configuration.");
    end_case;
    eInitSSW := _InitError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//look if it is right hardware
	if ( udID2Check <> DEVICE_ID_AI040 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;

END_FUNCTION


FUNCTION VIRTUAL AI040::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR
  
  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_CY;

END_FUNCTION


FUNCTION AI040::ResetServer
    
  //Invalid Input-Values
  AI1 := AI040_INVALID_VALUE;
  AI2 := AI040_INVALID_VALUE;
  AI3 := AI040_INVALID_VALUE;
  AI4 := AI040_INVALID_VALUE;
  AI1ConfigValid := -1;
  AI2ConfigValid := -1;
  AI3ConfigValid := -1;
  AI4ConfigValid := -1;
  
END_FUNCTION


FUNCTION AI040::AI040
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_AI040;

END_FUNCTION


FUNCTION GLOBAL AI040::GetSettings
	VAR_INPUT
		usChannelNr 	: USINT;
		pSampleRate 	: ^LREAL;(* := NIL *)
		pMaxValuesCycle 	: ^UINT;(* := NIL *)
		pConversionTime 	: ^USINT;(* := NIL *)
		pChannelsActive 	: ^USINT;(* := NIL *)
		pBusCycleTime 	: ^UDINT;(* := NIL *)
		pMultiplier 	: ^DINT;(* := NIL *)
		pDivisor 	: ^DINT;(* := NIL *)
		pOffset 	: ^DINT;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
   
  dRetCode := 0;
  
  if pSampleRate <> NIL then
  pSampleRate^ := 0;
    if sMeasureControl.ArrayAssignment.ChActivated then
      pSampleRate^ := to_lreal(AI040_1S_TO_MICROSECOND/(to_dint(sMeasureControl.ArrayAssignment.ChActivated) * sHWControl.ConversionTime));
    end_if;    
  end_if;
  
  if pMaxValuesCycle <> NIL then
    pMaxValuesCycle^  := uiMaxValuesCycle$UINT;  
  end_if;

  if pConversionTime <> NIL then
    pConversionTime^  := sHWControl.ConversionTime;  
  end_if;

  if pChannelsActive <> NIL then
    pChannelsActive^  := sMeasureControl.ArrayAssignment.ChActivated; 
  end_if;

  if pBusCycleTime <> NIL then
    pBusCycleTime^    := udBusCycleTimeMicroSec*1000; //bus cycle time as nanosecond
  end_if;
  
  
  case usChannelNr of
  //analog input 1
  //*************************************************************************************************************
    1:  
      if pMultiplier then
        pMultiplier^ := sScaleSettings.Multiplier.Channel1;
      end_if;
      if pDivisor then
        pDivisor^ := sScaleSettings.Divider.Channel1;
      end_if;      
      if pOffset then
        pOffset^ := sScaleSettings.Offset.Channel1;
      end_if;
    
  //analog input 2
  //*************************************************************************************************************
    2:
      if pMultiplier then
        pMultiplier^ := sScaleSettings.Multiplier.Channel2;
      end_if;
      if pDivisor then
        pDivisor^ := sScaleSettings.Divider.Channel2;
      end_if;
      if pOffset then
        pOffset^ := sScaleSettings.Offset.Channel2;
      end_if;
    
  //analog input 3
  //*************************************************************************************************************
    3:
      if pMultiplier then
        pMultiplier^ := sScaleSettings.Multiplier.Channel3;
      end_if;
      if pDivisor then
        pDivisor^ := sScaleSettings.Divider.Channel3;
      end_if;
      if pOffset then
        pOffset^ := sScaleSettings.Offset.Channel3;
      end_if;
    
  //analog input 4
  //*************************************************************************************************************
    4:
      if pMultiplier then
        pMultiplier^ := sScaleSettings.Multiplier.Channel4;
      end_if;
      if pDivisor then
        pDivisor^ := sScaleSettings.Divider.Channel4;
      end_if;
      if pOffset then
        pOffset^ := sScaleSettings.Offset.Channel4;
      end_if;
     
  //****************************************************** 
    else
      dRetCode := -2;  //requested channel is not available
  end_case;
  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::AI1Gain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR  
  
  // restrict to valid range
  if input < 0 then
    input := 0;
  elsif input > 7 then
    input := 7;
  elsif input = 3 
  | input = 5 then
    input := 0;
  end_if;
  
  if bInitADCBuffer then
    AI1Gain := -1;
  end_if;
  
  if ((input <> AI1Gain) 
  & (AI1ConfigValid <> 0)) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 = TRUE)  then
    AI1Gain        := input;
    bsConfigChanged.Channel1 := TRUE;
    result         := AI1Gain;    
    sHWControl.HWControlCh1.CurrentGain1 := (AI1Gain and 1)$BOOL;
    sHWControl.HWControlCh1.CurrentGain2 := ((AI1Gain shr 1) and 1)$BOOL;    
    sHWControl.HWControlCh1.CurrentGain3 := ((AI1Gain shr 2) and 1)$BOOL;  
  else
    result := ACCESS_DENIED;    
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::AI1CurrentSource::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  // restrict to valid range
  if input < 0 then
    input := 0;
  elsif input > 3 then
    input := 3;
  end_if;
  
  if bInitADCBuffer then
    AI1CurrentSource := -1;
  end_if;
  
  if ((input <> AI1CurrentSource) 
  & (AI1ConfigValid <> 0)) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 = TRUE)  then
    AI1CurrentSource  := input;
    bsConfigChanged.Channel1    := TRUE;
    result            := AI1CurrentSource;
    
    sHWControl.HWControlCh1.CurrentSource1 := (AI1CurrentSource and 1)$BOOL;
    sHWControl.HWControlCh1.CurrentSource2 := ((AI1CurrentSource shr 1) and 1)$BOOL;  
  else    
    result := ACCESS_DENIED;    
  end_if;
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::AI2Gain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // restrict to valid range  
  if input < 0 then
    input := 0;
  elsif input > 7 then
    input := 7;
  elsif input = 3 
  | input = 5 then
    input := 0;
  end_if;
  
  if bInitADCBuffer then
    AI2Gain := -1;
  end_if;
  
  if ((input <> AI2Gain) 
  & (AI2ConfigValid <> 0)) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 = TRUE)  then
    AI2Gain        := input;
    bsConfigChanged.Channel2 := TRUE;
    result         := AI2Gain;    
    sHWControl.HWControlCh2.CurrentGain1 := (AI2Gain and 1)$BOOL;
    sHWControl.HWControlCh2.CurrentGain2 := ((AI2Gain shr 1) and 1)$BOOL;    
    sHWControl.HWControlCh2.CurrentGain3 := ((AI2Gain shr 2) and 1)$BOOL;  
  else
    result := ACCESS_DENIED;    
  end_if;  
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::AI2CurrentSource::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  // restrict to valid range
  if input < 0 then
    input := 0;
  elsif input > 3 then
    input := 3;
  end_if;
  
  if bInitADCBuffer then
    AI2CurrentSource := -1;
  end_if;
  
  if ((input <> AI2CurrentSource) 
  & (AI2ConfigValid <> 0)) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 = TRUE)  then
    AI2CurrentSource  := input;
    bsConfigChanged.Channel2    := TRUE;
    result            := AI2CurrentSource;
    
    sHWControl.HWControlCh2.CurrentSource1 := (AI2CurrentSource and 1)$BOOL;
    sHWControl.HWControlCh2.CurrentSource2 := ((AI2CurrentSource shr 1) and 1)$BOOL;  
  else    
    result := ACCESS_DENIED;    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::AI3Gain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // restrict to valid range  
  if input < 0 then
    input := 0;
  elsif input > 7 then
    input := 7;
  elsif input = 3 
  | input = 5 then
    input := 0;
  end_if;
  
  if bInitADCBuffer then
    AI3Gain := -1;
  end_if;
  
  if ((input <> AI3Gain) 
  & (AI3ConfigValid <> 0)) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 = TRUE)  then
    AI3Gain        := input;
    bsConfigChanged.Channel3 := TRUE;
    result         := AI3Gain;    
    sHWControl.HWControlCh3.CurrentGain1 := (AI3Gain and 1)$BOOL;
    sHWControl.HWControlCh3.CurrentGain2 := ((AI3Gain shr 1) and 1)$BOOL;    
    sHWControl.HWControlCh3.CurrentGain3 := ((AI3Gain shr 2) and 1)$BOOL;  
  else
    result := ACCESS_DENIED;    
  end_if;  
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::AI3CurrentSource::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  // restrict to valid range
  if input < 0 then
    input := 0;
  elsif input > 3 then
    input := 3;
  end_if;
  
  if bInitADCBuffer then
    AI3CurrentSource := -1;
  end_if;
  
  if ((input <> AI3CurrentSource) 
  & (AI3ConfigValid <> 0)) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 = TRUE)  then
    AI3CurrentSource  := input;
    bsConfigChanged.Channel3    := TRUE;
    result            := AI3CurrentSource;
    
    sHWControl.HWControlCh3.CurrentSource1 := (AI3CurrentSource and 1)$BOOL;
    sHWControl.HWControlCh3.CurrentSource2 := ((AI3CurrentSource shr 1) and 1)$BOOL;  
  else    
    result := ACCESS_DENIED;    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::AI4Gain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
	
  // restrict to valid range
  if input < 0 then
    input := 0;
  elsif input > 7 then
    input := 7;
  elsif input = 3 
  | input = 5 then
    input := 0;
  end_if;
  
  if bInitADCBuffer then
    AI4Gain := -1;
  end_if;
  
  if ((input <> AI4Gain) 
  & (AI4ConfigValid <> 0)) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 = TRUE)  then
    AI4Gain                  := input;
    bsConfigChanged.Channel4 := TRUE;
    result                   := AI4Gain;    
    sHWControl.HWControlCh4.CurrentGain1 := (AI4Gain and 1)$BOOL;
    sHWControl.HWControlCh4.CurrentGain2 := ((AI4Gain shr 1) and 1)$BOOL;    
    sHWControl.HWControlCh4.CurrentGain3 := ((AI4Gain shr 2) and 1)$BOOL;  
  else
    result := ACCESS_DENIED;    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI040::AI4CurrentSource::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR  
  
  // restrict to valid range
  if input < 0 then
    input := 0;
  elsif input > 3 then
    input := 3;
  end_if;
  
  if bInitADCBuffer then
    AI4CurrentSource := -1;
  end_if;
  
  if ((input <> AI4CurrentSource) 
  & (AI4ConfigValid <> 0)) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 = TRUE)  then
    AI4CurrentSource         := input;
    bsConfigChanged.Channel4 := TRUE;
    result                   := AI4CurrentSource;
    
    sHWControl.HWControlCh4.CurrentSource1 := (AI4CurrentSource and 1)$BOOL;
    sHWControl.HWControlCh4.CurrentSource2 := ((AI4CurrentSource shr 1) and 1)$BOOL;  
  else    
    result := ACCESS_DENIED;    
  end_if;  
  
END_FUNCTION


FUNCTION AI040::CalibDataHW
VAR
	dTempArray : DINT;
  dTempGain  : DINT;
END_VAR

  //analog input 1
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 = TRUE then
    dTempArray := AI1Gain;   

    case dTempArray of
    //*************************************
      0:  dTempGain  := 1;
    //*************************************
      1:  dTempGain  := 2;
    //*************************************
      2:  dTempGain  := 4;
    //*************************************
      4:  dTempGain  := 8;
          dTempArray := 3;
    //*************************************
      6:  dTempGain  := 16;
          dTempArray := 4;
    //*************************************
      7:  dTempGain  := 32;
          dTempArray := 5;
    end_case;    
    //if raw values is selected dont correct gain factor  
    if sScaleSettings.bRawValue.Channel1 = TRUE  then
      dTempGain := 1;
    end_if;    
    
    sWriteCalibData.Divisor.Channel1    := sReadCalibData.Channel1[dTempArray].Divisor;
    sWriteCalibData.Multiplier.Channel1 := sReadCalibData.Channel1[dTempArray].Multiplier;
    sWriteCalibData.Offset.Channel1     := sReadCalibData.Channel1[dTempArray].Offset;
    //if there is no valid calib data set it to mul and div to 1
    if sWriteCalibData.Divisor.Channel1 = 0 then      
      sWriteCalibData.Divisor.Channel1    := 1;
      sWriteCalibData.Multiplier.Channel1 := 1;
      sWriteCalibData.Offset.Channel1     := 0;    
    end_if;
  end_if;
  
  //analog input 2
  //*************************************************************************************************************
 if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 = TRUE then
    dTempArray := AI2Gain;
    
    case dTempArray of
    //*************************************
      0:  dTempGain  := 1;
    //*************************************
      1:  dTempGain  := 2;
    //*************************************
      2:  dTempGain  := 4;
    //*************************************
      4:  dTempGain  := 8;
          dTempArray := 3;
    //*************************************
      6:  dTempGain  := 16;
          dTempArray := 4;
    //*************************************
      7:  dTempGain  := 32;
          dTempArray := 5;
    end_case;
    //if raw values is selected dont correct gain factor  
    if sScaleSettings.bRawValue.Channel2 = TRUE then
      dTempGain := 1;
    end_if;
    
    sWriteCalibData.Divisor.Channel2    := sReadCalibData.Channel2[dTempArray].Divisor;
    sWriteCalibData.Multiplier.Channel2 := sReadCalibData.Channel2[dTempArray].Multiplier;
    sWriteCalibData.Offset.Channel2     := sReadCalibData.Channel2[dTempArray].Offset;
    //if there is no valid calib data set it to mul and div to 1
    if sWriteCalibData.Divisor.Channel2 = 0 then      
      sWriteCalibData.Divisor.Channel2    := 1;
      sWriteCalibData.Multiplier.Channel2 := 1;
      sWriteCalibData.Offset.Channel2     := 0;    
    end_if;
  end_if;
  
  //analog input 3
  //*************************************************************************************************************
if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 = TRUE then
    dTempArray := AI3Gain;
    
    case dTempArray of
    //*************************************
      0:  dTempGain  := 1;
    //*************************************
      1:  dTempGain  := 2;
    //*************************************
      2:  dTempGain  := 4;
    //*************************************
      4:  dTempGain  := 8;
          dTempArray := 3;
    //*************************************
      6:  dTempGain  := 16;
          dTempArray := 4;
    //*************************************
      7:  dTempGain  := 32;
          dTempArray := 5;
    end_case;
    //if raw values is selected dont correct gain factor  
    if sScaleSettings.bRawValue.Channel3 = TRUE then
      dTempGain := 1;
    end_if;
    
    sWriteCalibData.Divisor.Channel3    := sReadCalibData.Channel3[dTempArray].Divisor;
    sWriteCalibData.Multiplier.Channel3 := sReadCalibData.Channel3[dTempArray].Multiplier;
    sWriteCalibData.Offset.Channel3     := sReadCalibData.Channel3[dTempArray].Offset;
    //if there is no valid calib data set it to mul and div to 1
    if sWriteCalibData.Divisor.Channel3 = 0 then      
      sWriteCalibData.Divisor.Channel3    := 1;
      sWriteCalibData.Multiplier.Channel3 := 1;
      sWriteCalibData.Offset.Channel3     := 0;    
    end_if;
  end_if;
  
  //analog input 4
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 = TRUE then
    dTempArray := AI4Gain;
    
    case dTempArray of
    //*************************************
      0:  dTempGain  := 1;
    //*************************************
      1:  dTempGain  := 2;
    //*************************************
      2:  dTempGain  := 4;
    //*************************************
      4:  dTempGain  := 8;
          dTempArray := 3;
    //*************************************
      6:  dTempGain  := 16;
          dTempArray := 4;
    //*************************************
      7:  dTempGain  := 32;
          dTempArray := 5;
    end_case;
    
    //if raw values is selected dont correct gain factor  
    if sScaleSettings.bRawValue.Channel4 = TRUE then
      dTempGain := 1;
    end_if;
    
    sWriteCalibData.Divisor.Channel4    := sReadCalibData.Channel4[dTempArray].Divisor;
    sWriteCalibData.Multiplier.Channel4 := sReadCalibData.Channel4[dTempArray].Multiplier;
    sWriteCalibData.Offset.Channel4     := sReadCalibData.Channel4[dTempArray].Offset;
    //if there is no valid calib data set it to mul and div to 1
    if sWriteCalibData.Divisor.Channel4 = 0 then      
      sWriteCalibData.Divisor.Channel4    := 1;
      sWriteCalibData.Multiplier.Channel4 := 1;
      sWriteCalibData.Offset.Channel4     := 0;    
    end_if;
  end_if;  

END_FUNCTION

FUNCTION VIRTUAL GLOBAL AI040::DisconnectEvent

  SdiasBase::DisconnectEvent();

END_FUNCTION

FUNCTION AI040::SetScale
VAR_OUTPUT
  eModuleInitState 	: iprStates;
END_VAR
VAR
	dScale : DINT;
END_VAR
  
  eModuleInitState := READY;
  
  //analog input 1
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 then 
    AI1MaxValue  := AI1MaxValue.Read();
    AI1MinValue  := AI1MinValue.Read(); 
    
    //check if calculation is necessary
    if ((AI1MaxValue <> AI040_FIRMWARE_MAX) | (AI1MinValue <> AI040_FIRMWARE_MIN)) then
    
      ScaleAI1 := TRUE; 
      
      dScale := AI1MaxValue-AI1MinValue;    
      
      if dScale = 0 then
        eModuleInitState := ERROR;
        eInitState := _InvalidConfguration;
        LogValue("@014C (AI040::SetScale) Invalid minimal and maximal value settings for channel {0}. The values must not be the same.",1);
        return;
      end_if;
      
      sScaleSettings.Multiplier.Channel1 := dScale;
      sScaleSettings.Divider.Channel1 := (AI040_FIRMWARE_MAX - AI040_FIRMWARE_MIN);      
      sScaleSettings.Offset.Channel1  := (AI1MinValue * sScaleSettings.Divider.Channel1)/(sScaleSettings.Multiplier.Channel1) - AI040_FIRMWARE_MIN;
    else
      sScaleSettings.Offset.Channel1 := 0;
    end_if;
  end_if;
  
  //analog input 2
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 then 
    AI2MaxValue  := AI2MaxValue.Read();
    AI2MinValue  := AI2MinValue.Read(); 
    
    //check if calculation is necessary
    if ((AI2MaxValue <> AI040_FIRMWARE_MAX) | (AI2MinValue <> AI040_FIRMWARE_MIN)) then
    
      ScaleAI2 := TRUE; 
      
      dScale := AI2MaxValue-AI2MinValue;

      if dScale = 0 then
        eModuleInitState := ERROR;
        eInitState := _InvalidConfguration;
        LogValue("@014C (AI040::SetScale) Invalid minimal and maximal value settings for channel {0}. The values must not be the same.",2);  
        return;
      end_if;

      sScaleSettings.Multiplier.Channel2 := dScale;
      sScaleSettings.Divider.Channel2 := (AI040_FIRMWARE_MAX - AI040_FIRMWARE_MIN);      
      sScaleSettings.Offset.Channel2  := (AI2MinValue * sScaleSettings.Divider.Channel2)/(sScaleSettings.Multiplier.Channel2) - AI040_FIRMWARE_MIN;
    else
      sScaleSettings.Offset.Channel2 := 0;
    end_if;
  end_if; 
  
  //analog input 3
  //*************************************************************************************************************  
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 then 
    AI3MaxValue  := AI3MaxValue.Read();
    AI3MinValue  := AI3MinValue.Read();
    
    //check if calculation is necessary
    if ((AI3MaxValue <> AI040_FIRMWARE_MAX) | (AI3MinValue <> AI040_FIRMWARE_MIN)) then
    
      ScaleAI3 := TRUE;  
    
      dScale := AI3MaxValue-AI3MinValue;

      if dScale = 0 then
        eModuleInitState := ERROR;
        eInitState := _InvalidConfguration;
        LogValue("@014C (AI040::SetScale) Invalid minimal and maximal value settings for channel {0}. The values must not be the same.",3);  
        return;
      end_if;

      sScaleSettings.Multiplier.Channel3 := dScale;
      sScaleSettings.Divider.Channel3    := (AI040_FIRMWARE_MAX - AI040_FIRMWARE_MIN);      
      sScaleSettings.Offset.Channel3     := (AI3MinValue * sScaleSettings.Divider.Channel3)/(sScaleSettings.Multiplier.Channel3) - AI040_FIRMWARE_MIN;
    else
      sScaleSettings.Offset.Channel3 := 0;
    end_if;
  end_if; 
  
  //analog input 4
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 then 
    AI4MaxValue  := AI4MaxValue.Read();
    AI4MinValue  := AI4MinValue.Read(); 

    //check if calculation is necessary
    if ((AI4MaxValue <> AI040_FIRMWARE_MAX) | (AI4MinValue <> AI040_FIRMWARE_MIN)) then
    
      ScaleAI4 := TRUE;
    
      dScale := AI4MaxValue-AI4MinValue;

      if dScale = 0 then
        eModuleInitState := ERROR;
        eInitState := _InvalidConfguration;
        LogValue("@014C (AI040::SetScale) Invalid minimal and maximal value settings for channel {0}. The values must not be the same.",4);  
        return;
      end_if;

      sScaleSettings.Multiplier.Channel4 := dScale;
      sScaleSettings.Divider.Channel4    := (AI040_FIRMWARE_MAX - AI040_FIRMWARE_MIN);      
      sScaleSettings.Offset.Channel4     := (AI4MinValue * sScaleSettings.Divider.Channel4)/(sScaleSettings.Multiplier.Channel4) - AI040_FIRMWARE_MIN;
    else
      sScaleSettings.Offset.Channel4 := 0;
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL AI040::ClassState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  VAR
  	udActDataCount  : UDINT;
  END_VAR

	CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
    SDIAS_CLT_GET_ANALOG_DATA_BUFFER:
      // init with error, ok is set later
      ret_code := ERROR;
      
      if pPara^.aPara[0] = 1 then
        // request is version 1
      
        // check valid channel nr
        if (pPara^.aPara[1] >= 1) & (pPara^.aPara[1] <= 4) then
          
          // init result
          ret_code := READY;
          pResult^.aData[0x0]       := 1; //version 1
          pResult^.aData[0x1]       := AI040_SIZE_ONE_VALUE;
          pResult^.aData[0x2]$UDINT := to_udint(uiMaxValuesCycle);
          pResult^.aData[0x6]$UDINT := 0; // copied amount is set later
          pResult^.aData[0xA]$UDINT := 0; // no counter
          pResult^.aData[0xB]$UDINT := 0; // so set counter to 0
          
          // copy requested data amount, limit to avaliable data
          if (pPara^.aPara[2] <> NIL) & (pPara^.aPara[3]$UDINT > 0) then
            udActDataCount := pPara^.aPara[3]$UDINT;
            if (udActDataCount AND 1) = 1 then
              udActDataCount -= 1; // only whole values
            end_if;
            if udActDataCount > (uiMaxValuesCycle*AI040_SIZE_ONE_VALUE) then
              udActDataCount := (uiMaxValuesCycle*AI040_SIZE_ONE_VALUE);
            end_if;
            if GetData(usChannelNr:= pPara^.aPara[1]$USINT, uiDataLength:=udActDataCount$UINT, pBufferData:=pPara^.aPara[2]$^INT) = 0 then
              pResult^.aData[6]$UDINT := udActDataCount / AI040_SIZE_ONE_VALUE;
            //else
              // no data copied, probably data is INVALID
            end_if;
          //else
            //no data requested
          end_if;
        //else
          // wrong channel
        end_if;
      //else
        // unknown version of the request
      end_if;

//**********************************************************************************************************************************************************
  ELSE
    // we forward this message to the base class
		ret_code := SdiasBase::NewInst(pPara, pResult);
	END_CASE;

END_FUNCTION