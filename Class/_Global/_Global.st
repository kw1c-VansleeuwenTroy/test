//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_Global"
	Revision           = "0.15"
	GUID               = "{AE55EEC1-6C6D-11D5-8BC6-0048545E8899}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_Global\Global.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "unrestricted user-interfaces">
	<Channels>
		<Server Name="Server0" GUID="{AE55EEC2-6C6D-11D5-8BC6-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="Lse" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.15" Date="2018-10-18" Author="kolott" Company="sigmatek" Description="DEVSW-615, SA 42018: new virtual method IF_Progress() added"/>
		<Dokumentation Revision="0.14" Date="2016-11-07" Author="kolott" Company="sigmatek" Description="new virtual method IF_WindowMoveable() added"/>
		<Dokumentation Revision="0.13" Date="2016-07-25" Author="kolott" Company="sigmatek" Description="new virtual method IF_WritePost() added"/>
		<Dokumentation Revision="0.12" Date="2013-03-26" Author="kolott" Company="sigmatek" Description="new virtual methods IF_ProjectStart(), IF_ProjectRun() and IF_ProjectEnd() are added&#13;&#10;icon added"/>
		<Dokumentation Revision="0.11" Date="2012-06-19" Author="kolott" Company="sigmatek" Description="new method to detect if virtual method is overwritten"/>
		<Dokumentation Revision="0.10" Date="2011-10-07" Author="kolott" Company="sigmatek" Description="new method IF_CantWritoNoAccess"/>
		<Dokumentation Revision="0.9" Date="2011-08-10" Author="kolott" Company="sigmatek" Description="some corrections in comment of methodes"/>
		<Dokumentation Revision="0.8" Date="2011-06-10" Author="kolott" Company="sigmatek" Description="IF_Stop modification to get message on screen"/>
	</RevDoku>
</Class>
*)
_Global : CLASS
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
	Lse 	: CltChCmd__Lse;
  //Variables:
		FirstTime 	: BOOL;
  //Functions:
	
	FUNCTION _Global
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowStart
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			firsttime 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowReady
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			firsttime 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowRun
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowEnd
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_UserCall
		VAR_INPUT
			no 	: DINT;
			para 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_AccessInput
		VAR_INPUT
			pi 	: ^_INPUT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="bool" Name="IF_AccessInput.retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_ChkEnable
		VAR_INPUT
			key 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_SystemError
		VAR_INPUT
			errno 	: DINT;
			para 	: DINT;
			ptxt 	: ^_CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="function is called in case of an recalculation (formula) defined for a data-server&#13;&#10;pres ....... --&gt; to value&#13;&#10;pv ......... --&gt; to variable&#13;&#10;direction .. direction (TRUE Y=kX+d, FALSE X=(Y+d)/k)&#13;&#10;retcode .... return TRUE if kernel should do the calculation, on the other hand return FALSE&#13;&#10;" Name="IF_Recalculate"/>
	FUNCTION VIRTUAL GLOBAL IF_Recalculate
		VAR_INPUT
			pres 	: ^_RESULT;
			pv 	: ^_VARIABLE;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_DrawBubbleHelp
		VAR_INPUT
			pedit 	: ^_EDITOR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_Init;
	
	FUNCTION VIRTUAL GLOBAL IF_UrInit;
				//! <Function Comment="methode will be called right before lse-project will be loaded" Name="IF_ProjectStart"/>
	FUNCTION VIRTUAL GLOBAL IF_ProjectStart;
				//! <Function Comment="methode will be called after lse-project is successfully loaded and &#13;&#10;possibly given communication to extern plc is stable" Name="IF_ProjectReady"/>
	FUNCTION VIRTUAL GLOBAL IF_ProjectReady
		VAR_INPUT
			state 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_ProjectRun
		VAR_INPUT
			pe 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="Methode will be called when lse-project will end (eg.:softreset or lse-project download on the fly)" Name="IF_ProjectEnd"/>
	FUNCTION VIRTUAL GLOBAL IF_ProjectEnd;
	
	FUNCTION VIRTUAL GLOBAL IF_InputIsSaved
		VAR_INPUT
			pi 	: ^_INPUT;
			pr 	: ^_RESULT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_PowerDown;
				//! <Function Comment="method is called when input is identified unambiguous by touch and&#13;&#10;the editor can&apos;t open because access is denied.&#13;&#10;" Name="IF_InputWithoutAccess"/>
	FUNCTION VIRTUAL GLOBAL IF_InputWithoutAccess
		VAR_INPUT
			pi 	: ^_INPUT;
			pvi 	: ^_VARINFO;
		END_VAR;
				//! <Function Comment="method is called every time when input will be selected" Name="IF_OpenEditor"/>
	FUNCTION VIRTUAL GLOBAL IF_OpenEditor
		VAR_INPUT
			pedit 	: ^_EDITOR;
		END_VAR;
				//! <Function Comment="this method is called before a value is written into the system&#13;&#10;set return parameter with FALSE if you want to prohibit&#13;&#10;otherwise value will be written into system&#13;&#10;" Name="IF_Write"/>
	FUNCTION VIRTUAL GLOBAL IF_Write
		VAR_INPUT
			pres 	: ^_RESULT;
			pvar 	: ^_VARIABLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="this method is called right after a value is successfully written into system" Name="IF_WritePost"/>
	FUNCTION VIRTUAL GLOBAL IF_WritePost
		VAR_INPUT
			pres 	: ^_RESULT;
			pvar 	: ^_VARIABLE;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_CheckPrefix
		VAR_INPUT
			varno 	: UDINT;
			vi 	: ^_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_FoundSomethingByHid
		VAR_INPUT
			ima 	: _FOUNDHID;
		END_VAR;
				//! <Function Comment="method is called by the kernel right before a menu will be opend.&#13;&#10;the first parameter is a pointer to structure where the menudata like color,&#13;&#10;shape, lines etc. will be stored&#13;&#10;the second parameter is a pointer to the menunumber initialiced by lse&#13;&#10;return TRUE when structure is initialized by your own, &#13;&#10;on the other hand (FALSE) kernel will try to initialize data.&#13;&#10;" Name="IF_PopUpCall"/>
	FUNCTION VIRTUAL GLOBAL IF_PopUpCall
		VAR_INPUT
			pm 	: ^_MENU;
			pno 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is called right before the kernel wants to open a toucheditor&#13;&#10;the parameter &apos;pe&apos; is a pointer to structure where the whole editorinformation is shown&#13;&#10;parameter preselect is the windownumber of the editor &#13;&#10;return &apos;preselect&apos; if you want the kernel to open the editor, on the other hand 16#FFFF&#13;&#10;" Name="IF_OpenTouchEditor"/>
	FUNCTION VIRTUAL GLOBAL IF_OpenTouchEditor
		VAR_INPUT
			pe 	: ^_EDITOR;
			preselect 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_AccessButton
		VAR_INPUT
			pb 	: ^_BUTTON;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_LanguageHasChanged
		VAR_INPUT
			actno 	: UINT;
			oldno 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_LanguageWillChange
		VAR_INPUT
			newno 	: UINT;
			oldno 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_Offline
		VAR_INPUT
			station 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_OverloadEditor
		VAR_INPUT
			pm 	: ^_PICTUREMASK;
			whoami 	: ^_WHOAMI;
			pvl 	: ^_VARLABEL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_ConfigDriveList
		VAR_INPUT
			drvlst 	: ^CHAR;
			puser 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_Stop
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_Online
		VAR_INPUT
			station 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_TryToAccess
		VAR_INPUT
			ptx 	: ^void;
			state 	: _ACCESSFAILED;
			found 	: _FOUNDHID;
			preselect 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_CheckHeap
		VAR_INPUT
			display 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: _DOIT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_SwitchMultiStation
		VAR_INPUT
			station 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_ScreenSaverWillStart
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_ScreenSaverWillEnd
		VAR_INPUT
			pev 	: ^_EVENT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_Beep
		VAR_INPUT
			whobeep 	: _WHOBEEP;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_IpcIni
		VAR_INPUT
			pini 	: ^_IPCINI;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_UserStation
		VAR_INPUT
			station 	: UINT;
			pcd 	: ^_COMDEF;
			pobserve 	: ^BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Methode will be called each time when user will set value and correct accesslevel is not given&#13;&#10;return &apos;true&apos; to force write, on the other hand &apos;false&apos;" Name="IF_CantWriteNoAccess"/>
	FUNCTION VIRTUAL GLOBAL IF_CantWriteNoAccess
		VAR_INPUT
			pres 	: ^_RESULT;
			pvl 	: ^_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="is used to detect if method is overwritten" Name="IsMethodOverwritten"/>
	FUNCTION IsMethodOverwritten
		VAR_INPUT
			vmn 	: UDINT;
			pmeth 	: ^void;
			globit 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
				//! <Function Comment="method is called to get information if window is moveable by user.&#13;&#10;return &apos;true&apos; if window is moveable, on the other hand &apos;false&apos;" Name="IF_WindowMoveable"/>
	FUNCTION VIRTUAL GLOBAL IF_WindowMoveable
		VAR_INPUT
			whoami 	: ^_WHOAMI;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_Progress
		VAR_INPUT
			pscan 	: ^_SCAN;
			visible 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Server0::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Lse


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _Global::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__GLOBAL
0$UINT, 15$UINT, (SIZEOF(::_Global))$UINT, 
1$UINT, 1$UINT, 0$UINT, 
TO_UDINT(3788417926), "_Global", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_Global.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
(::_Global.Lse.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(299963966), "Lse", TO_UDINT(1552551876), "_Lse", 0$UINT, 128$UINT, 
END_FUNCTION


#define USER_CNT__Global 45

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__Global] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _Global::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__Global, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #IF_WindowStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #IF_WindowReady();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IF_WindowRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #IF_WindowEnd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #IF_UserCall();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_AccessInput();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #IF_ChkEnable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_SystemError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #IF_Recalculate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #IF_DrawBubbleHelp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #IF_Init();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #IF_UrInit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #IF_ProjectStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #IF_ProjectReady();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #IF_ProjectRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #IF_ProjectEnd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #IF_InputIsSaved();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #IF_PowerDown();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #IF_InputWithoutAccess();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #IF_OpenEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #IF_Write();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #IF_WritePost();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #IF_CheckPrefix();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #IF_FoundSomethingByHid();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #IF_PopUpCall();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #IF_OpenTouchEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #IF_AccessButton();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #IF_LanguageHasChanged();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #IF_LanguageWillChange();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #IF_Offline();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #IF_OverloadEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #IF_ConfigDriveList();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #IF_Stop();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #IF_Online();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #IF_TryToAccess();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #IF_CheckHeap();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #IF_SwitchMultiStation();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #IF_ScreenSaverWillStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #IF_ScreenSaverWillEnd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #IF_Beep();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #IF_IpcIni();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #IF_UserStation();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[42]		:= #IF_CantWriteNoAccess();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #IF_WindowMoveable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[44]		:= #IF_Progress();

#pragma warning (default : 74)
	Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _Global();

END_FUNCTION

//{{LSL_IMPLEMENTATION

#pragma warning (disable : 73)

var_private
  vmn_ifwinstart, vmn_ifwinready, vmn_ifwinrun, vmn_ifwinend : udint;
  vmn_ifaccessinput, vmn_ifaccessbutton, vmn_ifchkenable : udint;
  vmn_ifrecalc, vmn_ifusercall, vmn_iffoundhid, vmn_iftrytoaccess : udint;
  vmn_ifprjrun, vmn_ifwinmoveable : udint;
end_var

FUNCTION  _Global::_Global
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR

  ret_code  := C_OK;
  FirstTime := TRUE; 

  vmn_ifwinstart     := GetVirtualMethodNumber(this, #IF_WindowStart());
  vmn_ifwinready     := GetVirtualMethodNumber(this, #IF_WindowReady());
  vmn_ifwinrun       := GetVirtualMethodNumber(this, #IF_WindowRun());
  vmn_ifwinend       := GetVirtualMethodNumber(this, #IF_WindowEnd());
  vmn_ifrecalc       := GetVirtualMethodNumber(this, #IF_Recalculate());
  vmn_ifaccessinput  := GetVirtualMethodNumber(this, #IF_AccessInput()); 
  vmn_ifaccessbutton := GetVirtualMethodNumber(this, #IF_AccessButton());
  vmn_ifchkenable    := GetVirtualMethodNumber(this, #IF_ChkEnable());
  vmn_ifusercall     := GetVirtualMethodNumber(this, #IF_UserCall());
  vmn_iffoundhid     := GetVirtualMethodNumber(this, #IF_FoundSomethingByHid());
  vmn_iftrytoaccess  := GetVirtualMethodNumber(this, #IF_TryToAccess());
  vmn_ifprjrun       := GetVirtualMethodNumber(this, #IF_ProjectRun());
  vmn_ifwinmoveable  := GetVirtualMethodNumber(this, #IF_WindowMoveable());

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::Init
  VAR
    para : udint;
  END_VAR

  if(FirstTime = TRUE) then
    if(IsClientConnected(#Lse)) then
    
      para := IsMethodOverwritten(vmn_ifwinstart,     #IF_WindowStart(),         GLOBAL_BIT_IFWINSTART) or 
              IsMethodOverwritten(vmn_ifwinready,     #IF_WindowReady(),         GLOBAL_BIT_IFWINREADY) or 
              IsMethodOverwritten(vmn_ifwinrun,       #IF_WindowRun(),           GLOBAL_BIT_IFWINRUN) or 
              IsMethodOverwritten(vmn_ifwinend,       #IF_WindowEnd(),           GLOBAL_BIT_IFWINEND) or 
              IsMethodOverwritten(vmn_ifrecalc,       #IF_Recalculate(),         GLOBAL_BIT_IFRECALCULATE) or
              IsMethodOverwritten(vmn_ifaccessinput,  #IF_AccessInput(),         GLOBAL_BIT_IFACCESSINPUT) or 
              IsMethodOverwritten(vmn_ifaccessbutton, #IF_AccessButton(),        GLOBAL_BIT_IFACCESSBUTTON) or
              IsMethodOverwritten(vmn_ifchkenable,    #IF_ChkEnable(),           GLOBAL_BIT_IFCHKENABLE) or
              IsMethodOverwritten(vmn_ifusercall,     #IF_UserCall(),            GLOBAL_BIT_IFUSERCALL) or
              IsMethodOverwritten(vmn_iffoundhid,     #IF_FoundSomethingByHid(), GLOBAL_BIT_IFFOUNDHID) or
              IsMethodOverwritten(vmn_iftrytoaccess,  #IF_TryToAccess(),         GLOBAL_BIT_IFTRYTOACCESS) or
              IsMethodOverwritten(vmn_ifprjrun,       #IF_ProjectRun(),          GLOBAL_BIT_IFPRJRUN) or
              IsMethodOverwritten(vmn_ifwinmoveable,  #IF_WindowMoveable(),      GLOBAL_BIT_IFWINMOVEABLE);
              
      Lse.AddGlobalEx(this, para); 
    end_if; 
	  FirstTime := FALSE; 
  end_if; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_WindowStart
VAR_INPUT
	whoami		: ^_WHOAMI;
	pic		    : ^VOID; 
	firsttime	: BOOL;
END_VAR
    
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_WindowReady
VAR_INPUT
	whoami		: ^_WHOAMI;
	pic		    : ^VOID;
	firsttime	: BOOL;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_WindowRun
VAR_INPUT
	whoami		: ^_WHOAMI;
	pic		    : ^VOID;
	event		: ^_EVENT;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_WindowEnd
VAR_INPUT
	whoami		: ^_WHOAMI;
	pic		    : ^VOID;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_UserCall
VAR_INPUT
	no		: DINT;
	para	: DINT;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_AccessInput
VAR_INPUT
	pi		: ^_INPUT;
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR
 
  retcode := TRUE; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_ChkEnable
VAR_INPUT
	key		: DINT;
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR

  retcode := TRUE; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_SystemError
VAR_INPUT
	errno		: DINT;
	para        : DINT;  
	ptxt        : ^_CHAR; 
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR

  retcode := TRUE; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_Recalculate
VAR_INPUT
	pres		: ^_RESULT;
	pv          : ^_VARIABLE; 
	direction   : BOOL; 
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR

  retcode := TRUE; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_DrawBubbleHelp
VAR_INPUT
	pedit	: ^_EDITOR;
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR

  retcode := TRUE; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_UrInit

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_Init

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_ProjectStart

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_ProjectReady
VAR_INPUT
	state	: BOOL;
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := state;  

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_ProjectRun
VAR_INPUT
	pe	: ^_EVENT;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_ProjectEnd

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_InputIsSaved
VAR_INPUT
	pi	: ^_INPUT;
	pr  : ^_RESULT; 
END_VAR
   
END_FUNCTION 

FUNCTION VIRTUAL GLOBAL _Global::IF_PowerDown

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_InputWithoutAccess
VAR_INPUT
	pi		: ^_INPUT;
	pvi     : ^_VARINFO; 
END_VAR


END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_OpenEditor
VAR_INPUT
  pedit : ^_EDITOR; 
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_Write
VAR_INPUT
  pres : ^_RESULT;
  pvar : ^_VARIABLE;
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := TRUE; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_WritePost
VAR_INPUT
  pres : ^_RESULT;
  pvar : ^_VARIABLE;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_CheckPrefix
VAR_INPUT
	varno		: UDINT;
	vi		: ^_VARINFO;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := FALSE;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_FoundSomethingByHid
VAR_INPUT
    ima : _FOUNDHID; 
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_PopUpCall
VAR_INPUT
	pm		: ^_MENU;
	pno		: ^UINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := FALSE; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_OpenTouchEditor
VAR_INPUT
	pe        : ^_EDITOR;
	preselect : UINT;
END_VAR
VAR_OUTPUT
	retcode		: UINT;
END_VAR

  retcode := preselect; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_AccessButton
VAR_INPUT
	pb		: ^_BUTTON;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := TRUE; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_LanguageHasChanged
VAR_INPUT
	actno		: UINT;
	oldno		: UINT;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_LanguageWillChange
VAR_INPUT
	newno		: UINT;
	oldno		: UINT;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_Offline
VAR_INPUT
	station		: UINT;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_OverloadEditor
VAR_INPUT
	pm		: ^_PICTUREMASK;
	whoami		: ^_WHOAMI;
	pvl		: ^_VARLABEL;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::Server0::NewInst
VAR_INPUT
	pPara		: ^CmdStruct;
	pResult		: ^results;
END_VAR
VAR_OUTPUT
	ret_code		: iprStates;
END_VAR

	ret_code := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_ConfigDriveList
VAR_INPUT
	drvlst		: ^char;
	puser		: ^void;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_Stop
VAR_OUTPUT
	retcode		: bool;
END_VAR

  retcode := false;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_Online
VAR_INPUT
	station		: UINT;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_TryToAccess
VAR_INPUT
	ptx		: ^void;
	state		: _ACCESSFAILED;
	found		: _FOUNDHID;
	preselect		: bool;
END_VAR
VAR_OUTPUT
	retcode		: bool;
END_VAR

  retcode := preselect;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_CheckHeap
VAR_INPUT
	display		: bool;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  retcode := _IDLE;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_SwitchMultiStation
VAR_INPUT
	station		: UINT;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_ScreenSaverWillStart
VAR_OUTPUT
	retcode		: bool;
END_VAR

  retcode := true;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_ScreenSaverWillEnd
VAR_INPUT
    pev : ^_EVENT;
END_VAR
VAR_OUTPUT
	retcode		: bool;
END_VAR

  retcode := true;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_Beep
VAR_INPUT
	whobeep		: _WHOBEEP;
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_IpcIni
	VAR_INPUT
		pini 	: ^_IPCINI;
	END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_UserStation
	VAR_INPUT
		station 	: UINT;
		pcd 	: ^_COMDEF;
		pobserve 	: ^BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := true;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_CantWriteNoAccess
	VAR_INPUT
		pres 	: ^_RESULT;
		pvl 	: ^_VARLABEL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := false;
  
END_FUNCTION

FUNCTION _Global::IsMethodOverwritten
  VAR_INPUT
    vmn : udint;
    pmeth : ^void;
    globit : udint;
  END_VAR
  VAR_OUTPUT
    retcode : udint;
  END_VAR
  
  retcode := 0;
  if(GetVirtualMethodPointer(this, vmn) <> pmeth) then
    retcode := globit;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_WindowMoveable
	VAR_INPUT
		whoami 	: ^_WHOAMI;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := true;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Global::IF_Progress
	VAR_INPUT
		pscan 	: ^_SCAN;
		visible 	: BOOL;
	END_VAR
  
  
  
END_FUNCTION
