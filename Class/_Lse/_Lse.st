//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_Lse"
	Revision           = "0.128"
	GUID               = "{69AE884A-4EC4-11D5-8991-00902787C19C}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "always"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(450,1140)"
	Comment            = "Version :01.01.126, Compiler: 59-60&#13;&#10;">
	<Channels>
		<Server Name="ActivateBubbleHelp" GUID="{80500B66-87B7-4E40-98F5-AD0F12D50BD1}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Is used to activate BubbleHelptext when using Touchscreen.&#13;&#10;"/>
		<Server Name="AmericanDateFormat" GUID="{BFACB9E2-AE90-11D6-8BC7-0048545E97D3}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="set server to 1 when american date format is requested&#13;&#10;0 .... 23.12.2012&#13;&#10;1 .... 12/23/2013"/>
		<Server Name="AmericanTimeFormat" GUID="{FA0B643A-6BE7-4928-AE60-9739AC13176B}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Set server to 1 when american time format is requested.&#13;&#10;0 ... 22:11:55&#13;&#10;1 ... 10:11:55 pm&#13;&#10;"/>
		<Server Name="CommaSign" GUID="{BFACB9E1-AE90-11D6-8BC7-0048545E97D3}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="set server to 1 when [comma] is requested instead of [dot] to seperate decimals&#13;&#10;0 .... 3.14&#13;&#10;1 .... 3,14&#13;&#10;"/>
		<Server Name="CompilerVersion" GUID="{336DB2C3-835E-11D6-8BC9-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="compilerversion of lse-project"/>
		<Server Name="CursorWrapHorizontal" GUID="{3F363AA4-20CE-11D8-8BCB-0048545E8899}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="is used to affect horizontal cursornavigation on inputs."/>
		<Server Name="CursorWrapVertical" GUID="{3F363AA5-20CE-11D8-8BCB-0048545E8899}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="is used to affect vertical cursornavigation on inputs."/>
		<Server Name="DelayScreenSaver" GUID="{CCBE10A2-A38E-11D6-8BC9-0048545E8899}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="delaytime of screensaver in milliseconds&#13;&#10;0 ...... screensaver is off&#13;&#10;&gt;1000 .. delaytime in milliseconds"/>
		<Server Name="DirectionOnEnter" GUID="{39C27463-199B-11D8-8BCB-0048545E8899}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false"/>
		<Server Name="GotAlarm" GUID="{D64CF384-ECA3-11D6-8BC9-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Language" GUID="{5A275E6B-60CD-11D6-8BC7-0048545E97D3}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="index of actual language"/>
		<Server Name="Lse" GUID="{69AE884C-4EC4-11D5-8991-00902787C19C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="class server to connect arbitrary interacting objects"/>
		<Server Name="LseProjectRevision" GUID="{012B7219-A4C4-47A3-AF82-AE662F400058}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Is used to show revision number of lse-project"/>
		<Server Name="LseVersion" GUID="{336DB2C2-835E-11D6-8BC9-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual used version"/>
		<Server Name="NoExternCom" GUID="{04FDBB4B-2284-419B-9FCF-4D70757594D9}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false"/>
		<Server Name="OfflineMode" GUID="{FEDBC901-4B3B-11D8-8BCB-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="represents online state&#13;&#10;0 .... all stations are online"/>
		<Server Name="OpSysVersion" GUID="{88B29A81-1128-11D8-8BCB-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="OS Version Number"/>
		<Server Name="SeekAlgorithm" GUID="{D18C0E41-0066-11D7-8BC9-0048545E8899}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="server is used to change algorithm of corsornavigation (keyboard) at inputs"/>
		<Server Name="SystemMessage" GUID="{18942021-AC79-11D7-8BCB-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="DataServiceClient" Required="false" Internal="false"/>
		<Client Name="EventProcessor" Required="false" Internal="false"/>
		<Client Name="Gbcd" Required="false" Internal="false"/>
		<Client Name="JpgLib" Required="false" Internal="false" Comment="connect client to object of class _JPG_RT to get functionality to view and save jpg-files "/>
		<Client Name="LseReady" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\cppcode\T_alarm.cpp"/>
			<File Path=".\Source\cppcode\T_batch.cpp"/>
			<File Path=".\Source\cppcode\T_bmp.cpp"/>
			<File Path=".\Source\cppcode\T_com.cpp"/>
			<File Path=".\Source\cppcode\T_combox.cpp"/>
			<File Path=".\Source\cppcode\T_comid.cpp"/>
			<File Path=".\Source\cppcode\T_ComIdFast.cpp"/>
			<File Path=".\Source\cppcode\T_complr.cpp"/>
			<File Path=".\Source\cppcode\T_convert.cpp"/>
			<File Path=".\Source\cppcode\T_copy.cpp"/>
			<File Path=".\Source\cppcode\T_crc.cpp"/>
			<File Path=".\Source\cppcode\T_ctext.cpp"/>
			<File Path=".\Source\cppcode\T_cursor.cpp"/>
			<File Path=".\Source\cppcode\T_Diag.cpp"/>
			<File Path=".\Source\cppcode\T_direct.cpp"/>
			<File Path=".\Source\cppcode\T_edit.cpp"/>
			<File Path=".\Source\cppcode\T_explor.cpp"/>
			<File Path=".\Source\cppcode\T_file.cpp"/>
			<File Path=".\Source\cppcode\T_font.cpp"/>
			<File Path=".\Source\cppcode\T_gfx.cpp"/>
			<File Path=".\Source\cppcode\T_gfxgif.cpp"/>
			<File Path=".\Source\cppcode\T_Help.cpp"/>
			<File Path=".\Source\cppcode\T_Hotkey.cpp"/>
			<File Path=".\Source\cppcode\T_ibxlst.cpp"/>
			<File Path=".\Source\cppcode\T_icon.cpp"/>
			<File Path=".\Source\cppcode\T_init.cpp"/>
			<File Path=".\Source\cppcode\T_JPG.cpp"/>
			<File Path=".\Source\cppcode\T_kbrd.cpp"/>
			<File Path=".\Source\cppcode\T_lang.cpp"/>
			<File Path=".\Source\cppcode\T_lib.cpp"/>
			<File Path=".\Source\cppcode\T_libEx.cpp"/>
			<File Path=".\Source\cppcode\T_libExSt.st"/>
			<File Path=".\Source\cppcode\T_LseOsz.cpp"/>
			<File Path=".\Source\cppcode\T_main.cpp"/>
			<File Path=".\Source\cppcode\T_memo.cpp"/>
			<File Path=".\Source\cppcode\T_menu.cpp"/>
			<File Path=".\Source\cppcode\T_mesbox.cpp"/>
			<File Path=".\Source\cppcode\T_move.cpp"/>
			<File Path=".\Source\cppcode\T_obj.cpp"/>
			<File Path=".\Source\cppcode\T_Offline.cpp"/>
			<File Path=".\Source\cppcode\T_outio.cpp"/>
			<File Path=".\Source\cppcode\T_ovrlod.cpp"/>
			<File Path=".\Source\cppcode\T_pal.cpp"/>
			<File Path=".\Source\cppcode\T_picmem.cpp"/>
			<File Path=".\Source\cppcode\T_picadd.cpp"/>
			<File Path=".\Source\cppcode\T_picpic.cpp"/>
			<File Path=".\Source\cppcode\T_picsub.cpp"/>
			<File Path=".\Source\cppcode\T_piccar.cpp"/>
			<File Path=".\Source\cppcode\T_popsub.cpp"/>
			<File Path=".\Source\cppcode\T_popup.cpp"/>
			<File Path=".\Source\cppcode\T_pos.cpp"/>
			<File Path=".\Source\cppcode\T_prj.cpp"/>
			<File Path=".\Source\cppcode\T_render.cpp"/>
			<File Path=".\Source\cppcode\T_save.cpp"/>
			<File Path=".\Source\cppcode\T_scan.cpp"/>
			<File Path=".\Source\cppcode\T_schema.cpp"/>
			<File Path=".\Source\cppcode\T_scroll.cpp"/>
			<File Path=".\Source\cppcode\T_Scrsvr.cpp"/>
			<File Path=".\Source\cppcode\T_seek.cpp"/>
			<File Path=".\Source\cppcode\T_Sett.cpp"/>
			<File Path=".\Source\cppcode\T_setup.cpp"/>
			<File Path=".\Source\cppcode\T_soft.cpp"/>
			<File Path=".\Source\cppcode\T_slider.cpp"/>
			<File Path=".\Source\cppcode\T_stack.cpp"/>
			<File Path=".\Source\cppcode\T_task2.cpp"/>
			<File Path=".\Source\cppcode\T_text.cpp"/>
			<File Path=".\Source\cppcode\T_theme.cpp"/>
			<File Path=".\Source\cppcode\T_tool.cpp"/>
			<File Path=".\Source\cppcode\T_Tree.cpp"/>
			<File Path=".\Source\cppcode\T_urge.cpp"/>
			<File Path=".\Source\cppcode\T_urge1.cpp"/>
			<File Path=".\Source\cppcode\T_user.cpp"/>
			<File Path=".\Source\cppcode\T_valid.cpp"/>
			<File Path=".\Source\cppcode\T_varia.cpp"/>
			<File Path=".\Source\cppcode\T_watch.cpp"/>
			<File Path=".\Source\cppcode\T_win.cpp"/>
			<File Path=".\Source\cppcode\T_WinMove.cpp"/>
			<File Path=".\Source\cppcode\T_3d.cpp"/>
			<File Path=".\Source\cppcode\Japan.cpp"/>
			<File Path=".\Source\cppcode\Japan_Dictionary.cpp"/>
			<File Path=".\Source\cppcode\Japan_Hiragana.cpp"/>
			<File Path=".\Source\cppcode\Japan_Katakana.cpp"/>
			<File Path=".\Source\cppcode\T_color.h" Include="false"/>
			<File Path=".\Source\cppcode\T_nuc.h" Include="false"/>
			<File Path=".\Source\cppcode\T_types.h" Include="false"/>
			<File Path=".\Source\cppcode\T_ipc.h" Include="false"/>
			<File Path=".\Source\cppcode\Comintfc.h" Include="false"/>
			<File Path=".\Source\cppcode\T_USER.H" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.128" Date="2021-10-13" Author="kolott" Company="sigmatek" Description="8D-3231: RAM-DataCache for entries in alarmhistory implemented (#define UC_HISTORY_FILECACHE)&#13;&#10;8D-325: No need to have unique alarmconfigurationnumbers "/>
		<Dokumentation Revision="0.127" Date="2021-06-22" Author="kolott" Company="sigmatek" Description="Default setup UC_GETLASALID_DATALINK changed to not active"/>
		<Dokumentation Revision="0.126" Date="2021-02-10" Author="kolott" Company="sigmatek" Description="8D-1866: Speedup AlarmConfig and GetLasalid"/>
		<Dokumentation Revision="0.125" Date="2021-01-14" Author="kolott" Company="sigmatek" Description="8D-1641: Speedup &quot;GetLasalid&quot; at startup. Use #define UC_GETLASALID_DATALINK at T_ipc.h."/>
		<Dokumentation Revision="0.124" Date="2020-11-16" Author="kolott" Company="sigmatek" Description="8D-1157: Input of japanese text (hiragana, katakana)&#13;&#10;Function lib_is_linux() added"/>
		<Dokumentation Revision="0.123" Date="2020-09-22" Author="kolott" Company="sigmatek" Description="new function SetTimeDelayOfflineWindow() to delay OfflineWindow when activated.&#13;&#10;8D-1068: Communication between different LARS-instances on single PC will work."/>
		<Dokumentation Revision="0.122" Date="2020-04-01" Author="kolott" Company="sigmatek" Description="DEVVIS-30, sa54918: Call neg.edge-functuion at button in carousell + move&#13;&#10;DEVVIS-38, sa57327: switching off #define UC_UNICODE will work properly&#13;&#10;DEVVIS-36, sa57210: Password up to length 64 characters will work"/>
		<Dokumentation Revision="0.121" Date="2020-01-30" Author="kolott" Company="sigmatek" Description="sa53607: Carousel + Window Refreshproblem fixed&#13;&#10;sa54151: WordWrap will work in ComboBox as well&#13;&#10;sa55048: up to 3000 characters will work with text output&#13;&#10;Client SigCLib deleted to reduce dependency on other Libraries"/>
		<Dokumentation Revision="0.120" Date="2019-10-18" Author="kolott" Company="sigmatek" Description="sa53043: Missing outline at polygon when having dynamic backgroundcolor (Colorscheme)"/>
		<Dokumentation Revision="0.119" Date="2019-07-15" Author="kolott" Company="sigmatek" Description="Client SigCLib added to provide various functionality&#13;&#10;sa51056 implemented (need to be enabled by #define SA51056 in T_USER.H)"/>
		<Dokumentation Revision="0.118" Date="2019-04-23" Author="kolott" Company="sigmatek" Description="sa43610: View of Defaultlimit in Standardeditor will work when using Formula &quot;Division&quot; (Unit)&#13;&#10;sa42046: Ability to change stationnumber of each Server during load of ToolCatalogue. Revision 1.1 or higher of Class _ToolCat is therefore necessary. &#13;&#10;sa41991: Adjust &quot;Cancle Button&quot; with corresponding frame by 1 pixel."/>
		<Dokumentation Revision="0.117" Date="2019-01-24" Author="hubchr&#13;&#10;kolott" Company="sigmatek" Description="Useroptions UC_UC_MENU_TWOCOLOR and UC_MENU_NEWSCROLL added&#13;&#10;SA43152: Betterment in TextAlignment &quot;T_DOWNBOUND&quot; at MenueControl&#13;&#10;SA42886: Cleanup redentical redefinition when using Class &quot;_Stream&quot; from OSInterface-Library"/>
		<Dokumentation Revision="0.116" Date="2018-09-17" Author="kolott" Company="sigmatek" Description="sa42018: Enable userspecific progressbar at startup (new Methode: _Lse::IF_Progress())&#13;&#10;sa41205: Input of calculated limits is possible&#13;&#10;new Function grab_bmp() added"/>
		<Dokumentation Revision="0.115" Date="2018-06-15" Author="kolott" Company="sigmatek" Description="sa41229: problem with edit of american-date-format fixed."/>
		<Dokumentation Revision="0.114" Date="2018-03-07" Author="kolott" Company="sigmatek" Description="sa38678: Fileexplorer will show attribut &quot;writeprotected&quot; when given to file.&#13;&#10;Ability to have more than 1 Hostlanguage.&#13;&#10;sa40635: Redraw Carousell at CMD_REDRAW&#13;&#10;sa40534: Deactivate sa35201 (warning multiple alarmconfig) when USER_SMT is in use"/>
		<Dokumentation Revision="0.113" Date="2018-01-17" Author="kolott" Company="sigmatek" Description="sa36584: RefreshProblem when having Statscheme + placed object with just an horizontal line inside.&#13;&#10;sa39254: Delete AlarmHistory&#13;&#10;sa39401: Ability to clear EventJournal&#13;&#10;sa38992: Speedup Languageselection"/>
		<Dokumentation Revision="0.112" Date="2017-10-11" Author="kolott" Company="sigmatek" Description="new Formula (15::AngleToDeg()) is implemented&#13;&#10;SA38879: REAL DataServer will work as placed TesxtScheme &#13;&#10;SA39011: Fiew of Date and Time in Fileexplorer will work at x86-Target in non UnicodeVersion as well"/>
		<Dokumentation Revision="0.111" Date="2017-07-21" Author="kolott" Company="sigmatek" Description="sa37714: RealServer + Temperature (°C, F)&#13;&#10;sa37331: new virt.Methods at class _ToolCat"/>
		<Dokumentation Revision="0.110" Date="2017-02-14" Author="kolott" Company="sigmatek" Description="sa35926: scan multiple Alarmconfig&#13;&#10;sa35625: SysteError at wrong Date or Time in Editor&#13;&#10;sa36634: new functions VarList_GetUnitIndex() and VarList_GetUnitLabel()"/>
		<Dokumentation Revision="0.109" Date="2017-01-25" Author="kolott" Company="sigmatek" Description="New function TouchDeviceLock() to disable second TouchScreen when activated with #define UC_MULTIDISPLAY."/>
		<Dokumentation Revision="0.108" Date="2016-10-07" Author="kolott" Company="sigmatek" Description="sa25357: Ability to move Windows. Don&apos;t forget to activate UC_MOVING_WINDOW&#13;&#10;sa29832: Multitouch: more than one Slider will be focusable&#13;&#10;sa34959: Button Press + move over other Buttons will activate them as well. Don&apos;t forget to &quot;Group&quot; them in LSE&#13;&#10;sa35454: sometimes it could happen that momentary Button stuck when having connection to Server on other PLC.&#13;&#10;sa35537: ability to change cursorcolor in DropDownList and Menu. #define CURSOR_COLOR_MENU MakeColor(RED, BLUE)&#13;&#10;sa35472: call writemethod at triggerevent (autorep, contineous..) as well of enclosed server at button&#13;&#10;sa35953: bugfix when displaying string with more than 1024byte of length&#13;&#10;dr2503: new global function VarList_GetStringByNo() added&#13;&#10;dr2515: Frame NewAge will work in Carousell"/>
		<Dokumentation Revision="0.107" Date="2016-08-25" Author="kolott" Company="sigmatek" Description="sa32456: new functions Prj_HostLanguageSet(), Prj_HostLanguagePush(), Prj_HostLanguagePop()&#13;&#10;sa35235: Writeaccess to index of Carousel implemented&#13;&#10;sa33281: Different sortalgorithm at Fileexplorer implemented (A-Z, DateTime, FileSize)&#13;&#10;dr2481: Keep EditorFocus on given FirstInput&#13;&#10;sa31276: State of enclosed PLC will be shown in OfflineWindow&#13;&#10;betterment at PrintScreen and Button with option DoubleClick = true&#13;&#10;global function VarList_SetStringByNo() added"/>
		<Dokumentation Revision="0.106" Date="2016-08-25" Author="kolott" Company="sigmatek" Description="sa35306: Correction of evaluating color of editor when option UC_DYN_EDIT_COLOR is used. As Default this option is deactivated (set to INVISIBLE)"/>
		<Dokumentation Revision="0.105" Date="2016-08-16" Author="kolott" Company="sigmatek" Description="Write to single Bit will work when using access to Membervariables (UC_MEMBERVARIABLE)"/>
		<Dokumentation Revision="0.104" Date="2016-07-22" Author="kolott" Company="sigmatek" Description="sa34868: external server will work with PrintScreen&#13;&#10;sa32402: new virt. method ModifyTitleText() at keypads + dynamic color (limits) during edit of num value.&#13;&#10;sa26785: new property &quot;Leading 0&quot; at unit&#13;&#10;sa23116: new property &quot;Shadow&quot; at menu&#13;&#10;sa34987: temperaturevalue will work with more than 1 decimal place&#13;&#10;sa34586: Vartext2 will be used as longtext at unregistered alarms&#13;&#10;sa34706: 32Bit Alarmnumber instead of 16Bit (#define SA34706)&#13;&#10;Ability to place Membervariables as well (read only)&#13;&#10;Betterment in code when using #define UC_RELEASE_PRESS_FILTER&#13;&#10;new virtual method IF_WritePost() added"/>
		<Dokumentation Revision="0.103" Date="2016-05-12" Author="kolott" Company="sigmatek" Description="new themes NewAgeBright and NewAgeDark will work&#13;&#10;sa33149: enum (%s, %p) will be formatted as text instead numeric&#13;&#10;sa34449: new global function add_carousel_scrollbar()&#13;&#10;sa34115: view deeds in background of invalid softkey"/>
		<Dokumentation Revision="0.102" Date="2016-03-24" Author="kolott" Company="sigmatek" Description="new constant UC_MEMORIZE_PLCDATA to increase drawing of screen&#13;&#10;increased number of userdefined fontschemes (100 instead of 50)&#13;&#10;new command CMD_RESET_SCREENSAVER is added&#13;&#10;new constant WIN_EDITOR_ALTGR_COLOR to overlay color of 2nd keyfunkt&#13;&#10;sa32974: functionality to use _AlarmX0Para::QuitAlarmEx() added"/>
		<Dokumentation Revision="0.101" Date="2015-11-23" Author="kolott" Company="sigmatek" Description="dr2385, sa32834: Softkeys do not work anymore&#13;&#10;dr2386, sa32097: possibly crash fixed when user add command CMD_REDRAW"/>
		<Dokumentation Revision="0.100" Date="2015-10-23" Author="kolott" Company="sigmatek" Description="Dr2374, Sa32097: Crash when CMD_NEWWINDOW was performed from CY or RT-Work Methode right after booting visualisation&#13;&#10;Dr2353: Frame &quot;CoralCancel&quot; will work with class AnumKeypad and KeyPadAnumFileExplorer&#13;&#10;Dr2352, Sa31841: Simultaneously press/release of Softkey and Button when using MultiTouchhardware will work&#13;&#10;Dr2225, Sa30874: Correction in method _ScrollList::ActPos.Write()&#13;&#10;Dr2221, Sa30779: Function SaveJPG() will return &apos;false&apos; when targetdrive is not ready&#13;&#10;Dr2370, Sa32155: Asynchron Ping (instead of synchron) during OfflineWindow is open to ensure operating of terminal&#13;&#10;Dr2362: function free_MEM_VKLIST() is able to handle more than 65536 entries&#13;&#10;Dr2348, Sa31568: Multitouch and SingletouchHardware will operate identical when option UC_MULTITOUCH is disabled. &#13;&#10;Dr2362: Communication to extern PLC is optimized&#13;&#10;Dr2371, Sa32226: Color of Titlebar will work with KeyPadNum, Anum, ..."/>
		<Dokumentation Revision="0.99" Date="2015-05-22" Author="kolott" Company="sigmatek" Description="Dr2218: new constant UC_TRANSPARENT_TEXTCOLOR to ensure/disable view of transparent Text (SA29902)&#13;&#10;Dr2211, Sa31147: fix of possibly memleak when using overloaded(!) Button with given Checkbit and option Doubleclick = true"/>
		<Dokumentation Revision="0.98" Date="2015-02-05" Author="kolott" Company="sigmatek" Description="Dr2183, Sa30029: Indicator didn&apos;t work in range from 0 to 25.000.000&#13;&#10;Dr2186, Sa29644: Function ReDraw() will take care about statescjeme at objects as well. &#13;&#10;Dr2189, Sa29902: do not draw text with transparent color.&#13;&#10;Dr2191: function load_toolcat() will return &quot;false&quot; when crc of given file is wrong&#13;&#10;Use new define UC_EDITOR_PRESIGN to enable Sa28815"/>
		<Dokumentation Revision="0.97" Date="2014-11-18" Author="kolott" Company="sigmatek" Description="Dr2179, sa29709: corrected bug in CRC-calculation for UNICODE-String&#13;&#10;Dr2145, sa28723: Button with RepeaterFunction will work at Backgroundtime &gt;=100ms as well&#13;&#10;Dr2140, sa28695: Suppress Touch-Release when closing Window&#13;&#10;Dr2152, sa28815: Minus is no longer used to increment numeric value in activ editor"/>
		<Dokumentation Revision="0.96" Date="2014-07-14" Author="kolott" Company="sigmatek" Description="Dr2052, Sa27246: [SPACE] is allowed in filename while using class FileExplorer&#13;&#10;Dr2126, Sa28455: No &quot;SmoothDocking&quot; when using Button or Keypad to move Carousell&#13;&#10;Dr2140,SA28695: On Window was Closed with event HIDPRESS, avoid next event HIDRELEASE because context (window) where PRESS occured doesn&apos;t exist anymore."/>
		<Dokumentation Revision="0.95" Date="2014-04-24" Author="kolott" Company="sigmatek" Description="Dr2101, sa28003: Text in softkey will be hidden when screen is disabled with chkbit and(!) adequateness object of class _Screen is existing "/>
		<Dokumentation Revision="0.94" Date="2014-04-07" Author="kolott" Company="sigmatek" Description="Dr1998; Sa26008: ScrollBar at Carousel"/>
		<Dokumentation Revision="0.93" Date="2014-04-07" Author="kolott" Company="sigmatek" Description="correction of UNALIGNED_ACCESS at arm-platform when using REAL datatypes on screen"/>
		<Dokumentation Revision="0.92" Date="2014-04-07" Author="kolott" Company="sigmatek" Description="Dr2030, Sa26882: Open and Overload Window&#13;&#10;Dr2054: Betterment in positioning of Title at DefaultKeyPad&#13;&#10;Dr2038, Sa26937: Alarme at more than one instance of Lars will work as well&#13;&#10;Dr2049, Sa27201: Correction done in function RealToStr()&#13;&#10;Dr2051, Sa27172: Correction: View of Images at DefaultKeyPad failed after SoftReset."/>
		<Dokumentation Revision="0.91" Date="2014-02-19" Author="kolott" Company="sigmatek" Description="DNS-Adress in use to get uplink to plc&#13;&#10;Sa26514: no clear screen during load of project (starting visu)"/>
		<Dokumentation Revision="0.90" Date="2013-10-30" Author="kolott" Company="sigmatek" Description="Dr1976, Sa25529: JPG save/load didn&apos;t work after &quot;Download on the Fly&quot;&#13;&#10;Dr1995, Sa26061: MyIo + EVENT_HID_PRESS&#13;&#10;Dr2002, Sa26136: Crash when having Window without valid Accesslavel&#13;&#10;Dr1991, Sa26037: Betterment when updating Objectscheme on Screen&#13;&#10;Dr2001, Sa26144: _AlarmX0Para will work without Instance of _AlarmXBuffer&#13;&#10;Dr1993, Sa25639: russian, ukrainian and greek keypad added to class KeyPadAnum&#13;&#10;Dr1994, Sa25639: new Class HexValue to ensure view and input of hex-value&#13;&#10;Dr2005: Directory and Filelist will be sorted in ABC- instead of ASCII-manner"/>
		<Dokumentation Revision="0.89" Date="2013-09-03" Author="kolott" Company="sigmatek" Description="Dr1975, SA25529: JPG-Save will work properly&#13;&#10;Dr1976, SA25619: JPG-Load &amp; Save will work after SoftReset as well"/>
		<Dokumentation Revision="0.88" Date="2013-08-01" Author="kolott" Company="sigmatek" Description="Dr1969, Sa25469: Crash when opening Screen without valid Accesslevel&#13;&#10;Dr1967, Sa25422: Carousel wil work in Window as well&#13;&#10;Dr1964, Sa25405: Shut down alarms at seperate Station&#13;&#10;Dr1966: Ability to customize ComboBox by program&#13;&#10;Dr1961: Release of new Class Roboter"/>
		<Dokumentation Revision="0.86" Date="2013-06-25" Author="kolott" Company="sigmatek" Description="New global Function Prj_GetProjectInfo()"/>
		<Dokumentation Revision="0.85" Date="2013-06-10" Author="kolott" Company="sigmatek" Description="Dr1817, Dr1918, Sa24086: Defaultimplementation of numeric und anumeric Keyboard&#13;&#10;Dr11899, Sa24407: set all active alarms to inaktive when loading Alarmhistory and bit BIT_ONOFF is set&#13;&#10;Dr1900, Sa24489: function MakeColorFromIndex() should work in ProjectStart-Interface as well&#13;&#10;Dr1906, SA24509: funktion get_no_by_label() should work with fontschema as well&#13;&#10;Dr1907, Ds1930: new functions add_imagescheme() and add_myio() &#13;&#10;Dr1925, Sa25024: new embedded string in class _FileExplorer to provide full path of actual selection&#13;&#10;Dr1926: New server at class _LSE to show revisionsnumber of LSE-project&#13;&#10;Dr1929: ability to change defaultdesign of ChkBox and RadioButton&#13;&#10;Dr1909: improvement of funktion crc_string()&#13;&#10;Dr1915, Sa24818: Toolcat didn&apos;t work properly with real-values&#13;&#10;Dr1922, Sa24986: Checkbit directly given at graphic Object did not work"/>
		<Dokumentation Revision="0.84" Date="2013-02-12" Author="kolott" Company="sigmatek" Description="Dr1573, Sa20240: BubbleHelp at Touchscreen&#13;&#10;Dr1757, Dr1806: Use of Alarm witout Alarmtext, UC_UNREGISTEREN_ALARMS&#13;&#10;Dr1848, Sa23833: Cursornavigation  without TAB, UC_NO_TAB_CURSORNAVIGATION &#13;&#10;Dr1830: new Server &quot;LineHeighness&quot; at class _ScrollArea&#13;&#10;Dr1822: Button: Ability to avoid call of writemethode at enclosed Server&#13;&#10;Dr1819: Dutch Defaulttext in class _FileExplorer&#13;&#10;Dr1822: SAVE und SAVEAS Button at class _FileexplorerButton&#13;&#10;Dr1819, Sa23599: User is able to set a Filter at Touchscreen, UC_RELEASE_PRESS_FILTER&#13;&#10;Dr1855: Slider and Indicator will work with server of type REAL&#13;&#10;Dr1832, Dr1790: Betterment at Carousell with Statescheme and Carousell with elements including transparent Background"/>
		<Dokumentation Revision="0.83" Date="2012-11-14" Author="kolott" Company="sigmatek" Description="Dr1783: error with possibly not visible softkeys corrected&#13;&#10;Dr1784: new method Run() at class ExoOnline"/>
		<Dokumentation Revision="0.82" Date="2012-11-05" Author="kolott" Company="sigmatek" Description="Dr1767: sometimes it could happen to get 2 marked lines in Listview of FileExplorer&#13;&#10;Dr1765: Final view of none infinite Carousel has changed&#13;&#10;Dr1766: Design of buttons (default-frame) has changed at class FileExplorerButton&#13;&#10;Dr1730: function add_rectangle added"/>
		<Dokumentation Revision="0.81" Date="2012-10-11" Author="kolott" Company="sigmatek" Description="Dr1735: %x and %[ts.txtscmname(%x)] will work to enable individual index in same text&#13;&#10;Dr1730: user is able to assemble individual picturemask by using program&#13;&#10;Dr1718: change image for screensaver by program&#13;&#10;Dr1681, sa22021: betterment at move or selection of input/button in carousel&#13;&#10;Dr1663: negative enum-values are supported as well"/>
		<Dokumentation Revision="0.80" Date="2012-09-12" Author="kolott" Company="sigmatek" Description="Dr1696, sa22147: function is widened to find screen / windownumbers by label&#13;&#10;Dr1741: new release; class can be used to get userdefined acces to defined inputs, buttons, …&#13;&#10;Dr1689, sa22166: userdefined code is implemented in kernel when using #define USER_DEMAG&#13;&#10;Dr1719, sa22602: zoom of very big image sometimes went wrong when using #define UC_FIXMEMORY&#13;&#10;Dr1739: overwriting an already existing file did not work properly&#13;&#10;Dr1751: sometimes it could happen that carousel will not find it’s final position. Just happen with infinite carousel and very wide move."/>
		<Dokumentation Revision="0.79" Date="2012-06-25" Author="kolott" Company="sigmatek" Description="dr1677, sa21840: multiple hashcode of varnames will work as well"/>
		<Dokumentation Revision="0.78" Date="2012-06-15" Author="kolott" Company="sigmatek" Description="dr1618: Fileexplorer + new classes _FileExplorer, _FileExplorerButton, _FileExplorerToolCat&#13;&#10;dr1630: Buttons to increment /decrement placed Carousel&#13;&#10;dr1647: Standard-Functionality of MessageBoxes is implemented&#13;&#10;dr1658: some changes due to optimization of speed are done&#13;&#10;Servername + state of Alarm will be shown in AlarmList when undefined Alarm will occur&#13;&#10;dr1673, sa21263: more than 7 digits after dezimalpoint are possible&#13;&#10;dr1625: Function load_toolcat will return _FALSE if given file does not exist&#13;&#10;dr1640, sa21676: Check plausibility of alarmhistoryfile at start&#13;&#10;New function LSE_GetAlarmConfigIndex&#13;&#10;Language_GetActualLocal is used to get Identifier of actual Language&#13;&#10;dr1672, sa21860: change in function get_stationary_state()&#13;&#10;dr1671: sa21981: statescheme didn’t work properly at numedit"/>
		<Dokumentation Revision="0.76" Date="2012-03-01" Author="kolott" Company="sigmatek" Description="dr1603: show Servername at Alarm without given Alarmtext instead of &quot;unknown Alarm&quot;&#13;&#10;dr1608: up to 250 unicodecharacters in string&#13;&#10;dr1621, sa20831: betterment in scrolllist to ensure easy setup of lineheight"/>
		<Dokumentation Revision="0.75" Date="2012-02-09" Author="kolott" Company="sigmatek" Description="dr1513: Ability to set Press and ReleaseValue at each button.&#13;&#10;dr1540, sa20024: format YYYY-MM-DD an YY-MM-DD are possible&#13;&#10;dr1542: new Control “Carousel” is implemented&#13;&#10;dr1575, sa20566: Keep softkeylevel in actual screen when new language is activated.&#13;&#10;dr1579, sa19667: improvement of Windowbackgroundrestore&#13;&#10;dr1600, sa20814: Confirm of invalid Date or Time schould not cause any change in system&#13;&#10;dr1602, sa20810: CMD_NEWWINDOW and CMD_NEWSCREEN will do nothing when divern number is greater than 60000"/>
		<Dokumentation Revision="0.74" Date="2012-01-10" Author="kolott" Company="sigmatek" Description="dr1521, sa19670: get whole alarmbuffer from plc and add all active entries to temporary alarmlist after restart of visualisation&#13;&#10;dr1565: mouse will work on slider  &#13;&#10;dr1566: repeaterfunctionality (autorepeat, continous, …) will work on button, softkey and scrolllist when using mouse&#13;&#10;dr1563, sa20458: mouseclick on button with left and(!) right mousebutton will work in combination with mousemove.&#13;&#10;dr1555, sa20353: function did not work&#13;&#10;dr1539: when same font was referenced more than one time in fontlist it could lead into problem when performing softreset (DownloadOnTheFly)&#13;&#10;dr1534: flashing cursor is disabled on active slider"/>
		<Dokumentation Revision="0.73" Date="2011-11-04" Author="kolott" Company="sigmatek" Description="visualized flag of server _Lse::DelayScreenSaver = TRUE"/>
		<Dokumentation Revision="0.72" Date="2011-10-11" Author="kolott" Company="sigmatek" Description="dr1462: ability to increment/decrement ip-address control&#13;&#10;dr1470, sa18908: statescheme for each menuitem&#13;&#10;dr1444: Functionality to get crc of whole lse-project&#13;&#10;dr1488: function RealToString didn’t work properly when having negative value including decimals&#13;&#10;dr1493, sa19544: new interface which is called each time when user wants to write value and accesslevel doesn’t fit.&#13;&#10;dr1501: crash when having client in serverlist&#13;&#10;dr1494: ability to get informed on ENTER or ESC in offlinewindow"/>
		<Dokumentation Revision="0.71" Date="2011-07-25" Author="kolott" Company="sigmatek" Description="dr1447, sa19127: Server of type ENUM will work with Toolcatalogue"/>
		<Dokumentation Revision="0.70" Date="2011-06-08" Author="kolott" Company="sigmatek" Description="dr1379: Type Enum at Server is possible.&#13;&#10;New Compilerversion to ensure functionality of ENUM type&#13;&#10;dr1413: Slidercomponents are possible&#13;&#10;dr1425: new command will close all open windows, popups, etc. and open new given window.&#13;&#10;dr1386: betterment of speed during offlinewindow is on screen&#13;&#10;dr1381: inputs in objects which are encased for more than 6 times didn’t work"/>
		<Dokumentation Revision="0.69" Date="2011-01-31" Author="kolott" Company="sigmatek" Description="dr1331: ability to get more than 65536 lines in scrollarea"/>
		<Dokumentation Revision="0.68" Date="2011-01-26" Author="kolott" Company="sigmatek" Description="dr1377: dynamic color of text didn’t work when text is hidden by window and textcolor will change in same moment as window will close.&#13;&#10;dr1333: new server to show and set position in scrollarea from ‘outside’&#13;&#10;dr1336: standardfunctionality to clean screen is implemented to software. Use new UDC “@ScreenClean”&#13;&#10;dr1376: in Diagnostic-menu &lt;ALT ESC&gt; time to open screen / window will be shown.&#13;&#10;dr1329: use grayscale instead of colors on display&#13;&#10;dr1359, sa17302: object on left side in carousell can start with negative x-position.&#13;&#10;dr1332: betterment of service in scrollarea - drag move in scrollarea is faster.&#13;&#10;Increment and decrement of default time and date (--:--:--) will work.&#13;&#10;dr1383: CancleButton of X-Theme in combination with colorscheme will work.&#13;&#10;sa17620: Goto previous picture did not work properly when having many pictures logged."/>
		<Dokumentation Revision="0.67" Date="2010-11-16" Author="kolott" Company="Sigmatek" Description="Error : sometimes focus got lost"/>
	</RevDoku>
</Class>
*)
_Lse : CLASS
	TYPE
	  _PICPOI : STRUCT
	    whoami : _WHOAMI;
	    ptr : ^void;
	  END_STRUCT;
	  _PICMEMO : STRUCT
	    no : _UWORD;
	    ptr : ARRAY [0..999] OF _PICPOI;
	  END_STRUCT;
	  P_AlarmDisplay : ^_AlarmDisplay;  //! <Type Comment="Just for dependency !" Name="P_AlarmDisplay"/>
	  P_Bit32 : ^_Bit32;  //! <Type Comment="Just for dependency !" Name="P_Bit32"/>
	  P_Bit32Ram : ^_Bit32Ram;  //! <Type Comment="Just for dependency !" Name="P_Bit32Ram"/>
	  P_Global : ^_Global;
	  P_HotAlarm : ^_HotAlarm;  //! <Type Comment="Just for dependency !" Name="P_HotAlarm"/>
	  P_LanguageSelection : ^_LanguageSelection;  //! <Type Comment="Just for dependency !" Name="P_LanguageSelection"/>
	  P_LimitMax : ^_LimitMax;  //! <Type Comment="Just for dependency !" Name="P_LimitMax"/>
	  P_LimitMin : ^_LimitMin;  //! <Type Comment="Just for dependency !" Name="P_LimitMin"/>
	  P_MyIo : ^_MyIO;  //! <Type Comment="Just for dependency !" Name="P_MyIo"/>
	  P_Oszi : ^_OsziLSE;
	  P_Radio32 : ^_Radio32;  //! <Type Comment="Just for dependency !" Name="P_Radio32"/>
	  P_Radio32Ram : ^_Radio32Ram;  //! <Type Comment="Just for dependency !" Name="P_Radio32Ram"/>
	  P_Screen : ^_Screen;  //! <Type Comment="Just for dependency !" Name="P_Screen"/>
	  P_ScrollArea : ^_ScrollArea;  //! <Type Comment="Just for dependency !" Name="P_ScrollArea"/>
	  P_ScrollArea2 : ^_ScrollArea2;  //! <Type Comment="Just for dependency !" Name="P_ScrollArea2"/>
	  P_SysDateTime : ^_SysDateTime;  //! <Type Comment="Just for dependency !" Name="P_SysDateTime"/>
	  P_ToolCat : ^_ToolCat;  //! <Type Comment="Just for dependency !" Name="P_ToolCat"/>
	  P_XAccess : ^_XAccess;  //! <Type Comment="Just for dependency !" Name="P_XAccess"/>
	END_TYPE
  //Servers:
	Lse 	: SvrChCmd_DINT;
	Language 	: SvrCh_DINT;
	LseVersion 	: SvrCh_DINT;
	CompilerVersion 	: SvrCh_DINT;
	DelayScreenSaver 	: SvrCh_UDINT;
	CommaSign 	: SvrCh_DINT;
	AmericanDateFormat 	: SvrCh_DINT;
	GotAlarm 	: SvrCh_DINT;
	SeekAlgorithm 	: SvrCh_DINT;
	SystemMessage 	: SvrCh_DINT;
	OpSysVersion 	: SvrCh_UDINT;
	DirectionOnEnter 	: SvrCh_DINT;
	CursorWrapHorizontal 	: SvrCh_DINT;
	CursorWrapVertical 	: SvrCh_DINT;
	OfflineMode 	: SvrCh_DINT;
	NoExternCom 	: SvrCh_DINT;
	AmericanTimeFormat 	: SvrCh_DINT;
	ActivateBubbleHelp 	: SvrCh_DINT;
	LseProjectRevision 	: SvrCh_HDINT;
  //Clients:
	Gbcd 	: CltChCmd_GetBroadCastData;
	LseReady 	: CltCh_DINT;
	EventProcessor 	: CltChCmd_DINT;
	JpgLib 	: CltChCmd_DINT;
	DataServiceClient 	: CltChCmd_DataServiceClient;
  //Variables:
		RunState 	: _WORKSTATE;
		PicMemo 	: _PICMEMO;
		ToolCat 	: ^void;
		UserGlobal 	: _MEM_POINTERPARA;
		Oszis 	: _MEM_POINTER;
		IsEventProcessor 	: BOOL;
		DownloadState 	: UINT;
		GlobalBitState 	: UDINT;
  //Functions:
	
	FUNCTION _Lse
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;function is called before drawing a new screen (picture,window,popup)&#13;&#10;" Name="IF_WindowStart"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_WindowStart
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			firsttime 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;function is called once after drawing a new screen&#13;&#10;the parameter firsttime is set to FALSE if the function is called&#13;&#10;during a backgroundrestore&#13;&#10;" Name="IF_WindowReady"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_WindowReady
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			firsttime 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;function is called (cyclic) during a screen is open&#13;&#10;...don&apos;t mind the clipping&#13;&#10;" Name="IF_WindowRun"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_WindowRun
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;function is called at the end of a screen&#13;&#10;" Name="IF_WindowEnd"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_WindowEnd
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; call an userdefined function&#13;&#10; the parameter &apos;nr&apos; includes the number given by lse and &apos;para&apos; includes the parameter                                           &#13;&#10;" Name="IF_UserCall"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_UserCall
		VAR_INPUT
			nof 	: DINT;
			para 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;check if input is accessible for editor&#13;&#10;pi ...... --&gt; to inputinformation&#13;&#10;return TRUE if input is accessible, on the other hand FALSE&#13;&#10;" Name="IF_AccessInput"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_AccessInput
		VAR_INPUT
			pi 	: ^_INPUT;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;check userlevel (input accessible, supervisor)&#13;&#10;ena ..... required userlevel (access information)&#13;&#10;return TRUE if required userlevel fits, on the other hand FALSE&#13;&#10;" Name="IF_ChkEnable"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_ChkEnable
		VAR_INPUT
			key 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this function is called in case of an system error&#13;&#10;errno ... errorcode&#13;&#10;para .... parameter&#13;&#10;ptxt .... individual text&#13;&#10;return FALSE if the application should stop immediately&#13;&#10;" Name="IF_SystemError"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_SystemError
		VAR_INPUT
			errno 	: DINT;
			para 	: DINT;
			ptxt 	: ^_CHAR;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;function is called in case of an recalculation (formula) defined for a data-server&#13;&#10;pres ....... --&gt; to value&#13;&#10;pv ......... --&gt; to variable&#13;&#10;direction .. direction (TRUE Y=kX+d, FALSE X=(Y+d)/k)&#13;&#10;retcode .... return TRUE if kernel should do the calculation, on the other hand return FALSE&#13;&#10;" Name="IF_Recalculate"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Recalculate
		VAR_INPUT
			pres 	: ^_RESULT;
			pv 	: ^_VARIABLE;
			direction 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; to do a own design for the bubblehelp window use this function&#13;&#10; pedit ..... --&gt; to editor (including bubblehelp-area)&#13;&#10; return FALSE if bubblehelp-window should not be drawn by the kernel&#13;&#10;" Name="IF_DrawBubbleHelp"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_DrawBubbleHelp
		VAR_INPUT
			pedit 	: ^_EDITOR;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; this function is called once in lifetime of our application&#13;&#10; if you change the arrangement, or add a new global structure, your&#13;&#10; application has changed and therefore this function is called at&#13;&#10; once for another time (new application)&#13;&#10; note: the project is not ready loaded&#13;&#10;" Name="IF_UrInit"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_UrInit;
				//! <Function Comment="[#ENGLISH]&#13;&#10; this function is called every time when you start your application&#13;&#10; note: the project is not ready loaded&#13;&#10;" Name="IF_ProjectStart"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_ProjectStart;
				//! <Function Comment="[#ENGLISH]&#13;&#10;function is called after loading project&#13;&#10;graphic is already initialized,&#13;&#10;no picture is loaded and nothing is on the screen (blank screen)&#13;&#10;state .... TRUE successful loading project, either FALSE&#13;&#10;return FALSE if you don&apos;t want to start this application&#13;&#10;" Name="IF_ProjectReady"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_ProjectReady
		VAR_INPUT
			state 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this function is called after a succesfull writing of an input&#13;&#10;pi ......... --&gt; to saved _INPUT&#13;&#10;pr ......... --&gt; to _RESULT&#13;&#10;" Name="IF_InputIsSaved"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_InputIsSaved
		VAR_INPUT
			pi 	: ^_INPUT;
			pr 	: ^_RESULT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method will be called at least (before closing the application).&#13;&#10;note: afterwards there is no more executable code.&#13;&#10;" Name="IF_PowerDown"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_PowerDown;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called when input is identified unambiguous by touch and&#13;&#10;the editor can&apos;t open because access is denied.&#13;&#10;" Name="IF_InputWithoutAccess"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_InputWithoutAccess
		VAR_INPUT
			pi 	: ^_INPUT;
			pvi 	: ^_VARINFO;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called when a new alarm is added during runtime to the alarmlist&#13;&#10;" Name="IF_OpenEditor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_OpenEditor
		VAR_INPUT
			pedit 	: ^_EDITOR;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called right before data will be written to system&#13;&#10;pres ... --&gt; to data&#13;&#10;pvar ... --&gt; to serverdescription&#13;&#10;" Name="IF_Write"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Write
		VAR_INPUT
			pres 	: ^_RESULT;
			pvar 	: ^_VARIABLE;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called before a value is written into the system&#13;&#10;set return parameter with FALSE if you want to prohibit&#13;&#10;otherwise value will be written into system&#13;&#10;" Name="IF_CheckPrefix"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_CheckPrefix
		VAR_INPUT
			varno 	: UDINT;
			vi 	: ^_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_GetLookUpEmbeddedPointer
		VAR_OUTPUT
			retcode (EAX) 	: ^void;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called by the kernel to set statusserver like &apos;language&apos; etc.&#13;&#10;the first parameter is used as schedular which server is to initialize with value (second parameter)&#13;&#10;" Name="IF_SetStatus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_SetStatus
		VAR_INPUT
			no 	: DINT;
			value 	: DINT;
		END_VAR;
				//! <Function Comment="#pragma warning (disable: 74)&#13;&#10;" Name="IF_Trace"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Trace
		VAR_INPUT
			msg 	: ^_ASCII;
		END_VAR;
				//! <Function Comment="#pragma warning (default: 74)&#13;&#10;" Name="IF_GetHeapInfo"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_GetHeapInfo
		VAR_INPUT
			pr 	: ^_ROOM;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_FoundSomethingByHid
		VAR_INPUT
			ima 	: _FOUNDHID;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called by the kernel right before a menu will be opend.&#13;&#10;the first parameter is a pointer to structure where the menudata like color,&#13;&#10;shape, lines etc. will be stored&#13;&#10;the second parameter is a pointer to the menunumber initialiced by lse&#13;&#10;" Name="IF_PopUpCall"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_PopUpCall
		VAR_INPUT
			pm 	: ^_MENU;
			pno 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_GetThisPointer
		VAR_INPUT
			index 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: ^void;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_OpenTouchEditor
		VAR_INPUT
			pe 	: ^_EDITOR;
			preselect 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode (AX) 	: UINT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_AccessButton
		VAR_INPUT
			pb 	: ^_BUTTON;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_GetStatus
		VAR_INPUT
			no 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Interface is called right after language has changed&#13;&#10;parameter actno is number of actual language&#13;&#10;parameter oldno is number of previous language&#13;&#10;" Name="IF_LanguageHasChanged"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_LanguageHasChanged
		VAR_INPUT
			actno 	: UINT;
			oldno 	: UINT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_LanguageWillChange
		VAR_INPUT
			newno 	: UINT;
			oldno 	: UINT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Offline
		VAR_INPUT
			station 	: UINT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL EP_StartEvent
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL EP_StopEvent
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL EP_GetEvent
		VAR_INPUT
			posev 	: ^_OSEVENT;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL EP_SetEvent
		VAR_INPUT
			posev 	: ^_OSEVENT;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_OverloadEditor
		VAR_INPUT
			pm 	: ^_PICTUREMASK;
			whoami 	: ^_WHOAMI;
			pvl 	: ^_VARLABEL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_ConfigDriveList
		VAR_INPUT
			drvlst 	: ^CHAR;
			pthis 	: ^void;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Online
		VAR_INPUT
			station 	: UINT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_TryToAccess
		VAR_INPUT
			ptx 	: ^void;
			state 	: _ACCESSFAILED;
			found 	: _FOUNDHID;
			preselect 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_CheckHeap
		VAR_INPUT
			display 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_SwitchMultiStation
		VAR_INPUT
			station 	: UINT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL DoCmdInterface
		VAR_INPUT
			cmd 	: _PIC_COMMAND;
			op1 	: DINT;
			op2 	: DINT;
			psl 	: ^_STACK_LINE;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_ScreenSaverWillStart
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_ScreenSaverWillEnd
		VAR_INPUT
			pev 	: ^_EVENT;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Beep
		VAR_INPUT
			whobeep 	: _WHOBEEP;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_IpcIni
		VAR_INPUT
			pini 	: ^_IPCINI;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_SoftReset;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_UserStation
		VAR_INPUT
			station 	: UINT;
			pcd 	: ^_COMDEF;
			pobserve 	: ^BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="Interface will be called each time when uset will set value and correct accesslevel is not given" Name="IF_CantWriteNoAccess"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_CantWriteNoAccess
		VAR_INPUT
			pres 	: ^_RESULT;
			pvl 	: ^_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="Methode is called each time when project ends (eg.: softreset, lse-project download on the fly)" Name="IF_ProjectEnd"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_ProjectEnd;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_ProjectRun
		VAR_INPUT
			pe 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="method is called right after data were successfully written into system&#13;&#10;pres ... --&gt; to data&#13;&#10;pvar ... --&gt; to variable" Name="IF_WritePost"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_WritePost
		VAR_INPUT
			pres 	: ^_RESULT;
			pvar 	: ^_VARIABLE;
		END_VAR;
				//! <Function Comment="method is called to get information if window is moveable by user.&#13;&#10;return &apos;true&apos; if window is moveable, on the other hand &apos;false&apos;" Name="IF_WindowMoveable"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_WindowMoveable
		VAR_INPUT
			whoami 	: ^_WHOAMI;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="method is called when compileroption UC_PROGRESS is in use to implement userspecific view of startup-progress.&#13;&#10;NOTE: Do not rely on any projectitem, the may eventually not loaded yet." Name="IF_Progress"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Progress
		VAR_INPUT
			pscan 	: ^_SCAN;			//! <Variable Comment="pointer to individual scanbar" Name="IF_Progress.pscan"/>
			visible 	: BOOL;			//! <Variable Comment="parameter to indicate if standard progressbars are visible" Name="IF_Progress.visible"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;diese funktion wandelt eine zahl (4 Byte) in einen string um.&#13;&#10;die darstellung im string erfolgt dezimal.&#13;&#10;bitweise darstellung von format:&#13;&#10;.... .... .... **** no of digits&#13;&#10;.... .... **** .... position decimalpoint&#13;&#10;.... ...* .... .... preceding zeros&#13;&#10;.... ..*. .... .... descendant zeros&#13;&#10;.... .*.. .... .... vorzeichen unmittelbar vor wert (-3 ansonsten -  3)&#13;&#10;.... *... .... .... anzahl der stellen automatisch ermitteln&#13;&#10;" Name="Str_DToA"/>
	FUNCTION VIRTUAL GLOBAL Str_DToA
		VAR_INPUT
			pt 	: ^void;
			value 	: DINT;
			format 	: UINT;
			chr_size 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;diese funktion wandelt eine zahl (4 Byte) in einen string um.&#13;&#10;die darstellung im string erfolgt hexadezimal.&#13;&#10;bitweise darstellung von format:&#13;&#10;.... .... .... **** no of digits&#13;&#10;.... .... **** .... position decimalpoint&#13;&#10;.... ...* .... .... preceding zeros&#13;&#10;.... ..*. .... .... descendant zeros&#13;&#10;.... .*.. .... .... vorzeichen unmittelbar vor wert (-3 ansonsten -  3)&#13;&#10;.... *... .... .... anzahl der stellen automatisch ermitteln&#13;&#10;" Name="Str_DToH"/>
	FUNCTION VIRTUAL GLOBAL Str_DToH
		VAR_INPUT
			pt 	: ^void;
			value 	: DINT;
			format 	: UINT;
			chr_size 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;diese funktion ermittelt die anzahl der zeichen in einem string.&#13;&#10;der string wird mittels parameter txt bekanntgegeben.&#13;&#10;der parameter chr_size gibt auskunft ueber die groesse eines zeichens. (ASCII oder UNI code)&#13;&#10;" Name="Str_Len"/>
	FUNCTION VIRTUAL GLOBAL Str_Len
		VAR_INPUT
			txt 	: ^void;
			chr_size 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; diese funktion kopiert den string pt2 nach pt1.&#13;&#10; die parameter size1 und size2 geben auskunft ueber die jeweilige zeichengroesse&#13;&#10; uni und ascii-code string duerfen gemischt werden&#13;&#10;" Name="Str_Cpy"/>
	FUNCTION VIRTUAL GLOBAL Str_Cpy
		VAR_INPUT
			pt1 	: ^void;
			size1 	: UINT;
			pt2 	: ^void;
			size2 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; diese funktion kopiert den string pt2 an das ende von pt1.&#13;&#10; die parameter size1 und size2 geben auskunft ueber die jeweilige zeichengroesse&#13;&#10; uni und ascii-code string duerfen gemischt werden&#13;&#10;" Name="Str_Cat"/>
	FUNCTION VIRTUAL GLOBAL Str_Cat
		VAR_INPUT
			pt1 	: ^void;
			size1 	: UINT;
			pt2 	: ^void;
			size2 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; diese funktion vergleicht den string pt2 mit string pt1.&#13;&#10; die parameter size1 und size2 geben auskunft ueber die jeweilige zeichengroesse&#13;&#10; uni und ascii-code string duerfen gemischt werden&#13;&#10; sind beide strings ident so wird 0 zurueckgeliefert, ansonsten &lt;&gt;0&#13;&#10;" Name="Str_Cmp"/>
	FUNCTION VIRTUAL GLOBAL Str_Cmp
		VAR_INPUT
			pt1 	: ^void;
			size1 	: UINT;
			pt2 	: ^void;
			size2 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;diese funktion berechnet die größe eines strings in byte,&#13;&#10;wobei jedoch die abschließende 0 nicht mitgerechnet wird.&#13;&#10;" Name="Str_Size"/>
	FUNCTION VIRTUAL GLOBAL Str_Size
		VAR_INPUT
			pt1 	: ^void;
			size1 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;diese funktion sucht nach dem zeichen c im string p und gibt dessen position&#13;&#10;zurück. ist das zeichen c nicht im string vorhanden, so wird der wert 16#FFFF (65535) zurückgegeben.&#13;&#10;nach 0 (stringende) kann nicht gesucht werden; verwenden sie hierfür die funktion Str_Len().&#13;&#10;" Name="Str_Chr"/>
	FUNCTION VIRTUAL GLOBAL Str_Chr
		VAR_INPUT
			pt1 	: ^void;
			chr 	: _UNI;
			size1 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;im string pt1 werden alle kleinbuchstaben [a-z] auf großbuchstaben [A-Z] geändert.&#13;&#10;der parameter len gibt an, bis zu welcher position im string die zeichen geändert werden sollten.&#13;&#10;ist len gleich 0, so wird der gesamte string durchsucht.&#13;&#10;" Name="Str_Up"/>
	FUNCTION VIRTUAL GLOBAL Str_Up
		VAR_INPUT
			pt1 	: ^void;
			size1 	: UINT;
			len 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Fnt_Seek
		VAR_INPUT
			name 	: ^_ASCII;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Fnt_Set
		VAR_INPUT
			fnt 	: _FONT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Fnt_Size
		VAR_INPUT
			fnt 	: _FONT;
			x 	: ^UINT;
			y 	: ^UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetNo
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetDezPoint
		VAR_INPUT
			pvi 	: ^_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetSign
		VAR_INPUT
			pvi 	: ^_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetDigits
		VAR_INPUT
			pvi 	: ^_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetText
		VAR_INPUT
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetInvert
		VAR_INPUT
			info 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetUser
		VAR_INPUT
			info 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetRefr
		VAR_INPUT
			info 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetTool
		VAR_INPUT
			parameter 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetProt
		VAR_INPUT
			parameter 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetPde
		VAR_INPUT
			parameter 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetZero
		VAR_INPUT
			info 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetVarNo
		VAR_INPUT
			plabel 	: ^_ASCII;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetLabel
		VAR_INPUT
			pd 	: ^_ASCII;
			no 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetCompleteNoDigits
		VAR_INPUT
			pvi 	: ^_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_SetValueByNo
		VAR_INPUT
			no 	: UDINT;
			value 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;use this method to get data from a server which is adressed by servernumber&#13;&#10;note: function works just in case of numeric server (no time, date, string...)&#13;&#10;pn ......... servernumber&#13;&#10;pval ....... --&gt; to memorylocation where serverdata should be stored&#13;&#10;wait4plc ... TRUE means i want to wait till data are ready&#13;&#10;if server-data is valid, method returns TRUE on the other hand FALSE&#13;&#10;" Name="VarLst_GetValueByNo"/>
	FUNCTION VIRTUAL GLOBAL VarLst_GetValueByNo
		VAR_INPUT
			no 	: UDINT;
			pval 	: ^_IVALUE;
			wait4plc 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;use this method to set data which are defined by a _VARLABEL&#13;&#10;pr ............. --&gt; to structure who keeps data to store&#13;&#10;pv ............. --&gt; to structure where whole information about variable will be stored&#13;&#10;pvl ............ --&gt; to _VARLABEL which adresses your variable&#13;&#10;saveimmediate .. TRUE means i want to store data immediately&#13;&#10;if datas are stored, method returns TRUE on the other hand FALSE&#13;&#10;" Name="VarLst_SetSystemData"/>
	FUNCTION VIRTUAL GLOBAL VarLst_SetSystemData
		VAR_INPUT
			pr 	: ^_RESULT;
			pv 	: ^_VARIABLE;
			pvl 	: ^_VARLABEL;
			saveimmediate 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method returns the size of a variable which is defined by parameter pv&#13;&#10;pv ... --&gt; to structure which keeps information about variable&#13;&#10;method returns no of bytes. example: sizeof(DINT) or sizeof(USINT)&#13;&#10;" Name="VarLst_GetVariableSize"/>
	FUNCTION VIRTUAL GLOBAL VarLst_GetVariableSize
		VAR_INPUT
			pv 	: ^_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;use this method to get data which are defined by a _VARLABEL&#13;&#10;pr ........ --&gt; to structure where required data will be stored&#13;&#10;pv ........ --&gt; to structure where whole information about variable will be stored&#13;&#10;pvl ....... --&gt; to _VARLABEL which adresses your variable, maybe it could be a constant, date, time etc.&#13;&#10;wait4plc .. TRUE means i want to wait till data are ready&#13;&#10;if required variable is inaccessible, method returns FALSE on the other hand TRUE&#13;&#10;" Name="VarLst_GetSystemData"/>
	FUNCTION VIRTUAL GLOBAL VarLst_GetSystemData
		VAR_INPUT
			pr 	: ^_RESULT;
			pv 	: ^_VARIABLE;
			pvl 	: ^_VARLABEL;
			wait4plc 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this function gets the whole information about a variable&#13;&#10;pvi ... --&gt; to structure where information will be stored&#13;&#10;pvl ... --&gt; to information where variable is adressed&#13;&#10;if required variable is inaccessible, method returns FALSE on the other hand TRUE&#13;&#10;" Name="VarLst_GetVariable"/>
	FUNCTION VIRTUAL GLOBAL VarLst_GetVariable
		VAR_INPUT
			pv 	: ^_VARIABLE;
			pvl 	: ^_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this function gets the whole information about a variable&#13;&#10;pvi ... --&gt; to structure where information will be stored&#13;&#10;no .... number of variable&#13;&#10;if required variable is inaccessible, method returns FALSE on the other hand TRUE&#13;&#10;" Name="VarLst_GetSingleVariable"/>
	FUNCTION VIRTUAL GLOBAL VarLst_GetSingleVariable
		VAR_INPUT
			pv 	: ^_VARIABLE;
			no 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetVarInfo
		VAR_INPUT
			pvi 	: ^_VARINFO;
			no 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called when a new alarm is added during runtime to the alarmlist&#13;&#10;" Name="AddScreen"/>
	FUNCTION GLOBAL AddScreen
		VAR_INPUT
			ptr 	: ^void;
			whoami 	: ^_WHOAMI;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;use this method to get data which are defined by a _VARLABEL&#13;&#10;note: function works just in case of numeric server (no time, date, string...)&#13;&#10;pvl ........ --&gt; to _VARLABEL which adresses your server&#13;&#10;pd ......... --&gt; to memorylocation where serverdata should be stored&#13;&#10;wait4plc ... TRUE means i want to wait till data are ready&#13;&#10;if datas are stored, method returns TRUE on the other hand FALSE&#13;&#10;" Name="VarLst_GetValue"/>
	FUNCTION VIRTUAL GLOBAL VarLst_GetValue
		VAR_INPUT
			pvl 	: ^_VARLABEL;
			pd 	: ^_IVALUE;
			wait4plc 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetUnitInfo
		VAR_INPUT
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_UNIT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL VarLst_GetUnitNo
		VAR_INPUT
			punit 	: ^_ASCII;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL FindScreen
		VAR_INPUT
			whoami 	: ^_WHOAMI;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_PICPOI;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Out_ParameterString
		VAR_INPUT
			room 	: _ROOM;
			pt 	: ^_CHAR;
			pv 	: ^_MEM_VARLABEL;
			font 	: _FONT;
			att 	: _ATTRIB;
			col 	: _COLOR;
		END_VAR;
				//! <Function Comment="Diese Funktion gibt einen Text, der mittels dem Parameter txt angegeben ist&#13;&#10;im definierten Bereich (pr) aus.&#13;&#10;Parameter :&#13;&#10;txt     ^_CHAR    Pointer auf einen text&#13;&#10;pr     ^_ROOM   Pointer auf den Bereich&#13;&#10;font  _FONT       Schriftart&#13;&#10;att    _ATTRIB    Attribute (z.B T_BOLD &quot;fett&quot;)&#13;&#10;col   _COLOR     Farbe des Textes&#13;&#10;Diese Funktion gibt einen Text, der mittels dem Parameter txt angegeben ist&#13;&#10;im definierten Bereich (pr) aus.&#13;&#10;Parameter :&#13;&#10;txt     ^_CHAR    Pointer auf einen text&#13;&#10;pr     ^_ROOM   Pointer auf den Bereich&#13;&#10;font  _FONT       Schriftart&#13;&#10;att    _ATTRIB    Attribute (z.B T_BOLD &quot;fett&quot;)&#13;&#10;col   _COLOR     Farbe des Textes&#13;&#10;" Name="Out_TextAlign"/>
	FUNCTION VIRTUAL GLOBAL Out_TextAlign
		VAR_INPUT
			txt 	: ^_CHAR;
			pr 	: ^_ROOM;
			font 	: _FONT;
			att 	: _ATTRIB;
			col 	: _COLOR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TxtLst_GetNo
		VAR_INPUT
			list 	: _ANYLST;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TxtLst_GetPtr
		VAR_INPUT
			list 	: _ANYLST;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TxtLst_GetSize
		VAR_INPUT
			list 	: _ANYLST;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TxtLst_GetText
		VAR_INPUT
			list 	: _ANYLST;
			txtno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_CHAR;
		END_VAR;
				//! <Function Comment="Diese Funktion setzt ein geöffnetes File auf einen Error.&#13;&#10;Eventuell notwendig, wenn eine grosse Anzahl von Bytes aus dem File ausgelesen&#13;&#10;werden soll, aber nicht mehr genug Speicherkapazität zur Verfügung steht&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; auf das eigentliche Handle&#13;&#10;  ferr :  Übergabe der Fehlerart&#13;&#10;With this function you can set a file to an error. It will be necessary&#13;&#10; if you have to read a lot of bytes of the file,, but you haven&apos;t enough memory&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to handle&#13;&#10;  ferr :   error state&#13;&#10;" Name="File_SetError"/>
	FUNCTION VIRTUAL GLOBAL File_SetError
		VAR_INPUT
			filep 	: ^_LSEFILE;
			ferr 	: _FILE_ERROR;
		END_VAR;
				//! <Function Comment="Diese Funktion ist eine Weiterentwicklung der Funktion Lse_File_Read() und wird&#13;&#10;benötigt um eine einzelne Zeile aus einem TXT-File (Batch-File) auszulesen. Diese&#13;&#10;ausgelesene Zeile wird an die mit dst angegebene Adresse gespeichert.  Im Fehlerfall&#13;&#10;liefert diese Funktion FALSE ansonsten TRUE. Es muss darauf geachtet werden,&#13;&#10;dass das Handle auch zum Lesen geöffnet wurde. Da diese Funktion nach der&#13;&#10;Zeichenfolge CR und LF sucht, bzw. diese Kennung als Satzende interpretiert muss&#13;&#10;mit dem Parameter maxsize die maximale Anzahkl der zu lesenden Bytes angegeben&#13;&#10;werden. Ansonsten könnte es beim Fehlen dieser Kennung zu einem Systemabsturz&#13;&#10;führen.&#13;&#10;Rückgabewert:&#13;&#10; TRUE   Erfolg&#13;&#10; FALSE  Fehler, Daten auf dst können nicht weiterverwendet werden&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; auf das eigentliche Handle&#13;&#10; dst:  --&gt; auf Datenbereich&#13;&#10;maxsize: maximale anzahl der zu lesenden Bytes&#13;&#10;Beispiel:&#13;&#10; handle : _FILE ;&#13;&#10; line : ARRAY[0..99] of _ASCII;&#13;&#10; retcode : ;&#13;&#10; Lse_File_Open(&amp;handle, LOAD, &quot;C:\\TEST.TXT&quot;); // open File&#13;&#10; Lse_File_Read(&amp;handle, line, 100); // erste Zeile einlesen&#13;&#10; retcode = Lse_File_Close(&amp;handle); // close File samt erfolgsabfrage&#13;&#10;This function is a further development of the read function&#13;&#10;It is used for reading one line of a TXT-file. This line will be saved in the adress&#13;&#10;of dst. This function searchs for CR and LF and so you have to define a maximum&#13;&#10;size of bytes for reading one line. Without the definition of maxsize you can get&#13;&#10;an system error&#13;&#10;returned value:&#13;&#10; TRUE   success&#13;&#10; FALSE  error, you can&apos;t use the data on dst&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to Handle&#13;&#10; dst:  --&gt; to data area&#13;&#10;maxsize: maximum size of reading bytes&#13;&#10;exampple:&#13;&#10; handle : _FILE ;&#13;&#10; line : ARRAY[0..99] of _ASCII;&#13;&#10; retcode : ;&#13;&#10; Lse_File_Open(&amp;handle, LOAD, &quot;C:\\TEST.TXT&quot;); // open file&#13;&#10; Lse_File_Read(&amp;handle, line, 100); // read first line&#13;&#10; retcode = Lse_File_Close(&amp;handle); // close file including check success&#13;&#10;" Name="File_Read_CRLF"/>
	FUNCTION VIRTUAL GLOBAL File_Read_CRLF
		VAR_INPUT
			filep 	: ^_LSEFILE;
			dest 	: pVoid;
			maxsize 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Diese Funktion öffnet ein File welches mittels Parameter dpne angegeben wurde.&#13;&#10;Falls ein Handle mit dieser Funktion geöffnet wurde, darf auf das Schliessen mit&#13;&#10;Lse_File_Close() nicht vergessen werden.&#13;&#10;Rückgabewert:&#13;&#10; TRUE   falls  Handle erfolgreich geöffnet wurde&#13;&#10; FALSE  Fehler&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; auf das eigentliche Handle&#13;&#10; state: File zum lesen (LOAD), schreiben(SAVE) oder lesen und schreiben (LOADSAVE) öffnen&#13;&#10; dpne: Drive, Path, Name und Extension des Files&#13;&#10;Beispiel:&#13;&#10; handle : _FILE;&#13;&#10; Lse_File_Open(#handle, LOAD, &quot;C:\\TEST.TXT&quot;); // read only&#13;&#10; Lse_File_Open(#handle, SAVE, &quot;C:\\TEST.TXT&quot;); // write only&#13;&#10;This function open a file with the defined parameter dpne. If you open a file with&#13;&#10;function you have to close the file with Lse_File_Close().&#13;&#10;returned value:&#13;&#10; TRUE   if file could be opened&#13;&#10; FALSE   error&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to handle&#13;&#10; state: File for reading (LOAD), writing(SAVE) or reading and writing (LOADSAVE) open&#13;&#10; dpne: drive, path, name and extension of the file&#13;&#10;example:&#13;&#10; handle : _FILE;&#13;&#10; Lse_File_Open(#handle, LOAD, &quot;C:\\TEST.TXT&quot;); // read only&#13;&#10; Lse_File_Open(#handle, SAVE, &quot;C:\\TEST.TXT&quot;); // write only&#13;&#10;" Name="File_Open"/>
	FUNCTION VIRTUAL GLOBAL File_Open
		VAR_INPUT
			filep 	: ^_LSEFILE;
			state 	: _FILE_STATE;
			dpne 	: ^_ASCII;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Diese Funktion schliesst ein vorher mit Lse_File_Open() geöffnetes Handle.&#13;&#10;Als Parameter wird ein Pointer auf das Handle mitgegeben.&#13;&#10;Rückgabewert:&#13;&#10; TRUE&#13;&#10; FALSE  während der arbeit mit diesem Handle ist ein Fehler aufgetreten&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; auf das eigentliche Handle&#13;&#10;Beispiel:&#13;&#10; handle : _FILE;&#13;&#10; Lse_File_Open(#handle, LOAD, &quot;C:\\TEST.TXT&quot;); // open File&#13;&#10; Lse_File_Close(#handle); // close File&#13;&#10; This function closes an already opened file (with Lse_File_Open() )&#13;&#10; the parameter is a pointer to the handle&#13;&#10;returned value:&#13;&#10; TRUE&#13;&#10; FALSE  during  work with this handle an error occurred&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to Handle&#13;&#10;example:&#13;&#10; handle : _FILE;&#13;&#10; Lse_File_Open(#handle, LOAD, &quot;C:\\TEST.TXT&quot;); // open File&#13;&#10; Lse_File_Close(#handle); // close File&#13;&#10;" Name="File_Close"/>
	FUNCTION VIRTUAL GLOBAL File_Close
		VAR_INPUT
			filep 	: ^_LSEFILE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Ermittelt die aktuelle Lese- oder Schreib Position im File (aktueller Filepointer)&#13;&#10;Rückgabewert:&#13;&#10; Position des aktuellen Filepointers&#13;&#10;Parameter:&#13;&#10;  handle : --&gt; auf das eigentliche Handle&#13;&#10;With this function you will get the actual read or write pointer in the opened file&#13;&#10;returned value:&#13;&#10; position of the actual read or write pointer&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to Handle&#13;&#10;" Name="File_Tell"/>
	FUNCTION VIRTUAL GLOBAL File_Tell
		VAR_INPUT
			filep 	: ^_LSEFILE;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Versetzt den Filepointer an die angegebene Position&#13;&#10;Rückgabewert:&#13;&#10; TRUE Versetzen des Filepointers wurde erfolgreich durchgeführt&#13;&#10; FALSE  Keine Versetzen des Filepointers möglich&#13;&#10;Parameter:&#13;&#10;  handle : --&gt; uf das eigentliche Handle&#13;&#10;  offs :  neue Position des Filepointers&#13;&#10;  fromwhere : Angabe von wo die neue Position ermittelt werden soll&#13;&#10;    SEEK_SET von Beginn des Files&#13;&#10;    SEEK_CUR offs gibt die absolute Position des Filepointers an&#13;&#10;    SEEK_END am letzen Eintrag des Files&#13;&#10;With this function you set the read or write pointer in the opened file&#13;&#10;on a defined position&#13;&#10;returned value:&#13;&#10; TRUE the new position of the pointer is ok&#13;&#10; FALSE  during moving of the pointer an error occurred&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to Handle&#13;&#10;  offs :  new position of the filepointer&#13;&#10;  fromwhere : fromwhere should the new position computed&#13;&#10;    SEEK_SET from the startposition of the file&#13;&#10;    SEEK_CUR offs is the new absolut position&#13;&#10;    SEEK_END position is the last entry of the file&#13;&#10;" Name="File_Seek"/>
	FUNCTION VIRTUAL GLOBAL File_Seek
		VAR_INPUT
			filep 	: ^_LSEFILE;
			offs 	: _DWORD;
			fromwhere 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Ermittelt die aktuelle Grösse des Files in Byte&#13;&#10;Rückgabewert:&#13;&#10; Aktuelle Grösse des Files in Byte&#13;&#10;Parameter:&#13;&#10;  handle : --&gt; auf das eigentliche Handle&#13;&#10;With this function you will get the actual size of the file (bytes)&#13;&#10;returned value:&#13;&#10; the actual size of the file in byte&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to Handle&#13;&#10;" Name="File_Length"/>
	FUNCTION VIRTUAL GLOBAL File_Length
		VAR_INPUT
			filep 	: ^_LSEFILE;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Diese Funktion list eine definierte Anzahl von Bytes von einem vorher mit&#13;&#10;Lse_File_Open() geöffneten Handle. Diese Bytes werden an die mit dst angegebene&#13;&#10;Adresse gespeichert.  Im Fehlerfall liefert diese Funktion FALSE ansonsten TRUE.&#13;&#10;Eine Fehlerabarbeitung ist bereits im Handle gelöest. Es ist daher nicht notwendig&#13;&#10;nach jedem Aufruf dieser Funktion den Return-Parameter auszuwerten.&#13;&#10;Es muss darauf geachtet werden, dass das Handle auch zum Lesen geöffnet wurde.&#13;&#10;Rückgabewert:&#13;&#10; TRUE  Erfolg&#13;&#10; FALSE  Fehler, Daten auf dst können nicht weiterverwendet werden&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; auf das eigentliche Handle&#13;&#10; dst:  --&gt; auf Datenbereich&#13;&#10;  size: anzahl der zu lesenden Bytes&#13;&#10;Beispiel:&#13;&#10; handle : _FILE;&#13;&#10; word : INT;&#13;&#10; retcode : BOOL;&#13;&#10; Lse_File_Open(#handle, LOAD, &quot;C:\\TEST.TXT&quot;); // open File&#13;&#10; Lse_File_Read(#handle, #word, sizeof(INT)); // 2 Byte lesen&#13;&#10; Lse_File_Read(#handle, #word, sizeof(INT)); // weitere 2 Byte lesen&#13;&#10; retcode = Lse_File_Close(#handle); // close File samt erfolgsabfrage&#13;&#10;This function reads a defined size of bytes of an already opened file(handle)&#13;&#10;The bytes are saved to the adress of the paramter dst. An error processing is&#13;&#10;in integrated in the handle.It isn&apos;t necessary to check the returned value&#13;&#10;every time.&#13;&#10;It is important, that the file is opened for writing&#13;&#10;returned value:&#13;&#10; TRUE  success&#13;&#10; FALSE  error, you can&apos;t use the data on dst&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to Handle&#13;&#10; dst:  --&gt; to data area&#13;&#10;  size: size of the reading bytes&#13;&#10;example:&#13;&#10; handle : _FILE;&#13;&#10; word : INT;&#13;&#10; retcode : BOOL;&#13;&#10; Lse_File_Open(#handle, LOAD, &quot;C:\\TEST.TXT&quot;); // open File&#13;&#10; Lse_File_Read(#handle, #word, sizeof(INT)); // read 2 Byte&#13;&#10; Lse_File_Read(#handle, #word, sizeof(INT)); // read the next 2 Byte&#13;&#10; retcode = Lse_File_Close(#handle); // close File including check success&#13;&#10;" Name="File_Read"/>
	FUNCTION VIRTUAL GLOBAL File_Read
		VAR_INPUT
			filep 	: ^_LSEFILE;
			dest 	: pVoid;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Diese Funktion schreibt eine definierte Anzahl von Bytes in ein vorher mit&#13;&#10;Lse_File_Open() geöffnetes Handle. Im Fehlerfall liefert diese Funktion FALSE&#13;&#10;ansonsten TRUE. Eine Fehlerabarbeitung ist bereits im Handle gelöest. Es ist daher&#13;&#10;nicht notwendig nach jedem Aufruf dieser Funktion den Return-Parameter auszuwerten.&#13;&#10;Es muss darauf geachtet werden, dass das Handle auch zum Schreiben geöffnet wurde.&#13;&#10;Rückgabewert:&#13;&#10; TRUE  Erfolg&#13;&#10; FALSE  Fehler, Daten wurden nicht ins Handle gespeichert&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; auf das eigentliche Handle&#13;&#10; src:  --&gt; auf Datenbereich&#13;&#10; size: anzahl der zu schreibenden Bytes&#13;&#10;Beispiel:&#13;&#10; handle _FILE;&#13;&#10; word INT;&#13;&#10; retcode BOOL;&#13;&#10; Lse_File_Open(#handle, SAVE, &quot;C:\\TEST.TXT&quot;); // open File&#13;&#10; Lse_File_Write(#handle, &quot;aa&quot;, sizeof(INT)); // 2 Byte schreiben&#13;&#10; Lse_File_Write(#handle, &quot;bb&quot;, sizeof(INT)); // weitere 2 Byte schreiben&#13;&#10; retcode = Lse_File_Close(#handle); // close File samt erfolgsabfrage&#13;&#10;This function writes a defined size of bytes in an already opened file (handle)&#13;&#10;An error processing is in integrated in the handle.&#13;&#10;It isn&apos;t necessary to check the returned value every time&#13;&#10;It is important, that the file is opened for writing&#13;&#10;returned value:&#13;&#10; TRUE  success&#13;&#10; FALSE  error, data couldn&apos;t write in the file (handle)&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to Handle&#13;&#10; src:  --&gt; to data area&#13;&#10; size: size of data to write&#13;&#10;example:&#13;&#10; handle _FILE;&#13;&#10; word INT;&#13;&#10; retcode BOOL;&#13;&#10; Lse_File_Open(#handle, SAVE, &quot;C:\\TEST.TXT&quot;); // open File&#13;&#10; Lse_File_Write(#handle, &quot;aa&quot;, sizeof(INT)); // write 2 Byte&#13;&#10; Lse_File_Write(#handle, &quot;bb&quot;, sizeof(INT)); // write the next 2 Byte&#13;&#10; retcode = Lse_File_Close(#handle); // close File including check success&#13;&#10;" Name="File_Write"/>
	FUNCTION VIRTUAL GLOBAL File_Write
		VAR_INPUT
			filep 	: ^_LSEFILE;
			dest 	: pVoid;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Diese Funktion liefert den Error-Status eines bereits geöffneten Handle zurück.&#13;&#10;Nach dem Aufruf von Lse_File_Close() kann diese Funktion nicht mehr verwendet&#13;&#10;werden.&#13;&#10;Rückgabewert:&#13;&#10; TRUE     es ist bereits ein Fehler aufgetreten&#13;&#10; FALSE   bis zu diesem Zeitpunkt kein Fehler aufgetreten&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; auf das eigentliche Handle&#13;&#10;With this function you will get the error state of an already opened handle&#13;&#10;You can&apos;t use this function after calling the function  LSE_File_Close()&#13;&#10;returned value:&#13;&#10; TRUE     it already exists an error&#13;&#10; FALSE    no error up to now&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to handle&#13;&#10;" Name="File_GetError"/>
	FUNCTION VIRTUAL GLOBAL File_GetError
		VAR_INPUT
			filep 	: ^_LSEFILE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;This function delete a file with the defined parameter dpne.&#13;&#10;The file must be closed.&#13;&#10;&#13;&#10;returned value:&#13;&#10; TRUE   if file could be deleted&#13;&#10; FALSE   error&#13;&#10;Parameter:&#13;&#10; handle:  --&gt; to handle&#13;&#10; dpne: drive, path, name and extension of the file&#13;&#10;example:&#13;&#10; handle : _FILE;&#13;&#10; Lse_File_Remove(#handle, &quot;C:\\TEST.TXT&quot;);&#13;&#10;" Name="File_Remove"/>
	FUNCTION VIRTUAL GLOBAL File_Remove
		VAR_INPUT
			filep 	: ^_LSEFILE;
			dpne 	: ^_ASCII;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_GetLinePosition
		VAR_INPUT
			pt1 	: ^_SCROLL;
			y 	: UINT;
			pr 	: ^_ROOM;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_OutLine
		VAR_INPUT
			pt1 	: ^_SCROLL;
			y 	: UINT;
			no 	: UINT;
			beam 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_Beam
		VAR_INPUT
			pt1 	: ^_SCROLL;
			y 	: UINT;
			no 	: UINT;
			state 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_ActBeam
		VAR_INPUT
			pt1 	: ^_SCROLL;
			state 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_Draw
		VAR_INPUT
			pt1 	: ^_SCROLL;
			beam 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_Start
		VAR_INPUT
			pt1 	: ^_SCROLL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_Ready
		VAR_INPUT
			pt1 	: ^_SCROLL;
			beam 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_Run
		VAR_INPUT
			pt1 	: ^_SCROLL;
			pevent 	: ^_EVENT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_End
		VAR_INPUT
			pt1 	: ^_SCROLL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_OutPage
		VAR_INPUT
			pt1 	: ^_SCROLL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_ScrollUp
		VAR_INPUT
			pt1 	: ^_SCROLL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_ScrollDown
		VAR_INPUT
			pt1 	: ^_SCROLL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_GetPosition
		VAR_INPUT
			pt1 	: ^_SCROLL;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_level_draw
		VAR_INPUT
			pt1 	: ^_LEVEL;
			horiz 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SCROLL_level_run
		VAR_INPUT
			pt1 	: ^_LEVEL;
			no 	: DINT;
			pos 	: DINT;
			horiz 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Lib_FormatValue
		VAR_INPUT
			txt 	: ^_CHAR;
			value 	: _IVALUE;
			pi1 	: ^_VARINFO;
			pf1 	: ^_PICFORMAT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Lib_FormatTime
		VAR_INPUT
			txt 	: ^_CHAR;
			pt1 	: ^_TIME;
			format 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Lib_FormatDate
		VAR_INPUT
			txt 	: ^_CHAR;
			pt1 	: ^_DATE;
			format 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BMP_Draw
		VAR_INPUT
			x1 	: _KOORD;
			y1 	: _KOORD;
			dpne 	: ^_ASCII;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BMP_Save
		VAR_INPUT
			dpne 	: ^_ASCII;
			x1 	: _KOORD;
			y1 	: _KOORD;
			x2 	: _KOORD;
			y2 	: _KOORD;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetReady
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL AddGlobal
		VAR_INPUT
			ptr 	: ^_Global;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SetThisPointer
		VAR_INPUT
			pointer 	: ^void;
			index 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL AddOszi
		VAR_INPUT
			ptr 	: ^_OsziLSE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_STOP
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL GLOBAL Thread2
		VAR_INPUT
			pthis 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL AddGlobalEx
		VAR_INPUT
			ptr 	: ^_Global;
			para 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION InitJpgLib;
	
	FUNCTION VIRTUAL GLOBAL Lse::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Language::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DelayScreenSaver::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DelayScreenSaver::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CommaSign::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CommaSign::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AmericanDateFormat::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AmericanDateFormat::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GotAlarm::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SeekAlgorithm::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SeekAlgorithm::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OpSysVersion::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DirectionOnEnter::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CursorWrapHorizontal::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CursorWrapVertical::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OfflineMode::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL NoExternCom::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AmericanTimeFormat::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AmericanTimeFormat::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActivateBubbleHelp::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd DataServiceClient
#pragma usingLtd GetBroadCastData


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _Lse::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__LSE
0$UINT, 128$UINT, (SIZEOF(::_Lse))$UINT, 
19$UINT, 5$UINT, 0$UINT, 
TO_UDINT(1552551876), "_Lse", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_Lse.Lse.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(299963966), "Lse", 
(::_Lse.Language.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(317255161), "Language", 
(::_Lse.LseVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1352387781), "LseVersion", 
(::_Lse.CompilerVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1779595821), "CompilerVersion", 
(::_Lse.DelayScreenSaver.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4079336021), "DelayScreenSaver", 
(::_Lse.CommaSign.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2324505737), "CommaSign", 
(::_Lse.AmericanDateFormat.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3375599169), "AmericanDateFormat", 
(::_Lse.GotAlarm.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(651110556), "GotAlarm", 
(::_Lse.SeekAlgorithm.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3850326751), "SeekAlgorithm", 
(::_Lse.SystemMessage.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2035048664), "SystemMessage", 
(::_Lse.OpSysVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(198377262), "OpSysVersion", 
(::_Lse.DirectionOnEnter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(329568312), "DirectionOnEnter", 
(::_Lse.CursorWrapHorizontal.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3100032135), "CursorWrapHorizontal", 
(::_Lse.CursorWrapVertical.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1194532108), "CursorWrapVertical", 
(::_Lse.OfflineMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2598403969), "OfflineMode", 
(::_Lse.NoExternCom.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(780782003), "NoExternCom", 
(::_Lse.AmericanTimeFormat.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(917604273), "AmericanTimeFormat", 
(::_Lse.ActivateBubbleHelp.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1446036184), "ActivateBubbleHelp", 
(::_Lse.LseProjectRevision.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3083793750), "LseProjectRevision", 
//Clients:
(::_Lse.Gbcd.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4269571961), "Gbcd", TO_UDINT(4194672191), "GetBroadCastData", 0$UINT, 10$UINT, 
(::_Lse.LseReady.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1331417148), "LseReady", 
(::_Lse.EventProcessor.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2865008861), "EventProcessor", 
(::_Lse.JpgLib.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3778578354), "JpgLib", 
(::_Lse.DataServiceClient.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1926365810), "DataServiceClient", TO_UDINT(1926365810), "DataServiceClient", 0$UINT, 2$UINT, 
END_FUNCTION


#define USER_CNT__Lse 132

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__Lse] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _Lse::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__Lse, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #IF_WindowStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IF_WindowReady();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #IF_WindowRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #IF_WindowEnd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_UserCall();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #IF_AccessInput();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_ChkEnable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #IF_SystemError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #IF_Recalculate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #IF_DrawBubbleHelp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #IF_UrInit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #IF_ProjectStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #IF_ProjectReady();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #IF_InputIsSaved();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #IF_PowerDown();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #IF_InputWithoutAccess();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #IF_OpenEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #IF_Write();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #IF_CheckPrefix();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #IF_GetLookUpEmbeddedPointer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #IF_SetStatus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #IF_Trace();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #IF_GetHeapInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #IF_FoundSomethingByHid();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #IF_PopUpCall();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #IF_GetThisPointer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #IF_OpenTouchEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #IF_AccessButton();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #IF_GetStatus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #IF_LanguageHasChanged();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #IF_LanguageWillChange();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #IF_Offline();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #EP_StartEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #EP_StopEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #EP_GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #EP_SetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #IF_OverloadEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #IF_ConfigDriveList();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #IF_Online();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #IF_TryToAccess();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #IF_CheckHeap();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[42]		:= #IF_SwitchMultiStation();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #DoCmdInterface();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[44]		:= #IF_ScreenSaverWillStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #IF_ScreenSaverWillEnd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #IF_Beep();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #IF_IpcIni();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[48]		:= #IF_SoftReset();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[49]		:= #IF_UserStation();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[50]		:= #IF_CantWriteNoAccess();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[51]		:= #IF_ProjectEnd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[52]		:= #IF_ProjectRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[53]		:= #IF_WritePost();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[54]		:= #IF_WindowMoveable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[55]		:= #IF_Progress();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[56]		:= #Str_DToA();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[57]		:= #Str_DToH();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[58]		:= #Str_Len();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[59]		:= #Str_Cpy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[60]		:= #Str_Cat();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[61]		:= #Str_Cmp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[62]		:= #Str_Size();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[63]		:= #Str_Chr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[64]		:= #Str_Up();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[65]		:= #Fnt_Seek();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[66]		:= #Fnt_Set();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[67]		:= #Fnt_Size();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[68]		:= #VarLst_GetNo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[69]		:= #VarLst_GetDezPoint();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[70]		:= #VarLst_GetSign();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[71]		:= #VarLst_GetDigits();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[72]		:= #VarLst_GetText();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[73]		:= #VarLst_GetInvert();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[74]		:= #VarLst_GetUser();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[75]		:= #VarLst_GetRefr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[76]		:= #VarLst_GetTool();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[77]		:= #VarLst_GetProt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[78]		:= #VarLst_GetPde();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[79]		:= #VarLst_GetZero();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[80]		:= #VarLst_GetVarNo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[81]		:= #VarLst_GetLabel();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[82]		:= #VarLst_GetCompleteNoDigits();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[83]		:= #VarLst_SetValueByNo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[84]		:= #VarLst_GetValueByNo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[85]		:= #VarLst_SetSystemData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[86]		:= #VarLst_GetVariableSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[87]		:= #VarLst_GetSystemData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[88]		:= #VarLst_GetVariable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[89]		:= #VarLst_GetSingleVariable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[90]		:= #VarLst_GetVarInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[91]		:= #VarLst_GetValue();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[92]		:= #VarLst_GetUnitInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[93]		:= #VarLst_GetUnitNo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[94]		:= #Out_ParameterString();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[95]		:= #Out_TextAlign();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[96]		:= #TxtLst_GetNo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[97]		:= #TxtLst_GetPtr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[98]		:= #TxtLst_GetSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[99]		:= #TxtLst_GetText();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[100]		:= #File_SetError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[101]		:= #File_Read_CRLF();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[102]		:= #File_Open();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[103]		:= #File_Close();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[104]		:= #File_Tell();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[105]		:= #File_Seek();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[106]		:= #File_Length();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[107]		:= #File_Read();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[108]		:= #File_Write();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[109]		:= #File_GetError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[110]		:= #File_Remove();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[111]		:= #SCROLL_GetLinePosition();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[112]		:= #SCROLL_OutLine();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[113]		:= #SCROLL_Beam();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[114]		:= #SCROLL_ActBeam();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[115]		:= #SCROLL_Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[116]		:= #SCROLL_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[117]		:= #SCROLL_Ready();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[118]		:= #SCROLL_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[119]		:= #SCROLL_End();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[120]		:= #SCROLL_OutPage();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[121]		:= #SCROLL_ScrollUp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[122]		:= #SCROLL_ScrollDown();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[123]		:= #SCROLL_GetPosition();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[124]		:= #SCROLL_level_draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[125]		:= #SCROLL_level_run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[126]		:= #Lib_FormatValue();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[127]		:= #Lib_FormatTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[128]		:= #Lib_FormatDate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[129]		:= #BMP_Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[130]		:= #BMP_Save();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[131]		:= #IF_STOP();

#pragma warning (default : 74)
	Lse.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Lse.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Language.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Language::Write() );
	IF Language.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DelayScreenSaver.pMeth			:= StoreMethod( #DelayScreenSaver::Read(), #DelayScreenSaver::Write() );
	IF DelayScreenSaver.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CommaSign.pMeth			:= StoreMethod( #CommaSign::Read(), #CommaSign::Write() );
	IF CommaSign.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AmericanDateFormat.pMeth			:= StoreMethod( #AmericanDateFormat::Read(), #AmericanDateFormat::Write() );
	IF AmericanDateFormat.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	GotAlarm.pMeth			:= StoreMethod( #M_RD_DIRECT(), #GotAlarm::Write() );
	IF GotAlarm.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SeekAlgorithm.pMeth			:= StoreMethod( #SeekAlgorithm::Read(), #SeekAlgorithm::Write() );
	IF SeekAlgorithm.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SystemMessage.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SystemMessage.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	OpSysVersion.pMeth			:= StoreMethod( #OpSysVersion::Read(), #M_NO_F() );
	IF OpSysVersion.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DirectionOnEnter.pMeth			:= StoreMethod( #M_RD_DIRECT(), #DirectionOnEnter::Write() );
	IF DirectionOnEnter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CursorWrapHorizontal.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CursorWrapHorizontal::Write() );
	IF CursorWrapHorizontal.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CursorWrapVertical.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CursorWrapVertical::Write() );
	IF CursorWrapVertical.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	OfflineMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #OfflineMode::Write() );
	IF OfflineMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	NoExternCom.pMeth			:= StoreMethod( #M_RD_DIRECT(), #NoExternCom::Write() );
	IF NoExternCom.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AmericanTimeFormat.pMeth			:= StoreMethod( #AmericanTimeFormat::Read(), #AmericanTimeFormat::Write() );
	IF AmericanTimeFormat.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActivateBubbleHelp.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ActivateBubbleHelp::Write() );
	IF ActivateBubbleHelp.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _Lse();

END_FUNCTION

#pragma usingLtd _AlarmDisplay
#pragma usingLtd _Bit32
#pragma usingLtd _Bit32Ram
#pragma usingLtd _Global
#pragma usingLtd _HotAlarm
#pragma usingLtd _LanguageSelection
#pragma usingLtd _LimitMax
#pragma usingLtd _LimitMin
#pragma usingLtd _MyIO
#pragma usingLtd _OsziLSE
#pragma usingLtd _Radio32
#pragma usingLtd _Radio32Ram
#pragma usingLtd _Screen
#pragma usingLtd _ScrollArea
#pragma usingLtd _ScrollArea2
#pragma usingLtd _SysDateTime
#pragma usingLtd _ToolCat
#pragma usingLtd _XAccess

//{{LSL_IMPLEMENTATION
#pragma using _Global
#pragma using _OsziLSE
#pragma using _ToolCat
#pragma using _ScrollArea
#pragma using _ScrollArea2
#pragma using _LanguageSelection
#pragma using _XAccess
#pragma using _LimitMin
#pragma using _LimitMax
#pragma using _SysDateTime
#pragma using _Screen

#include <t_grc.h>
//#include <LSL_ST_KERNEL.H> // necessary to get lasalos information
//#include <rtos_interfaces.h>
//#include <rtos_variables.h>

#include <lsl_st_mt.h>
#include <Lsl_st_ifssr.h>
#include <lsl_st_sysmsg.h>
#include <lsl_st_tcp_user.h>
#include <ComTypes.h>

VAR_GLOBAL
  _SigmatekOpSysInfo AT % M 0F44     : UDINT;
END_VAR

VAR_PRIVATE
  PThis_Lse      : ^_Lse;
  mt_api         : ^LSL_MT_TYPE;
  MutexHandler   : array[0..4] of MT_SEMAHANDLE; 
  Thread2Handle  : MT_TASKHANDLE;
  MailBox2Handle : MT_MAILBOX;
  OS_pLslSysMsg  : ^OS_LSLSYSMSG;
  lsl_tcp_user   : ^LSL_TCP_USER;
  TxData         : array[0..31] of results;
  TxDataIndex    : UDINT;
END_VAR

#define MailBox2RecordSize 516

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::EP_StartEvent
VAR_OUTPUT
  retcode : _DOIT;
END_VAR
VAR
  para  : CmdStruct;
END_VAR

  retcode := _IDLE;

  if(IsEventProcessor = TRUE) then
    retcode := _IFAILED;
    para.uiCmd := 0;
    para.aPara[0] := 16#FFFF;
    if((EventProcessor.NewInst(#para, NIL))$BOOL = TRUE) then
      retcode := _IDIDIT;
    end_if;
  end_if;
  
END_FUNCTION

#ifdef UC_JPG
FUNCTION GLOBAL __CDECL jpg_load_jpg VAR_INPUT width : ^uint; height : ^uint; dpne : ^char; errorcode : ^uint; pcallback : ^void; END_VAR VAR_OUTPUT retcode : ^usint; END_VAR;
FUNCTION GLOBAL __CDECL jpg_save_jpg VAR_INPUT dpne : ^char; rgb : ^usint; width : uint; height : uint; quality : uint; color : uint; END_VAR VAR_OUTPUT retcode : udint; END_VAR;
#endif

FUNCTION _Lse::InitJpgLib

 #ifdef UC_JPG
  JpgFunctSetup(#jpg_load_jpg(), #jpg_save_jpg());
 #else
  VAR
    psave, pload : ^void;
    para  : CmdStruct;
  END_VAR
  
  if(IsClientConnected(#JpgLib) = TRUE) then
    pload := NIL;
    para.uiCmd := 133;
    para.aPara[0]$^void := #pload;
    JpgLib.NewInst(#para, NIL);
    
    psave := NIL;
    para.uiCmd := 134;
    para.aPara[0]$^void := #psave;
    JpgLib.NewInst(#para, NIL);
    
    JpgFunctSetup(pload, psave);
  end_if;
 #endif
 
END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::EP_StopEvent
VAR_OUTPUT
  retcode : _DOIT;
END_VAR
VAR
  para  : CmdStruct;
END_VAR

  retcode := _IDLE;

  if(IsEventProcessor = TRUE) then
    retcode := _IDIDIT;
    para.uiCmd := 1;
    para.aPara[0] := 16#FFFF;
    EventProcessor.NewInst(#para, NIL);
  end_if;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::EP_GetEvent
VAR_INPUT
  posev : ^_OSEVENT;
END_VAR
VAR_OUTPUT
  retcode : _DOIT;
END_VAR
VAR
  para  : CmdStruct;
END_VAR

  retcode := _IDLE;

  if(IsEventProcessor = TRUE) then
    retcode := _IFAILED;
    para.uiCmd := 2;
    para.aPara[0] := posev$DINT;
    para.aPara[1] := 16#FFFF;
    if((EventProcessor.NewInst(#para, NIL))$BOOL = TRUE) then
      retcode := _IDIDIT;
    end_if;
  end_if;
    
END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::EP_SetEvent
VAR_INPUT
  posev : ^_OSEVENT;
END_VAR
VAR_OUTPUT
  retcode : _DOIT;
END_VAR
VAR
  para  : CmdStruct;
END_VAR

  retcode := _IDLE;

  if(IsEventProcessor = TRUE) then
    retcode := _IFAILED;
    para.uiCmd := 3;
    para.aPara[0] := posev$DINT;
   #ifdef USER_DEKEMA
    para.aPara[1] := posev^.eventSourceID;
   #else
    para.aPara[1] := 16#FFFF;
   #endif
    if((EventProcessor.NewInst(#para, NIL))$BOOL = TRUE) then
      retcode := _IDIDIT;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL __CDECL _Screen_GetAccess
  VAR_INPUT
    pwai : ^_WHOAMI;
  END_VAR
  VAR_OUTPUT
    retcode : bool;
  END_VAR

  retcode := false;
  if(PThis_Lse^.FindScreen(pwai) <> NIL) then
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION GLOBAL __CDECL _Screen_Create
  VAR_INPUT
    psetup : ^_NEWSCREENPROP;
    pwai : ^_WHOAMI;
  END_VAR
  VAR_OUTPUT
    retcode : bool;
  END_VAR
  VAR
  	pp : ^_Lse::_PICPOI;
  END_VAR

  pp := PThis_Lse^.FindScreen(pwai);
  if(pp <> NIL) then
    retcode := pp^.ptr$^_Screen^.S_CreateNew(psetup);
  end_if;

END_FUNCTION

FUNCTION GLOBAL __CDECL LseTxCommand VAR_INPUT bef:UDINT; len:UDINT; pdata:^USINT; pcd:^void; presult:^pVoid; svrtyp:DINT; END_VAR VAR_OUTPUT retcode:DINT; END_VAR
 #ifdef CANOPEN
  retcode := TXCOMMAND(bef, len, pdata, pcd$^Comdef, presult$^UDINT, svrtyp);
 #else
  var
    reason : comlinkReason;
    ptx    : ^results;
    idx : udint;
  end_var
  
  retcode := COMLINK_ERR_GENERAL;
  
  idx := lib_atomic_incU32(#TxDataIndex);
  idx := (idx + 1) mod lib_arraysize(TxData);

  ptx        := #TxData[idx];
  presult^   := NIL;
  ptx^.uiLng := 0;
  if(TXCOMMANDEX(bef, len, pdata, pcd$^Comdef, ptx, sizeof(results), #reason) = READY) then
    retcode := COMLINK_OK;
    if(ptx^.uiLng > 2) then
      presult^ := ptx$^void;
    end_if;
  end_if;
 #endif

END_FUNCTION

FUNCTION GLOBAL __CDECL Lse_Reset
VAR_INPUT
  restart : bool;
END_VAR

  if(restart = true) then
    OS_SSR_AddToKernelSP("exec run",0);
  else
    OS_SSR_AddToKernelSP("exec reset",0);
  end_if;
  
END_FUNCTION

FUNCTION __CDECL GLOBAL ExternPing
  VAR_INPUT
    ipaddress : ^_ASCII;
  END_VAR
  VAR_OUTPUT
    retcode : udint;
  END_VAR

  retcode := 0; // not supported

  if(OS_TCP_USER_VERSION >= 6) then
    //if(OS_TCP_USER_PING(ipaddress, 1024, 128, 450) < 0) then
    if(OS_TCP_USER_PING(ipaddress, 32, 500, 2000) < 0) then
      retcode := 2; // error
    else
      retcode := 1; // success
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL __CDECL MakeLogfile1Entry
VAR_INPUT
  txt : ^char;
  p1 : dint;
  p2 : dint;
END_VAR

  if(OS_pLslSysMsg <> NIL) then
    OS_USERLOG_PRINTFLN2(txt,p1,p2);
  end_if;

END_FUNCTION

FUNCTION GLOBAL __CDECL Mutex
VAR_INPUT
  state : BOOL; 
  no    : UINT; 
END_VAR
VAR
  mh    : MT_SEMAHANDLE; 
END_VAR

  mh := MutexHandler[no]; 
  if((mt_api <> NIL)&(mh <> NIL)) then
    if(state = TRUE) then
      OS_MT_Wait(mh); 
    else
      OS_MT_Signal(mh); 
    end_if; 
  end_if; 

END_FUNCTION

#ifdef _LSL_TARGETARCH_ARM
#pragma warning (disable: 73) 
FUNCTION GLOBAL __CDECL SetColorPalette
VAR_INPUT
    tptr0 : ^USINT;
END_VAR
END_FUNCTION
#pragma warning (default: 73)
#else
FUNCTION AWL GLOBAL __CDECL SetColorPalette
VAR_INPUT
    tptr0 : ^USINT;
END_VAR

    pushad
    pushfd
    cld
    l.esi    tptr0   // mov  esi, tptr
    l.ecx    256     // mov  ecx, 256
    xor.ebx  ebx     // xor  ebx, ebx
SETRGB_LOOP
    l.dx     16#3C8  // mov  dx, 0x3C8
    l.al     bl      // mov  al, bl
    outb             // out  dx, al
    inc      dx      // inc  dx
    lodsb            // lodsb
    outb             // out  dx, al
    lodsb            // lodsb
    outb             // out  dx, al
    lodsb            // lodsb
    outb             // out  dx, al
    inc      ebx     // inc  bx
    LOOP     SETRGB_LOOP //  loop SETRGB_LOOP
    popfd
    popad

END_FUNCTION
#endif


FUNCTION AWL GLOBAL __CDECL StrCpy
  VAR_INPUT 
    p0 : ^void; 
    x1 : UINT; 
    p2 : ^void; 
    x3 : UINT; 
  END_VAR

#ifdef _LSL_TARGETARCH_ARM
    CMP       p0, #0
    BEQ       StrCpyEnd       // dst = NIL: nothing to do
    
    CMP       p2, #0
    BNE       StrCpyStart
    MOV       r10, #0
    STRB      r10, [p0, #0]
    STRB      r10, [p0, #1]   // src = NIL: create ASCII/UNI-0-String
    B         StrCpyEnd
    
StrCpyStart    
    CMP       x1, x3
    BEQ       StrCpySameSize

    CMP       x1, #1
    BEQ       StrCpySize12

              // UNI <- ASCII
    MOV       r11, #0
StrCpySize21
    LDRB      r10, [p2], #1
    STRB      r10, [p0], #1
    STRB      r11, [p0], #1
    CMP       r10, #0
    BNE       StrCpySize21
    B         StrCpyEnd

StrCpySize12  // ASCII <- UNI
    LDRB      r10, [p2], #1
    LDRB      r11, [p2], #1
    ORR       r10, r10, r11, LSL #8
    CMP       r10, #255
    MOVHI     r10, #'?'
    STRB      r10, [p0], #1
    CMP       r10, #0
    BNE       StrCpySize12
    B         StrCpyEnd
    
StrCpySameSize
    CMP       x1, #1
    BEQ       StrCpySize11
    
              // UNI <- UNI
    ORR       r11, p0, p2
    TST       r11, #1
    BNE       StrCpySize22Byte   // one or both pointer is misaligned

StrCpySize22Half
    LDRH      r10, [p2], #2    
    STRH      r10, [p0], #2
    CMP       r10, #0
    BNE       StrCpySize22Half
    B         StrCpyEnd

StrCpySize22Byte
    LDRB      r10, [p2], #1    
    LDRB      r11, [p2], #1
    STRB      r10, [p0], #1
    STRB      r11, [p0], #1
    CMP       r10, #0
    BNE       StrCpySize22Byte
    CMP       r11, #0
    BNE       StrCpySize22Byte
    B         StrCpyEnd
    
StrCpySize11  // ASCII <- ASCII
    LDRB      r10, [p2], #1
    STRB      r10, [p0], #1
    CMP       r10, #0
    BNE       StrCpySize11

StrCpyEnd

#else //elif _LSL_TARGETARCH_X86
    pushf
    push      edi
    push      esi

    l.edi     p0
    o.edi     edi               // load dest
    jz        StrCpyEnd         // dst = NIL: nothing to do
    
    l.esi     p2                // load src
    o.esi     esi
    jnz       StrCpyStart
    l.ax      0
    s.ax      (edi)             // src = NIL: craete ASCII/UNI-0-string
    jmp       StrCpyEnd
    
StrCpyStart
    l.ax      x1
    cmp.ax    x3
    je        StrCpySameSize

    cmp.ax    1
    je        StrCpySize12

StrCpySize21  // UNI <- ASCII
    lzxb.ax   (esi)
    s.ax      (edi)
    inc       esi
    add.edi   2
    o.ax      ax
    jne       StrCpySize21
    jmp       StrCpyEnd
    
StrCpySize12  // ASCII <- UNI
    l.ax      (esi)
    cmp.ax    255
    jle       StrCpySize12Tmp
    l.ax      '?'    
StrCpySize12Tmp
    s.al      (edi)
    add.esi   2
    inc       edi   
    o.ax      ax
    jne       StrCpySize12
    jmp       StrCpyEnd
  
StrCpySameSize
    cld
    cmp.ax    1
    je        StrCpySize11

              // UNI <- UNI
    l.edi     esi
    l.ecx     -1
    clr       ax
    rep
    scasw
    neg       ecx
    dec       ecx
    l.edi     p0
    rep
    movsw
    jmp       StrCpyEnd
    
StrCpySize11  // ASCII <- ASCII
//    l.al 255 // so gehts auch
//startox
//    test.al (esi)
//    movsb
//    jnz startox

    l.edi     esi
    l.ecx     -1
    clr       al
    rep
    scasb
    neg       ecx
    dec       ecx
    l.edi     p0
    rep
    movsb

StrCpyEnd    
    
    pop       esi
    pop       edi
    popf
#endif

END_FUNCTION

FUNCTION AWL GLOBAL __CDECL StringCountChr
  VAR_INPUT
    pTxt    : ^void; 
    cSize   : UINT;
    zeichen : UINT;   
  END_VAR
  VAR_OUTPUT
    retcode : UDINT; 
  END_VAR

#ifdef _LSL_TARGETARCH_ARM
    MOV       retcode, #0
    CMP       pTxt, #0
    BEQ       StrCountChrEnd
    CMP       cSize, #1
    BNE       StrCountChrUni
    
StrCountChrAscii
    LDRB      r3, [pTxt], #1
    CMP       r3, #0
    BEQ       StrCountChrEnd
    CMP       r3, zeichen
    ADDEQ     retcode, retcode, #1
    B         StrCountChrAscii

StrCountChrUni
    TST       pTxt, #1
    BNE       StrCountChrUniBbB
StrCountChrUniHalf
    LDRH      r3, [pTxt], #2
    CMP       r3, #0
    BEQ       StrCountChrEnd
    CMP       r3, zeichen
    ADDEQ     retcode, retcode, #1
    B         StrCountChrUniHalf
StrCountChrUniBbB
    LDRB      r3, [pTxt], #1
    LDRB      r10, [pTxt], #1
    ORR       r3, r3, r10, LSL #8
    CMP       r3, #0
    BEQ       StrCountChrEnd
    CMP       r3, zeichen
    ADDEQ     retcode, retcode, #1
    B         StrCountChrUniBbB

StrCountChrEnd
#else //elif _LSL_TARGETARCH_X86
    push      esi
    push      ebx
    push      ecx
    clr       ebx

    l.esi     pTxt
    o.esi     esi
    jz        StringCountRet
    l.cx      zeichen

    cmp.w     cSize,1
    jne       StringCountLoopUni
StringCountLoop
    lodsb				
    o.al      al
    jz        StringCountRet
    cmp.al    cl
    jne       StringCountLoop
    inc       ebx
    jmp       StringCountLoop

StringCountLoopUni
    lodsw				
    o.ax      ax
    jz        StringCountRet
    cmp.ax    cx
    jne       StringCountLoopUni
    inc       ebx
    jmp       StringCountLoopUni

StringCountRet
    s.ebx     retcode
    l.eax     ebx				
    pop       ecx
    pop       ebx
    pop       esi
#endif

END_FUNCTION
FUNCTION AWL GLOBAL __CDECL StrLen
  VAR_INPUT
    txt  : ^void; 
    size : UINT;   
  END_VAR
  VAR_OUTPUT
    retcode : UINT; 
  END_VAR

#ifdef _LSL_TARGETARCH_ARM
    MOV       retcode, #0
    CMP       txt, #0
    BEQ       StrLenEnd
    CMP       size, #1
    BNE       StrLenUni
    
    ADD       r10, txt, #1
StrLenAscii
    LDRB      r3, [txt], #1
    CMP       r3, #0
    BNE       StrLenAscii
    SUB       retcode, txt, r10
    B         StrLenEnd

StrLenUni
    ADD       r10, txt, #2
StrLenUniBbB
    LDRB      r3, [txt], #2
    CMP       r3, #0
    BNE       StrLenUniBbB
    LDRB      r3, [txt, #-1]
    CMP       r3, #0
    BNE       StrLenUniBbB
    SUB       retcode, txt, r10
    MOV       retcode, retcode, LSR #1

StrLenEnd  
#else //elif _LSL_TARGETARCH_X86
    push      edi
    push      ecx
    pushfd

    test.w  	size,1
    jz      	StrLenUni
  
    cld
    l.edi    	txt
    l.ecx    	-1
    clr       al
    rep
    scasb
    neg      	ecx
    sub.ecx  	2
    s.cx      retcode
    jmp       StrLenEnd

StrLenUni  
    cld
    l.edi    	txt
    l.ecx    	-1
    clr      	ax
    rep
    scasw
    neg      	ecx
    sub.ecx  	2
    s.cx    	retcode
    jmp  		  StrLenEnd

StrLenEnd 
    popfd
    pop		    ecx
    pop		    edi
#endif
END_FUNCTION

FUNCTION TAB crc32table
 16#00000000$UDINT,16#77073096$UDINT,16#ee0e612c$UDINT,16#990951ba$UDINT,16#076dc419$UDINT,16#706af48f$UDINT,16#e963a535$UDINT,16#9e6495a3$UDINT,
 16#0edb8832$UDINT,16#79dcb8a4$UDINT,16#e0d5e91e$UDINT,16#97d2d988$UDINT,16#09b64c2b$UDINT,16#7eb17cbd$UDINT,16#e7b82d07$UDINT,16#90bf1d91$UDINT,
 16#1db71064$UDINT,16#6ab020f2$UDINT,16#f3b97148$UDINT,16#84be41de$UDINT,16#1adad47d$UDINT,16#6ddde4eb$UDINT,16#f4d4b551$UDINT,16#83d385c7$UDINT,
 16#136c9856$UDINT,16#646ba8c0$UDINT,16#fd62f97a$UDINT,16#8a65c9ec$UDINT,16#14015c4f$UDINT,16#63066cd9$UDINT,16#fa0f3d63$UDINT,16#8d080df5$UDINT,
 16#3b6e20c8$UDINT,16#4c69105e$UDINT,16#d56041e4$UDINT,16#a2677172$UDINT,16#3c03e4d1$UDINT,16#4b04d447$UDINT,16#d20d85fd$UDINT,16#a50ab56b$UDINT,
 16#35b5a8fa$UDINT,16#42b2986c$UDINT,16#dbbbc9d6$UDINT,16#acbcf940$UDINT,16#32d86ce3$UDINT,16#45df5c75$UDINT,16#dcd60dcf$UDINT,16#abd13d59$UDINT,
 16#26d930ac$UDINT,16#51de003a$UDINT,16#c8d75180$UDINT,16#bfd06116$UDINT,16#21b4f4b5$UDINT,16#56b3c423$UDINT,16#cfba9599$UDINT,16#b8bda50f$UDINT,
 16#2802b89e$UDINT,16#5f058808$UDINT,16#c60cd9b2$UDINT,16#b10be924$UDINT,16#2f6f7c87$UDINT,16#58684c11$UDINT,16#c1611dab$UDINT,16#b6662d3d$UDINT,
 16#76dc4190$UDINT,16#01db7106$UDINT,16#98d220bc$UDINT,16#efd5102a$UDINT,16#71b18589$UDINT,16#06b6b51f$UDINT,16#9fbfe4a5$UDINT,16#e8b8d433$UDINT,
 16#7807c9a2$UDINT,16#0f00f934$UDINT,16#9609a88e$UDINT,16#e10e9818$UDINT,16#7f6a0dbb$UDINT,16#086d3d2d$UDINT,16#91646c97$UDINT,16#e6635c01$UDINT,
 16#6b6b51f4$UDINT,16#1c6c6162$UDINT,16#856530d8$UDINT,16#f262004e$UDINT,16#6c0695ed$UDINT,16#1b01a57b$UDINT,16#8208f4c1$UDINT,16#f50fc457$UDINT,
 16#65b0d9c6$UDINT,16#12b7e950$UDINT,16#8bbeb8ea$UDINT,16#fcb9887c$UDINT,16#62dd1ddf$UDINT,16#15da2d49$UDINT,16#8cd37cf3$UDINT,16#fbd44c65$UDINT,
 16#4db26158$UDINT,16#3ab551ce$UDINT,16#a3bc0074$UDINT,16#d4bb30e2$UDINT,16#4adfa541$UDINT,16#3dd895d7$UDINT,16#a4d1c46d$UDINT,16#d3d6f4fb$UDINT,
 16#4369e96a$UDINT,16#346ed9fc$UDINT,16#ad678846$UDINT,16#da60b8d0$UDINT,16#44042d73$UDINT,16#33031de5$UDINT,16#aa0a4c5f$UDINT,16#dd0d7cc9$UDINT,
 16#5005713c$UDINT,16#270241aa$UDINT,16#be0b1010$UDINT,16#c90c2086$UDINT,16#5768b525$UDINT,16#206f85b3$UDINT,16#b966d409$UDINT,16#ce61e49f$UDINT,
 16#5edef90e$UDINT,16#29d9c998$UDINT,16#b0d09822$UDINT,16#c7d7a8b4$UDINT,16#59b33d17$UDINT,16#2eb40d81$UDINT,16#b7bd5c3b$UDINT,16#c0ba6cad$UDINT,
 16#edb88320$UDINT,16#9abfb3b6$UDINT,16#03b6e20c$UDINT,16#74b1d29a$UDINT,16#ead54739$UDINT,16#9dd277af$UDINT,16#04db2615$UDINT,16#73dc1683$UDINT,
 16#e3630b12$UDINT,16#94643b84$UDINT,16#0d6d6a3e$UDINT,16#7a6a5aa8$UDINT,16#e40ecf0b$UDINT,16#9309ff9d$UDINT,16#0a00ae27$UDINT,16#7d079eb1$UDINT,
 16#f00f9344$UDINT,16#8708a3d2$UDINT,16#1e01f268$UDINT,16#6906c2fe$UDINT,16#f762575d$UDINT,16#806567cb$UDINT,16#196c3671$UDINT,16#6e6b06e7$UDINT,
 16#fed41b76$UDINT,16#89d32be0$UDINT,16#10da7a5a$UDINT,16#67dd4acc$UDINT,16#f9b9df6f$UDINT,16#8ebeeff9$UDINT,16#17b7be43$UDINT,16#60b08ed5$UDINT,
 16#d6d6a3e8$UDINT,16#a1d1937e$UDINT,16#38d8c2c4$UDINT,16#4fdff252$UDINT,16#d1bb67f1$UDINT,16#a6bc5767$UDINT,16#3fb506dd$UDINT,16#48b2364b$UDINT,
 16#d80d2bda$UDINT,16#af0a1b4c$UDINT,16#36034af6$UDINT,16#41047a60$UDINT,16#df60efc3$UDINT,16#a867df55$UDINT,16#316e8eef$UDINT,16#4669be79$UDINT,
 16#cb61b38c$UDINT,16#bc66831a$UDINT,16#256fd2a0$UDINT,16#5268e236$UDINT,16#cc0c7795$UDINT,16#bb0b4703$UDINT,16#220216b9$UDINT,16#5505262f$UDINT,
 16#c5ba3bbe$UDINT,16#b2bd0b28$UDINT,16#2bb45a92$UDINT,16#5cb36a04$UDINT,16#c2d7ffa7$UDINT,16#b5d0cf31$UDINT,16#2cd99e8b$UDINT,16#5bdeae1d$UDINT,
 16#9b64c2b0$UDINT,16#ec63f226$UDINT,16#756aa39c$UDINT,16#026d930a$UDINT,16#9c0906a9$UDINT,16#eb0e363f$UDINT,16#72076785$UDINT,16#05005713$UDINT,
 16#95bf4a82$UDINT,16#e2b87a14$UDINT,16#7bb12bae$UDINT,16#0cb61b38$UDINT,16#92d28e9b$UDINT,16#e5d5be0d$UDINT,16#7cdcefb7$UDINT,16#0bdbdf21$UDINT,
 16#86d3d2d4$UDINT,16#f1d4e242$UDINT,16#68ddb3f8$UDINT,16#1fda836e$UDINT,16#81be16cd$UDINT,16#f6b9265b$UDINT,16#6fb077e1$UDINT,16#18b74777$UDINT,
 16#88085ae6$UDINT,16#ff0f6a70$UDINT,16#66063bca$UDINT,16#11010b5c$UDINT,16#8f659eff$UDINT,16#f862ae69$UDINT,16#616bffd3$UDINT,16#166ccf45$UDINT,
 16#a00ae278$UDINT,16#d70dd2ee$UDINT,16#4e048354$UDINT,16#3903b3c2$UDINT,16#a7672661$UDINT,16#d06016f7$UDINT,16#4969474d$UDINT,16#3e6e77db$UDINT,
 16#aed16a4a$UDINT,16#d9d65adc$UDINT,16#40df0b66$UDINT,16#37d83bf0$UDINT,16#a9bcae53$UDINT,16#debb9ec5$UDINT,16#47b2cf7f$UDINT,16#30b5ffe9$UDINT,
 16#bdbdf21c$UDINT,16#cabac28a$UDINT,16#53b39330$UDINT,16#24b4a3a6$UDINT,16#bad03605$UDINT,16#cdd70693$UDINT,16#54de5729$UDINT,16#23d967bf$UDINT,
 16#b3667a2e$UDINT,16#c4614ab8$UDINT,16#5d681b02$UDINT,16#2a6f2b94$UDINT,16#b40bbe37$UDINT,16#c30c8ea1$UDINT,16#5a05df1b$UDINT,16#2d02ef8d$UDINT,
END_FUNCTION

FUNCTION GLOBAL __CDECL GetCrc32Table
  VAR_OUTPUT
    retcode : ^void;
  END_VAR
  
  retcode := #crc32table() + 4;
  
END_FUNCTION

FUNCTION AWL GLOBAL __CDECL StrCrc
VAR_INPUT
	ptxt   : ^void;
  csize : udint;
END_VAR
VAR_OUTPUT
	retcode : UDINT;
END_VAR
#ifdef _LSL_TARGETARCH_ARM
    STMDB     sp!, {r6, r7, r8, r10, r11}
    
    MOV       r8, #0                  // init result
    CMP       ptxt, #0
    BEQ       StringCrc32End
    
    LDR       r6, [pc, &crc32table()] // adresse von tabelle ermitteln
    ADD       r6, r6, #4              // r6 zeigt auf tabelle
    MVN       r10, #0
    EOR       r8, r8, r10              // r8 := r8 xor 0xFFFFFFFF
    
    CMP       csize, #1
    BNE       StringCrc32LoopUni
    
StringCrc32LoopAscii
    LDRB      r7, [ptxt], #1
    CMP       r7, #0
    BEQ       StringCrc32End
    AND       r10, r8, #255
    EOR       r7, r7, r10
    MOV       r8, r8, LSR #8
    MOV       r7, r7, LSL #2
    LDR       r10, [r6, r7]
    EOR       r8, r8, r10
    B         StringCrc32LoopAscii

StringCrc32LoopUni
    LDRB      r7, [ptxt], #1
    LDRB      r10, [ptxt], #1
    ADD       r11, r7, r10
    CMP       r11, #0
    BEQ       StringCrc32End
    EOR       r7, r7, r10
    AND       r10, r8, #255
    EOR       r7, r7, r10
    MOV       r8, r8, LSR #8
    MOV       r7, r7, LSL #2
    LDR       r10, [r6, r7]
    EOR       r8, r8, r10
    B         StringCrc32LoopUni
    
StringCrc32End
    MVN       r10, #0
    EOR       r8, r8, r10              // r8 := r8 xor 0xFFFFFFFF
    MOV       retcode, r8
    LDMIA     sp!, {r6, r7, r8, r10, r11}
    
#else 
    push      esi
    push      edi
    push      edx
  
    clr       edx
    l.esi     ptxt
    o.esi     esi
    jz        StringCrc32End
  
    l.edi     #crc32table()
    add.edi   4
    xor.edx   16#FFFFFFFF	
    clr       eax
    cmp.d     cSize,1
    jne       StringCrc32LoopUni

StringCrc32LoopAscii
    lodsb
    o.al      al
    jz        StringCrc32End
    xor.al    dl
    shr.edx   8
    xor.edx   (edi + eax*4)
    jmp       StringCrc32LoopAscii

StringCrc32LoopUni
    lodsw
    o.ax      ax
    jz        StringCrc32End
    xor.al    ah
    and.eax   255
    xor.al    dl
    shr.edx   8
    xor.edx   (edi + eax*4)
    jmp       StringCrc32LoopUni

StringCrc32End
    xor.edx   16#FFFFFFFF
    s.edx     retcode

    pop       edx
    pop       edi
    pop       esi
#endif  
END_FUNCTION


FUNCTION AWL GLOBAL __CDECL StrChr
  VAR_INPUT
    p0    : ^void; 
    x1    : UINT;
    x2    : UINT;
  END_VAR
  VAR_OUTPUT
    retcode : UINT; 
  END_VAR

#ifdef _LSL_TARGETARCH_ARM
    MOV       r10, #0
    CMP       p0, #0
    BEQ       StrChrNotFound
    
    CMP       x2, #1
    BNE       StrChrUni

StrChrAscii
    LDRB      r3, [p0], #1
    CMP       r3, x1
    BEQ       StrChrEnd
    CMP       r3, #0
    BEQ       StrChrNotFound
    ADD       r10, r10, #1
    B         StrChrAscii
    
StrChrUni
    TST       p0, #1
    BNE       StrChrUniBbB
StrChrUniHalf
    LDRH      r3, [p0], #2
    CMP       r3, x1
    BEQ       StrChrEnd
    CMP       r3, #0
    BEQ       StrChrNotFound
    ADD       r10, r10, #1
    B         StrChrUniHalf

StrChrUniBbB
    LDRB      r3, [p0], #1
    LDRB      r11, [p0], #1
    ORR       r3, r3, r11, LSL #8
    CMP       r3, x1
    BEQ       StrChrEnd
    CMP       r3, #0
    BEQ       StrChrNotFound
    ADD       r10, r10, #1
    B         StrChrUniBbB
  
StrChrNotFound
    MOV       r10, #65280
    ADD       r10, r10, #255

StrChrEnd
    MOV       retcode, r10
#else //elif _LSL_TARGETARCH_X86
    pushfd
    push      esi
  
    clr       ebx
    clr       ecx
  
    l.esi     p0
    o.esi     esi
    jz        StringChrRet

    cld
    l.bx      x1
    cmp.w     x2,1
    jne       StringChrLoopUni
  
StringChrLoop
    lodsb
    o.al      al
    jz        StringChrRet
    x.al      bl
    jz        StringChrSuccess
    inc       ecx
    jmp       StringChrLoop

StringChrLoopUni
    lodsw				
    o.ax      ax
    jz        StringChrRet
    x.ax      bx
    jz        StringChrSuccess
    inc       ecx
    jmp       StringChrLoopUni

StringChrRet
    l.ecx     16#FFFF
 
StringChrSuccess
    s.cx      retcode
  
    pop       esi
    popfd
#endif

END_FUNCTION

FUNCTION AWL GLOBAL __CDECL StrXmp
  VAR_INPUT
    pTxt0    : ^void; 
    pTxt1    : ^void;
    cSize : UINT;
  END_VAR
  VAR_OUTPUT
    retcode : UDINT; 
  END_VAR

#ifdef _LSL_TARGETARCH_ARM
    MOV       retcode, #0
    
    CMP       pTxt0, pTxt1
    BEQ       StrXmpEnd

    CMP       pTxt0, #0
    BEQ       StrXmpNotEqual
    CMP       pTxt1, #0
    BEQ       StrXmpNotEqual
    
    CMP       cSize, #1
    BNE       StrXmpUni

StrXmpAscii
    LDRB      r10, [pTxt0], #1
    LDRB      r11, [pTxt1], #1
    CMP       r10, r11
    BNE       StrXmpNotEqual
    CMP       r10, #0
    BEQ       StrXmpEnd
    B         StrXmpAscii
    
StrXmpUni
    ORR       r11, pTxt0, pTxt1
    TST       r11, #1
    BNE       StrXmpUniBbB   // one or both pointer are missaligned

StrXmpUniH
    LDRH      r10, [pTxt0], #2
    LDRH      r11, [pTxt1], #2
    CMP       r10, r11
    BNE       StrXmpNotEqual
    CMP       r10, #0
    BNE       StrXmpUniH
    B         StrXmpEnd

StrXmpUniBbB
    LDRB      r10, [pTxt0], #1
    LDRB      r3,  [pTxt0], #1
    ORR       r10, r10, r3, LSL #8
    LDRB      r11, [pTxt1], #1
    LDRB      r3,  [pTxt1], #1
    ORR       r11, r11, r3, LSL #8
    CMP       r10, r11
    BNE       StrXmpNotEqual
    CMP       r10, #0
    BNE       StrXmpUniBbB
    B         StrXmpEnd

StrXmpNotEqual
    MOV       retcode, #1
    
StrXmpEnd

#else //elif _LSL_TARGETARCH_X86
    pushfd
    push      edi
    push      esi
  
    l.esi     pTxt0
    l.edi     pTxt1
    clr       ecx
  
    x.esi     edi
    jz        StringXmpEqual
  
    l.esi     pTxt0
    o.esi     esi
    jz        StringXmpRet
    o.edi     edi
    jz        StringXmpRet
  
    cld
    cmp.w     cSize,1
    jne       StringXmpLoopUni
  
StringXmpLoop
    l.cl      (edi)
    or.cl     (esi)
    jecxz     StringXmpEqual
    cmpsb
    jz        StringXmpLoop
    jmp       StringXmpRet

StringXmpLoopUni
    l.cx      (edi)
    or.cx     (esi)
    jecxz     StringXmpEqual
    cmpsw
    jz        StringXmpLoopUni
    //jmp       StringXmpRet

StringXmpRet
    l.ecx     1

StringXmpEqual
    s.ecx     retcode
  
    pop       esi
    pop       edi
  
    popfd
#endif

END_FUNCTION


FUNCTION GLOBAL __CDECL get_loaderversion
VAR_OUTPUT
  retcode : UDINT;
END_VAR

  retcode := ops.uiLoaderVersion.usLoRev or (ops.uiLoaderVersion.usHiRev shl 16); 

END_FUNCTION

FUNCTION _LookupCls VAR_INPUT pname : ^char; END_VAR VAR_OUTPUT retcode : ^CLSHDR; END_VAR;
FUNCTION GLOBAL __cdecl GetRevisionOfClass VAR_INPUT classname : ^char; END_VAR VAR_OUTPUT retcode : udint; END_VAR
  var
    pClsHdr : ^CLSHDR;
    rhi, rlo : udint;
  end_var

  retcode := 0;
  pClsHdr := _LookupCls(classname);
  
  if(pClsHdr <> NIL) then
    if(pClsHdr^.pDsc <> NIL) then
      rhi := pClsHdr^.pDsc^.udRev.hi;
      rlo := pClsHdr^.pDsc^.udRev.lo;
      retcode := (rhi shl 16) or rlo;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL __CDECL rotate_DOT
VAR_INPUT
  p    : ^_DOT;
  w1   : INT;
END_VAR
VAR
  a1, x, y : _REAL;
  m0, m1 : _REAL;
END_VAR

  x := p^.x;
  y := p^.y;

  a1 := (to_real(w1) * 3.1416) / 180;
  m0 := COS(a1);
  m1 := SIN(a1);

  p^.x := to_int((m0 * x) + (m1 * y));
  p^.y := to_int((m0 * y) - (m1 * x));

END_FUNCTION

FUNCTION GLOBAL __CDECL matrize
VAR_INPUT
  pm : ^_REAL;
  px : ^_REAL;
  py : ^_REAL;
  pz : ^_REAL;
END_VAR
VAR
  x : _REAL;
  y : _REAL;
  z : _REAL;
END_VAR


  x := px^;
  y := py^;
  z := pz^;

  px^ :=( pm^ * x) + ((pm + sizeof(_REAL))^ * y) + ((pm + (sizeof(_REAL) * 2))^ * z);
  py^ := ((pm + (sizeof(_REAL) * 3))^ * x) + ((pm + (sizeof(_REAL) * 4))^ * y) + ((pm + (sizeof(_REAL) * 5))^ * z);
  pz^ := ((pm + (sizeof(_REAL) * 6))^ * x) + ((pm + (sizeof(_REAL) * 7))^ * y) + ((pm + (sizeof(_REAL) * 8))^ * z);

END_FUNCTION

FUNCTION GLOBAL __CDECL rotate_DOT3D
VAR_INPUT
  p    : ^_DOT3D;
  w1   : INT;
  w2   : INT;
  w3   : INT;
END_VAR
VAR
  a1   : _REAL;
  a2   : _REAL;
  a3   : _REAL;
  x    : _REAL;
  y    : _REAL;
  z    : _REAL;
  matr : ARRAY[0..8] of _REAL;
END_VAR

  a1 := w1; 
  a2 := w2;
  a3 := w3;

  a1 := (a1 * 3.1416) / 180;
  a2 := (a2 * 3.1416) / 180;
  a3 := (a3 * 3.1416) / 180;

  x := p^.x;
  y := p^.y;
  z := p^.z;

  matr[0] := COS(a1);
  matr[1] := SIN(a1);
  matr[2] := 0;
  matr[3] := -matr[1];
  matr[4] := matr[0];
  matr[5] := 0;
  matr[6] := 0;
  matr[7] := 0;
  matr[8] := 1;
  matrize(#matr[0], #x, #y, #z);

  matr[0] := 1;
  matr[1] := 0;
  matr[2] := 0;
  matr[3] := 0;
  matr[4] := COS(a2);
  matr[5] := SIN(a2);
  matr[6] := 0;
  matr[7] := -matr[5];
  matr[8] := matr[4];
  matrize(#matr[0], #x, #y, #z);

  matr[0] := COS(a3);
  matr[1] := 0;
  matr[2] := SIN(a3);
  matr[3] := 0;
  matr[4] := 1;
  matr[5] := 0;
  matr[6] := -matr[2];
  matr[7] := 0;
  matr[8] := matr[0];
  matrize(#matr[0], #x, #y, #z);
  
//  p^.x := FTOL(x);
//  p^.y := FTOL(y);
//  p^.z := FTOL(z);

  p^.x := to_int(x);
  p^.y := to_int(y);
  p^.z := to_int(z);

END_FUNCTION

FUNCTION GLOBAL __CDECL AMBDC
VAR_INPUT
  a : UDINT; 
  b : UDINT; 
  c : UDINT; 
END_VAR
VAR_OUTPUT
  retcode : UDINT; 
END_VAR

  retcode := a*b/c; 

END_FUNCTION

FUNCTION GLOBAL __CDECL heap_size
VAR_INPUT
  total : ^UDINT;
  free  : ^UDINT;
END_VAR
VAR_OUTPUT
  retcode : bool;
END_VAR

  free^  := _UserHeapFreeMem;
  total^ := _UserHeapTotalSize;
  retcode := true;

END_FUNCTION

FUNCTION GLOBAL __CDECL get_microtime
VAR_OUTPUT
  retcode : UDINT;
END_VAR

  retcode := OS_ReadMicroSec();

END_FUNCTION

FUNCTION GLOBAL __CDECL GetResetTaskTime
VAR_INPUT
  pudi : ^UDINT; 
END_VAR

  if(pudi <> NIL) then
    pudi^ := _RealMaximumTime;       pudi += 4; // maximum duration of RT-methods
    pudi^ := _RealAverageTime;       pudi += 4; // average duration of RT-methods
    pudi^ := _CyclicMaximumTime;     pudi += 4; // maximum duration of Cy-methods
    pudi^ := _CyclicAverageTime;     pudi += 4; // average duration of Cy-methods
    pudi^ := _BackgroundMaximumTime; pudi += 4; // maximum duration of Bg-methods
    pudi^ := _BackgroundAverageTime;            // average duration of Bg-methods
  else
    _RealMaximumTime       := 0;  // maximum duration of RT-methods
    _RealAverageTime       := 0;  // average duration of RT-methods
    _CyclicMaximumTime     := 0;  // maximum duration of Cy-methods
    _CyclicAverageTime     := 0;  // average duration of Cy-methods
    _BackgroundMaximumTime := 0;  // maximum duration of Bg-methods
    _BackgroundAverageTime := 0;  // average duration of Bg-methods
  end_if; 

END_FUNCTION

FUNCTION GLOBAL __CDECL CilGet
VAR_INPUT
	name : ^_ASCII; 
	ptr  : ^PVOID; 
END_VAR
VAR_OUTPUT
	retcode : BOOL;
END_VAR

  retcode := TRUE; 

  if(OS_CILGet(name, ptr) <> SYS_ERR_NONE) then
    ptr^    := NIL; 
	retcode := FALSE; 
  end_if; 

END_FUNCTION

FUNCTION GLOBAL __CDECL GetTCPIPAddressFromDNS
VAR_INPUT
  dnsname   : ^_ASCII;
END_VAR
VAR_OUTPUT
  retcode : UDINT;
END_VAR

  retcode := 0;
  if((lsl_tcp_user <> NIL) & (dnsname <> NIL)) then
    retcode := OS_TCP_USER_STRTOULONG(dnsname);
  end_if;

END_FUNCTION

FUNCTION GLOBAL __CDECL GetTCPIPAddress
VAR_INPUT
  interface : UDINT;
  address   : ^UDINT;
  subnet    : ^UDINT;
  gateway   : ^UDINT;
END_VAR
VAR_OUTPUT
  retcode : BOOL;
END_VAR
 
  retcode := FALSE;
 
  if(lsl_tcp_user <> NIL) then
    if(address <> NIL) then
      address^ := 0;
      OS_TCP_USER_IPINFO(interface$DINT, IP_OPT_ADDR, address);
      retcode := TRUE;
    end_if;
    if(subnet <> NIL) then
      subnet^ := 0;
      OS_TCP_USER_IPINFO(interface$DINT, IP_OPT_SUBNETMASK, subnet);
      retcode := TRUE;
    end_if;
    if(gateway <> NIL) then
      gateway^ := 0;
      OS_TCP_USER_IPINFO(interface$DINT, IP_OPT_GATEWAY, gateway);
      retcode := TRUE;
    end_if;
  end_if;
 
END_FUNCTION

function global __cdecl lib_ctor;
FUNCTION  _Lse::_Lse
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR
VAR
  i : UINT; 
  ptr : ^_PICPOI;
END_VAR

  lib_ctor();
  
  PThis_Lse      := this;
  DownloadState  := 0;
  GlobalBitState := 0;
//LDR_SetWait4Visu(true, 0);

  construct_MAIN();

  mt_api         := NIL; 
  Thread2Handle  := NIL;
  MailBox2Handle := NIL;
  
  if(OS_CILGet("LSL_MULTITASK", #mt_api$void)) THEN
    mt_api := NIL; 
  end_if;
  
  MutexHandler[0] := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, "KERNELMUTEX");
  MutexHandler[1] := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, "ALARMMUTEX");
  MutexHandler[2] := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, "RTK2TASK");
  MutexHandler[3] := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, "ReallocREFLIST");
  MutexHandler[4] := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, "StartREFLIST");
  

  OS_pLslSysMsg := NIL;
  if(OS_CILGet("SYSMSG", #OS_pLslSysMsg$void)) THEN
    OS_pLslSysMsg := NIL;
  end_if;

  lsl_tcp_user := NIL;
  if(OS_CILGet("TCP_USER", #lsl_tcp_user$void)) then
    lsl_tcp_user := NIL;
  end_if;

//  init_MAIN(); 
  init_MEM_POINTERPARA(#UserGlobal);
  init_MEM_POINTER(#Oszis);

  ToolCat    := NIL; 
  RunState   := STATE_START; 
  ret_code   := C_OK;
  PicMemo.no := 0; 
  ptr        := #PicMemo.ptr[0];
  i          := sizeof(PicMemo.ptr) / sizeof(_PICPOI);
  while(i) do
    init_WHOAMI(#ptr^.whoami); 
	  ptr^.ptr := NIL; 
	  ptr      += sizeof(_PICPOI); 
    i        -= 1;
  end_while;

  IsEventProcessor := FALSE;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::Init
var
  urinit : bool;
end_var

  if((RunState = STATE_START) | (RunState = STATE_FLY)) then
    urinit := true;
	  if(RunState = STATE_FLY) then
	    urinit := false;
	  end_if;
    RunState := STATE_READY;

    if(RTK_Init(this, urinit) = FALSE) then
	    RunState := STATE_END; 
    end_if; 
  end_if; 

  if(_firstscan) then
    if(IsClientConnected(#EventProcessor) = TRUE) then
      IsEventProcessor := TRUE;
    end_if;
    
    InitJpgLib();
    
    if(mt_api <> NIL) then 
      if(MailBox2Handle = NIL) then
        MailBox2Handle := OS_MT_CreateMailBox(sizeof(_Thread2CmdLine), 16, "MyMailBox2");
      end_if;
      
      if(MailBox2Handle <> NIL) & (Thread2Handle = NIL) then
        Thread2Handle := OS_MT_CreateThread(#Thread2(), 9, 8192, 0, this, "MyThread2");
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::CyWork
VAR_INPUT
EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR

  state := Background(0); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::Background
VAR_INPUT
 EAX  : UDINT;
END_VAR
VAR_OUTPUT
 state  : UDINT;
END_VAR

  if((ops.sysstate = C_RUNRAM) | (ops.sysstate = C_RUNROM)) then
 
    if(DownloadState = 2) then
      DownloadState := 0;
      new_PLC();
      RTK_End(TRUE);
      RunState := STATE_FLY;
      OfflineMode := 0;
      Init();
    end_if;
 
    if(RunState = STATE_RUN) then
      if(RTK_Run() = FALSE) then
        if(IF_Stop() = TRUE) then
          MakeLogfile1Entry("End of LSE-task forced by program.", 0, 0);
          RunState := STATE_END;
        end_if;
      end_if; 
    elsif(RunState = STATE_READY) then
      RunState   := STATE_RUN; 
      if(RTK_Ready() = FALSE) then
        RunState := STATE_END; 
      end_if; 
    elsif(RunState = STATE_END) then
      RTK_End(FALSE);
      RunState := STATE_ERROR; 
    end_if; 
  end_if; 
 
  state := READY$UDINT;
 
END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_WindowStart
VAR_INPUT
	whoami		: ^_WHOAMI;
	pic		    : ^VOID; 
	firsttime	: BOOL;
END_VAR
VAR
  pp  : ^_PICPOI; 
	no  : UDINT; 
  ppp : ^_POINTERPARA;
END_VAR 

  if(GlobalBitState and GLOBAL_BIT_IFWINSTART) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      if(ppp^.para and GLOBAL_BIT_IFWINSTART) then
        ppp^.ptr$^_Global^.IF_WindowStart(whoami, pic, firsttime); 
      end_if;
	    no  -= 1; 
	    ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;
  
  pp := FindScreen(whoami);
  if(pp <> NIL) then
    pp^.ptr$^_Screen^.S_Start(pic, firsttime); 
    pic^$^_Screen := pp^.ptr$^_Screen;
  end_if;
  
END_FUNCTION 

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_WindowReady
VAR_INPUT
	whoami		: ^_WHOAMI;
	pic		    : ^VOID;
	firsttime	: BOOL;
END_VAR
VAR
	no  : UDINT; 
	ppp : ^_POINTERPARA; 
END_VAR 

  if(GlobalBitState and GLOBAL_BIT_IFWINREADY) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      if(ppp^.para and GLOBAL_BIT_IFWINREADY) then
        ppp^.ptr$^_Global^.IF_WindowReady(whoami, pic, firsttime); 
      end_if;
      no  -= 1;
      ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;

  if(pic <> NIL) then
    if(pic^$^_Screen <> NIL) then
      pic^$^_Screen^.S_Ready(pic, firsttime); 
    end_if;
  end_if;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_WindowRun
VAR_INPUT
	whoami		: ^_WHOAMI;
	pic		    : ^VOID;
	event		: ^_EVENT;
END_VAR
VAR
 	no  : UDINT; 
	ppp : ^_POINTERPARA; 
END_VAR 

  if(GlobalBitState and GLOBAL_BIT_IFWINRUN) then
    no  := UserGlobal.no;
    ppp := UserGlobal.ptr; 
    while no do
      if(ppp^.para and GLOBAL_BIT_IFWINRUN) then
        ppp^.ptr$^_Global^.IF_WindowRun(whoami, pic, event); 
      end_if;
      no  -= 1; 
      ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;
  
  if(pic <> NIL) then
    if(pic^$^_Screen <> NIL) then
      pic^$^_Screen^.S_Run(pic, event);
    end_if;
  end_if;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_WindowEnd
VAR_INPUT
	whoami		: ^_WHOAMI;
	pic		    : ^VOID;
END_VAR
VAR
  pp  : ^_PICPOI; 
	no  : UDINT; 
	ppp : ^_POINTERPARA; 
END_VAR 

  if(GlobalBitState and GLOBAL_BIT_IFWINEND) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      if(ppp^.para and GLOBAL_BIT_IFWINEND) then
        ppp^.ptr$^_Global^.IF_WindowEnd(whoami, pic); 
      end_if;
      no  -= 1; 
      ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;
  
  // parameter 'pic' is used to be NIL therefore use FindScreen
  pp := FindScreen(whoami); 
  if(pp <> NIL) then
    pp^.ptr$^_Screen^.S_End(pic); 
  end_if; 
  
END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_UserCall
VAR_INPUT
	nof	 : DINT;
	para : DINT;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  if(GlobalBitState and GLOBAL_BIT_IFUSERCALL) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      if(ppp^.para and GLOBAL_BIT_IFUSERCALL) then
        ppp^.ptr$^_Global^.IF_UserCall(nof, para); 
      end_if;
      no  -= 1; 
      ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;
  
END_FUNCTION 

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_AccessInput
VAR_INPUT
	pi		: ^_INPUT;
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := TRUE;  

  if(GlobalBitState and GLOBAL_BIT_IFACCESSINPUT) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      no  -= 1; 
      if(ppp^.para and GLOBAL_BIT_IFACCESSINPUT) then
        if(ppp^.ptr$^_Global^.IF_AccessInput(pi) = FALSE) then
          no := 0; 
          retcode := FALSE; 
        end_if; 
      end_if;
      ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;
  
END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_ChkEnable
VAR_INPUT
	key		: DINT;
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := TRUE;

  if(GlobalBitState and GLOBAL_BIT_IFCHKENABLE) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      no  -= 1; 
      if(ppp^.para and GLOBAL_BIT_IFCHKENABLE) then
        if(ppp^.ptr$^_Global^.IF_ChkEnable(key) = FALSE) then
          no := 0; 
          retcode := FALSE; 
        end_if; 
      end_if;
      ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;
  
END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_SystemError
VAR_INPUT
	errno		: DINT;
	para        : DINT;  
	ptxt        : ^_CHAR; 
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode       := TRUE;  
  SystemMessage := SystemMessage.Write(errno); 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    if(ppp^.ptr$^_Global^.IF_SystemError(errno, para, ptxt) = FALSE) then
      no := 0; 
      retcode := FALSE; 
    end_if; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_DrawBubbleHelp
VAR_INPUT
	pedit	: ^_EDITOR;
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := TRUE;  

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    if(ppp^.ptr$^_Global^.IF_DrawBubbleHelp(pedit) = FALSE) then
      no := 0; 
      retcode := FALSE; 
    end_if; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_UrInit
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    ppp^.ptr$^_Global^.IF_UrInit(); 	
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_ProjectStart
VAR
  no  : UDINT; 
  ppp : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1;
    ppp^.ptr$^_Global^.IF_ProjectStart();
    ppp += sizeof(_POINTERPARA); 
  end_while;

END_FUNCTION

#ifdef UC_MULTICPU
FUNCTION IsSubStationZero
VAR_INPUT
    pcm   : ^_COMAP;
    index : uint;
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR
VAR
    no : uint;
END_VAR

  retcode := false;
  no      := 256;
  while(no) do
    no -= 1;
    if(pcm^.multimap[0] = index) then
	  retcode := true;
	end_if;
	pcm += sizeof(_COMAP);
  end_while;

END_FUNCTION  
#endif

//[#ENGLISH]
//function is called after loading project
//graphic is already initialized,
//no picture is loaded and nothing is on the screen (blank screen)
//state .... TRUE successful loading project, either FALSE
//return FALSE if you don't want to start this application
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_ProjectReady
VAR_INPUT
	state	: BOOL;
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR
VAR
  no      : UDINT; 
	ppp     : ^_POINTERPARA; 
  ptrOszi : ^P_Oszi;
  pcs     : ^_COMSET;
  pcp     : ^_COMPORT;
END_VAR 

  retcode := state;  

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    if(ppp^.ptr$^_Global^.IF_ProjectReady(state) = FALSE) then
      no := 0; 
      retcode := FALSE; 
    end_if; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

  no := Oszis.no; 
  ptrOszi$^UDINT := Oszis.ptr; 
  while no do
    no  -= 1; 
    if(ptrOszi^^.InitOszi() = FALSE) then
      no := 0; 
      retcode := FALSE; 
    end_if; 
	ptrOszi += 4; 
  end_while; 

  if(IsClientConnected((#Gbcd)$^DINT) = 1) then
    pcs := Lse_GetComSet();
    no  := pcs^.no;
    pcp := pcs^.ptr;
    while(no) do
      no -= 1;
      if(pcp^.comdef.typ <> _COM_INTERN) then
       #ifdef UC_MULTICPU
        if(IsSubStationZero(#pcs^.mapper[0], to_uint(no)) = true) then
          // geht leider nur von substation 0, alarme sind einfach nur schlecht
          Gbcd.GetLostAlarms(#pcp^.comdef);
        end_if;
       #else
        Gbcd.GetLostAlarms(#pcp^.comdef);
       #endif
      end_if;
	  pcp += sizeof(_COMPORT);
    end_while;
  end_if;

  LseReady := 1; 
  if(IsClientConnected((#LseReady)$^DINT) = 1) then
    LseReady.Write(1); 
  end_if; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_ProjectRun
VAR_INPUT
	pe	: ^_EVENT;
END_VAR
VAR
  no  : UDINT; 
  ppp : ^_POINTERPARA; 
END_VAR 

  if(GlobalBitState and GLOBAL_BIT_IFPRJRUN) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      no  -= 1;
      if(ppp^.para and GLOBAL_BIT_IFPRJRUN) then
        ppp^.ptr$^_Global^.IF_ProjectRun(pe);
      end_if;
      ppp += sizeof(_POINTERPARA); 
    end_while;
  end_if;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_ProjectEnd
VAR
  no  : UDINT; 
  ppp : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1;
    ppp^.ptr$^_Global^.IF_ProjectEnd();
    ppp += sizeof(_POINTERPARA); 
  end_while;

END_FUNCTION

//[#ENGLISH]
//this function is called after a succesfull writing of an input
//pi ......... --> to saved _INPUT
//pr ......... --> to _RESULT
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_InputIsSaved
VAR_INPUT
	pi	: ^_INPUT;
	pr  : ^_RESULT; 
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    ppp^.ptr$^_Global^.IF_InputIsSaved(pi, pr); 	
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION 

//[#ENGLISH]
//this method will be called at least (before closing the application).
//note: afterwards there is no more executable code.
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_PowerDown
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    ppp^.ptr$^_Global^.IF_PowerDown(); 	
    ppp += sizeof(_POINTERPARA); 
  end_while;

END_FUNCTION

//[#ENGLISH]
//method is called when input is identified unambiguous by touch and
//the editor can't open because access is denied.
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_InputWithoutAccess
VAR_INPUT
	pi		: ^_INPUT;
	pvi     : ^_VARINFO; 
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    ppp^.ptr$^_Global^.IF_InputWithoutAccess(pi, pvi); 	
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

//[#ENGLISH]
//method is called when a new alarm is added during runtime to the alarmlist
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_OpenEditor
VAR_INPUT
    pedit : ^_EDITOR; 
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    ppp^.ptr$^_Global^.IF_OpenEditor(pedit); 	
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

//[#ENGLISH]
//method is called right before data will be written to server
//pres ... --> to data
//pvar ... --> to serverdescription
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_Write
VAR_INPUT
  pres : ^_RESULT;
  pvar : ^_VARIABLE;
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := TRUE;

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1;
    if(ppp^.ptr$^_Global^.IF_Write(pres, pvar) = FALSE) then
      no := 0;
      retcode := FALSE;
    end_if;
    ppp += sizeof(_POINTERPARA); 
  end_while;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_WritePost
VAR_INPUT
  pres : ^_RESULT;
  pvar : ^_VARIABLE;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1;
    ppp^.ptr$^_Global^.IF_WritePost(pres, pvar);
    ppp += sizeof(_POINTERPARA); 
  end_while;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_CheckPrefix
VAR_INPUT
  varno : UDINT;
  vi    : ^_VARINFO;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := FALSE;  

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    if(ppp^.ptr$^_Global^.IF_CheckPrefix(varno, vi) = TRUE) then
      no := 0; 
      retcode := TRUE; 
    end_if; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_GetLookUpEmbeddedPointer
VAR_OUTPUT
	retcode		: ^VOID;
END_VAR

  retcode := NIL; 

  if((ops.SysState = C_RUNRAM)|(ops.SysState = C_RUNROM)|(ops.SysState = C_OK)) then
    if(_lsl_pos^.piLINKER <> NIL) then
     // if(_lsl_pos^.piLINKER^.LNK_LookupEmbedded <> NIL) then// STR-function from Loader
        retcode := _lsl_pos^.piLINKER^.LNK_LookupEmbedded;
     // end_if; 
    end_if;
  end_if; 

END_FUNCTION

//[#ENGLISH]
//method is called when a new alarm is added to the alarmlist
FUNCTION GLOBAL _Lse::AddScreen
VAR_INPUT
	ptr		: ^VOID;
	whoami	: ^_WHOAMI;
END_VAR
VAR_OUTPUT
	retcode	: BOOL;
END_VAR
VAR
  pp : ^_PICPOI; 
END_VAR

  retcode := TRUE; 
  pp      := FindScreen(whoami); 

  if(pp <> NIL) then
    pp^.ptr := ptr; 
  elsif(PicMemo.no < (sizeof(PicMemo.ptr) / sizeof(_PICPOI))) then
    pp := #PicMemo.ptr[PicMemo.no]; 
    pp^.whoami := whoami^; 
    pp^.ptr    := ptr; 
    PicMemo.no += 1; 
  else
    retcode    := FALSE; 
  end_if; 
      
END_FUNCTION

FUNCTION GLOBAL _Lse::AddGlobal
VAR_INPUT
	ptr		: ^_Global;
END_VAR
VAR_OUTPUT
	retcode		: bool;
END_VAR

  retcode := AddGlobalEx(ptr, 0xFFFFFFFF);

END_FUNCTION

FUNCTION GLOBAL _Lse::AddGlobalEx
VAR_INPUT
	ptr		: ^_Global;
  para : udint;
END_VAR
VAR_OUTPUT
	retcode		: bool;
END_VAR

  retcode := FALSE; 
  if(add_MEM_POINTERPARA(#UserGlobal, ptr, para) = TRUE) then
    GlobalBitState := GlobalBitState or para;
    retcode := TRUE; 
  end_if; 

END_FUNCTION

FUNCTION GLOBAL _Lse::FindScreen
	VAR_INPUT
		whoami 	: ^_WHOAMI;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_PICPOI;
	END_VAR
VAR
  no : UINT; 
  pp : ^_PICPOI; 
END_VAR

  retcode := NIL;  
  if(PicMemo.no > 0) then
    no := PicMemo.no; 
    pp := #PicMemo.ptr[0];
    while no do
      no -= 1;
      if(pp^.whoami.no = whoami^.no) then
        if((pp^.whoami.ima = whoami^.ima) | ((whoami^.ima = IMA_TOUCHEDITOR) & (pp^.whoami.ima = IMA_WINDOW))) then
          retcode  := pp;
          return;
        end_if;
      end_if;
      pp += sizeof(_PICPOI);
    end_while;
  end_if; 
  
END_FUNCTION

FUNCTION GLOBAL _Lse::GetReady
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := FALSE; 
  if(RunState = STATE_RUN) then
    retcode := TRUE; 
  end_if; 

END_FUNCTION

//[#ENGLISH]
//this method is called by the kernel to set statusserver like 'language' etc.
//the first parameter is used as schedular which server is to initialize with value (second parameter)
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_SetStatus
VAR_INPUT
  no    : DINT;
  value : DINT;
END_VAR

// no - Which server has to be changed
// 0...language
// 1...compiler-version
// 2...lse-version
// 3...delaytime screensaver
// 4...commasign
// 5...american date format
// 6...seek algorithm

  case no of
    LSE_COMPILERVERSION      : CompilerVersion    := value;  
    LSE_LSEVERSION           : LseVersion         := value;  
    LSE_LANGUAGE             : Language           := value; 
    LSE_SCREENDELAY	         : DelayScreenSaver   := to_udint(value); 
    LSE_DIRECTIONONENTER     : DirectionOnEnter   := value; 
    LSE_OFFLINEMODE          : OfflineMode        := value;
    LSE_OPSYSVERSION         : OpSysVersion.Read();  
    LSE_COMMASIGN            : Commasign.Write(value);
    LSE_AMERICANDATEFORMAT   : AmericanDateFormat.Write(value);
    LSE_AMERICANTIMEFORMAT   : AmericanTimeFormat.Write(value);
    LSE_SEEKALGORITHM        : SeekAlgorithm.Write(value); 
    LSE_CURSORWRAPHORIZONTAL : CursorWrapHorizontal.Write(value); 
    LSE_CURSORWRAPVERTICAL   : CursorWrapVertical.Write(value); 
    LSE_NOEXTERNCOM          : NoExternCom.Write(value);
    LSE_ACTIVATEBUBBLEHELP   : ActivateBubbleHelp := value;
    LSE_LSEREVISION          : LseProjectRevision := value$hdint;
  end_case;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_GetStatus
VAR_INPUT
	no		: DINT;
END_VAR
VAR_OUTPUT
	retcode		: DINT;
END_VAR

  case no of
    LSE_LANGUAGE             : retcode := Language; 
    LSE_SCREENDELAY	         : retcode$UDINT := DelayScreenSaver; 
    LSE_DIRECTIONONENTER     : retcode := DirectionOnEnter; 
    LSE_COMMASIGN            : retcode := Commasign;
    LSE_AMERICANDATEFORMAT   : retcode := AmericanDateFormat;
    LSE_AMERICANTIMEFORMAT   : retcode := AmericanTimeFormat;
    LSE_SEEKALGORITHM        : retcode := SeekAlgorithm; 
    LSE_CURSORWRAPHORIZONTAL : retcode := CursorWrapHorizontal; 
    LSE_CURSORWRAPVERTICAL   : retcode := CursorWrapVertical; 
    LSE_LSEVERSION           : retcode := LseVersion;
    LSE_NOEXTERNCOM          : retcode := NoExternCom; 
    LSE_ACTIVATEBUBBLEHELP   : retcode := ActivateBubbleHelp;
    LSE_LSEREVISION          : retcode$HDINT := LseProjectRevision;
  end_case;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_Trace
VAR_INPUT
	msg		: ^_ASCII;
END_VAR

  Trace(msg); 
  
END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_GetHeapInfo
VAR_INPUT
	pr : ^_ROOM; 
END_VAR

  draw_heap(pr);

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_FoundSomethingByHid
VAR_INPUT
	ima		: _FOUNDHID;
END_VAR
VAR
	no  : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  if(GlobalBitState and GLOBAL_BIT_IFFOUNDHID) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      if(ppp^.para and GLOBAL_BIT_IFFOUNDHID) then
        ppp^.ptr$^_Global^.IF_FoundSomethingByHid(ima); 
      end_if;
      no  -= 1; 
      ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;

END_FUNCTION

//[#ENGLISH]
//method is called by the kernel right before a menu will be opend.
//the first parameter is a pointer to structure where the menudata like color,
//shape, lines etc. will be stored
//the second parameter is a pointer to the menunumber initialiced by lse
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_PopUpCall
VAR_INPUT
	pm		: ^_MENU;
	pno		: ^UINT; 
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
	no  : UDINT;
	ppp  : ^_POINTERPARA; 
END_VAR

  retcode := FALSE;

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1;
    if(ppp^.ptr$^_Global^.IF_PopUpCall(pm, pno) = TRUE) then
      retcode := TRUE;
      no := 0;
    end_if;
    ppp += sizeof(_POINTERPARA); 
  end_while;

END_FUNCTION

FUNCTION GLOBAL _Lse::AddOszi
VAR_INPUT
	ptr		: ^_OsziLSE;
END_VAR
VAR_OUTPUT
	retcode		: bool;
END_VAR

  retcode := FALSE; 
  if(add_MEM_POINTER(#Oszis, ptr) = TRUE) then
    retcode := TRUE; 
  end_if; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_OpenTouchEditor
VAR_INPUT
	pe        : ^_EDITOR;
	preselect : UINT; 
END_VAR
VAR_OUTPUT
	retcode		: UINT; 
END_VAR
VAR
	no  : UDINT;
	ppp  : ^_POINTERPARA; 
END_VAR

  retcode := preselect; 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1;
    retcode := ppp^.ptr$^_Global^.IF_OpenTouchEditor(pe, preselect); 
    if(retcode <> preselect) then
      no := 0;
    end_if;
    ppp += sizeof(_POINTERPARA); 
  end_while;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_AccessButton
VAR_INPUT
  pb        : ^_BUTTON;
END_VAR
VAR_OUTPUT
  retcode		: BOOL;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := TRUE;  

  if(GlobalBitState and GLOBAL_BIT_IFACCESSBUTTON) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      no -= 1; 
      if(ppp^.para and GLOBAL_BIT_IFACCESSBUTTON) then
        if(ppp^.ptr$^_Global^.IF_AccessButton(pb) = FALSE) then
          no := 0;
          retcode := FALSE;
        end_if;
      end_if;
      ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL _Lse::SetThisPointer
VAR_INPUT
	pointer		: ^void;
	index		: UINT;
END_VAR

  case index of
    0 : ToolCat := pointer; 
  end_case; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_GetThisPointer
VAR_INPUT
	index		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: ^void;
END_VAR

  retcode := NIL; 

  case index of
    0 : retcode := ToolCat; 
  end_case; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::Language::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

  InsertCmd(CMD_NEWLANGUAGE, input, 0); 
  result := 1;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::DelayScreenSaver::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	DelayScreenSaver := input$UDINT;
    set_delay_screensave(input$UDINT);
	result := 1; 
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::DelayScreenSaver::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

    DelayScreenSaver := get_delay_screensave();  
    output := DelayScreenSaver; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::CommaSign::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
    tmp : BOOL; 
END_VAR

  tmp := FALSE; 
  if(input) then
    tmp := TRUE;
  end_if; 

  CommaSign := tmp; 
  set_commasign(tmp);
  result := 1;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::CommaSign::Read
VAR_OUTPUT
	output		: DINT;
END_VAR

  CommaSign := get_commasign();
  output := TO_DINT(CommaSign);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::AmericanDateFormat::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
    tmp : BOOL; 
END_VAR

  tmp := FALSE; 
  if(input) then
    tmp := TRUE;
  end_if; 

  AmericanDateFormat := tmp; 
  set_americandateformat(tmp);
  result := 1;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::AmericanDateFormat::Read
VAR_OUTPUT
	output		: DINT;
END_VAR

  AmericanDateFormat := get_americandateformat();
  output := TO_DINT(AmericanDateFormat);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::AmericanTimeFormat::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
    tmp : BOOL; 
END_VAR

  tmp := FALSE; 
  if(input) then
    tmp := TRUE;
  end_if; 

  AmericanTimeFormat := tmp; 
  set_americantimeformat(tmp);
  result := 1;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::AmericanTimeFormat::Read
VAR_OUTPUT
	output		: DINT;
END_VAR

  AmericanTimeFormat := get_americantimeformat();
  output := TO_DINT(AmericanTimeFormat);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::GotAlarm::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
  pac : ^_ALACELL;
  check : BOOL;
END_VAR

  result := input;
  check  := TRUE;
  pac    := input$^_ALACELL;

  if(pac^.kennung and 2#00000010) then
    pac^.kennung := pac^.kennung and 2#11111101;  // GetLostAlarms Kennung entfernen
    check := CheckLostAlarm(pac);
 #ifdef USER_BILLION
  elsif (LseReady = 0) & (IsClientConnected((#Gbcd)$^DINT) = 1) then
    if Gbcd.Server0.read() then
      check := FALSE; // RamAnd 2007-04-27 Bei Mehrprozessorlösungen keine Alarme annehmen (von verbundenem Gbcd),
    end_if;           // bevor Lse bereit ist (sonst Alarme doppelt in Liste)
 #endif
  end_if;

  if(check = TRUE) then
    store_ALACELL(pac);
  end_if;

  GotAlarm := input;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SeekAlgorithm::Read
VAR_OUTPUT
	output		: DINT;
END_VAR

  if(get_seek_algorithm() = FALSE) then
    output := 
	SeekAlgorithm := 0;
  else
    output := 
	SeekAlgorithm := 1;
  end_if; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SeekAlgorithm::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
    tmp : BOOL; 
END_VAR

  tmp := FALSE; 
  if(input) then
    tmp := TRUE; 
  end_if; 

  set_seek_algorithm(tmp);
  SeekAlgorithm := tmp; 
  result := 1;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::OpSysVersion::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

  OpSysVersion := _RTOSVERSION; 
  output := OpSysVersion;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::DirectionOnEnter::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
    tmp : BOOL; 
END_VAR

  tmp := FALSE; 
  if(input) then
    tmp := TRUE; 
  end_if; 

  DirectionOnEnter := tmp; 
  set_directiononenter(tmp); 
  result := 1; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::CursorWrapHorizontal::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
    tmp : BOOL; 
END_VAR

  tmp := FALSE; 
  if(input) then
    tmp := TRUE; 
  end_if; 

  CursorWrapHorizontal := tmp; 
  set_cursorwraphorizontal(tmp); 
  result := 1; 


END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::CursorWrapVertical::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
    tmp : BOOL; 
END_VAR

  tmp := FALSE; 
  if(input) then
    tmp := TRUE; 
  end_if; 

  CursorWrapVertical := tmp; 
  set_cursorwrapvertical(tmp); 
  result := 1; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::OfflineMode::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

  result := ACCESS_DENIED;
  if(input = 0) then
    if(OfflineMode <> 0) then
	  result := 0; 
      InsertCmd(CMD_RECONFIGVAR, 0, 0);
	  end_if; 
  end_if; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::NoExternCom::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
    tmp : BOOL; 
END_VAR

  tmp := FALSE; 
  if(input) then
    tmp := TRUE; 
  end_if; 

  NoExternCom := tmp; 
  set_noexterncom(tmp); 
  result := 1; 

END_FUNCTION

//[#ENGLISH]
//Interface is called right after language has changed
//parameter actno is number of actual language
//parameter oldno is number of previous language
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_LanguageHasChanged
VAR_INPUT
	actno		: UINT;
	oldno		: UINT;
END_VAR
VAR
	no  : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    ppp^.ptr$^_Global^.IF_LanguageHasChanged(actno, oldno); 
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_LanguageWillChange
VAR_INPUT
	newno		: UINT;
	oldno		: UINT;
END_VAR
VAR
	no  : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    ppp^.ptr$^_Global^.IF_LanguageWillChange(newno, oldno); 
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_Offline
VAR_INPUT
	station		: UINT;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    ppp^.ptr$^_Global^.IF_Offline(station);
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_OverloadEditor
VAR_INPUT
    pm          : ^_PICTUREMASK;
	whoami		: ^_WHOAMI;
	pvl		: ^_VARLABEL;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    ppp^.ptr$^_Global^.IF_OverloadEditor(pm, whoami, pvl);
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_ConfigDriveList
VAR_INPUT
	drvlst		: ^char;
	pthis		: ^void;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    ppp^.ptr$^_Global^.IF_ConfigDriveList(drvlst, pthis);
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

#ifndef UC_IPC
FUNCTION GLOBAL __CDECL RealComp
VAR_INPUT
  a : ^REAL;
  b : ^REAL; 
  op : UINT;
END_VAR
VAR_OUTPUT
  retcode : _BOOL;
END_VAR


  retcode := _FALSE;

  case op of
    IOP_OR:            // logic ||
      if(a^ | b^) then
        retcode := _TRUE;
      end_if;
    IOP_AND:           // logic &&
      if(a^ & b^) then
        retcode := _TRUE;
      end_if;
    IOP_SMALLER:       // logic <
      if(a^ < b^) then
        retcode := _TRUE;
      end_if;
    IOP_SMALLEREQUAL:  // logic <=
      if(a^ <= b^) then
        retcode := _TRUE;
      end_if;
    IOP_EQUAL:         // logic ==
      if(a^ = b^) then
        retcode := _TRUE;
      end_if;
    IOP_BIGGER:        // logic >
      if(a^ > b^) then
        retcode := _TRUE;
      end_if;
    IOP_BIGGEREQUAL:   // logic >=
      if(a^ >= b^) then
        retcode := _TRUE;
      end_if;

  end_case;
  
END_FUNCTION

FUNCTION GLOBAL __CDECL RealCalc
VAR_INPUT
  ret : ^_REAL;
  a : ^REAL;
  b : ^REAL; 
  op : UINT;
END_VAR

  case op of
    IOP_A_PLUS:        // arithmetic +
      ret^ := a^ + b^;
    IOP_A_MINUS:       // arithmetic -
      ret^ := a^ - b^;
    IOP_A_MULTI:       // arithmetic *
      ret^ := a^ * b^;
    IOP_A_DIV:         // arithmetic /
      ret^ := a^ / b^;
    IOP_A_MOD:         // arithmetic %
      ret^ := a^ mod b^;
    IOP_A_OR:          // arithmetic |
      ret^ := a^ or b^;
    IOP_A_AND:         // arithmetic &
      ret^ := a^ and b^;
    IOP_A_EQUAL:       // arithmetic =
      ret^ := a^;

  end_case;

END_FUNCTION

FUNCTION GLOBAL __CDECL ftol_
VAR_INPUT
  a : ^_REAL;
END_VAR
VAR_OUTPUT
  ret : _DWORD;
END_VAR

  ret := to_dint(a^);

END_FUNCTION

FUNCTION GLOBAL __CDECL format_value_st
VAR_INPUT
	value : ^REAL;
	pi    : ^_VARINFO;
  dezpt : _UWORD;
END_VAR
VAR_OUTPUT
  retcode : _IVALUE;
END_VAR 
VAR
  tempr : _REAL;
END_VAR

  retcode$REAL := value^;

  if((pi^.vartype = BINARY) & (pi^.format = SIZE_REAL)) then

    tempr := value^;

    if(tempr >= 0) then
      retcode := to_dint((tempr * to_real(get_multiplicator(dezpt))) + 0.5);
    else
      retcode := to_dint((tempr * to_real(get_multiplicator(dezpt))) - 0.5);
    end_if;
          
  end_if;

END_FUNCTION

FUNCTION GLOBAL __CDECL RealToStr
VAR_INPUT
  txt : ^void;
  value : _REAL;
  dzp : UINT;
  chr_size : UINT;
END_VAR
VAR
  vk  : DINT;
  nk  : DINT;
  len : UINT;
END_VAR
  // dzp ... anzahl der gültigen nachkommastellen

  vk := TO_DINT(value);
  DToA(txt, vk, 0x0800, chr_size);

  if(dzp <> 0) then
    nk  := TO_DINT((value - TO_REAL(vk)) * TO_REAL(get_multiplicator(dzp)));
    len := StrLen(txt, chr_size);
	StrCat(txt, chr_size, ".", sizeof(_ASCII));
    txt += (len + 1) * chr_size;
    DToA(txt, nk, 0x0800, chr_size);
  end_if;

END_FUNCTION

FUNCTION GLOBAL __CDECL StrToReal
VAR_INPUT
  dv : ^_REAL;
  txt : ^void;
  chr_size : _UWORD;
END_VAR
VAR_OUTPUT
  retcode : _BOOL;
END_VAR
VAR
  neg : _BOOL;
  dot : _BOOL;
  run : _BOOL;
  vk : _DWORD;
  nk : _DWORD;
  div : _UWORD;
  rval : _REAL;
  atx : ^_ASCII;
  ac : _ASCII;
END_VAR

  retcode := _FALSE;
  neg := _FALSE;
  dot := _FALSE;
  run := _TRUE;
  vk := 0;
  nk := 0;
  div := 1;
  rval := 0;

  if(chr_size = 1) then
    atx := txt$^_ASCII;
    repeat
      ac := atx^;
      if(ac = '-') then
        neg := _TRUE;
      elsif((ac = '.')|(ac = ',')) then
        dot := _TRUE;
      elsif((ac >= '0') & (ac <= '9')) then
        retcode := _TRUE;
        if(dot = _FALSE) then
          vk := (vk * 10) + (ac - '0');
        else
          div := div * 10;
          nk := (nk * 10) + (ac - '0');
        end_if;
      elsif(ac = 0) then
        run := _FALSE;
      end_if;

      atx += 1;

		until(run = _FALSE)
    end_repeat;
    
  end_if;

  if(retcode = _TRUE) then
    rval := vk;

    if((div > 1) & (nk <> 0)) then
      rval := rval + ((to_real(nk)) / div);
    end_if;
  end_if;

  if(neg = _TRUE) then
    rval := -rval;
  end_if;

  dv^ := rval;

END_FUNCTION

FUNCTION GLOBAL __CDECL string_to_value
VAR_INPUT
  x0 : DINT;
  p1 : ^_VARINFO;
END_VAR
VAR_OUTPUT
  retcode : DINT;
END_VAR

  retcode := x0;

 #ifdef UC_REAL
  if((p1^.vartype = BINARY) & (p1^.format = SIZE_REAL)) then
    retcode$REAL := ((to_real(x0) / TO_REAL(get_multiplicator(TO_UINT(VarList_GetDezPoint(p1))))));
  end_if;
 #endif

END_FUNCTION

FUNCTION GLOBAL __CDECL MakeMinMax
VAR_INPUT
  dz   : ^_RESULT; 
  sz   : ^_RESULT; 
  minz : BOOL; 
END_VAR
VAR
  rval : REAL;
  dval : DINT;
END_VAR

 #ifdef UC_REAL
  if(dz^.ftype = RES_REAL) then
    if((sz^.ftype = RES_CONSTANT)|(sz^.ftype = RES_NUMERIC)) then
      rval := TO_REAL(sz^.value);
    elsif(sz^.ftype = RES_REAL) then
      rval := sz^.value$REAL;
    end_if; 

    if(minz = _TRUE) then

      if(rval > dz^.rmin$REAL) then
        dz^.rmin$REAL := rval;
      end_if; 
    else
      if(rval < dz^.rmax$REAL) then
        dz^.rmax$REAL := rval;
      end_if;
    end_if; 

    return; 

  end_if;   
 #endif

  if((sz^.ftype = RES_CONSTANT)|(sz^.ftype = RES_NUMERIC)) then
    dval := sz^.value;
  else
    dval := TO_DINT(sz^.value$REAL);
  end_if; 

  if(minz = _TRUE) then
    if(dval > dz^.rmin) then
      dz^.rmin := dval;
    end_if; 
  else
    if(dval < dz^.rmax) then
      dz^.rmax := dval;
    end_if; 
  end_if; 

END_FUNCTION

FUNCTION GLOBAL __CDECL dword2real
VAR_INPUT
  a : ^_REAL;
  b : _DWORD;
END_VAR

  a^ := to_real(b);

END_FUNCTION

#endif

FUNCTION GetMulDiv VAR_INPUT einheit:UDINT; posdezpt:DINT; END_VAR VAR_OUTPUT retcode:UDINT; END_VAR
  var
    dekade : dint;
  end_var

  dekade := 0;
  case(einheit) of
    1000000000 : dekade := 9;
    100000000  : dekade := 8;
    10000000   : dekade := 7;
    1000000    : dekade := 6;
    100000     : dekade := 5;
    10000      : dekade := 4;
    1000       : dekade := 3;
    100        : dekade := 2;
    10         : dekade := 1;
  end_case;

  retcode := 1; 
  case(dekade - posdezpt) of 
    9 : retcode := 1000000000;  
    8 : retcode :=  100000000;  
    7 : retcode :=   10000000;  
    6 : retcode :=    1000000;  
    5 : retcode :=     100000;  
    4 : retcode :=      10000;  
    3 : retcode :=       1000; 
    2 : retcode :=        100;  
    1 : retcode :=         10;  
  end_case;   

END_FUNCTION

FUNCTION MyRealCalc VAR_INPUT value:REAL; posdezpt:DINT; direction:BOOL; END_VAR VAR_OUTPUT retcode:REAL; END_VAR
  var
    div : REAL;
  end_var

  div := 1.0;
  case(posdezpt) of
    1 : div :=     10.0;
    2 : div :=    100.0;
    3 : div :=   1000.0;
    4 : div :=  10000.0;
  end_case;
  
  if(direction = true) then
    retcode := (value * div);
  else
    retcode := (value / div);
  end_if;

END_FUNCTION

FUNCTION R_Stroke2mm VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then // stroke -> mm
    r := v  / (1mm); 
  else // mm -> stroke
    r := v * (1mm); 
  end_if; 

END_FUNCTION

FUNCTION R_Temp2Celsius VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then
    r := v / 10.0;
  else
    r := v * 10.0;
  end_if;

END_FUNCTION

FUNCTION R_Weight2Kilogram VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then
    r := v / 10000.0;
  else
    r := v * 10000.0;
  end_if;
  
END_FUNCTION

FUNCTION R_Time2Second VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then
    r := v / (1.0sec);
  else
    r := v * (1.0sec);
  end_if; 
  
END_FUNCTION

FUNCTION R_Time2Minute VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then
    r := R_Time2Second((v + 30)/60, p, true);
  else
    r := R_Time2Second(v*60, p, false);
  end_if;  

END_FUNCTION

FUNCTION R_Time2Hour VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then
    r := R_Time2Minute((v + 30)/60, p, true); 
  else
    r := R_Time2Minute(v*60, p, false); 
  end_if;

END_FUNCTION

FUNCTION R_Pressure2Bar VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR
  
  if(d = true) then 
    r := v / (1bar); // pressure -> bar
  else  
    r := v * (1bar); // bar -> pressure
  end_if; 

END_FUNCTION

FUNCTION R_Stroke2inch VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then // stroke -> inch
    r := v / (25.4mm);
  else  // inch -> stroke
    r := v * (25.4mm);
  end_if;

END_FUNCTION

FUNCTION R_Pressure2Psi VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  // 1bar = 14.50376808 psi
  if(d = true) then // pressure -> psi
    r := (v * (14.50376808)) / (1.0 bar);
  else // psi -> pressure
    r := (v * (1.0bar)) / (14.50376808);
  end_if; 

END_FUNCTION

FUNCTION R_Weight2Pound VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then
    r := (v * 2.205) / 10000.0;
  else
    r := (v * 10000.0) /  2.205;
  end_if;

END_FUNCTION

FUNCTION R_Temp2Fahrenheit VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR
  // lasal grundeinheit : 10E-1 Grad C
  // [C] = ([F]-32)*5/9

  if(d = true) then
    r := 32.0 + (v * 0.9) / 5.0; // sa37714
  else
    r := ((v - 32.0) * 50) / 9.0; // sa37714
  end_if; 

END_FUNCTION

FUNCTION R_Force2KN VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then 
    r := v  / (1.0 kn); // stroke -> mm
  else  
    r := v * (1.0 kn); // mm -> stroke
  end_if; 

END_FUNCTION

FUNCTION R_Angle2deg VAR_INPUT v:REAL; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:REAL; END_VAR

  if(d = true) then // angle -> mm
    r := v  / (1deg); 
  else // deg -> angle
    r := v * (1deg); 
  end_if; 

END_FUNCTION

FUNCTION S_Stroke2mm VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR

  r$udint := GetMulDiv(1mm, p^.info.posdezpt);

  if(d = true) then // stroke -> mm
    if(v < 0) then
      r := (v - (r/2)) / r; 
	else
      r := (v + (r/2)) / r; 
    end_if;
  else // mm -> stroke
    r := v * r; 
  end_if; 

END_FUNCTION

FUNCTION S_Temp2Celsius VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR
  
  r$udint := GetMulDiv(10, p^.info.posdezpt);
  
  if(d = true) then // temperature -> C
    if(v < 0) then
      r := (v - (r/2)) / r;
	else
      r := (v + (r/2)) / r;
	end_if;
  else // C -> temperature
    r := v * r;
  end_if;

END_FUNCTION

FUNCTION S_Weight2Kilogram VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR

  r$udint := GetMulDiv(10000, p^.info.posdezpt);

  if(d = true) then // weight -> kg
    if(v < 0) then
      r := (v - (r/2)) / r;
	else
      r := (v + (r/2)) / r;
    end_if;
  else // kg -> weight
    r := v * r;
  end_if;

END_FUNCTION

FUNCTION S_Time2Second VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR

  r$udint := GetMulDiv(1sec, p^.info.posdezpt);

  if(d = true) then
    if(v < 0) then
      r := (v - (r/2)) / r; 
	else
      r := (v + (r/2)) / r; 
    end_if;
  else
    r := v * r; 
  end_if; 

END_FUNCTION

FUNCTION S_Time2Minute VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR

  if(d = true) then
    if(v < 0) then
      r := S_Time2Second((v-30)/60, p, true);
	else
      r := S_Time2Second((v+30)/60, p, true);
    end_if;
  else
    r := S_Time2Second(v*60, p, false);
  end_if;  
  
END_FUNCTION

FUNCTION S_Time2Hour VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR

  if(d = true) then
    if(v < 0) then
      r := S_Time2Minute((v-30)/60, p, true); 
	else
      r := S_Time2Minute((v+30)/60, p, true); 
    end_if;
  else
    r := S_Time2Minute(v*60, p, false); 
  end_if;

END_FUNCTION

FUNCTION S_Pressure2Bar VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT;END_VAR

  r$udint := GetMulDiv(1bar, p^.info.posdezpt); 

  if(d = true) then
    if(v < 0) then
      r := (v - (r/2)) / r; // pressure -> bar
    else
      r := (v + (r/2)) / r; // pressure -> bar
	end_if;
  else
    r := v * r; // bar -> pressure
  end_if; 

END_FUNCTION

FUNCTION S_Stroke2inch VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR

  r$udint := GetMulDiv(1mm, p^.info.posdezpt) * 254; 

  if(d = true) then // stroke -> inch
    if(v < 0) then
      r := ((v * 10) - (r / 2)) / r;
	else
      r := ((v * 10) + (r / 2)) / r;
    end_if;
  else // inch -> stroke
    r := ((v * r) + 5) / 10;
  end_if;

END_FUNCTION

FUNCTION S_Pressure2Psi VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR
  var
    rv : real;
  end_var
  
  rv := R_Pressure2Psi(v, p, d);
  r  := to_dint(MyRealCalc(rv, p^.info.posdezpt, d));

END_FUNCTION

FUNCTION S_Weight2Pound VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR
  var
    rv : real;
  end_var
  
  rv := R_Weight2Pound(v, p, d);
  r  := to_dint(MyRealCalc(rv, p^.info.posdezpt, d));
  
END_FUNCTION

FUNCTION S_Temp2Fahrenheit VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR
  // lasal grundeinheit : 10E-1 Grad C
  // [C] = ([F]-32)*5/9
  VAR
  	df, f : real;
  END_VAR

  if(p^.info.posdezpt > 1) then
    // sa34987
    df := to_real(GetMulDiv(0, -p^.info.posdezpt));
    f  := to_real(v);
    if(d = true) then
      f := ((f * 9.0) / (5.0 * df)) + 32.0;
      r := to_dint(f * df);
    else
      f := ((f - 32.0) * 5.0 * df) / 9.0;
      r := to_dint(f);
    end_if;
  else
    if(d = true) then
      if(v < 0) then
        r := (((v * 9) - 2) / 5) + 320;
      else
        r := (((v * 9) + 2) / 5) + 320;
      end_if;
      if(p^.info.posdezpt = 0) then
        if(r < 0) then
          r := (r - 5) / 10;
        else
          r := (r + 5) / 10;
        end_if;
      end_if;
    else
      if(p^.info.posdezpt = 0) then
        r := (v - 32) * 10;
      else
        r := v - 320;
      end_if;
  
      if(r < 0) then
        r := ((r * 5) - 4) / 9;
      else
        r := ((r * 5) + 4) / 9;
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION S_Force2KN VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR

  r$udint := GetMulDiv(1kn, p^.info.posdezpt);

  if(d = true) then
    if(v < 0) then
      r := (v - (r/2)) / r; // force -> KN
    else
      r := (v + (r/2)) / r; // force -> KN
    end_if;
  else
    r := v * r; // KN -> force
  end_if; 

END_FUNCTION

FUNCTION S_Angle2deg VAR_INPUT v:DINT; p:^_VARIABLE; d:BOOL; END_VAR VAR_OUTPUT r:DINT; END_VAR

  r$udint := GetMulDiv(1deg, p^.info.posdezpt);

  if(d = true) then // angle -> deg
    if(v < 0) then
      r := (v - (r/2)) / r; 
    else
      r := (v + (r/2)) / r; 
    end_if;
  else // deg -> angle
    r := v * r; 
  end_if; 

END_FUNCTION


//[#ENGLISH]
//function is called in case of an recalculation (formula) defined for a data-server
//pres ....... --> to value
//pv ......... --> to variable
//direction .. direction (TRUE Y=kX+d, FALSE X=(Y+d)/k)
//retcode .... return TRUE if kernel should do the calculation, on the other hand return FALSE
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_Recalculate
VAR_INPUT
	pres		: ^_RESULT;
	pv          : ^_VARIABLE; 
	direction   : BOOL; 
END_VAR
VAR_OUTPUT
    retcode : BOOL; 
END_VAR
VAR
 #ifndef CUTOFF_USER
  no   : UDINT; 
  ppp  : ^_POINTERPARA; 
 #endif
END_VAR 
 
  retcode := TRUE;  
 
 #ifndef CUTOFF_USER
  if(GlobalBitState and GLOBAL_BIT_IFRECALCULATE) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      no  -= 1; 
      if(ppp^.para and GLOBAL_BIT_IFRECALCULATE) then
        if(ppp^.ptr$^_Global^.IF_Recalculate(pres, pv, direction) = FALSE) then
          no := 0; 
          retcode := FALSE; 
        end_if; 
      end_if;
      ppp += sizeof(_POINTERPARA); 
    end_while;
  end_if;
 #endif

  if(retcode = TRUE) then
    retcode := FALSE;
   #ifdef UC_REAL
    if(pres^.ftype = RES_REAL) then
      case(pv^.info.formula) of
         3 : pres^.value$REAL := R_Stroke2mm(pres^.value$REAL, pv, direction);
         4 : pres^.value$REAL := R_Stroke2inch(pres^.value$REAL, pv, direction);
         5 : pres^.value$REAL := R_Temp2Celsius(pres^.value$REAL, pv, direction);
         6 : pres^.value$REAL := R_Temp2Fahrenheit(pres^.value$REAL, pv, direction);
         7 : pres^.value$REAL := R_Weight2Kilogram(pres^.value$REAL, pv, direction);
         8 : pres^.value$REAL := R_Weight2Pound(pres^.value$REAL, pv, direction);
         9 : pres^.value$REAL := R_Pressure2Bar(pres^.value$REAL, pv, direction);
        10 : pres^.value$REAL := R_Pressure2Psi(pres^.value$REAL, pv, direction);
        11 : pres^.value$REAL := R_Time2Second(pres^.value$REAL, pv, direction);
        12 : pres^.value$REAL := R_Time2Minute(pres^.value$REAL, pv, direction);
        13 : pres^.value$REAL := R_Time2Hour(pres^.value$REAL, pv, direction);
        14 : pres^.value$REAL := R_Force2KN(pres^.value$REAL, pv, direction);
        15 : pres^.value$REAL := R_Angle2deg(pres^.value$REAL, pv, direction);
		else retcode := TRUE;
	  end_case;
	else
   #endif
      case(pv^.info.formula) of
         3 : pres^.value := S_Stroke2mm(pres^.value, pv, direction);
         4 : pres^.value := S_Stroke2inch(pres^.value, pv, direction);
         5 : pres^.value := S_Temp2Celsius(pres^.value, pv, direction);
         6 : pres^.value := S_Temp2Fahrenheit(pres^.value, pv, direction);
         7 : pres^.value := S_Weight2Kilogram(pres^.value, pv, direction);
         8 : pres^.value := S_Weight2Pound(pres^.value, pv, direction);
         9 : pres^.value := S_Pressure2Bar(pres^.value, pv, direction);
        10 : pres^.value := S_Pressure2Psi(pres^.value, pv, direction);
        11 : pres^.value := S_Time2Second(pres^.value, pv, direction);
        12 : pres^.value := S_Time2Minute(pres^.value, pv, direction);
        13 : pres^.value := S_Time2Hour(pres^.value, pv, direction);
        14 : pres^.value := S_Force2KN(pres^.value, pv, direction);
        15 : pres^.value := S_Angle2deg(pres^.value, pv, direction);
		else retcode := TRUE;
	  end_case;
   #ifdef UC_REAL
	end_if;
   #endif

  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::Lse::NewInst
VAR_INPUT
 pPara  : ^CmdStruct;
 pResult  : ^Results;
END_VAR
VAR_OUTPUT
 ret_code  : IprStates;
END_VAR
 
  ret_code:= READY;

  CASE pPara^.uiCmd OF
 
    0:  // download start
      DownloadState := 1;
      pResult^.aData[0]$UDINT := 16#46544F44; // DOTF-id
      pResult^.uiLng          := 6;
 
    1:  // download finished
      DownloadState := 2;
      pResult^.aData[0]$UDINT := 16#46544F44; // DOTF-id
      pResult^.uiLng          := 6;
 
  END_CASE;


END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::IF_STOP
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := true;
//  InsertCmd(CMD_NEWPICTURE, get_startpicture(), 0);

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    if(ppp^.ptr$^_Global^.IF_Stop() = false) then
      retcode := false;
    end_if;
    ppp += sizeof(_POINTERPARA); 
  end_while; 

  if(retcode = false) then
    do_start();
  end_if;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_Online
VAR_INPUT
	station		: UINT;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    ppp^.ptr$^_Global^.IF_Online(station);
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_TryToAccess
VAR_INPUT
	ptx		: ^void;
	state		: _ACCESSFAILED;
	found		: _FOUNDHID;
	preselect		: bool;
END_VAR
VAR_OUTPUT
	retcode		: bool;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := preselect;
  
  if(GlobalBitState and GLOBAL_BIT_IFTRYTOACCESS) then
    no      := UserGlobal.no; 
    ppp     := UserGlobal.ptr; 
    while no do
      no      -= 1; 
      if(ppp^.para and GLOBAL_BIT_IFTRYTOACCESS) then
        retcode := ppp^.ptr$^_Global^.IF_TryToAccess(ptx, state, found, preselect);
        if(retcode <> preselect) then
          no := 0;
        end_if;
      end_if;
      ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;
  
END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_CheckHeap
VAR_INPUT
	display		: bool;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode    := _IDLE;

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    retcode := ppp^.ptr$^_Global^.IF_CheckHeap(display);
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
    if(retcode <> _IDLE) then
      no := 0;
    end_if;
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_SwitchMultiStation
VAR_INPUT
	station		: UINT;
END_VAR
VAR
	no   : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    ppp^.ptr$^_Global^.IF_SwitchMultiStation(station);
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

#pragma warning (disable: 73)
FUNCTION __CDECL VIRTUAL GLOBAL _Lse::DoCmdInterface
VAR_INPUT
	cmd		: _PIC_COMMAND;
	op1		: DINT;
	op2		: DINT;
	psl		: ^_STACK_LINE;
END_VAR
VAR_OUTPUT
	retcode	: BOOL;
END_VAR

  retcode := true;

END_FUNCTION
#pragma warning (default: 73)

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_ScreenSaverWillStart
VAR_OUTPUT
	retcode		: bool;
END_VAR
VAR
	no  : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := true;

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    retcode := ppp^.ptr$^_Global^.IF_ScreenSaverWillStart();
    no  -= 1;
    ppp += sizeof(_POINTERPARA); 
    if(retcode = _FALSE) then
      no := 0;
    end_if;
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_ScreenSaverWillEnd
VAR_INPUT
    pev : ^_EVENT;
END_VAR
VAR_OUTPUT
	retcode		: bool;
END_VAR
VAR
	no  : UDINT; 
	ppp  : ^_POINTERPARA; 
END_VAR 

  retcode := true;

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    retcode := ppp^.ptr$^_Global^.IF_ScreenSaverWillEnd(pev);
    no  -= 1;
    ppp += sizeof(_POINTERPARA); 
    if(retcode = _FALSE) then
      no := 0;
    end_if;
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_Beep
  VAR_INPUT
    whobeep 	: _WHOBEEP;
  END_VAR
  VAR
    no  : UDINT; 
	  ppp  : ^_POINTERPARA; 
  END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    ppp^.ptr$^_Global^.IF_Beep(whobeep); 
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_IpcIni
  VAR_INPUT
    pini 	: ^_IPCINI;
  END_VAR
  VAR
    no  : UDINT; 
    ppp  : ^_POINTERPARA; 
  END_VAR 

  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    ppp^.ptr$^_Global^.IF_IpcIni(pini); 
    no  -= 1; 
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

//[#ENGLISH]
//diese funktion wandelt eine zahl (4 Byte) in einen string um.
//die darstellung im string erfolgt hexadezimal.
//bitweise darstellung von format:
//.... .... .... **** no of digits
//.... .... **** .... position decimalpoint
//.... ...* .... .... preceding zeros
//.... ..*. .... .... descendant zeros
//.... .*.. .... .... vorzeichen unmittelbar vor wert (-3 ansonsten -  3)
//.... *... .... .... anzahl der stellen automatisch ermitteln
FUNCTION VIRTUAL GLOBAL _Lse::Str_DToH
VAR_INPUT
  pt       : ^VOID; 
  value    : DINT;
  format   : UINT; 
  chr_size : UINT; 
END_VAR

  Lse_DToH(pt, value, format, chr_size); 
  
END_FUNCTION

//[#ENGLISH]
//diese funktion wandelt eine zahl (4 Byte) in einen string um.
//die darstellung im string erfolgt dezimal.
//bitweise darstellung von format:
//.... .... .... **** no of digits
//.... .... **** .... position decimalpoint
//.... ...* .... .... preceding zeros
//.... ..*. .... .... descendant zeros
//.... .*.. .... .... vorzeichen unmittelbar vor wert (-3 ansonsten -  3)
//.... *... .... .... anzahl der stellen automatisch ermitteln
FUNCTION VIRTUAL GLOBAL _Lse::Str_DToA
VAR_INPUT
  pt       : ^VOID; 
  value    : DINT;
  format   : UINT; 
  chr_size : UINT; 
END_VAR

  Lse_DToA(pt, value, format, chr_size); 

END_FUNCTION

//[#ENGLISH]
//diese funktion ermittelt die anzahl der zeichen in einem string.
//der string wird mittels parameter txt bekanntgegeben.
//der parameter chr_size gibt auskunft ueber die groesse eines zeichens. (ASCII oder UNI code)
FUNCTION VIRTUAL GLOBAL _Lse::Str_Len
VAR_INPUT
  txt       : ^VOID; 
  chr_size : UINT; 
END_VAR
VAR_OUTPUT
  retcode : UINT; 
END_VAR

  retcode := Lse_StrLen(txt, chr_size); 

END_FUNCTION

//[#ENGLISH]
// diese funktion kopiert den string pt2 nach pt1.
// die parameter size1 und size2 geben auskunft ueber die jeweilige zeichengroesse
// uni und ascii-code string duerfen gemischt werden
FUNCTION VIRTUAL GLOBAL _Lse::Str_Cpy
VAR_INPUT
  pt1   : ^VOID; 
  size1 : UINT; 
  pt2   : ^VOID; 
  size2 : UINT; 
END_VAR

  Lse_StrCpy(pt1, size1, pt2, size2); 

END_FUNCTION

//[#ENGLISH]
// diese funktion kopiert den string pt2 an das ende von pt1.
// die parameter size1 und size2 geben auskunft ueber die jeweilige zeichengroesse
// uni und ascii-code string duerfen gemischt werden
FUNCTION VIRTUAL GLOBAL _Lse::Str_Cat
VAR_INPUT
  pt1   : ^VOID; 
  size1 : UINT; 
  pt2   : ^VOID; 
  size2 : UINT; 
END_VAR

  Lse_StrCat(pt1, size1, pt2, size2); 

END_FUNCTION

//[#ENGLISH]
// diese funktion vergleicht den string pt2 mit string pt1.
// die parameter size1 und size2 geben auskunft ueber die jeweilige zeichengroesse
// uni und ascii-code string duerfen gemischt werden
// sind beide strings ident so wird 0 zurueckgeliefert, ansonsten <>0
FUNCTION VIRTUAL GLOBAL _Lse::Str_Cmp
VAR_INPUT
  pt1   : ^VOID; 
  size1 : UINT; 
  pt2   : ^VOID; 
  size2 : UINT; 
END_VAR
VAR_OUTPUT
  retcode : UINT; 
END_VAR

  retcode := Lse_StrCmp(pt1, size1, pt2, size2); 

END_FUNCTION

//[#ENGLISH]
//diese funktion berechnet die größe eines strings in byte,
//wobei jedoch die abschließende 0 nicht mitgerechnet wird.
FUNCTION VIRTUAL GLOBAL _Lse::Str_Size
VAR_INPUT
  pt1   : ^VOID; 
  size1 : UINT; 
END_VAR
VAR_OUTPUT
  retcode : UINT; 
END_VAR

  retcode := Lse_StrSize(pt1, size1); 

END_FUNCTION

//[#ENGLISH]
//diese funktion sucht nach dem zeichen c im string p und gibt dessen position
//zurück. ist das zeichen c nicht im string vorhanden, so wird der wert 16#FFFF (65535) zurückgegeben.
//nach 0 (stringende) kann nicht gesucht werden; verwenden sie hierfür die funktion Str_Len().
FUNCTION VIRTUAL GLOBAL _Lse::Str_Chr
VAR_INPUT
  pt1   : ^VOID;
  chr   : _UNI;  
  size1 : UINT; 
END_VAR
VAR_OUTPUT
  retcode : UINT; 
END_VAR

  retcode := Lse_StrChr(pt1, chr, size1); 

END_FUNCTION

//[#ENGLISH]
//im string pt1 werden alle kleinbuchstaben [a-z] auf großbuchstaben [A-Z] geändert.
//der parameter len gibt an, bis zu welcher position im string die zeichen geändert werden sollten.
//ist len gleich 0, so wird der gesamte string durchsucht.
FUNCTION VIRTUAL GLOBAL _Lse::Str_Up
VAR_INPUT
  pt1   : ^VOID;
  size1 : UINT; 
  len   : UINT; 
END_VAR

  Lse_StrUp(pt1, size1, len); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::Out_ParameterString
VAR_INPUT
  room : _ROOM; 
  pt   : ^_CHAR; 
  pv   : ^_MEM_VARLABEL; 
  font : _FONT; 
  att  : _ATTRIB; 
  col  : _COLOR; 
END_VAR

  Lse_OutParaString(#room, pt, pv, font, att, col);

END_FUNCTION

//[#DEUTSCH]
//Diese Funktion gibt einen Text, der mittels dem Parameter txt angegeben ist
//im definierten Bereich (pr) aus.
//
//Parameter :
//txt     ^_CHAR    Pointer auf einen text
//pr     ^_ROOM   Pointer auf den Bereich
//font  _FONT       Schriftart
//att    _ATTRIB    Attribute (z.B T_BOLD "fett")
//col   _COLOR     Farbe des Textes
//[#ENGLISH]
//Diese Funktion gibt einen Text, der mittels dem Parameter txt angegeben ist
//im definierten Bereich (pr) aus.
//
//Parameter :
//txt     ^_CHAR    Pointer auf einen text
//pr     ^_ROOM   Pointer auf den Bereich
//font  _FONT       Schriftart
//att    _ATTRIB    Attribute (z.B T_BOLD "fett")
//col   _COLOR     Farbe des Textes
FUNCTION VIRTUAL GLOBAL _Lse::Out_TextAlign
VAR_INPUT
  txt  : ^_CHAR; 
  pr   : ^_ROOM; 
  font : _FONT; 
  att  : _ATTRIB; 
  col  : _COLOR; 
END_VAR

  Lse_OutTextAlign(txt, pr, font, att, col); 

END_FUNCTION 

FUNCTION VIRTUAL GLOBAL _Lse::Lib_FormatValue
VAR_INPUT
  txt   : ^_CHAR; 
  value : _IVALUE; 
  pi1   : ^_VARINFO; 
  pf1   : ^_PICFORMAT; 
END_VAR    

  format_value(txt, value, pi1, pf1);  

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::Lib_FormatTime 
VAR_INPUT 
  txt    : ^_CHAR; 
  pt1    : ^_TIME; 
  format : UINT; 
END_VAR

  format_time(txt, pt1, format);   

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::Lib_FormatDate 
VAR_INPUT 
  txt    : ^_CHAR; 
  pt1    : ^_DATE; 
  format : UINT; 
END_VAR

  format_date(txt, pt1, format); 

END_FUNCTION 

FUNCTION VIRTUAL GLOBAL _Lse::BMP_Draw 
VAR_INPUT 
  x1   : _KOORD; 
  y1   : _KOORD; 
  dpne : ^_ASCII; 
END_VAR
VAR_OUTPUT
  retcode : BOOL;  
END_VAR
 
 #ifdef UC_IPC
  retcode := flash_bmp(x1, y1, dpne); 
 #else
  retcode := FALSE; 
 #endif

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::BMP_Save 
VAR_INPUT 
  dpne : ^_ASCII; 
  x1   : _KOORD;  
  y1   : _KOORD; 
  x2   : _KOORD; 
  y2   : _KOORD; 
END_VAR
VAR_OUTPUT
  retcode : BOOL;  
END_VAR
    
 #ifdef UC_IPC 
  retcode := save_bmp(dpne, x1, y1, x2, y2, FALSE); 
 #else
  retcode := FALSE; 
 #endif

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::Fnt_Size
VAR_INPUT
  fnt : _FONT; 
  x   : ^UINT; 
  y   : ^UINT; 
END_VAR
  
  font_size(fnt, x, y); 

END_FUNCTION    

FUNCTION VIRTUAL GLOBAL _Lse::Fnt_Set
VAR_INPUT
  fnt : _FONT; 
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  font_set(fnt);
  retcode := TRUE;  

END_FUNCTION   

FUNCTION VIRTUAL GLOBAL _Lse::Fnt_Seek
VAR_INPUT
  name : ^_ASCII; 
END_VAR
VAR_OUTPUT
  retcode : UINT; 
END_VAR

  retcode := font_seek(name); 

END_FUNCTION    

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetVarInfo
VAR_INPUT
  pvi  : ^_VARINFO; 
  no   : UDINT; 
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR
  
  retcode := VarList_GetVarInfo(pvi, no); 

END_FUNCTION

//[#ENGLISH]
//this function gets the whole information about a variable
//pvi ... --> to structure where information will be stored
//no .... number of variable
//if required variable is inaccessible, method returns FALSE on the other hand TRUE
FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetSingleVariable
VAR_INPUT
  pv : ^_VARIABLE; 
  no : UDINT; 
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_GetSingleVariable(pv, no); 

END_FUNCTION

//[#ENGLISH]
//this function gets the whole information about a variable
//pvi ... --> to structure where information will be stored
//pvl ... --> to information where variable is adressed
//if required variable is inaccessible, method returns FALSE on the other hand TRUE
FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetVariable
VAR_INPUT
  pv      : ^_VARIABLE; 
  pvl     : ^_VARLABEL; 
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_GetVariable(pv, pvl); 

END_FUNCTION

//[#ENGLISH]
//use this method to get data which are defined by a _VARLABEL
//pr ........ --> to structure where required data will be stored
//pv ........ --> to structure where whole information about variable will be stored
//pvl ....... --> to _VARLABEL which adresses your variable, maybe it could be a constant, date, time etc.
//wait4plc .. TRUE means i want to wait till data are ready
//if required variable is inaccessible, method returns FALSE on the other hand TRUE
FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetSystemData
VAR_INPUT
  pr       : ^_RESULT; 
  pv       : ^_VARIABLE; 
  pvl      : ^_VARLABEL;
  wait4plc : BOOL;   
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_GetSystemData(pr, pv, pvl, wait4plc); 

END_FUNCTION

//[#ENGLISH]
//this method returns the size of a variable which is defined by parameter pv
//pv ... --> to structure which keeps information about variable
//method returns no of bytes. example: sizeof(DINT) or sizeof(USINT)
FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetVariableSize
VAR_INPUT
  pv      : ^_VARINFO; 
END_VAR
VAR_OUTPUT
  retcode : UINT; 
END_VAR

  retcode := VarList_GetVariableSize(pv);

END_FUNCTION

//[#ENGLISH]
//use this method to set data which are defined by a _VARLABEL
//pr ............. --> to structure who keeps data to store
//pv ............. --> to structure where whole information about variable will be stored
//pvl ............ --> to _VARLABEL which adresses your variable
//saveimmediate .. TRUE means i want to store data immediately
//if datas are stored, method returns TRUE on the other hand FALSE
FUNCTION VIRTUAL GLOBAL _Lse::VarLst_SetSystemData
VAR_INPUT
  pr            : ^_RESULT; 
  pv            : ^_VARIABLE; 
  pvl           : ^_VARLABEL; 
  saveimmediate : BOOL; 
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_SetSystemData(pr, pv, pvl, saveimmediate); 

END_FUNCTION

//[#ENGLISH]
//use this method to get data from a server which is adressed by servernumber
//note: function works just in case of numeric server (no time, date, string...)
//pn ......... servernumber
//pval ....... --> to memorylocation where serverdata should be stored
//wait4plc ... TRUE means i want to wait till data are ready
//if server-data is valid, method returns TRUE on the other hand FALSE
FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetValueByNo
VAR_INPUT
  no       : UDINT; 
  pval     : ^_IVALUE; 
  wait4plc :  BOOL;
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_GetValueByNo(no, pval, wait4plc); 

END_FUNCTION

//[#ENGLISH]
//use this method to get data which are defined by a _VARLABEL
//note: function works just in case of numeric server (no time, date, string...)
//pvl ........ --> to _VARLABEL which adresses your server
//pd ......... --> to memorylocation where serverdata should be stored
//wait4plc ... TRUE means i want to wait till data are ready
//if datas are stored, method returns TRUE on the other hand FALSE
FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetValue
VAR_INPUT
  pvl      : ^_VARLABEL; 
  pd       : ^_IVALUE; 
  wait4plc : BOOL;
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_GetValue(pvl, pd, wait4plc); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_SetValueByNo
VAR_INPUT
  no    : UDINT; 
  value : DINT;
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_SetValueByNo(no, value); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetCompleteNoDigits
VAR_INPUT
  pvi : ^_VARINFO;
END_VAR
VAR_OUTPUT
  retcode : UINT; 
END_VAR

  retcode := VarList_GetCompleteNoDigits(pvi); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetLabel
VAR_INPUT
  pd  : ^_ASCII; 
  no  : UDINT; 
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR
VAR
  dummy : _UBYTE; 
END_VAR
  retcode := VarList_GetLabel(pd, #dummy, no); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetVarNo
VAR_INPUT
  plabel : ^_ASCII;       
END_VAR
VAR_OUTPUT
  retcode : UDINT; 
END_VAR

  retcode := VarList_GetVarNo(plabel); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetTool
VAR_INPUT
  parameter : UDINT;
END_VAR 
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_GetParameter(parameter, 0); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetProt
VAR_INPUT
  parameter : UDINT;
END_VAR 
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_GetParameter(parameter, 1); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetPde
VAR_INPUT
  parameter : UDINT;
END_VAR 
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_GetParameter(parameter, 2); 

END_FUNCTION    

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetZero
VAR_INPUT
  info : UINT;
END_VAR 
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_VOWPRUIC(info, 7); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetRefr
VAR_INPUT
  info : UINT;
END_VAR 
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_VOWPRUIC(info, 3); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetUser
VAR_INPUT
  info : UINT;
END_VAR 
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_VOWPRUIC(info, 2); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetInvert
VAR_INPUT
  info : UINT;
END_VAR 
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_VOWPRUIC(info, 1); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetText
VAR_INPUT
  no : UINT;
END_VAR 
VAR_OUTPUT
  retcode : ^_CHAR; 
END_VAR

  retcode := VarList_GetText(no); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetDigits
VAR_INPUT
  pvi : ^_VARINFO;
END_VAR 
VAR_OUTPUT
  retcode : UINT; 
END_VAR

  retcode := VarList_GetDigits(pvi);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetSign
VAR_INPUT
  pvi : ^_VARINFO;
END_VAR 
VAR_OUTPUT
  retcode : BOOL; 
END_VAR

  retcode := VarList_GetSign(pvi); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetDezPoint
VAR_INPUT
  pvi : ^_VARINFO;
END_VAR 
VAR_OUTPUT
  retcode : DINT; 
END_VAR

  retcode := VarList_GetDezPoint(pvi);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetNo
VAR_OUTPUT
  retcode : UDINT; 
END_VAR
  
  retcode := VarList_GetNo(); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetUnitInfo
VAR_INPUT
  no : UINT;
END_VAR
VAR_OUTPUT
  retcode : ^_UNIT;
END_VAR

  retcode := VarList_GetUnitInfo(no);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::VarLst_GetUnitNo
VAR_INPUT
	punit		: ^_ASCII;
END_VAR
VAR_OUTPUT
	retcode		: UINT;
END_VAR

  retcode := VarList_GetUnitNo(punit);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::TxtLst_GetText
VAR_INPUT
  list   : _ANYLST; 
  txtno  : UDINT;
END_VAR
VAR_OUTPUT
 retcode : ^_CHAR;
END_VAR
  retcode := textpuffer_getText(list, txtno);
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::TxtLst_GetSize
VAR_INPUT
  list   : _ANYLST; 
END_VAR
VAR_OUTPUT
 retcode : DINT;
END_VAR
  retcode := textpuffer_getSize(list);
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::TxtLst_GetPtr
VAR_INPUT
  list   : _ANYLST; 
END_VAR
VAR_OUTPUT
  retcode : ^_CHAR;
END_VAR
  retcode := textpuffer_getPtr(list);
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::TxtLst_GetNo
VAR_INPUT
  list   : _ANYLST; 
END_VAR
VAR_OUTPUT
  retcode : UDINT;
END_VAR
  retcode := textpuffer_getNo(list);
END_FUNCTION

//[#DEUTSCH]
//Diese Funktion liefert den Error-Status eines bereits geöffneten Handle zurück.
//Nach dem Aufruf von Lse_File_Close() kann diese Funktion nicht mehr verwendet
//werden.
//
//Rückgabewert:
//	TRUE     es ist bereits ein Fehler aufgetreten
//	FALSE 	 bis zu diesem Zeitpunkt kein Fehler aufgetreten
//Parameter:
//	handle: 	--> auf das eigentliche Handle
//[#ENGLISH]
//With this function you will get the error state of an already opened handle
//You can't use this function after calling the function  LSE_File_Close()
//
//returned value:
//	TRUE     it already exists an error
//	FALSE 	 	no error up to now
//Parameter:
//	handle: 	--> to handle
FUNCTION VIRTUAL GLOBAL  _Lse::File_GetError
VAR_INPUT
  filep   : ^_LSEFILE;
END_VAR
VAR_OUTPUT
  retcode : BOOL;
END_VAR

  retcode := Lse_File_GetError(filep);
  
END_FUNCTION

//[#ENGLISH]
//With this function you can set a file to an error. It will be necessary
// if you have to read a lot of bytes of the file,, but you haven't enough memory
//
//Parameter:
//	handle: 	--> to handle
//  ferr : 		error state
FUNCTION VIRTUAL GLOBAL  _Lse::File_SetError
VAR_INPUT
  filep : ^_LSEFILE;
  ferr  : _FILE_ERROR;
END_VAR

  Lse_File_SetError(filep, ferr);
  
END_FUNCTION

//[#ENGLISH]
//This function open a file with the defined parameter dpne. If you open a file with
//function you have to close the file with Lse_File_Close().
//
//returned value:
//	TRUE 		if file could be opened
//	FALSE 		error
//Parameter:
//	handle: 	--> to handle
//	state: File for reading (LOAD), writing(SAVE) or reading and writing (LOADSAVE) open
//	dpne: drive, path, name and extension of the file
//example:
//	handle : _FILE;
//	Lse_File_Open(#handle, LOAD, "C:\\TEST.TXT"); // read only
//	Lse_File_Open(#handle, SAVE, "C:\\TEST.TXT"); // write only
FUNCTION VIRTUAL GLOBAL  _Lse::File_Open
VAR_INPUT
  filep : ^_LSEFILE;
  state : _FILE_STATE;
  dpne  :  ^_ASCII;
END_VAR
VAR_OUTPUT
  retcode : BOOL;
END_VAR

  retcode := Lse_File_Open(filep, state, dpne);
  
END_FUNCTION

//[#ENGLISH]
// This function closes an already opened file (with Lse_File_Open() )
// the parameter is a pointer to the handle
//
//returned value:
//	TRUE
//	FALSE 	during  work with this handle an error occurred
//Parameter:
//	handle: 	--> to Handle
//
//example:
//	handle : _FILE;
//	Lse_File_Open(#handle, LOAD, "C:\\TEST.TXT"); // open File
//	Lse_File_Close(#handle); // close File
FUNCTION VIRTUAL GLOBAL  _Lse::File_Close
VAR_INPUT
  filep : ^_LSEFILE;
END_VAR
VAR_OUTPUT
  retcode : BOOL;
END_VAR

  retcode := Lse_File_Close(filep);
  
END_FUNCTION

//[#ENGLISH]
//This function delete a file with the defined parameter dpne.
//The file must be closed.
//
//returned value:
//	TRUE 		if file could be deleted
//	FALSE 		error
//Parameter:
//	handle: 	--> to handle
//	dpne: drive, path, name and extension of the file
//example:
//	handle : _FILE;
//	Lse_File_Remove(#handle, "C:\\TEST.TXT");
FUNCTION VIRTUAL GLOBAL _Lse::File_Remove
VAR_INPUT
	filep		: ^_LSEFILE;
	dpne		: ^_ASCII;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := Lse_File_Remove(filep, dpne);
  
END_FUNCTION

//[#ENGLISH]
//With this function you will get the actual read or write pointer in the opened file
//
//returned value:
//	position of the actual read or write pointer
//Parameter:
//	handle: 	--> to Handle
FUNCTION VIRTUAL GLOBAL  _Lse::File_Tell
VAR_INPUT
  filep  : ^_LSEFILE;
END_VAR
VAR_OUTPUT
  retcode : _DWORD;
END_VAR

  retcode := Lse_File_Tell(filep);
  
END_FUNCTION

//[#ENGLISH]
//With this function you set the read or write pointer in the opened file
//on a defined position
//
//returned value:
//	TRUE	the new position of the pointer is ok
//	FALSE 	during moving of the pointer an error occurred
//Parameter:
//	handle: 	--> to Handle
//  offs :		new position of the filepointer
//  fromwhere :	fromwhere should the new position computed
//				SEEK_SET	from the startposition of the file
//				SEEK_CUR	offs is the new absolut position
//				SEEK_END	position is the last entry of the file
FUNCTION VIRTUAL GLOBAL  _Lse::File_Seek
VAR_INPUT
  filep     : ^_LSEFILE;
  offs      : _DWORD;
  fromwhere : _UWORD;
END_VAR
VAR_OUTPUT
  retcode : BOOL;
END_VAR

  retcode := Lse_File_Seek(filep, offs, fromwhere);
  
END_FUNCTION

//[#ENGLISH]
//With this function you will get the actual size of the file (bytes)
//
//returned value:
//	the actual size of the file in byte
//Parameter:
//	handle: 	--> to Handle
FUNCTION VIRTUAL GLOBAL  _Lse::File_Length
VAR_INPUT
  filep : ^_LSEFILE;
END_VAR
VAR_OUTPUT
 retcode : _DWORD;
END_VAR

  retcode := Lse_File_Length(filep);
  
END_FUNCTION

//[#ENGLISH]
//This function reads a defined size of bytes of an already opened file(handle)
//The bytes are saved to the adress of the paramter dst. An error processing is
//in integrated in the handle.It isn't necessary to check the returned value
//every time.
//It is important, that the file is opened for writing
//
//returned value:
//	TRUE 	success
//	FALSE 	error, you can't use the data on dst
//Parameter:
//	handle: 	--> to Handle
//	dst: 	--> to data area
//  size: size of the reading bytes
//example:
//	handle : _FILE;
//	word : INT;
//	retcode : BOOL;
//
//	Lse_File_Open(#handle, LOAD, "C:\\TEST.TXT"); // open File
//	Lse_File_Read(#handle, #word, sizeof(INT)); // read 2 Byte
//	Lse_File_Read(#handle, #word, sizeof(INT)); // read the next 2 Byte
//	retcode = Lse_File_Close(#handle); // close File including check success
FUNCTION VIRTUAL GLOBAL  _Lse::File_Read
VAR_INPUT
  filep : ^_LSEFILE;
  dest  :  pVoid;
  size  :  _UDWORD;
END_VAR
VAR_OUTPUT
  retcode : BOOL;
END_VAR

  retcode := Lse_File_Read(filep, dest, size);
  
END_FUNCTION

//[#ENGLISH]
//This function writes a defined size of bytes in an already opened file (handle)
//An error processing is in integrated in the handle.
//It isn't necessary to check the returned value every time
//It is important, that the file is opened for writing
//
//returned value:
//	TRUE 	success
//	FALSE 	error, data couldn't write in the file (handle)
//Parameter:
//	handle: 	--> to Handle
//	src: 	--> to data area
//	size: size of data to write
//example:
//	handle _FILE;
//	word INT;
//	retcode BOOL;
//
//	Lse_File_Open(#handle, SAVE, "C:\\TEST.TXT"); // open File
//	Lse_File_Write(#handle, "aa", sizeof(INT)); // write 2 Byte
//	Lse_File_Write(#handle, "bb", sizeof(INT)); // write the next 2 Byte
//	retcode = Lse_File_Close(#handle); // close File including check success
FUNCTION VIRTUAL GLOBAL  _Lse::File_Write
VAR_INPUT
  filep : ^_LSEFILE;
  dest  : pVoid;
  size  : _UDWORD;
END_VAR
VAR_OUTPUT
  retcode : BOOL;
END_VAR

  retcode := Lse_File_Write(filep, dest, size);
  
END_FUNCTION

//[#ENGLISH]
//This function is a further development of the read function
//It is used for reading one line of a TXT-file. This line will be saved in the adress
//of dst. This function searchs for CR and LF and so you have to define a maximum
//size of bytes for reading one line. Without the definition of maxsize you can get
//an system error
//
//returned value:
//	TRUE   success
//	FALSE 	error, you can't use the data on dst
//Parameter:
//	handle: 	--> to Handle
//	dst: 	--> to data area
//maxsize: maximum size of reading bytes
//exampple:
//	handle : _FILE ;
//	line : ARRAY[0..99] of _ASCII;
//	retcode : ;
//
//	Lse_File_Open(&handle, LOAD, "C:\\TEST.TXT"); // open file
//	Lse_File_Read(&handle, line, 100); // read first line
//	retcode = Lse_File_Close(&handle); // close file including check success
FUNCTION VIRTUAL GLOBAL  _Lse::File_Read_CRLF
VAR_INPUT
  filep : ^_LSEFILE;
  dest  : pVoid;
  maxsize : _UWORD;
END_VAR
VAR_OUTPUT
  retcode : BOOL;
END_VAR

  retcode := Lse_File_Read_CRLF(filep, dest$^char, maxsize);
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_GetLinePosition
VAR_INPUT 
  pt1 : ^_SCROLL; 
  y   : UINT; 
  pr  :^_ROOM; 
END_VAR

  GetLinePosition_SCROLL(pt1, y, pr); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_OutLine 
VAR_INPUT 
  pt1   : ^_SCROLL; 
  y     : UINT; 
  no    : UINT; 
  beam  : BOOL; 
END_VAR

  OutLine_SCROLL(pt1, y, no, beam, TRUE); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_Beam
VAR_INPUT 
  pt1   : ^_SCROLL; 
  y     : UINT; 
  no    : UINT; 
  state : BOOL; 
END_VAR 

  Beam_SCROLL(pt1, y, no, state); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_ActBeam 
VAR_INPUT 
  pt1   : ^_SCROLL; 
  state : BOOL; 
END_VAR 

  ActBeam_SCROLL(pt1, state); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_Draw
VAR_INPUT 
  pt1  : ^_SCROLL; 
  beam : BOOL; 
END_VAR 

  Draw_SCROLL(pt1, beam); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_Start
VAR_INPUT 
  pt1 : ^_SCROLL; 
END_VAR  

  Start_SCROLL(pt1, TRUE); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_Ready 
VAR_INPUT 
  pt1  : ^_SCROLL; 
  beam : BOOL; 
END_VAR  

  Ready_SCROLL(pt1, beam); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_Run 
VAR_INPUT 
  pt1    : ^_SCROLL; 
  pevent : ^_EVENT; 
END_VAR
  
  Run_SCROLL(pt1, pevent); 

END_FUNCTION    

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_End 
VAR_INPUT 
  pt1 : ^_SCROLL; 
END_VAR  

  End_SCROLL(pt1); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_OutPage 
VAR_INPUT 
  pt1 : ^_SCROLL; 
END_VAR

  OutPage_SCROLL(pt1); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_ScrollUp 
VAR_INPUT 
  pt1 : ^_SCROLL; 
END_VAR 

  ScrollUp_SCROLL(pt1); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_ScrollDown 
VAR_INPUT 
  pt1 : ^_SCROLL; 
END_VAR 

  ScrollDown_SCROLL(pt1); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_GetPosition
VAR_INPUT 
  pt1 : ^_SCROLL;  
END_VAR 
VAR_OUTPUT 
  retcode : UINT; 
END_VAR  

  retcode := GetPosition_SCROLL(pt1); 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_level_draw 
VAR_INPUT 
  pt1   : ^_LEVEL; 
  horiz : BOOL; 
END_VAR

  level_draw(pt1, horiz, TRUE); 

END_FUNCTION
 
FUNCTION VIRTUAL GLOBAL _Lse::SCROLL_level_run 
VAR_INPUT  
  pt1   : ^_LEVEL; 
  no    : DINT; 
  pos   : DINT; 
  horiz : BOOL; 
END_VAR  

  level_run(pt1, no, pos, horiz); 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_SoftReset

  DownloadState := 2;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_UserStation
	VAR_INPUT
		station 	: UINT;
		pcd 	: ^_COMDEF;
		pobserve 	: ^BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
	  no   : UDINT; 
    ppp  : ^_POINTERPARA; 
  END_VAR 
  
  retcode    := true;
  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    if(ppp^.ptr$^_Global^.IF_UserStation(station, pcd, pobserve) = false) then
      retcode := false;
    end_if;
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_CantWriteNoAccess
	VAR_INPUT
		pres 	: ^_RESULT;
		pvl 	: ^_VARLABEL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
	  no   : UDINT; 
    ppp  : ^_POINTERPARA; 
  END_VAR 
  
  retcode := false;
  no  := UserGlobal.no; 
  ppp := UserGlobal.ptr; 
  while no do
    no  -= 1; 
    if(ppp^.ptr$^_Global^.IF_CantWriteNoAccess(pres, pvl) = true) then
      retcode := true;
    end_if;
    ppp += sizeof(_POINTERPARA); 
  end_while; 

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _Lse::ActivateBubbleHelp::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ActivateBubbleHelp := input;
 	result := ActivateBubbleHelp;

  if(result <> 0) then
    InsertCmd(CMD_KILLEDITOR, 0, 0);
  end_if;
  
END_FUNCTION

FUNCTION __CDECL GLOBAL Thread2_AddCmd
  VAR_INPUT
    pcmd : ^_Thread2CmdLine;
  END_VAR
  VAR_OUTPUT
    retcode : bool;
  END_VAR
  
  retcode := false;
  
  if(pcmd^.cmd <> T2_NONE) then
    if(MailBox2Handle <> NIL) then
      if(OS_MT_PutCond(MailBox2Handle, pcmd) = 1) then
        retcode := true;
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION __CDECL GLOBAL _Lse::Thread2
	VAR_INPUT
		pthis 	: ^void;
	END_VAR
  VAR
  	t2cmdline : _Thread2CmdLine;
  END_VAR

  this := pthis$^_Lse;
  
  while(1) do
    if(OS_MT_GET(MailBox2Handle, #t2cmdline) = MTERROR_NONE) then // wait for cmd in mailbox
      RTK_Thread2(#t2cmdline);
    end_if;
    OS_MT_DELAY(1);
  end_while;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_WindowMoveable
	VAR_INPUT
		whoami 	: ^_WHOAMI;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    pp  : ^_PICPOI; 
	  no  : UDINT; 
    ppp : ^_POINTERPARA;
  END_VAR 

  retcode := true;

  if(GlobalBitState and GLOBAL_BIT_IFWINMOVEABLE) then
    no  := UserGlobal.no; 
    ppp := UserGlobal.ptr; 
    while no do
      if(ppp^.para and GLOBAL_BIT_IFWINMOVEABLE) then
        if(ppp^.ptr$^_Global^.IF_WindowMoveable(whoami) = false) then
          retcode := false;
          return;
        end_if;
      end_if;
	    no  -= 1; 
	    ppp += sizeof(_POINTERPARA); 
    end_while; 
  end_if;
  
  pp := FindScreen(whoami);
  if(pp <> NIL) then
    if(pp^.ptr$^_Screen^.S_WindowMoveable() = false) then
      retcode := false;
    end_if;
  end_if;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL _Lse::IF_Progress
	VAR_INPUT
		pscan 	: ^_SCAN;
		visible 	: BOOL;
	END_VAR
  VAR
	  no  : UDINT; 
    ppp : ^_POINTERPARA;
  END_VAR 

  no  := UserGlobal.no;
  ppp := UserGlobal.ptr;
  while no do
    ppp^.ptr$^_Global^.IF_Progress(pscan, visible);
    no  -= 1;
    ppp += sizeof(_POINTERPARA);
  end_while;

END_FUNCTION

