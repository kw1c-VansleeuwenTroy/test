//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "HmiFontList"
	Revision           = "0.3"
	GUID               = "{889F159B-83A1-4786-99E0-D991EE7E780E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{42C113EE-AD7E-497F-BAB0-1B9249D9A57C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="File" Required="true" Internal="false"/>
		<Client Name="Label" Required="true" Internal="true"/>
		<Client Name="StringLib" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.3" Date="2014-04-15" Author="kolott" Company="sigmatek" Description="ClassSvr will show number of loaded fonts"/>
		<Dokumentation Revision="0.2" Date="2014-03-26" Author="kolott" Company="sigmatek" Description="innovation to shrink memoryrequirement when using same font in different definitions"/>
		<Dokumentation Revision="0.1" Date="2014-02-28" Author="kolott" Company="sigmatek" Description="speed"/>
	</RevDoku>
	<Network Name="HmiFontList">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "Label"
				GUID       = "{19940C1E-BDE0-468A-8F8C-83D3890F5F2E}"
				Class      = "HmiAsciiBuffer"
				Position   = "(240,270)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
					<Client Name="StringLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Label" Destination="Label.ClassSvr"/>
			<Connection Source="Label.File" Destination="this.File" Vertices="(240,360),(38,210),"/>
			<Connection Source="Label.StringLib" Destination="this.StringLib" Vertices="(240,420),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
HmiFontList : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	File 	: CltChCmd_HmiFile;
	StringLib 	: CltChCmd_HmiStrLib;
	Label 	: CltChCmd_HmiAsciiBuffer;
  //Variables:
		No 	: UDINT;
		Ptr 	: ^HMI_FONTINFO;
		IncNo 	: UDINT;
  //Functions:
	
	FUNCTION HmiFontList
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION Free;
	
	FUNCTION HMIFONT_Free
		VAR_INPUT
			tmp 	: ^HMI_FONTINFO;
		END_VAR;
	
	FUNCTION HMIFONT_Init
		VAR_INPUT
			tmp 	: ^HMI_FONTINFO;
			att 	: UDINT;
		END_VAR;
	
	FUNCTION HMIFONT_Load
		VAR_INPUT
			tmp 	: ^HMI_FONTINFO;
			dpne 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL LoadFile
		VAR_INPUT
			dpne 	: ^CHAR;
			project_dp 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Get
		VAR_INPUT
			index 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^HMI_FONTINFO;
		END_VAR;
	
	FUNCTION GLOBAL IncNumber
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetIndex35
		VAR_INPUT
			pfi 	: ^HMI_FONTINFO;
			index35 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL FreeMem;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using HmiAsciiBuffer
#pragma usingLtd HmiFile
#pragma usingLtd HmiStrLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiFontList::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMIFONTLIST
0$UINT, 3$UINT, (SIZEOF(::HmiFontList))$UINT, 
1$UINT, 3$UINT, 0$UINT, 
TO_UDINT(3893392983), "HmiFontList", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiFontList.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::HmiFontList.File.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(3121273764), "File", TO_UDINT(2548286290), "HmiFile", 0$UINT, 4$UINT, 
(::HmiFontList.StringLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(3243119075), "StringLib", TO_UDINT(103556616), "HmiStrLib", 0$UINT, 2$UINT, 
(::HmiFontList.Label.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4193489496), "Label", TO_UDINT(3253426089), "HmiAsciiBuffer", 0$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_HmiFontList 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiFontList] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiFontList::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_HmiFontList, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HmiFontList();

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION HmiFontList::HmiFontList
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;
  No       := 0;
  Ptr      := NIL;
  IncNo    := 0;
  ClassSvr := 0;

END_FUNCTION

FUNCTION HmiFontList::HMIFONT_Init
	VAR_INPUT
		tmp 	: ^HMI_FONTINFO;
    att : udint;
	END_VAR
  
  tmp^.size    := 0;
  tmp^.ptr     := NIL;
  tmp^.attrib  := att;
  tmp^.index35 := HMI_DEFSCOPE;

END_FUNCTION

FUNCTION HmiFontList::HMIFONT_Free
	VAR_INPUT
		tmp 	: ^HMI_FONTINFO;
	END_VAR

  File.Memory(#tmp^.ptr, 0);   
  HMIFONT_Init(tmp, 0);

END_FUNCTION

FUNCTION HmiFontList::HMIFONT_Load
	VAR_INPUT
		tmp 	: ^HMI_FONTINFO;
		dpne 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	size : dint;
  END_VAR
  
  retcode := false;

  if(File.FOpen(dpne, 'r') = true) then 
    size := File.FLength();
    if(size > 0) then
      if(File.FMemory(#tmp^.ptr$^void, to_udint(size)) = true) then
        tmp^.size := to_udint(size);
        File.FRead(tmp^.ptr, tmp^.size);
      end_if;
    end_if;
    retcode := File.FChkFile();
    File.FClose();
  end_if;  

END_FUNCTION

FUNCTION HmiFontList::Free
  var 
    tmp : ^HMI_FONTINFO; 
  end_var

  tmp := Ptr; 
  while(No) do
    No -= 1; 
    HMIFONT_Free(tmp); 
    tmp += sizeof(HMI_FONTINFO); 
  end_while; 
  
  File.Memory(#Ptr, 0);   
  No       := 0;
  Ptr      := NIL; 
  IncNo    := 0;
  ClassSvr := 0;

END_FUNCTION

FUNCTION GLOBAL HmiFontList::LoadFile
	VAR_INPUT
		dpne 	: ^CHAR;
		project_dp 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	anz, idx : udint;
    tpne : array[0..128] of char;
    att : array[0..19] of udint;
    tmp : ^HMI_FONTINFO;
    ano : uint;
  END_VAR

  Free();
  retcode := false; 

  if(File.FOpen(dpne, 'R') = true) then 
    File.FReadHeader();
    if(Label.Load() = true) then
      if(File.FRead(#ano, 2) = true) then
        if(ano > 20) then
          ano := 20;
        end_if;
        retcode := File.FRead(#att[0], ano * 4);
      end_if;
    end_if;
    
    File.FClose();
    
    if(retcode = true) then
      retcode := false;
      anz     := Label.GetNo();
      if(File.Memory(#Ptr$^void, anz * sizeof(HMI_FONTINFO)) = true) then
        retcode := true;
        tmp     := Ptr;
        idx     := 0;
        while(anz) do
          anz -= 1;
          StringLib.StrCpy(#tpne[0], sizeof(char), project_dp, sizeof(char));
          StringLib.StrCat(#tpne[0], sizeof(char), Label.GetText(idx), sizeof(char));
          HMIFONT_Init(tmp, att[idx]);
          HMIFONT_Load(tmp, #tpne[0]);
          idx += 1;
          tmp += sizeof(HMI_FONTINFO);
          No  += 1;
        end_while;
      end_if;
      
      ClassSvr$udint := Label.GetNo();
    end_if;
  end_if; 

END_FUNCTION

FUNCTION GLOBAL HmiFontList::Get
	VAR_INPUT
		index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^HMI_FONTINFO;
	END_VAR

  retcode := NIL;
  if(index < No) then
    retcode := Ptr + (index * sizeof(HMI_FONTINFO));
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFontList::IncNumber
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := IncNo;
  IncNo += 1;

END_FUNCTION

FUNCTION GLOBAL HmiFontList::SetIndex35
	VAR_INPUT
		pfi 	: ^HMI_FONTINFO;
		index35 	: UDINT;
	END_VAR
  VAR
  	nox : udint;
    ph  : ^HMI_FONTINFO;
  END_VAR

  if(pfi <> nil) then

    pfi^.index35 := index35;
    
    // lookup same font
    nox  := No;
    ph   := Ptr;
    while(nox) do
      if(ph <> pfi) then
        if(ph^.index35 = HMI_DEFSCOPE) then
          if(pfi^.size = ph^.size) then
            if(pfi^.ptr = ph^.ptr) then
              ph^.index35 := index35;
            elsif((pfi^.ptr <> nil) & (ph^.ptr <> nil)) then
              if(_memcmp(pfi^.ptr, ph^.ptr, ph^.size) = 0) then
                ph^.index35 := index35;
              end_if;
            end_if;
          end_if;
        end_if;
      end_if;
  
      ph  += sizeof(HMI_FONTINFO);
      nox -= 1;
    end_while;

  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFontList::FreeMem

  Free();

END_FUNCTION
