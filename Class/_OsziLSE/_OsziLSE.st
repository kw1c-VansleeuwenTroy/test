//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_OsziLSE"
	Revision           = "0.6"
	GUID               = "{DB3C7A9A-7D8A-4A4B-B7A7-69159F772C4C}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "simple oszilloscope to watch arbitrary server">
	<Channels>
		<Server Name="ActChannel" GUID="{1FC5383E-60BF-40A4-A05B-582CFBECA943}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Active channel for cursordata (server value)"/>
		<Server Name="DateTime" GUID="{FA3AB569-FDF6-4BB1-935D-4F9BEDB4949B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Date and time of the cursor position. (Pointer to a _DATIM variable)"/>
		<Server Name="InitOk" GUID="{5155DBC9-D939-4426-8C4C-BB05645A0393}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Server0">
		</Server>
		<Server Name="Value" GUID="{B098829D-79B2-4BF8-81B1-F2FE3B09665D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Value of the cursor position"/>
		<Server Name="XZoom" GUID="{A91BFE9D-524B-48D6-9C40-9C25447058BB}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="No functionality"/>
		<Server Name="YZoom" GUID="{69993B24-90ED-4C86-B848-682770ECC88E}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="YZoom in (0,1 %)"/>
		<Client Name="EntryNo" Required="true" Internal="false" Comment="Buffersize of the ringbuffer"/>
		<Client Name="OsziLSEBackground" Required="true" Internal="true"/>
		<Client Name="RecordDateTime" Required="true" Internal="false" Comment="0=don&apos;t recode date and time"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.6" Date="2012-10-11" Author="kolott" Company="sigmatek" Description="changes at ClearData"/>
		<Dokumentation Revision="0.5" Date="2011-12-09" Author="kolott" Company="sigmatek" Description="SA20353: Method ClearData() did not work properly"/>
	</RevDoku>
	<Network Name="_OsziLSE">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{17373B39-4288-11D7-8BC9-0048545E8899}"
				Class      = "_MyIO"
				Position   = "(330,150)"
				Visualized = "true">
				<Channels>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="Graphic"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
			<Object
				Name           = "OsziLSEBackground"
				GUID           = "{DC84BB0A-2FA1-4DF9-909B-19BCFA77024D}"
				Class          = "_OsziLSEBackground"
				Position       = "(330,420)"
				Visualized     = "true"
				BackgroundTime = "10 ms">
				<Channels>
					<Server Name="Server0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(802,210),(630,240),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(330,240),(38,210),"/>
			<Connection Source="this.OsziLSEBackground" Destination="OsziLSEBackground.Server0"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _MyIO

_OsziLSE : CLASS
: _MyIO
  //Servers:
	InitOk 	: SvrCh_DINT;
	XZoom 	: SvrCh_DINT;
	YZoom 	: SvrCh_DINT;
	ActChannel 	: SvrCh_DINT;
	Value 	: SvrCh_DINT;
	DateTime 	: SvrCh_DINT;
  //Clients:
	EntryNo 	: CltCh_UDINT;
	OsziLSEBackground 	: CltChCmd__OsziLSEBackground;
	RecordDateTime 	: CltCh_DINT;
  //Variables:
		FirstTime 	: BOOL;
		FirstDraw 	: BOOL;
		DrawAll 	: BOOL;
		ScrollBarDraw 	: BOOL;
		Focus 	: BOOL;
		LseOszi 	: _LSEOSZI;
		OsziRoom 	: _ROOM;
		hlevel 	: _LEVEL;
		hpos 	: _POSITION;
		Datim 	: _DATIM;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION _OsziLSE
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method will be called once when the focus will be given to this object&#13;&#10;&#13;&#10;pio ....... pointer to _IO information&#13;&#10;&#13;&#10;return _IFAILED if you dont want to get the focus on the other hand _IDLE&#13;&#10;" Name="GetFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="GetFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return _IFAILED if you dont want to get the focus on the other hand _IDLE" Name="GetFocus.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once when the focus is taken from object&#13;&#10;&#13;&#10;pio ....... pointer to _IO information&#13;&#10;&#13;&#10;return always _IDLE because you can&apos;t prevent action&#13;&#10;" Name="KillFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL KillFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="KillFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return always _IDLE because you can&apos;t prevent action" Name="KillFocus.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to redraw the io&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;pr ........ pointer to result information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Ready
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Ready.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Ready.input"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL InitOszi
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="CalcOszi"/>
	FUNCTION CalcOszi
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR;
	
	FUNCTION GLOBAL AddChannel
		VAR_INPUT
			name 	: ^CHAR;
			ymin 	: DINT;
			ymax 	: DINT;
			color 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL ClearData;
	
	FUNCTION VIRTUAL GLOBAL Server0::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL XZoom::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL YZoom::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActChannel::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Value::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _OsziLSEBackground


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _OsziLSE::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__OSZILSE
0$UINT, 6$UINT, (SIZEOF(::_OsziLSE))$UINT, 
6$UINT, 3$UINT, 0$UINT, 
TO_UDINT(2875346491), "_OsziLSE", //Class
TO_UDINT(2980745877), "_MyIO", 0$UINT, 3$UINT, //Baseclass
//Servers:
(::_OsziLSE.InitOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1695565350), "InitOk", 
(::_OsziLSE.XZoom.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1857763531), "XZoom", 
(::_OsziLSE.YZoom.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1406865787), "YZoom", 
(::_OsziLSE.ActChannel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2756798773), "ActChannel", 
(::_OsziLSE.Value.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3928201860), "Value", 
(::_OsziLSE.DateTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1438669446), "DateTime", 
//Clients:
(::_OsziLSE.EntryNo.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4184763179), "EntryNo", 
(::_OsziLSE.OsziLSEBackground.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(712220295), "OsziLSEBackground", TO_UDINT(3872794727), "_OsziLSEBackground", 0$UINT, 0$UINT, 
(::_OsziLSE.RecordDateTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3142344183), "RecordDateTime", 
END_FUNCTION


#define USER_CNT__OsziLSE 18

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__OsziLSE] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _OsziLSE::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _MyIO::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__OsziLSE;
	vmt.CmdTable.Read		:= #Server0::Read();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #KillFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #IF_Ready();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #InitOszi();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	InitOk.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF InitOk.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	XZoom.pMeth			:= StoreMethod( #M_RD_DIRECT(), #XZoom::Write() );
	IF XZoom.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	YZoom.pMeth			:= StoreMethod( #M_RD_DIRECT(), #YZoom::Write() );
	IF YZoom.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActChannel.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ActChannel::Write() );
	IF ActChannel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Value.pMeth			:= StoreMethod( #Value::Read(), #M_NO_F() );
	IF Value.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _OsziLSE();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma using _Lse


//*********************Inserted from .\_OsziLSE\_OsziLSE_00_00.st*********************



 



#pragma warning (disable: 73)

FUNCTION  _OsziLSE::_OsziLSE
VAR_OUTPUT
  ret_code : CONFSTATES;
END_VAR

  InitOk := 0;
  FirstTime := TRUE;
  FirstDraw := TRUE;
  DrawAll := FALSE;
  ScrollBarDraw := FALSE;
  Focus := FALSE;

  init_LSEOSZI(#LseOszi);

  init_LEVEL(#hlevel);
//  init_LEVEL(#vlevel);
  init_POSITION(#hpos);
//  init_POSITION(#vpos);
  init_DATIM(#Datim);

  DateTime := (#Datim)$DINT;

  ret_code := C_OK;
END_FUNCTION //  _OsziLSE::_OsziLSE
FUNCTION VIRTUAL GLOBAL _OsziLSE::Init

  if(FirstTime = TRUE) then
    FirstTime := FALSE;
    Lse.AddOszi(this);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL _OsziLSE::Init
FUNCTION VIRTUAL GLOBAL _OsziLSE::InitOszi
VAR_OUTPUT
  retcode : BOOL;
END_VAR

  retcode := TRUE;

//  AddChannel("NumIn1.Data", 0, 1000, Graphic.MakeColor(RED, RED)); 
//  AddChannel("NumIn0.Data", 0, 20, Graphic.MakeColor(BLUE, BLUE)); 

  InitOk  := 1;
  OsziLseBackground.PutPtr(#LseOszi);

END_FUNCTION //GLOBAL _OsziLSE::InitOszi
FUNCTION GLOBAL _OsziLSE::AddChannel
VAR_INPUT
	name  : ^char;
	ymin  : DINT;
	ymax  : DINT;
	color : _COLOR;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  EntryNo := EntryNo.Read();
  retcode := LseOsziAddChannel(#LseOszi, EntryNo, name$^_ASCII, 255, ymin, ymax, color);

END_FUNCTION //VIRTUAL GLOBAL _OsziLSE::AddChannel
//[#ENGLISH]
//this method is called once right in front of drawing the object.
//for example open screen

FUNCTION _OsziLSE::CalcOszi
VAR_INPUT
  pio     : ^_IO;
END_VAR
VAR
  froffs : _UWORD;
  width  : _UWORD;
  tcol   : _COLOR; 
END_VAR;


  froffs := get_framewidth(pio^.frametype, pio^.attrib);
  width := (pio^.space.xy2.x - pio^.space.xy1.x + 1 - (froffs * 2))$_UWORD;

  if(EntryNo > width) then
    hlevel.active := TRUE;
    hlevel.drag := TRUE;
    tcol := GetPenColor(pio^.colback); 
    hlevel.color := Graphic.MakeColor(tcol, tcol); //InvertColor_Makro(pio^.colback);
    hlevel.frame_color := pio^.colframe; // neu
  end_if;

  hpos.begin := 0;
  hpos.pos := 0;
  hpos.no := EntryNo$_DWORD;
  hpos.height := width;

  if(hlevel.active = TRUE) then
    hlevel.room.xy1.x := pio^.space.xy1.x;
    hlevel.room.xy2.x := pio^.space.xy2.x;
    hlevel.room.xy1.y := pio^.space.xy2.y - LEVELBUTTON_WIDTH;
    hlevel.room.xy2.y := pio^.space.xy2.y;

    OsziRoom.xy1.x := pio^.space.xy1.x;
    OsziRoom.xy2.x := pio^.space.xy2.x;
    OsziRoom.xy1.y := pio^.space.xy1.y;
    OsziRoom.xy2.y := pio^.space.xy2.y - LEVELBUTTON_WIDTH - 1;
  else
    OsziRoom := pio^.space;
  end_if;

  ScrollBarDraw := TRUE;

END_FUNCTION
(*
FUNCTION VIRTUAL GLOBAL _OsziLSE::CyWork
VAR_INPUT
  EAX : UDINT;
END_VAR
VAR_OUTPUT
  state : UDINT;
END_VAR


  if(InitOk = 1) then
    LseOsziCyclic(#LseOszi);
  end_if;

  state := READY$UDINT;

END_FUNCTION //VIRTUAL GLOBAL _OsziLSE::CyWork
*)
FUNCTION __CDECL VIRTUAL GLOBAL _OsziLSE::IF_Start
VAR_INPUT
	pio		: ^_IO;
	firsttime		: BOOL;
END_VAR
VAR
  datetime : BOOL;
END_VAR


  if(firsttime = TRUE) then
    pio^.bRefreshAct := TRUE;
    ScrollBarDraw := TRUE;
  end_if;

  datetime := FALSE;
  if(RecordDateTime > 0) then
    datetime := TRUE;
  end_if;

  // LseOszi.channels.no = 0 - otherwise the oszi is already configered without a
  // userdefined component or IF_START is called one more time (window close)
  if((pio^.theurge <> NIL) & (LseOszi.channels.no = 0)) then
    if(pio^.theurge^.urgetype = _URGE_OSZI) then
      if(LseOsziConfigChannelsNew(#LseOszi, EntryNo, datetime, pio^.theurge) = TRUE) then
        InitOk := 1;
        OsziLseBackground.PutPtr(#LseOszi);
      end_if;
    end_if;
  end_if;

  FirstDraw     := TRUE;
  DrawAll       := TRUE; 
  ScrollBarDraw := TRUE;

END_FUNCTION //__CDECL VIRTUAL GLOBAL _OsziLSE::IF_Start
FUNCTION __CDECL VIRTUAL GLOBAL _OsziLSE::IF_Ready
VAR_INPUT
	pio		: ^_IO;
	input		: BOOL;
END_VAR


END_FUNCTION //__CDECL VIRTUAL GLOBAL _OsziLSE::IF_Ready
//[#ENGLISH]
//this method is called everytime when system wants to redraw the io
//
//pio ....... pointer to io information
//pr ........ pointer to result information
//pv ........ pointer to io variableinformation
//input ..... TRUE it's an input / FALSE it's an output
//
//for the returnstatement there are 3 different possibilities
//_IDLE ..... the system should goon like it is (system goes on)
//_IDIDIT ... i did it (system is ready)
//_IFAILED .. i tried to do my best, but i failed (system is ready)
//
//if you want to draw the io let's return _IDIDIT


FUNCTION __CDECL VIRTUAL GLOBAL _OsziLSE::Draw
VAR_INPUT
 pio  : ^_IO;
 pr  : ^_RESULT;
 pv  : ^_VARIABLE;
 input  : BOOL;
END_VAR
VAR_OUTPUT
 retcode  : _DOIT;
END_VAR
VAR
  act     : _NEWSCREEN;
END_VAR
 

  retcode := _IDLE;
 
  if(InitOk = 1) then
    if(FirstDraw = TRUE) then
      FirstDraw := FALSE;
      CalcOszi(pio);
    end_if;
    push_screen(#act);
    Graphic.Putimage(#pio^.image, DEFKOORD, DEFKOORD);
 
    Value := LseOsziDrawNew(#Datim, #LseOszi, #hpos, pio, #OsziRoom, XZoom$_UWORD, YZoom$_UWORD, ActChannel$_UWORD);
 
   #ifndef UC_ROTATE
    if(ScrollBarDraw = TRUE) then
   #endif
      ScrollBarDraw := FALSE;
      if(hlevel.active = TRUE) then
        DrawAll := TRUE;
        level_draw(#hlevel, TRUE, TRUE);
        level_run(#hlevel, hpos.no, hpos.pos, TRUE);
      end_if;
   #ifndef UC_ROTATE
    end_if;
   #endif
 
    pop_screen(#act);
 
    if(DrawAll = TRUE) then
      DrawAll := FALSE;
      copy_screen(#act, #pio^.space);
    else
      copy_screen(#act, #OsziRoom);
    end_if;
 
    retcode := _IDIDIT;
  end_if;
 
END_FUNCTION //__CDECL VIRTUAL GLOBAL _OsziLSE::Draw


//[#ENGLISH]
//this method will be called once when the focus will be given to this object
//
//pio ....... pointer to _IO information
//
//return _IFAILED if you dont want to get the focus on the other hand _IDLE

FUNCTION __CDECL VIRTUAL GLOBAL _OsziLSE::GetFocus
VAR_INPUT
	pio		: ^_IO;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  Focus := TRUE;

  retcode := _IDLE;

END_FUNCTION //__CDECL VIRTUAL GLOBAL _OsziLSE::GetFocus


//[#ENGLISH]
//this method is called once when the focus is taken from object
//
//pio ....... pointer to _IO information
//
//return always _IDLE because you can't prevent action

FUNCTION __CDECL VIRTUAL GLOBAL _OsziLSE::KillFocus
VAR_INPUT
	pio		: ^_IO;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  Focus := FALSE;

  retcode := _IDLE;

END_FUNCTION //__CDECL VIRTUAL GLOBAL _OsziLSE::KillFocus


//[#ENGLISH]
//this method is called everytime when the input is active and a event occured
//
//ped ....... pointer to _EDITOR information
//pe ........ pointer to _EVENT information
//
//for the returnstatement there are 3 different possibilities
//_IDLE ..... the system should goon like it is (system goes on)
//_IDIDIT ... i did it (system is ready)
//_IFAILED .. i tried to do my best, but i failed (system is ready)
//
//if you want to draw the io let's return _IDIDIT

FUNCTION __CDECL VIRTUAL GLOBAL _OsziLSE::GetEvent
VAR_INPUT
	ped		: ^_EDITOR;
	pe		: ^_EVENT;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR
VAR
  st    : _POSRESULT;
  doit  : BOOL;
END_VAR

  
  retcode := _IDLE;

  if(Focus = TRUE) then
    doit := FALSE;
    if(pe^.ftype = _EVENT_KEYPRESS) then
      doit := FALSE;
      case pe^.scancode of
        _RIGHT: //if(hlevel.active = TRUE) then
                  if(hpos.pos < (hpos.no - 1)) then
                    doit := TRUE;
                  end_if;
                //end_if;
        _LEFT : //if(hlevel.active = TRUE) then
                  if(hpos.pos > 0) then
                    doit := TRUE;
                  end_if;
                //end_if;
        _PGLEFT,
        _PGRIGHT : doit := TRUE;
      end_case;

    else
      doit := TRUE;
    end_if;

    if(doit = TRUE) then
     #ifdef HID
      do_HID_SCROLL(pe, NIL, NIL, #hlevel, #hpos, #OsziRoom, 1, 1);
     #endif
      st := calculate_h_position(#hpos, pe, hpos.height);
      if((st <> P_NOP)) then
        ScrollBarDraw := TRUE;
        retcode := _IDIDIT;
      end_if;

      case pe^.ftype of
        _EVENT_KEYPRESS:  init_EVENT(pe);
        _EVENT_HIDPRESS,
        _EVENT_HIDMOVE,
  		  _EVENT_HIDRELEASE : if((pe^.dot.x >= ped^.input.io.space.xy1.x)&(pe^.dot.x <= ped^.input.io.space.xy2.x)&
                               (pe^.dot.y >= ped^.input.io.space.xy1.y)&(pe^.dot.y <= ped^.input.io.space.xy2.y)) then
                              init_EVENT(pe);
                            end_if;
      end_case;
    end_if;
  end_if;

END_FUNCTION //__CDECL VIRTUAL GLOBAL _OsziLSE::GetEvent


FUNCTION VIRTUAL GLOBAL _OsziLSE::Server0::Read
VAR_OUTPUT
	output		: DINT;
END_VAR


	output :=
  Server0 := LseOszi.change$DINT;

END_FUNCTION //VIRTUAL GLOBAL _OsziLSE::Server0::Read


FUNCTION VIRTUAL GLOBAL _OsziLSE::XZoom::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

	XZoom := input;
  result := input;
END_FUNCTION //VIRTUAL GLOBAL _OsziLSE::XZoom::Write


FUNCTION VIRTUAL GLOBAL _OsziLSE::YZoom::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

	YZoom := input;
  result := input;
END_FUNCTION //VIRTUAL GLOBAL _OsziLSE::YZoom::Write


FUNCTION VIRTUAL GLOBAL _OsziLSE::ActChannel::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

	ActChannel := input;
  result := input;

END_FUNCTION //VIRTUAL GLOBAL _OsziLSE::ActChannel::Write


FUNCTION VIRTUAL GLOBAL _OsziLSE::Value::Read
VAR_OUTPUT
	output		: DINT;
END_VAR

	output := 0;

  if(Focus = TRUE) then
	  output := Value;
  end_if; 

END_FUNCTION //VIRTUAL GLOBAL _OsziLSE::Value::Read


FUNCTION GLOBAL _OsziLSE::ClearData
VAR
  i : UINT;
  pch : ^_LSEOSZI_CHANNEL;
END_VAR

  i := 0;
  pch := LseOszi.channels.ptr;
  while(i < LseOszi.channels.no) do
    pch^.ringbuffer.begin := 0;
    pch^.ringbuffer.pos := 0;
    pch^.ringbuffer.used := FALSE;
    pch += sizeof(_LSEOSZI_CHANNEL);
    i += 1;
  end_while;
 
  LseOszi.channels.ringbuffer.begin := 0;
  LseOszi.channels.ringbuffer.pos := 0;
  LseOszi.channels.ringbuffer.used := FALSE;
 
END_FUNCTION //GLOBAL _OsziLSE::ClearData