//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "HmiStrLib"
	Revision           = "0.2"
	GUID               = "{FA24E53F-4586-4583-B88E-21211059765B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{F7872E22-2F0F-4974-839C-8FE7E32B1D25}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="StdLib" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.2" Date="2014-04-07" Author="kolott" Company="sigmatek" Description="new method StrXchg() added"/>
		<Dokumentation Revision="0.1" Date="2013-12-20" Author="kolott" Company="sigmatek" Description="release"/>
	</RevDoku>
</Class>
*)
HmiStrLib : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	StdLib 	: CltChCmd__StdLib;
  //Variables:
  //Functions:
	
	FUNCTION AWL GLOBAL StrLen
		VAR_INPUT
			ptr 	: ^void;
			chrsize 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION AWL GLOBAL StrCpy
		VAR_INPUT
			dptr 	: ^void;
			dchrsize 	: UINT;
			sptr 	: ^void;
			schrsize 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL StrCat
		VAR_INPUT
			dptr 	: ^void;
			dchrsize 	: UINT;
			sptr 	: ^void;
			schrsize 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL XMemory
		VAR_INPUT
			pptr 	: ^pVoid;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL DelComment
		VAR_INPUT
			txt 	: ^void;
			chrsize 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL DelSpace
		VAR_INPUT
			txt 	: ^void;
			chrsize 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL StrToDint
		VAR_INPUT
			txt 	: ^void;
			chrsize 	: UINT;
			pnk 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL DintToStr
		VAR_INPUT
			ptr 	: ^void;
			value 	: DINT;
			format 	: UINT;
			chrsize 	: UINT;
		END_VAR;
	
	FUNCTION DintToStrASCII
		VAR_INPUT
			ptr 	: ^USINT;
			value 	: DINT;
			format 	: UINT;
		END_VAR;
	
	FUNCTION DoFormat
		VAR_INPUT
			value 	: DINT;
			format 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL MakeGuidePost
		VAR_INPUT
			ppgp 	: ^pVoid;
			ptxt 	: ^void;
			txtno 	: UDINT;
			chrsize 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL StrCmp
		VAR_INPUT
			ptr1 	: ^void;
			chrsize1 	: UINT;
			ptr2 	: ^void;
			chrsize2 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: INT;
		END_VAR;
	
	FUNCTION AWL StrXmp
		VAR_INPUT
			pTxt0 	: ^void;
			pTxt1 	: ^void;
			cSize 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: INT;
		END_VAR;
	
	FUNCTION GLOBAL UniToAscii
		VAR_INPUT
			pa 	: ^USINT;
			pu 	: ^UINT;
			no 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL AsciiToUni
		VAR_INPUT
			pu 	: ^UINT;
			pa 	: ^USINT;
			no 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL HexToStr
		VAR_INPUT
			ptr 	: ^void;
			value 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL StrXchg
		VAR_INPUT
			ptr 	: ^CHAR;
			old 	: CHAR;
			new 	: CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiStrLib::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMISTRLIB
0$UINT, 2$UINT, (SIZEOF(::HmiStrLib))$UINT, 
1$UINT, 1$UINT, 0$UINT, 
TO_UDINT(103556616), "HmiStrLib", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiStrLib.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::HmiStrLib.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_HmiStrLib 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiStrLib] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiStrLib::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION AWL GLOBAL HmiStrLib::StrLen // ok, v1
	VAR_INPUT
		ptr 	: ^void;
		chrsize 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

#ifdef _LSL_TARGETARCH_ARM
    MOV       retcode, #0
    CMP       ptr, #0
    BEQ       StrLenEnd
    CMP       chrsize, #1
    BNE       StrLenUni
    
    ADD       r10, ptr, #1
StrLenAscii
    LDRB      r3, [ptr], #1
    CMP       r3, #0
    BNE       StrLenAscii
    SUB       retcode, ptr, r10
    B         StrLenEnd

StrLenUni
    ADD       r10, ptr, #2
StrLenUniBbB
    LDRB      r3, [ptr], #2
    CMP       r3, #0
    BNE       StrLenUniBbB
    LDRB      r3, [ptr, #-1]
    CMP       r3, #0
    BNE       StrLenUniBbB
    SUB       retcode, ptr, r10
    MOV       retcode, retcode, LSR #1

StrLenEnd  
#else //elif _LSL_TARGETARCH_X86
    CLR       ECX
    CMP.D     ptr,0   
    JE        StrLenEnd
    TEST.W   	chrsize, 1
    JZ      	StrLenUni
  
    CLD
    L.EDI    	ptr
    L.ECX    	-1
    CLR      	AL
    REP
    SCASB
    NEG      	ECX
    SUB.ECX  	2
    JMP       StrLenEnd
    
StrLenUni  
    CLD
    L.EDI    	ptr
    L.ECX    	-1
    CLR      	AX
    REP
    SCASW
    NEG      	ECX
    SUB.ECX  	2
    JMP       StrLenEnd

StrLenEnd 
    S.CX      retcode
    LZXW.EAX  CX
#endif

END_FUNCTION


FUNCTION AWL GLOBAL HmiStrLib::StrCpy  // ok, v1
	VAR_INPUT
		dptr 	: ^void;
		dchrsize 	: UINT;
		sptr 	: ^void;
		schrsize 	: UINT;
	END_VAR

#ifdef _LSL_TARGETARCH_ARM
    CMP       dptr, #0
    BEQ       StrCpyEnd       // dst = NIL: nothing to do
    
    CMP       sptr, #0
    BNE       StrCpyStart
    MOV       r10, #0
    STRB      r10, [dptr, #0]
    STRB      r10, [dptr, #1]   // src = NIL: create ASCII/UNI-0-String
    B         StrCpyEnd
    
StrCpyStart    
    CMP       dchrsize, schrsize
    BEQ       StrCpySameSize

    CMP       dchrsize, #1
    BEQ       StrCpySize12

              // UNI <- ASCII
    MOV       r11, #0
StrCpySize21
    LDRB      r10, [sptr], #1
    STRB      r10, [dptr], #1
    STRB      r11, [dptr], #1
    CMP       r10, #0
    BNE       StrCpySize21
    B         StrCpyEnd

StrCpySize12  // ASCII <- UNI
    LDRB      r10, [sptr], #1
    LDRB      r11, [sptr], #1
    ORR       r10, r10, r11, LSL #8
    CMP       r10, #255
    MOVHI     r10, #'?'
    STRB      r10, [dptr], #1
    CMP       r10, #0
    BNE       StrCpySize12
    B         StrCpyEnd
    
StrCpySameSize
    CMP       dchrsize, #1
    BEQ       StrCpySize11
    
              // UNI <- UNI
    ORR       r11, dptr, sptr
    TST       r11, #1
    BNE       StrCpySize22Byte   // one or both pointer is misaligned

StrCpySize22Half
    LDRH      r10, [sptr], #2    
    STRH      r10, [dptr], #2
    CMP       r10, #0
    BNE       StrCpySize22Half
    B         StrCpyEnd

StrCpySize22Byte
    LDRB      r10, [sptr], #1    
    LDRB      r11, [sptr], #1
    STRB      r10, [dptr], #1
    STRB      r11, [dptr], #1
    CMP       r10, #0
    BNE       StrCpySize22Byte
    CMP       r11, #0
    BNE       StrCpySize22Byte
    B         StrCpyEnd
    
StrCpySize11  // ASCII <- ASCII
    LDRB      r10, [sptr], #1
    STRB      r10, [dptr], #1
    CMP       r10, #0
    BNE       StrCpySize11

StrCpyEnd
#else //elif _LSL_TARGETARCH_X86
    PUSHF
    PUSH      EDI
    PUSH      ESI

    L.EDI     dptr
    O.EDI     EDI               // load dest
    JZ        StrCpyEnd         // dst = NIL: nothing to do
    
    L.ESI     sptr                // load src
    O.ESI     ESI
    JNZ       StrCpyStart
    L.AX      0
    S.AX      (EDI)             // src = NIL: craete ASCII/UNI-0-string
    JMP       StrCpyEnd
    
StrCpyStart
    L.AX      dchrsize
    CMP.AX    schrsize
    JE        StrCpySameSize

    CMP.AX    1
    JE        StrCpySize12

StrCpySize21  // UNI <- ASCII
    LZXB.AX   (ESI)
    S.AX      (EDI)
    INC       ESI
    ADD.EDI   2
    O.AX      AX
    JNE       StrCpySize21
    JMP       StrCpyEnd
    
StrCpySize12  // ASCII <- UNI
    L.AX      (ESI)
    CMP.AX    255
    JLE       StrCpySize12Tmp
    L.AX      '?'    
StrCpySize12Tmp
    S.AL      (EDI)
    ADD.ESI   2
    INC       EDI   
    O.AX      AX
    JNE       StrCpySize12
    JMP       StrCpyEnd
  
StrCpySameSize
    CLD
    CMP.AX    1
    JE        StrCpySize11

              // UNI <- UNI
    L.EDI     ESI
    L.ECX     -1
    CLR       AX
    REP
    SCASW
    NEG       ECX
    SUB.ECX   1
    L.EDI     dptr
    REP
    MOVSW
    JMP       StrCpyEnd
    
StrCpySize11  // ASCII <- ASCII
    L.EDI     ESI
    L.ECX     -1
    CLR       AL
    REP
    SCASB
    NEG       ECX
    SUB.ECX   1
    L.EDI     dptr
    REP
    MOVSB

StrCpyEnd    
    
    POP       ESI
    POP       EDI
    POPF
#endif

END_FUNCTION

FUNCTION GLOBAL HmiStrLib::StrCat
	VAR_INPUT
		dptr 	: ^void;
		dchrsize 	: UINT;
		sptr 	: ^void;
		schrsize 	: UINT;
	END_VAR
  var
    ls  : uint; 
  end_var

  ls := StrLen(dptr, dchrsize);
  StrCpy(dptr+(ls*dchrsize), dchrsize, sptr, schrsize);

END_FUNCTION

FUNCTION GLOBAL HmiStrLib::XMemory
	VAR_INPUT
		pptr 	: ^pVoid;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    dst : ^void; 
  end_var

  dst := pptr^;
  
  if(size > 0) then
    retcode := false; 
    if(dst = NIL) then
      dst := StdLib.MallocV1(size, 0); 
    else
      dst := StdLib.ReAllocV1(dst, size, 0);
    end_if; 
    if(dst <> NIL) then
      retcode := true;
      pptr^:= dst; 
    end_if; 
  else
    retcode := true; 
    if(dst <> NIL) then
      StdLib.Free(dst); 
      pptr^ := NIL; 
    end_if; 
  end_if;
    
END_FUNCTION

FUNCTION GLOBAL HmiStrLib::DelComment
	VAR_INPUT
		txt 	: ^void;
		chrsize 	: UINT;
	END_VAR
  var
    pui : ^uint; 
    pud : ^udint; 
    val : udint; 
    len : uint; 
  end_var
  
  len := StrLen(txt, chrsize);

  if(chrsize = 1) then
    pui := txt$^uint; 
    while(len) do 
      len -= 1; 
      val := pui^; 
      if(val = 0x2F2F) then //
        pui^ := 0; 
        len  := 0; 
      end_if; 
    end_while; 
  else
    pud := txt$^udint; 
    while(len) do 
      len -= 1; 
      val := pud^; 
      if(val = 0x002F002F) then
        pud^ := 0; 
        len  := 0; 
      end_if; 
    end_while; 
  end_if; 

END_FUNCTION

FUNCTION GLOBAL HmiStrLib::DelSpace
	VAR_INPUT
		txt 	: ^void;
		chrsize 	: UINT;
	END_VAR
  var
    tmp : array[0..200] of usint; 
    pa : ^usint; 
    pda : ^usint; 
    pu : ^uint; 
    pdu : ^uint; 
    size : uint; 
    len : uint; 
  end_var; 

  len := StrLen(txt, chrsize); 

  if(chrsize = 1) then
    size := 1; 
    if(len < 200) then
      pa   := txt$^USINT; 
      pda  := #tmp[0]$USINT; 
      while(len) do
        len -= 1; 
        if(pa^ <> 32) then
          pda^ := pa^; 
          pda  += 1; 
          size += 1; 
        end_if; 
        pa += 1; 
      end_while;
    end_if; 
    pda^ := 0; 
  else
    size := 2; 
    if(len < 100) then
      pu   := txt$^UINT; 
      pdu  := #tmp[0]$UINT; 
      while(len) do
        len -= 1; 
        if(pu^ <> 32) then
          pdu^ := pu^; 
          pdu  += 2; 
          size += 2; 
        end_if; 
        pu += 2; 
      end_while; 
    end_if; 
    pdu^ := 0; 
  end_if; 

  _memcpy(txt, #tmp[0], size); 

END_FUNCTION

FUNCTION GLOBAL HmiStrLib::StrToDint
	VAR_INPUT
		txt 	: ^void;
		chrsize 	: UINT;
		pnk 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  var
    stop : bool; 
    neg : bool; 
    pa : ^usint;
    pu : ^uint;
    chr : uint; 
    i : uint;
    vk : uint;
  end_var

  retcode := 0; 
  neg     := false; 
  stop    := false; 
  
  vk := 0xFFFF;
  i  := 0;
  if(chrsize = 1) then
    pa := txt$^usint; 
    repeat
      chr := pa^; 
      if((chr >= '0')&(chr <= '9')) then
        retcode := (retcode * 10) + (chr - '0');
        i += 1;
      elsif((chr = '-')&(retcode = 0)) then
        neg := true; 
      elsif((chr = '.')|(chr = ',')) then
        if(pnk = NIL) then
          stop := true;
        end_if;
        vk := i;
      else
        stop := true; 
      end_if; 
      pa += 1; 
    until(stop = true) end_repeat; 
  else
    pu := txt$^uint; 
    repeat
      chr := pu^; 
      if((chr >= '0') & (chr <= '9')) then
        retcode := (retcode * 10) + (chr - '0'); 
        i += 1;
      elsif((chr = '-') & (retcode = 0)) then
        neg := true; 
      elsif((chr = '.')|(chr = ',')) then
        vk := i;
      else
        stop := true; 
      end_if; 
      pu += 2; 
    until(stop = true) end_repeat; 
  end_if; 

  if(neg = true) then
    retcode := -retcode; 
  end_if; 

  if(pnk <> NIL) then
    if(vk = 0xFFFF) then
      pnk^ := 0;
    else
      pnk^ := i - vk;
    end_if;
  end_if;

END_FUNCTION

FUNCTION HmiStrLib::DintToStrASCII
	VAR_INPUT
		ptr 	: ^USINT;
		value 	: DINT;
		format 	: UINT;
	END_VAR
  var 
    dig, pd, i, vn : uint;
    hp : ^usint;
    neg : bool;
    empty : usint;
   #ifdef NO_PRECEDINGSPACE
    v : dint;
   #endif 
  end_var

  vn  := format and 16#100; 
  neg := false;
  dig := (format and 0x000F);
  pd  := to_uint((format shr 4) and 0x000F);

 #ifdef NO_PRECEDINGSPACE
  if((format and 0x0300) = 0) then // keine vornullen und keine vorspace
    v := value;
    i := 0;
    repeat
      v := v/10;
      i += 1;
    until(v=0) end_repeat;
    if(dig >= i) then
      dig := i;
    end_if;
    if(dig <= pd) then
      dig := pd + 1;
    end_if;
  end_if;
 #endif

  hp  := ptr + dig;

  if(pd > 0) then
    hp += 1;
  end_if;
  
  if(value < 0) then
    hp    += 1;
    value := -value;
    neg   := true;
  end_if;
  
  hp^ := 0; // abschluss ascii-0-string
  hp  -= 1;
  i   := 0;
  
  empty := ' ';
  if(format and 0x0100) then
    empty := '0';
  end_if;
  
  while(hp >= ptr) do
    i += 1;
    if((value > 0)|(i <= pd)|(i = 1)) then
      hp^   := '0' + to_usint(value mod 10);
      value := value / 10;
    else
      if(neg = true) then
        if(vn = 0) then
          hp^ := '-';
          neg := false;
        else
          hp^ := empty;
          if(hp = ptr) then
            hp^ := '-';
            neg := false;
          end_if;
        end_if;
      else
        hp^ := empty;
      end_if;
    end_if;
    
    hp -= 1;
    
    if(i = pd) then
      hp^   := '.';
      hp    -= 1;
      hp^   := '0' + to_usint(value mod 10); // 1 stelle vor dem komma eintragen
      value := value / 10;
      hp    -= 1;
    end_if;
  end_while;

  if(value <> 0) then // wert zu gross
    hp := ptr;
    while(hp^ <> 0) do
			if(hp^ <> '.') then
        hp^ := '>';
      end_if; 
      hp += 1;
    end_while; 
  end_if; 
  
END_FUNCTION

FUNCTION HmiStrLib::DoFormat
	VAR_INPUT
		value 	: DINT;
		format 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  var
    tmp : dint; 
    nk : uint; 
    digs : uint; 
  end_var

  if((format and 0x000F) = 0) then
    format := format or 0x0800;
  end_if; 

  if(format and 0x0800) then
    tmp  := value;
    digs := 0;
    
    if(tmp = 0) then
      digs := 1; 
    else
      while(tmp) do
        tmp := tmp / 10;
        digs += 1;
      end_while; 
    end_if; 

    nk := ((format shr 4) and 0x0F);
    if(nk >= digs) then
      digs := nk + 1;
    end_if; 

    format := (format and 0x00F0) or (digs and 0x000F);
  end_if; 

  retcode := format;

END_FUNCTION

FUNCTION GLOBAL HmiStrLib::DintToStr
	VAR_INPUT
		ptr 	: ^void;
		value 	: DINT;
		format 	: UINT;
		chrsize 	: UINT;
	END_VAR
  var
    tmparray : array[0..20] of usint; 
  end_var

  // xxxx 0xx0 0000 0000 format
	//      .... .... **** anzahl der stellen
  //      .... **** .... position dezimalpunkt
  //      ...* .... .... vornullen
  //      ..*. .... .... vorspace
  //      *... .... .... anzahl der stellen automatisch ermitteln

  format := DoFormat(value, format);

  if(chrsize = 1) then
    DintToStrASCII(ptr$^usint, value, format); 
  else
    DintToStrASCII(#tmparray[0], value, format); 
    StrCpy(ptr, 2, #tmparray[0], 1); 
  end_if; 

END_FUNCTION

FUNCTION GLOBAL HmiStrLib::HexToStr
	VAR_INPUT
		ptr 	: ^void;
		value 	: UDINT;
	END_VAR
  var
    ph : ^usint;
    dig, nib : udint;
  end_var

  if(value and 16#FFFF0000) then
    dig := 8;
  elsif(value and 16#FF00) then
    dig := 4;
  else
    dig := 2;
  end_if;

  ph := ptr + dig;
  ph^:= 0;
  
  while(dig) do
    dig   -= 1;
    ph    -= 1;
    nib   := value mod 16;
    value := value / 16;
    
    if(nib < 10) then
      ph^ := '0' + nib$usint;
    else
      ph^ := ('A' - 10) + nib$usint;
    end_if;
  end_while;

END_FUNCTION


FUNCTION GLOBAL HmiStrLib::MakeGuidePost
	VAR_INPUT
		ppgp 	: ^pVoid;
		ptxt 	: ^void;
		txtno 	: UDINT;
		chrsize 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    offset : udint;
    ph : ^udint;
  end_var;

  retcode := false;

  if(XMemory(ppgp, txtno*4) = true) then
    retcode := true;
    ph      := (ppgp^)$^udint;
    offset  := 0;
    if(chrsize = 1) then
      while(txtno) do
        txtno  -= 1;
        ph^    := offset;
        ph     += 4;
        offset += (StrLen(ptxt+offset, 1) + 1);
      end_while; 
    else
      while(txtno) do
        txtno  -= 1;
        ph^    := offset;
        ph     += 4;
        offset += ((StrLen(ptxt+offset, 2) + 1) * 2);
      end_while; 
    end_if;
  end_if;

END_FUNCTION

FUNCTION AWL HmiStrLib::StrXmp
	VAR_INPUT
		pTxt0 	: ^void;
		pTxt1 	: ^void;
		cSize 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: INT;
	END_VAR

#ifdef _LSL_TARGETARCH_ARM
    MOV       retcode, #0
    
    CMP       pTxt0, pTxt1
    BEQ       StrXmpEnd

    CMP       pTxt0, #0
    BEQ       StrXmpNotEqual
    CMP       pTxt1, #0
    BEQ       StrXmpNotEqual
    
    CMP       cSize, #1
    BNE       StrXmpUni

StrXmpAscii
    LDRB      r10, [pTxt0], #1
    LDRB      r11, [pTxt1], #1
    CMP       r10, r11
    BNE       StrXmpNotEqual
    CMP       r10, #0
    BEQ       StrXmpEnd
    B         StrXmpAscii
    
StrXmpUni
    ORR       r11, pTxt0, pTxt1
    TST       r11, #1
    BNE       StrXmpUniBbB   // one or both pointer are missaligned

StrXmpUniH
    LDRH      r10, [pTxt0], #2
    LDRH      r11, [pTxt1], #2
    CMP       r10, r11
    BNE       StrXmpNotEqual
    CMP       r10, #0
    BNE       StrXmpUniH
    B         StrXmpEnd

StrXmpUniBbB
    LDRB      r10, [pTxt0], #1
    LDRB      r3,  [pTxt0], #1
    ORR       r10, r10, r3, LSL #8
    LDRB      r11, [pTxt1], #1
    LDRB      r3,  [pTxt1], #1
    ORR       r11, r11, r3, LSL #8
    CMP       r10, r11
    BNE       StrXmpNotEqual
    CMP       r10, #0
    BNE       StrXmpUniBbB
    B         StrXmpEnd

StrXmpNotEqual
    MOV       retcode, #1
    
StrXmpEnd
#else //elif _LSL_TARGETARCH_X86
  pushfd
  push      edi
  push      esi
  
  l.esi     pTxt0
  l.edi     pTxt1
  clr       ecx
  
  x.esi     edi
  jz        StringXmpEqual
  
  l.esi     pTxt0
  o.esi     esi
  jz        StringXmpRet
  o.edi     edi
  jz        StringXmpRet
  
  cld
  cmp.w     cSize,1
  jne       StringXmpLoopUni
  
StringXmpLoop
  l.cl      (edi)
  or.cl     (esi)
  jecxz     StringXmpEqual
  cmpsb
  jz        StringXmpLoop
  jmp       StringXmpRet

StringXmpLoopUni
  l.cx      (edi)
  or.cx     (esi)
  jecxz     StringXmpEqual
  cmpsw
  jz        StringXmpLoopUni
  //jmp       StringXmpRet

StringXmpRet
  l.ecx     1

StringXmpEqual
  s.cx      retcode
  
  pop       esi
  pop       edi
  
  popfd
#endif

END_FUNCTION

FUNCTION GLOBAL HmiStrLib::StrCmp
	VAR_INPUT
		ptr1 	: ^void;
		chrsize1 	: UINT;
		ptr2 	: ^void;
		chrsize2 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: INT;
	END_VAR
  VAR
    l1  : uint;  
    l2  : uint;  
    pa  : ^usint; 
    pu  : ^uint; 
  END_VAR

  if(chrsize1 = chrsize2) then
    retcode := StrXmp(ptr1, ptr2, chrsize1);
    return;
  end_if;

  retcode := 1; 

  l1 := StrLen(ptr1, chrsize1);
  l2 := StrLen(ptr2, chrsize2);

	if(l1 = l2) then
    retcode := 0;
    if(l1 > 0) then
      if(chrsize1 = chrsize2) then
        retcode := to_int(_memcmp(ptr1, ptr2, to_udint(l1) * chrsize1));
      else
        if(chrsize1 = 1) then
          pa := ptr1$^usint;
          pu := ptr2$^uint;
        else
          pa := ptr2$^usint;
          pu := ptr1$^uint;
        end_if;

        while(l1) do
          if(pa^ <> pu^) then
            retcode := 1;
            return;
          end_if;
        
          pa += 1;
          pu += 2;
          l1 -= 1;
          
        end_while;

     end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiStrLib::AsciiToUni
	VAR_INPUT
		pu 	: ^UINT;
		pa 	: ^USINT;
		no 	: UDINT;
	END_VAR

  while(no) do
    pu^ := pa^; 
    pu += 2; 
    pa += 1; 
    no -= 1; 
  end_while; 

END_FUNCTION


FUNCTION GLOBAL HmiStrLib::UniToAscii
	VAR_INPUT
		pa 	: ^USINT;
		pu 	: ^UINT;
		no 	: UDINT;
	END_VAR

  while(no) do
    pa^ := pu$^usint^; 
    pu += 2; 
    pa += 1; 
    no -= 1; 
  end_while; 

END_FUNCTION

FUNCTION GLOBAL HmiStrLib::StrXchg
	VAR_INPUT
		ptr 	: ^CHAR;
		old 	: CHAR;
		new 	: CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: uint;
	END_VAR
  VAR
  	len : uint;
  END_VAR

  retcode := 0;

  if(ptr <> nil) then
    len     := StrLen(ptr, 1);
    retcode := len;
    while(len) do
      if(ptr^ = old) then
        ptr^ := new;
      end_if;
      ptr += 1;
      len -= 1;
    end_while;
  end_if;

END_FUNCTION
