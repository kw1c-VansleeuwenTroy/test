//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES


// Eigenschaften des UDCs
//----------------------------------------------------------------------------------------------------------------------------
#define   AccessControlList_UDCVersion                2           // Version des aktuellen UDCs (sprdie v1.4 changed from 1 -> 2)

#define   AccessControlList_VariableNo                8           // Anzahl der Variablen, die dem UDC mitgegeben werden (sprdie v1.4 changed from 6 -> 8)
#define   AccessControlList_ImageAndTextNo            2           // Anzahl der Images und TextSchemes, die dem UDC mitgegeben werden

#define   AccessControlList_VarUserNameRoom           0           // Index 0
#define   AccessControlList_VarPasswordRoom           1           // Index 1
#define   AccessControlList_VarLevelRoom              2           // Index 2
#define   AccessControlList_VarTimeoutRoom            3           // Index 3
#define   AccessControlList_VarUSBSerNumRoom          4           // Index 4
#define   AccessControlList_VarInfoRoom               5           // Index 5
#define   AccessControlList_LoginInfoRoom             6           // Index 6 (sprdie v1.4)
#define   AccessControlList_LogoutInfoRoom            7           // Index 7 (sprdie v1.4)

// Einstellungen zum Bestimmen der Texte aus LSE
//----------------------------------------------------------------------------------------------------------------------------
#define   AccessControlList_USBLinkedNo               0           // Text wenn der USB Stick nicht gelinkt ist
#define   AccessControlList_USBLinkedYes              1           // Text wenn der USB Stick gelinkt ist
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_AccContList"
	Revision           = "2.19"
	GUID               = "{9505AB2E-C41F-471A-BBFA-C0AE45895270}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,360)"
	Comment            = "This class is listing the users (ScrollList)&#13;&#10;Mode=0: administration all users (show all data) &#13;&#10;Mode=1: login data (show only user names)&#13;&#10;">
	<Channels>
		<Server Name="SelectFunction" GUID="{910F880F-BD1A-4637-A408-648C07AF54D2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Selects a function of the Class:&#13;&#10;1:  DeleteSelectedUser()&#13;&#10;2:  ModifySelectedUser()&#13;&#10;3:  ShowUserDataSelectedUser()&#13;&#10;4:  AddUsbSNSelectedUser()&#13;&#10;5:  DelUsbSNSelectedUser()"/>
		<Server Name="UpdateList" GUID="{1C407C1D-CEDF-4BDE-9B42-7C1A2EAC5F82}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="write() refreshes the list"/>
		<Server Name="UserUsbLinked" GUID="{D72DA4FB-7106-4B55-9E4B-CA45E0A42D4C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows if the user of the actual line is USB linked or not"/>
		<Server Name="Visible" GUID="{979D2115-0ADE-4FAE-8B55-2B64F035CF39}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Server (Marker) to set the list invisible or visible in LSE"/>
		<Client Name="ccSystemLogging" Required="false" Internal="false" Comment="command channel to SystemLogging (optional)."/>
		<Client Name="coAccessControl" Required="true" Internal="false" Comment="object channel - Connect to AccessControlMain object"/>
		<Client Name="ColumnChoice" Required="false" Internal="false"/>
		<Client Name="coTitleLine" Required="false" Internal="false"/>
		<Client Name="Dummy" Required="true" Internal="true"/>
		<Client Name="Mode" Required="true" Internal="false" Comment="0...Use list for Usermanagement&#13;&#10;1...Use list to select Username for Login"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_AccContList\_AccContList_de.pdf"/>
			<File Path=".\Class\_AccContList\_AccContList_en.pdf"/>
			<File Path=".\Class\_AccContList\AccessControl.UDC"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="2.19" Date="2019-09-04" Author="dacpat" Company="Sigmatek" Description="- Updated structs to new version."/>
		<Dokumentation Revision="2.18" Date="2019-07-12" Author="HerMor" Company="Sigmatek" Description="Added ColumnChoice"/>
		<Dokumentation Revision="2.17" Date="2019-07-11" Author="HerMor" Company="Sigmatek" Description="TempAdmin does not reset to default after list is closed and opened"/>
		<Dokumentation Revision="2.16" Date="2018-04-03" Author="SprDie" Company="Sigmatek" Description="class is now compatible with other UDC-Versions"/>
		<Dokumentation Revision="2.15" Date="2018-02-16" Author="KaiAnd" Company="Sigmatek" Description="added the actual UDC to the Files"/>
		<Dokumentation Revision="2.14" Date="2018-01-26" Author="SprDie" Company="Sigmatek" Description="last login &amp; logout of each user is now shown in list"/>
		<Dokumentation Revision="2.13" Date="2017-12-26" Author="sprdie" Company="Sigmatek" Description="added sending of horizontal offset to title-line"/>
		<Dokumentation Revision="2.12" Date="2016-10-10" Author="HubChr" Company="Sigmatek" Description="Added documentation pdfs."/>
		<Dokumentation Revision="2.11" Date="2016-10-06" Author="KaiAnd" Company="Sigmatek" Description="changed column width (UDC values) from [%] to absolute values "/>
		<Dokumentation Revision="2.10" Date="2016-10-05" Author="KaiAnd" Company="Sigmatek" Description="changed object channel for SystemLogging to a command channel; new help function LogMyText() for logging"/>
		<Dokumentation Revision="2.9" Date="2016-05-19" Author="GreJoh" Company="Sigmatek" Description="Get Text if USB Stick is linked or not from a textscheme from the UDC.&#13;&#10;Client coSystemLogging need not be connected."/>
		<Dokumentation Revision="2.8" Date="2016-05-11" Author="KaiAnd" Company="Sigmatek" Description="create a tmpAdmin (&quot;Admin&quot;/&quot;Admin&quot; with level 255) automatically if no user is configured"/>
		<Dokumentation Revision="2.7" Date="2016-05-xx" Author="GreJoh" Company="Sigmatek" Description="Overwrite IfRun() and added the server UserUsbLinked."/>
		<Dokumentation Revision="2.6&#13;&#10;" Date="2015-09-29" Author="BraLis" Company="Sigmatek" Description="insert the method SystemLogging::LogEventText instead of TRACE-Messages"/>
		<Dokumentation Revision="2.5" Date="2015-09-28" Author="KruAle" Company="Sigmatek" Description="get udc-data in IF_Start."/>
		<Dokumentation Revision="2.4" Date="2015-09-22" Company="Sigmatek" Description="Creation."/>
	</RevDoku>
	<Network Name="_AccContList">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{9977A37A-76E1-432E-A867-1BB798F38617}"
				Class      = "_ScrollArea2"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="ActPos"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="ExtendedScrollBar" Value="0"/>
					<Client Name="LineHighness"/>
					<Client Name="LineWidth"/>
					<Client Name="Lse"/>
					<Client Name="VerticalLevel" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "Dummy"
				GUID       = "{F5EC8281-4317-4ED1-A70C-205EA8149617}"
				Class      = "String"
				Position   = "(270,480)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(886,210),(714,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.LineWidth" Destination="this.LineWidth" Vertices="(218,330),(38,270),"/>
			<Connection Source="this.Dummy" Destination="Dummy.Data"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _ScrollArea2

_AccContList : CLASS
: _ScrollArea2
  //Servers:
	UpdateList 	: SvrCh_DINT;
	SelectFunction 	: SvrCh_DINT;
	Visible 	: SvrCh_DINT;
	UserUsbLinked 	: SvrCh_DINT;
  //Clients:
	Mode 	: CltCh_DINT;
	coAccessControl 	: CltChCmd__AccContMain;
	Dummy 	: CltChCmd_String;
	ccSystemLogging 	: CltChCmd_DINT;
	coTitleLine 	: CltChCmd__AccTitleLine;
	ColumnChoice 	: CltCh_BDINT;
  //Variables:
		bInitialized 	: BOOL;
		ScrollImage 	: _ANYTHING;
		aExtVisPara : ARRAY [0..AccessControlList_VariableNo-1] OF DINT;

		aVarSingle : ARRAY [0..AccessControlList_VariableNo-1] OF _VARSINGLE;

		USBLinkText 	: _ANYTHING;
		IsCon_ccSystemLogging 	: BOOL;
		IsCon_coTitleLine 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to redraw the io&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;pr ........ pointer to result information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;
			pr 	: ^_RESULT;
			pv 	: ^_VARIABLE;
			input 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL InitScroll
		VAR_INPUT
			pio 	: ^_IO;
			vno 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when redraw of a single line is necessary.&#13;&#10;ps ..... --&gt; to structure _SCROLL&#13;&#10;pr ..... --&gt; to place where line should be drawn&#13;&#10;line ... number of line which should be drawn&#13;&#10;state .. line is selected (TRUE) or passive (FALSE)&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;
			pr 	: ^_ROOM;
			line 	: UINT;
			state 	: BOOL;
		END_VAR;
				//! <Function Comment="Get user data depending on the list position and delete them." Name="DeleteSelectedUser"/>
	FUNCTION GLOBAL DeleteSelectedUser;
				//! <Function Comment="Calls the method EditUser() of the class AccessControlMain." Name="EditSelectedUser"/>
	FUNCTION GLOBAL EditSelectedUser;
				//! <Function Comment="Get the userdata depending on the line position." Name="ShowUserDataSelectedUser"/>
	FUNCTION GLOBAL ShowUserDataSelectedUser;
				//! <Function Comment="Writes the username to the string for editing or login." Name="setUserName"/>
	FUNCTION setUserName
		VAR_INPUT
			User 	: _AccContMain::t_s_UserV2;			//! <Variable Comment="Struct with the user data." Name="setUserName.User"/>
		END_VAR;
				//! <Function Comment="Links the serial number of a plugged in usb-stick with the selected user." Name="AddUsbSNSelectedUser"/>
	FUNCTION GLOBAL AddUsbSNSelectedUser;
				//! <Function Comment="Deletes the usb link of the selected user." Name="DelUsbSNSelectedUser"/>
	FUNCTION GLOBAL DelUsbSNSelectedUser;
				//! <Function Comment="This method reads the data, which are delivered by the UDC, with the theurge pointer." Name="GetTheUrge"/>
	FUNCTION GetTheUrge
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="Pointer to the _IO information." Name="GetTheUrge.pio"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE..Ok&#13;&#10;FALSE..Error" Name="GetTheUrge.bSuccessful"/>
		END_VAR;
				//! <Function Comment="Get values for the column width from servers if they were defined as server values in LSE." Name="GetTheUrgeValues"/>
	FUNCTION GetTheUrgeValues
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="Pointer to the _IO information." Name="GetTheUrgeValues.pio"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="TRUE..Ok&#13;&#10;FALSE..Error" Name="GetTheUrgeValues.bSuccessful"/>
		END_VAR;
				//! <Function Comment="help function to log a text via command channel to SystemLogging" Name="LogMyText"/>
	FUNCTION LogMyText
		VAR_INPUT
			pLogTxt 	: ^CHAR;			//! <Variable Comment="pointer to the text which should be logged" Name="LogMyText.pLogTxt"/>
		END_VAR;
	
	FUNCTION GLOBAL CalcWidth;
	
	FUNCTION VIRTUAL GLOBAL UpdateList::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SelectFunction::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _AccContMain
#pragma usingLtd _AccTitleLine


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _AccContList::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__ACCCONTLIST
2$UINT, 19$UINT, (SIZEOF(::_AccContList))$UINT, 
4$UINT, 6$UINT, 0$UINT, 
TO_UDINT(250039909), "_AccContList", //Class
TO_UDINT(2779823616), "_ScrollArea2", 0$UINT, 8$UINT, //Baseclass
//Servers:
(::_AccContList.UpdateList.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3579543998), "UpdateList", 
(::_AccContList.SelectFunction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2341012260), "SelectFunction", 
(::_AccContList.Visible.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1173689923), "Visible", 
(::_AccContList.UserUsbLinked.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2901458497), "UserUsbLinked", 
//Clients:
(::_AccContList.Mode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2707401247), "Mode", 
(::_AccContList.coAccessControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3559082873), "coAccessControl", TO_UDINT(4110908185), "_AccContMain", 2$UINT, 31$UINT, 
(::_AccContList.Dummy.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3097505935), "Dummy", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContList.ccSystemLogging.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1000190998), "ccSystemLogging", 
(::_AccContList.coTitleLine.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2871397703), "coTitleLine", TO_UDINT(1356137340), "_AccTitleLine", 1$UINT, 6$UINT, 
(::_AccContList.ColumnChoice.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3823519998), "ColumnChoice", 
END_FUNCTION


#define USER_CNT__AccContList 23

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__AccContList] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _AccContList::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _ScrollArea2::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__AccContList;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #InitScroll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	UpdateList.pMeth			:= StoreMethod( #M_RD_DIRECT(), #UpdateList::Write() );
	IF UpdateList.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SelectFunction.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SelectFunction::Write() );
	IF SelectFunction.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Visible.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Visible.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION GLOBAL __CDECL accesslist_line
  VAR_INPUT
    ps    : ^_SCROLL;  
    pt    : ^void;  
    pr    : ^_ROOM; 
    line  : UINT; 
    state : BOOL; 
  END_VAR

  pt$^_ScrollArea^.Line(ps, pr, line, state); 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContList::Init

  if (_FirstScan) then
  
    //-----------------------------------------------------------------------------------------
    //  check client-connnections and set flags                   GreJoh
    //-----------------------------------------------------------------------------------------    
    if (IsClientConnected(#ccSystemLogging)) then
      IsCon_ccSystemLogging := TRUE;
    else 
      IsCon_ccSystemLogging := FALSE;
    end_if;  
    // sprdie v2.13 - send horizontal offset to Title-Line
    if (IsClientConnected(#coTitleLine)) then
      IsCon_coTitleLine := TRUE;
    else
      IsCon_coTitleLine := FALSE;
    end_if;

  
    coAccessControl.RegisterAccessList(pNewAccessList:=this);
    
  end_if;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _AccContList::Line
	VAR_INPUT
		ps 	: ^_SCROLL;
		pr 	: ^_ROOM;
		line 	: UINT;
		state 	: BOOL;
	END_VAR
  VAR
    txt         : ARRAY [0..300] of _ASCII;
    tmpActUser  : _AccContMain::t_s_UserV2;  //V2.19, dacpat, updated to new struct
    color       : _COLOR; 
    att         : _ATTRIB; 
    tmpX        : INT;
    tmpY        : INT;
    tmpYDiff    : INT;
    tmpRoomDiff : INT;
    tmpHeight   : INT;
    tmpWidth    : INT;
    pString     : ^_CHAR;
    tmpStr      : ARRAY[0..10] OF _CHAR; // sprdie v2.14 - tmp unicode string for date/time
  END_VAR
  
  // UDC-Parameter geholt?
  if bInitialized then

    tmpX        := pr^.xy1.x + 5;
    tmpY        := pr^.xy1.y;
    tmpRoomDiff := pr^.xy2.x - pr^.xy1.x;
    att         := T_LEFTBOUND or T_UPBOUND or T_COPY or T_SOLID or T_PROP; 

    // Größe des eingestellten Font ermitteln
    font_size(ps^.font, (#tmpWidth)$^UINT, (#tmpHeight)$^UINT);
    
    tmpYDiff := (pr^.xy2.y - pr^.xy1.y) / 2 + pr^.xy1.y - tmpHeight / 2;
      
    // Gültige Zeile und gültige Benutzerdaten
    if(line < ps^.position.no) & (coAccessControl.getUserDataByNr(udUserNr:=line, #tmpActUser) = 0) then
      
      if(state = TRUE) then
        // Ausgewählte Zeile gleich in entsprechendes Stringfeld schreiben
        if Mode = 1 then
          setUserName(User:=tmpActUser);
        end_if;
        color := Graphic.MakeColor(INVISIBLE, ps^.color_activ); 
      else
        color := Graphic.MakeColor(INVISIBLE, ps^.color_inactiv); 
      end_if; 


      // Benutzername immer zeichnen
      if ((aExtVisPara[AccessControlList_VarUserNameRoom] > 0) & (ColumnChoice AND 2#00000001)) then    
        StrCpy(#txt[0], sizeof(_ASCII), #tmpActUser.aUsername[0], sizeof(_ASCII));
        Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
        tmpX += TO_INT(aExtVisPara[AccessControlList_VarUserNameRoom]);
      end_if;
      
      // Nur bei der Benutzerverwaltung alles zeichnen
      //-----------------------------------------------------------------------------------------
      if (Mode = 0) then
              
        if ((aExtVisPara[AccessControlList_VarPasswordRoom] > 0) & (ColumnChoice AND 2#00000010)) then
          StrCpy(#txt[0], sizeof(_ASCII), "******", sizeof(_ASCII));
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
          tmpX += TO_INT(aExtVisPara[AccessControlList_VarPasswordRoom]);
        end_if;
        
        if ((aExtVisPara[AccessControlList_VarLevelRoom] > 0) & (ColumnChoice AND 2#00000100)) then
          DToA(#txt[0], tmpActUser.usUserLevel, 0x0000, sizeof(_ASCII));
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
          tmpX += TO_INT(aExtVisPara[AccessControlList_VarLevelRoom]);
        end_if;
        
        if ((aExtVisPara[AccessControlList_VarTimeoutRoom] > 0) & (ColumnChoice AND 2#00001000)) then
          DToA(#txt[0], TO_DINT(tmpActUser.udUserTimeout), 0x0000, sizeof(_ASCII));
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
          tmpX += TO_INT(aExtVisPara[AccessControlList_VarTimeoutRoom]);
        end_if;

        if ((aExtVisPara[AccessControlList_VarUSBSerNumRoom] > 0) & (ColumnChoice AND 2#00010000)) then 
          if (_strlen(#tmpActUser.USBSerial[0])) then
          
            pString$^void := NewDoScheme( x0 := USBLinkText.list, 
                                          x1 := AccessControlList_USBLinkedYes, 
                                          x2 := USBLinkText.no);
                                          
            StrCpy(#txt[0], sizeof(_UNI), pString, sizeof(_UNI));
            
          else
          
            pString$^void := NewDoScheme( x0 := USBLinkText.list, 
                                          x1 := AccessControlList_USBLinkedNo, 
                                          x2 := USBLinkText.no);
                                          
            StrCpy(#txt[0], sizeof(_UNI), pString, sizeof(_UNI));
            
          end_if;
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_UNI));
          tmpX += TO_INT(aExtVisPara[AccessControlList_VarUSBSerNumRoom]);
        end_if;

        if ((aExtVisPara[AccessControlList_VarInfoRoom] > 0) & (ColumnChoice AND 2#00100000)) then
          StrCpy(#txt[0], sizeof(_ASCII), #tmpActUser.aUserInfo[0], sizeof(_ASCII));
          Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
          tmpX += TO_INT(aExtVisPara[AccessControlList_VarInfoRoom]);
        end_if;
        
        // sprdie v2.14 - draw last login & logout of user >>>
        if ((aExtVisPara[AccessControlList_LoginInfoRoom] > 0) & (ColumnChoice AND 2#01000000)) then
          
          if tmpActUser.LastLogin.fdate.year <> 0 then
            format_date(#tmpStr[0], #tmpActUser.LastLogin.fdate, SIZE_DDMMYYYY);
            StrCpy(#txt[0], sizeof(_ASCII), #tmpStr[0], sizeof(_CHAR));
            
            StrCat(#txt[0], sizeof(_ASCII), " ", sizeof(_ASCII));
            
            format_time(#tmpStr[0], #tmpActUser.LastLogin.ftime, SIZE_HHMM);
            StrCat(#txt[0], sizeof(_ASCII), #tmpStr[0], sizeof(_CHAR));
            
            Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
            tmpX += TO_INT(aExtVisPara[AccessControlList_LoginInfoRoom]);
          end_if;
          
        end_if;
        
        if ((aExtVisPara[AccessControlList_LogoutInfoRoom] > 0) & (ColumnChoice AND 2#10000000)) then
          
          if tmpActUser.LastLogout.fdate.year <> 0 then
            format_date(#tmpStr[0], #tmpActUser.LastLogout.fdate, SIZE_DDMMYYYY);
            StrCpy(#txt[0], sizeof(_ASCII), #tmpStr[0], sizeof(_CHAR));
            
            StrCat(#txt[0], sizeof(_ASCII), " ", sizeof(_ASCII));
            
            format_time(#tmpStr[0], #tmpActUser.LastLogout.ftime, SIZE_HHMM);
            StrCat(#txt[0], sizeof(_ASCII), #tmpStr[0], sizeof(_CHAR));
            
            Graphic.OutTextXY(tmpX, tmpYDiff, #txt[0], att, color, sizeof(_ASCII));
            tmpX += TO_INT(aExtVisPara[AccessControlList_LogoutInfoRoom]);
          end_if;
          
        end_if;
        
        // sprdie v2.14 <<<
        
      end_if;
    end_if;
    
    
    // Spalten nur bei der Benutzerverwaltung zeichnen
    //-----------------------------------------------------------------------------------------
    if (Mode = 0) then
    
      tmpX := pr^.xy1.x;
    
      if ((aExtVisPara[AccessControlList_VarUserNameRoom] > 0) & (ColumnChoice AND 2#00000001)) then
        tmpX += TO_INT(aExtVisPara[AccessControlList_VarUserNameRoom]);
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      if ((aExtVisPara[AccessControlList_VarPasswordRoom] > 0) & (ColumnChoice AND 2#00000010)) then
        tmpX += TO_INT(aExtVisPara[AccessControlList_VarPasswordRoom]);
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      if ((aExtVisPara[AccessControlList_VarLevelRoom] > 0) & (ColumnChoice AND 2#00000100)) then
        tmpX += TO_INT(aExtVisPara[AccessControlList_VarLevelRoom]);
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      if ((aExtVisPara[AccessControlList_VarTimeoutRoom] > 0) & (ColumnChoice AND 2#00001000)) then
        tmpX += TO_INT(aExtVisPara[AccessControlList_VarTimeoutRoom]);
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      if ((aExtVisPara[AccessControlList_VarUSBSerNumRoom] > 0) & (ColumnChoice AND 2#00010000)) then
        tmpX += TO_INT(aExtVisPara[AccessControlList_VarUSBSerNumRoom]);
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      // sprdie v2.14 - draw lines for added columns >>>
      if ((aExtVisPara[AccessControlList_VarInfoRoom] > 0) & (ColumnChoice AND 2#00100000)) then
        tmpX += TO_INT(aExtVisPara[AccessControlList_VarInfoRoom]);
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      
      if ((aExtVisPara[AccessControlList_LoginInfoRoom] > 0) & (ColumnChoice AND 2#01000000)) then
        tmpX += TO_INT(aExtVisPara[AccessControlList_LoginInfoRoom]);
        Graphic.Line(tmpX, pr^.xy1.y, tmpX, pr^.xy2.y, T_COPY OR T_SOLID, BLACK);
      end_if;
      /// sprdie v2.14 <<<
      
      // Rahmen erneut zeichnen
      DrawButton(#ps^.out_room, T_FILL or T_COPY or T_SOLID, ps^.frametype, INVISIBLE, ps^.frame_out);
      
    end_if;      
    
    // sprdie v2.13 - send horizontal offset to Title-Line
    if (Mode = 0) & (IsCon_coTitleLine = TRUE) then
      coTitleLine.setActLineBegin(Scroll.scroll_room.xy1.x - TO_INT(Scroll.hposition.begin)); 
    end_if;

  end_if;
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _AccContList::Draw
	VAR_INPUT
		pio 	: ^_IO;
		pr 	: ^_RESULT;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  
  if bInitialized then
    
    GetTheUrgeValues(pio:=pio);
    
    // ScrollListe initialisieren
    InitScroll(pio:=pio, vno:=TO_UINT(coAccessControl.getNumberOfUsers()));
    
    retcode := _ScrollArea2::Draw(pio, pr, pv, input);
    
  else
    retcode := _IFAILED;
  end_if;
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _AccContList::InitScroll
	VAR_INPUT
		pio 	: ^_IO;
		vno 	: UINT;
	END_VAR
VAR
  tmpX  : UINT; 
  tmpY  : UINT; 
	hno   : DINT; 
	hzl   : BOOL; 
	tmpColor : _COLOR; 
   #ifdef LEFT_RIGHT_SELECTION
    sb_iswo : dint; 
   #endif
END_VAR 

  font_size(pio^.font, #tmpX, #tmpY); 
  tmpY := LineHeight(tmpY);

  Scroll.attrib_inactiv    := pio^.attrib; 
  Scroll.attrib_activ      := pio^.attrib; 
  Scroll.out_room          := pio^.space; 
  Scroll.scroll_room       := pio^.space;
  Scroll.font              := pio^.font; 
  Scroll.color_inactiv     := Graphic.MakeColor(GetPenColor(pio^.colback), GetPenColor(pio^.coltxt));
  Scroll.color_activ       := Graphic.MakeColor(GetEditColorBack(_EDITACTIVE), GetEditColorTxt(_EDITACTIVE));
  Scroll.frame_out         := pio^.colframe;
  Scroll.frame_scroll      := pio^.colframe;
  tmpColor := GetBackColor(Scroll.color_inactiv); 
  Scroll.level.color       := Graphic.MakeColor(tmpColor, tmpColor); 
  Scroll.level.frame_color := pio^.colframe;
  if (ExtendedScrollBar.Read() = 1) then
    Scroll.level.pguppgdown  := true;
  end_if;
  Scroll.hlevel.color       := Scroll.level.color; 
  Scroll.hlevel.frame_color := pio^.colframe;
  Scroll.line_height        := tmpY;
  Scroll.frametype          := pio^.frametype;

  Scroll.scroll_room.xy1.x += 1; 
  Scroll.scroll_room.xy1.y += 1; 
  Scroll.scroll_room.xy2.x -= 1; 
  Scroll.scroll_room.xy2.y -= 1; 

  Scroll.position.no  := vno; 

  Scroll.level.active := FALSE;

 #ifdef LEFT_RIGHT_SELECTION
  sb_iswo := VerticalLevel.Read(); 
  if(sb_iswo = 1) then
    // scrollbalken rechts
    Scroll.scroll_room.xy2.x -= LEVELBUTTON_WIDTH; 
    Scroll.level.room.xy1.x  := Scroll.scroll_room.xy2.x+1; 
    Scroll.level.room.xy2.x  := Scroll.out_room.xy2.x;
    Scroll.level.room.xy1.y  := Scroll.out_room.xy1.y; 
    Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
    Scroll.level.active      := TRUE; 
  elsif(sb_iswo = 2) then
    //scrollbalken links
    Scroll.scroll_room.xy1.x += LEVELBUTTON_WIDTH; 
    Scroll.level.room.xy1.x  := Scroll.out_room.xy1.x + 1;  
    Scroll.level.room.xy2.x  := Scroll.out_room.xy1.x + LEVELBUTTON_WIDTH;
    Scroll.level.room.xy1.y  := Scroll.out_room.xy1.y; 
    Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
    Scroll.level.active      := TRUE; 
  end_if; 
 #else
  if(VerticalLevel.Read() = TRUE) then
    Scroll.scroll_room.xy2.x -= LEVELBUTTON_WIDTH; 
    Scroll.level.room.xy1.x  := Scroll.scroll_room.xy2.x+1; 
    Scroll.level.room.xy1.y  := Scroll.out_room.xy1.y; 
    Scroll.level.room.xy2.x  := Scroll.out_room.xy2.x;
    Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
    Scroll.level.active      := TRUE; 
  end_if; 
 #endif

  Scroll.line_width := to_uint(Scroll.scroll_room.xy2.x - Scroll.scroll_room.xy1.x + 1);


  // neuer code
  hno := LineWidth.Read();
  if(hno < Scroll.line_width) then
    hzl := FALSE;
    Scroll.hposition.no := 0; 
  else
    hzl := TRUE; 
	  Scroll.hposition.no := hno - Scroll.line_width; 
  end_if; 	 


  if(hzl = TRUE) then
    Scroll.level.room.xy2.y  -= (LEVELBUTTON_HEIGHT + 1); 
    Scroll.scroll_room.xy2.y -= (LEVELBUTTON_HEIGHT + 1);
    Scroll.hlevel.room.xy1.x := Scroll.out_room.xy1.x;  
    Scroll.hlevel.room.xy1.y := Scroll.scroll_room.xy2.y + 1;  
    Scroll.hlevel.room.xy2.x := Scroll.out_room.xy2.x;  
    Scroll.hlevel.room.xy2.y := Scroll.out_room.xy2.y;  
    if(Scroll.level.active = TRUE) then
     #ifdef LEFT_RIGHT_SELECTION
	  if(sb_iswo = 1) then
	    // scrollbalken ist rechts
        Scroll.hlevel.room.xy2.x -= LEVELBUTTON_WIDTH; 
	  elsif(sb_iswo = 2) then
	    // scrollbalken ist links
        Scroll.hlevel.room.xy1.x += LEVELBUTTON_WIDTH-1;
	    Scroll.hlevel.room.xy2.x -= 1; 
      end_if; 
     #else
      Scroll.hlevel.room.xy2.x -= LEVELBUTTON_WIDTH; 
     #endif 
    end_if; 
    Scroll.hlevel.active     := TRUE;  
    Scroll.hposition.height  := 1; //to_uint((Scroll.scroll_room.xy2.x - Scroll.scroll_room.xy1.x) / 4);  
  elsif (Scroll.hlevel.active = TRUE) then
  	Scroll.scroll_room.xy2.y := pio^.space.xy2.y - 1;
	  Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
	  Scroll.hlevel.active     := FALSE;
  end_if; 
  
  Scroll.position.height := to_uint((Scroll.scroll_room.xy2.y - Scroll.scroll_room.xy1.y + 1) / tmpY);
  if(Scroll.position.height < 1) then 
    Scroll.position.height := 1; 
  end_if; 

  if(Scroll.level.active = TRUE) then
    Scroll.hlevel.room.xy2.x += 1; 
  end_if; 

  Scroll.line_height += to_uint((Scroll.scroll_room.xy2.y - Scroll.scroll_room.xy1.y + 1 - Scroll.position.height * Scroll.line_height) / Scroll.position.height); 

  // wenn "eigentlich nicht mehr sichtbare Zeile" selektiert ist bzw. selektierte Zeile nicht mehr existiert
  if Scroll.position.pos >= Scroll.position.no then
    Scroll.position.pos := Scroll.position.no - 1;
  end_if;
  if Scroll.position.begin > (Scroll.position.no - Scroll.position.height) then
    if (Scroll.position.no - Scroll.position.height) < 1 then
      Scroll.position.begin := 0;
    else
      Scroll.position.begin := (Scroll.position.no - Scroll.position.height) - 1;
    end_if;
  end_if;

  // Bild von der Visu als Scrollbutton angeben
  Scroll.image := (get_Anything(#ScrollImage, NIL))$^_BMP;
  
  Scroll.pt      := this;  
  Scroll.pt_line := #accesslist_line(); // to userdefined linedraw-interface
  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContList::UpdateList::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	UpdateList := input;
  
  Refresh.Write(input:=1);
  
 	result := UpdateList;
  UpdateList := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContList::SelectFunction::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	SelectFunction := input;
  
  //*****************************************************************************
  //** Ausgewählte Funktion                                                    **
  //*****************************************************************************
  case SelectFunction of
    
    // Ausgewählten Benutzer löschen
    1:  DeleteSelectedUser();
    
    // Ausgewählten Benutzer bearbeiten
    2:  EditSelectedUser();
    
    // Daten des ausgewählten Benutzers anzeigen
    3:  ShowUserDataSelectedUser();
    
    // Verknüpft die Seriennummer des aktuellen Speichermediums mit dem eingeloggten Benutzer
    4:  AddUsbSNSelectedUser();
    
    // Löscht die Verknüpfung der Seriennummer mit dem aktuellen Speichermedium
    5:  DelUsbSNSelectedUser();
  
  end_case;
  
 	result := SelectFunction;
  SelectFunction := 0;

END_FUNCTION


FUNCTION GLOBAL _AccContList::DeleteSelectedUser
  VAR
    tmpUser : _AccContMain::t_s_UserV2;  //V2.19, dacpat, updated to new struct
  END_VAR
  
  // Benutzerdaten anhand der Zeilenposition holen und löschen
  //-----------------------------------------------------------------------------------------
  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
    setUserName(User:=tmpUser);
    coAccessControl.DeleteUser();
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContList::EditSelectedUser
  
  // Methode der Manager-Klasse aufrufen
  coAccessControl.EditUser();

END_FUNCTION


FUNCTION GLOBAL _AccContList::ShowUserDataSelectedUser
  VAR
    tmpUser : _AccContMain::t_s_UserV2;  //V2.19, dacpat, updated to new struct
  END_VAR

  // Benutzerdaten anhand der Zeilenposition holen
  //-----------------------------------------------------------------------------------------
  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
    setUserName(User:=tmpUser);
    coAccessControl.ShowUserData();
  end_if;

END_FUNCTION


FUNCTION _AccContList::setUserName
	VAR_INPUT
		User 	: _AccContMain::t_s_UserV2;  //V2.19, dacpat, updated to new struct
	END_VAR
  
  // Benutzername in den String zum Editieren oder zum Anmelden schreiben
  //-----------------------------------------------------------------------------------------
  if Mode = 0 then
  
    coAccessControl.StrEditUserName.WriteDataOff(udLen:=StrLen(txt:=#User.aUsername[0], size:=sizeof(_ASCII)), udOff:=0, pData:=#User.aUsername[0]);
  
  elsif Mode = 1 then
  
    coAccessControl.StrLoginUserName.WriteDataOff(udLen:=StrLen(txt:=#User.aUsername[0], size:=sizeof(_ASCII)), udOff:=0, pData:=#User.aUsername[0]);
  
  end_if;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _AccContList::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  VAR
    tmpUser : _AccContMain::t_s_UserV2;  //V2.19, dacpat, updated to new struct
  END_VAR

  // Methoder der Basis-Klasse aufrufen
  retcode :=_ScrollArea::GetEvent(ped, pe);
  
  if (Focus = TRUE) then
    
    //***************************************************************************** 
    //** Schrittschaltwerk für das Event in der Login-Help Scroll-Liste          **
    //***************************************************************************** 
    case (pe^.ftype) of
	    
      //***************************************************************************** 
		  _EVENT_HIDPRESS: 
                
                // Touch-Event im Bereich der Scroll-Liste
                if ((pe^.dot.x >= Scroll.out_room.xy1.x) & (pe^.dot.x <= Scroll.out_room.xy2.x) &
                    (pe^.dot.y >= Scroll.out_room.xy1.y) & (pe^.dot.y <= Scroll.out_room.xy2.y)) then
                  
                  // Benutzerdaten anhand der Position holen
                  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
                    setUserName(User:=tmpUser);
                  else 
                    tmpUser.aUsername[0] := 0;
                    setUserName(tmpUser);
                  end_if;
                  
                end_if;
                
      
      //***************************************************************************** 
      _EVENT_HIDRELEASE:
                
                // Benutzerdaten anhand der Position holen
                if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
                  setUserName(User:=tmpUser);
                else
                  tmpUser.aUsername[0] := 0;
                  setUserName(tmpUser);
                end_if;

    end_case; 
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContList::AddUsbSNSelectedUser
  VAR
    tmpUser : _AccContMain::t_s_UserV2;  //V2.19, dacpat, updated to new struct
  END_VAR
  
  // Benutzerdaten anhand der Position holen
  //-----------------------------------------------------------------------------------------
  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
    setUserName(User:=tmpUser);
    coAccessControl.AddUsbSN();
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContList::DelUsbSNSelectedUser
VAR
	tmpUser : _AccContMain::t_s_UserV2;  //V2.19, dacpat, updated to new struct
END_VAR
  
  // Benutzerdaten anhand der Position holen
  //-----------------------------------------------------------------------------------------
  if coAccessControl.getUserDataByNr(udUserNr:=TO_UDINT(Scroll.position.pos), #tmpUser) = 0 then
    setUserName(User:=tmpUser);
    coAccessControl.DelUsbSN();
  end_if;
  
END_FUNCTION



FUNCTION _AccContList::GetTheUrge
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
	  pVarLabel       : ^_VARLABEL;
    tmpCounter      : USINT;
    pHelpAnyThing   : ^_ANYTHING;
    calculatedWidth : DINT; // sprdie v2.14 - calculate LineWidth
    varCount        : UINT;
    arraySize       : UINT;
  END_VAR
  
  tmpCounter  := 0;
  bSuccessful := true;
  
  // Zeiger auf die Daten aus der Visu gültig?
  if (pio <> NIL) & (pio^.theurge <> NIL) then
    
    // Richtige Version des UDCs?
//    if (pio^.theurge^.info = AccessControlList_UDCVersion) then

      // Variablen-Informationen
      //--------------------------------------------------------------
      // check number of variables
//      if pio^.theurge^.memvarlabel.no = AccessControlList_VariableNo then
        
        // pointer to variable informations
        pVarLabel := pio^.theurge^.memvarlabel.ptr;
        
        calculatedWidth := 0; // sprdie v2.14
        
        // sprdie v2.16 -------------------------------------------
        arraySize := sizeof(aVarSingle) / sizeof(aVarSingle[0]);
        
        if pio^.theurge^.memvarlabel.no > arraySize then
          varCount := arraySize;
        else
          varCount := pio^.theurge^.memvarlabel.no;
        end_if;
        // -------------------------------------------------------
        
        // loop to store all parameter
        for tmpCounter := 0 to varCount - 1 do
        
          // save variable informations
          aVarSingle[tmpCounter] := pVarLabel^.info[0];
          
          // check for constant
          if aVarSingle[tmpCounter].state = CONST_VAL then
            aExtVisPara[tmpCounter] := aVarSingle[tmpCounter].value;
            calculatedWidth += aExtVisPara[tmpCounter]; // sprdie v2.14
          end_if;

          // step to next variable
          pVarLabel += sizeof(_VARLABEL);
          
        end_for;
        
        CalcWidth(); //HerMor V2.18
        
//      else
//        bSuccessful := false;
//      end_if;
      
      
      // Scroll-Bild holen
      //-----------------------------------------------------------------------------------------
      if (pio^.theurge^.memanything.no = AccessControlList_ImageAndTextNo) then
        
        pHelpAnyThing := pio^.theurge^.memanything.ptr;

        ScrollImage.list := pHelpAnyThing^.list;
        ScrollImage.no   := pHelpAnyThing^.no;
        
        // Textschema holen
        //-----------------------------------------------------------------------------------------
        pHelpAnyThing += sizeof(_ANYTHING);
        
        // Schema ein Textschema?
        if (pHelpAnyThing^.list = TEXTSCHEME) then
          USBLinkText.list := pHelpAnyThing^.list;
          USBLinkText.no   := pHelpAnyThing^.no;
        else
          USBLinkText.list := DEFLST;
          USBLinkText.no   := DEFSCOPE;
          LogMyText("_AccContList::GetTheUrge: Verweis auf Textliste konnte nicht bestimmt werden");
        end_if;
      
      else
        bSuccessful := false;
      end_if;
    
//    else
//      bSuccessful := false;
//      LogMyText("_AccContList::GetTheUrge(): Falsche Version des UDCs");
//    end_if;

  else
    bSuccessful := false;
    LogMyText("_AccContList::GetTheUrge(): Ungültiger Übergabeparameter");
  end_if;

END_FUNCTION


FUNCTION _AccContList::GetTheUrgeValues
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpCounter  : USINT;
    tmpResult   : _RESULT;
    tmpVariable : _VARIABLE;
    tmpVarLabel : _VARLABEL;
  END_VAR
  
  bSuccessful := true;
  
  // loop to check all variables
  for tmpCounter := 0 to sizeof(aVarSingle) / sizeof(aVarSingle[0]) - 1 do
  
    // check if variable is a dataserver
    if aVarSingle[tmpCounter].state = VAR_VAL then
      
      // build varlabel
      tmpVarLabel.no      := 1;
      tmpVarLabel.info[0] := aVarSingle[tmpCounter];
    
      // get server-value
      if VarList_GetSystemData( p0  := #tmpResult, 
                                p1  := #tmpVariable, 
                                p2  := #tmpVarLabel, 
                                x3  := false) = true then
        
        // save the new value + change checksum
        aExtVisPara[tmpCounter] := tmpResult.value;
      
      else
        bSuccessful := false;
      end_if;

    end_if;

  end_for;  
    
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _AccContList::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  VAR
	  myNumUsers : UDINT;
    tmpAdmin   : BOOL;
  END_VAR
  
  bInitialized := GetTheUrge(pio:=pio);

  // Methode der Basis-Klasse
  _ScrollArea2::IF_Start(pio, firsttime);


  //-----------------------------------------------------------------------------------------------
  // Admin-User temporär anlegen, solange keine echten User angelegt sind               KaiAnd
  //-----------------------------------------------------------------------------------------------
  myNumUsers := coAccessControl.getNumberOfUsers();
  
  //HerMor V2.27: Check if there is already a tmp-admin
  tmpAdmin := coAccessControl.getTmpAdmin();
  if ((myNumUsers <= 0) & (tmpAdmin = false)) then
    coAccessControl.CreateAdmin(pUsername:="Admin", pPassword:="Admin", usLevel:=255);
  end_if;
  //-----------------------------------------------------------------------------------------------


END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _AccContList::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR
  VAR
  	tmpActUser  : _AccContMain::t_s_UserV2;  //V2.19, dacpat, updated to new struct
  END_VAR

  coAccessControl.getUserDataByNr(udUserNr:=to_UDINT(ActPos), #tmpActUser);

  if aExtVisPara[AccessControlList_VarUSBSerNumRoom] > 0 then 
    if _strlen(#tmpActUser.USBSerial[0]) then
      UserUsbLinked := 1;
    else
      UserUsbLinked := 0;
    end_if;
  end_if;    

  // Methode der Basisklasse aufrufen
  _ScrollArea2::IF_Run(pio, input);

END_FUNCTION


FUNCTION _AccContList::LogMyText
VAR_INPUT
		pLogTxt 	: ^CHAR;
	END_VAR

  VAR
    NiGive	  : CmdStruct;
    NiGet     : Results;
  END_VAR

  if ((IsCon_ccSystemLogging = True) & (pLogTxt <> NIL)) then

    NiGive.uiCmd    := 0;               // Command
    NiGive.aPara[0] := (pLogTxt)$DINT;  // pointer to text

    ccSystemLogging.NewInst(#NiGive, #NiGet);

  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContList::CalcWidth
  // HerMor V2.18
  // Breite der Zeile berechnen
  //--------------------------------------------------------------------------------------------
  // Konfiguration der Spalten lesen
  ColumnChoice := ColumnChoice.Read();
  
  if ColumnChoice = 0 then
  
    ColumnChoice := 2#11111111;  //V2.19, dacpat, Set a default value
  end_if;
  
  LineWidth := 0;
  
  // Benutzername
  if (ColumnChoice AND 2#00000001) then
    LineWidth += aExtVisPara[0];
  end_if;

  // Passwort
  if (ColumnChoice AND 2#00000010) then
    LineWidth += aExtVisPara[1];
  end_if;
  
  // Level
  if (ColumnChoice AND 2#00000100) then
    LineWidth += aExtVisPara[2];
  end_if;
  
  // Timeout
  if (ColumnChoice AND 2#00001000) then
    LineWidth += aExtVisPara[3];
  end_if;
  
  // USB
  if (ColumnChoice AND 2#00010000) then
    LineWidth += aExtVisPara[4];
  end_if;
  
  // Info
  if (ColumnChoice AND 2#00100000) then
    LineWidth += aExtVisPara[5];
  end_if;
  
  // Login
  if (ColumnChoice AND 2#01000000) then
    LineWidth += aExtVisPara[6];
  end_if;
  
  // Logout
  if (ColumnChoice AND 2#10000000) then
    LineWidth += aExtVisPara[7];
  end_if;
  
END_FUNCTION
