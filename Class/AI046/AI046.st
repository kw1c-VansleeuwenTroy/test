//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_AI046                 1081

#define AI046_SDO_RESPONSE_TIMEOUT      (SDIAS_SDO_TIMEOUT * 2)
#define AI046_SDO_REQUEST_TIME          50

#define AI046_ADDR_HWCONTROL_REGISTER   16#216

#define AI046_NUMBER_OF_ANALOG_IN       4
#define AI046_INVALID_VALUE             16#80000010$DINT

#define AI046_SIZE_ONE_VALUE_18Bit      sizeof(DINT)
#define AI046_SIZE_ONE_VALUE_16Bit      sizeof(INT)

#define AI046_INPUT_RAW_VALUE_PLACE_18BIT    (0*AI046_SIZE_ONE_VALUE_18Bit)  //select array entry of buffer to display on AIx server
#define AI046_INPUT_RAW_VALUE_PLACE_16BIT    (0*AI046_SIZE_ONE_VALUE_16Bit)  //select array entry of buffer to display on AIx server

#define AI046_MAX_LENGTH_ONE_READ       16#80   
#define AI046_FULL_BUFFERSIZE           16#800   //max buffersize 

#define AI046_MAX_BUFFER_ACCESSES       (AI046_FULL_BUFFERSIZE/AI046_MAX_LENGTH_ONE_READ)  //max pdo accesses for one channel
#define AI046_MAX_ARRAY_ENTRYS          (AI046_MAX_BUFFER_ACCESSES * AI046_NUMBER_OF_ANALOG_IN) //max possible pdo accesse if every channel is activated

//pll settings
#define AI046_SYNC_OUT_ID               16#03
#define AI046_PLL_OFFSET                16#140
#define AI046_PLL_CONTROL               (AI046_PLL_OFFSET+8)
#define AI046_PLL_OFFSETTIME            4 //µsec offset to get right buffer bit state //4

// 18Bit Mode
#define AI046_FIRMWARE_MAX_18BIT        110000                            // +/-110000 are equal to +/- 11V
#define AI046_FIRMWARE_MIN_18BIT       -110000                            // +/-110000 are equal to +/- 11V
// 16Bit Mode
#define AI046_FIRMWARE_MAX_16BIT        (AI046_FIRMWARE_MAX_18BIT/4)      // +/-27500 are equal to +/- 11V
#define AI046_FIRMWARE_MIN_16BIT        (AI046_FIRMWARE_MIN_18BIT/4)      // +/-27500 are equal to +/- 11V
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "AI046"
	Revision           = "1.8"
	GUID               = "{9A0A4DF1-D111-4206-95D6-02F1A7FC99AA}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(626,120)"
	Comment            = "Class for AI046 hardware module (4x analog inputs +/- 11V)&#13;&#10;">
	<Channels>
		<Server Name="AI1" GUID="{8DF2E3A2-F077-4413-B416-129D337ED8C0}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input, shows the first value from buffer.&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010.&#13;&#10;Value is shown according to property settings of &#13;&#10;AIxMaxValue, AIxMinValue and state AIxGain.&#13;&#10;&#13;&#10;"/>
		<Server Name="AI1Gain" GUID="{DA4F0FA1-3966-419A-8AFE-F5A673131E7C}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="The channel gain can be set with this server.&#13;&#10;this setting multiplies the analog input value with gain factor&#13;&#10;0 ... Gain of x1 (Default)&#13;&#10;1 ... Gain of x10&#13;&#10;&#13;&#10;"/>
		<Server Name="AI1SetLed" GUID="{6544E965-25A1-412C-8FE2-F42241ED3F32}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Set LED Overwrite Register&#13;&#10;0 ... HW Status aktiv&#13;&#10;1 ... LED on&#13;&#10;2 ... LED off"/>
		<Server Name="AI2" GUID="{880FF504-94DA-41A0-88C7-3D832CA4544C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input, shows the first value from buffer.&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010.&#13;&#10;Value is shown according to property settings of &#13;&#10;AIxMaxValue, AIxMinValue and state AIxGain.&#13;&#10;&#13;&#10;"/>
		<Server Name="AI2Gain" GUID="{35A66A3D-FEE8-4213-943E-68F2AD95B7E3}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="The channel gain can be set with this server.&#13;&#10;this setting multiplies the analog input value with gain factor&#13;&#10;0 ... Gain of x1 (Default)&#13;&#10;1 ... Gain of x10&#13;&#10;"/>
		<Server Name="AI2SetLed" GUID="{6C0A7343-7DED-40B9-A415-6D0F4E2490AF}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Set LED Overwrite Register&#13;&#10;0 ... HW Status aktiv&#13;&#10;1 ... LED on&#13;&#10;2 ... LED off"/>
		<Server Name="AI3" GUID="{69109345-5960-47AC-B7BA-99829D578B80}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input, shows the first value from buffer.&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010.&#13;&#10;Value is shown according to property settings of &#13;&#10;AIxMaxValue, AIxMinValue and state AIxGain.&#13;&#10;&#13;&#10;"/>
		<Server Name="AI3Gain" GUID="{327CD07B-481F-4F37-8323-3D77B4805D56}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="The channel gain can be set with this server.&#13;&#10;this setting multiplies the analog input value with gain factor&#13;&#10;0 ... Gain of x1 (Default)&#13;&#10;1 ... Gain of x10&#13;&#10;"/>
		<Server Name="AI3SetLed" GUID="{2C1D06B2-54C4-4F95-8F32-3F107873C007}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Set LED Overwrite Register&#13;&#10;0 ... HW Status aktiv&#13;&#10;1 ... LED on&#13;&#10;2 ... LED off"/>
		<Server Name="AI4" GUID="{92CF84AC-15F7-4BC6-B8AD-20D2998E276A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input, shows the first value from buffer.&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010.&#13;&#10;Value is shown according to property settings of &#13;&#10;AIxMaxValue, AIxMinValue and state AIxGain.&#13;&#10;&#13;&#10;"/>
		<Server Name="AI4Gain" GUID="{BB59D996-E9FD-4CAA-B237-19F660B2753E}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="The channel gain can be set with this server.&#13;&#10;this setting multiplies the analog input value with gain factor&#13;&#10;0 ... Gain of x1 (Default)&#13;&#10;1 ... Gain of x10&#13;&#10;&#13;&#10; "/>
		<Server Name="AI4SetLed" GUID="{977B1523-1363-4C19-BB52-20F3BB8A9A38}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Set LED Overwrite Register&#13;&#10;0 ... HW Status aktiv&#13;&#10;1 ... LED on&#13;&#10;2 ... LED off"/>
		<Server Name="ClassState">
		</Server>
		<Server Name="ConfigValid" GUID="{FC5C62FB-73DB-448C-A08E-9801B13D3798}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server shows the config valid state of analog input&#13;&#10; 1 ... configuration of the ADCs is valid&#13;&#10; 0 ... configuration of the ADCs is not valid&#13;&#10;-1 ... failed to send configuration to ADC"/>
		<Server Name="OversampleMode" GUID="{7FD0C3D0-7742-43B3-8A1C-58E66CAF3FC1}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Change between FPGA- / ADC-Oversampling&#13;&#10;0 ... FPGA (default)&#13;&#10;1 ... ADC"/>
		<Server Name="RangeError" GUID="{A8273EFA-62A0-48EE-81EE-4AA26E7B95B4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="range detection:&#13;&#10;Bit0 ... low range on AI1&#13;&#10;Bit1 ... low range on AI2&#13;&#10;Bit2 ... low range on AI3&#13;&#10;Bit3 ... low range on AI4&#13;&#10;&#13;&#10;(cablebreak)&#13;&#10;Bit4 ... high range on AI1&#13;&#10;Bit5 ... high range on AI2&#13;&#10;Bit6 ... high range on AI3&#13;&#10;Bit7 ... high range on AI4&#13;&#10;&#13;&#10;"/>
		<Server Name="Voltage24V" GUID="{44BA5C2E-C3AF-4849-A3C7-7378A7006010}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="this server show state of Voltage supply.&#13;&#10;0 ... Voltage not ok&#13;&#10;1 ... Voltage ok"/>
		<Client Name="AI1Active" Required="false" Internal="false" DefValue="1" Comment="The channel can be activated/ deactived with this client as init value.&#13;&#10;0 ... Channel is deactivated. &#13;&#10;1 ... Channel is activated. "/>
		<Client Name="AI1Freq" Required="true" Internal="false" DefValue="0" Comment="Cut off frequency for analog in 1 low pass filter&#13;&#10;0 ... off (default)&#13;&#10;1 ... 10kHz&#13;&#10;2 ... 5kHz&#13;&#10;3 ... 1000Hz(1kHz)&#13;&#10;4 ... 500Hz&#13;&#10;5 ... 100Hz&#13;&#10;6 ... 50Hz&#13;&#10;7 ... 25Hz&#13;&#10;8 ... 10Hz"/>
		<Client Name="AI1MaxValue" Required="true" Internal="false" DefValue="110000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-11V)&#13;&#10;As initvalue"/>
		<Client Name="AI1MinValue" Required="true" Internal="false" DefValue="-110000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-11V)&#13;&#10;As initvalue"/>
		<Client Name="AI2Active" Required="false" Internal="false" DefValue="1" Comment="The channel can be activated/ deactived with this client as init value.&#13;&#10;0 ... Channel is deactivated. &#13;&#10;1 ... Channel is activated. "/>
		<Client Name="AI2Freq" Required="false" Internal="false" DefValue="0" Comment="Cut off frequency for analog in 2 low pass filter&#13;&#10;0 ... off (default)&#13;&#10;1 ... 10kHz&#13;&#10;2 ... 5kHz&#13;&#10;3 ... 1000Hz(1kHz)&#13;&#10;4 ... 500Hz&#13;&#10;5 ... 100Hz&#13;&#10;6 ... 50Hz&#13;&#10;7 ... 25Hz&#13;&#10;8 ... 10Hz"/>
		<Client Name="AI2MaxValue" Required="true" Internal="false" DefValue="110000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-11V)&#13;&#10;As initvalue"/>
		<Client Name="AI2MinValue" Required="true" Internal="false" DefValue="-110000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-11V)&#13;&#10;As initvalue"/>
		<Client Name="AI3Active" Required="false" Internal="false" DefValue="1" Comment="The channel can be activated/ deactived with this client as init value.&#13;&#10;0 ... Channel is deactivated. &#13;&#10;1 ... Channel is activated. "/>
		<Client Name="AI3Freq" Required="false" Internal="false" DefValue="0" Comment="Cut off frequency for analog in 3 low pass filter&#13;&#10;0 ... off (default)&#13;&#10;1 ... 10kHz&#13;&#10;2 ... 5kHz&#13;&#10;3 ... 1000Hz(1kHz)&#13;&#10;4 ... 500Hz&#13;&#10;5 ... 100Hz&#13;&#10;6 ... 50Hz&#13;&#10;7 ... 25Hz&#13;&#10;8 ... 10Hz"/>
		<Client Name="AI3MaxValue" Required="true" Internal="false" DefValue="110000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-11V)&#13;&#10;As initvalue"/>
		<Client Name="AI3MinValue" Required="true" Internal="false" DefValue="-110000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-11V)&#13;&#10;As initvalue"/>
		<Client Name="AI4Active" Required="false" Internal="false" DefValue="1" Comment="The channel can be activated/ deactived with this client as init value.&#13;&#10;0 ... Channel is deactivated. &#13;&#10;1 ... Channel is activated. "/>
		<Client Name="AI4Freq" Required="false" Internal="false" DefValue="0" Comment="Cut off frequency for analog in 4 low pass filter&#13;&#10;0 ... off (default)&#13;&#10;1 ... 10kHz&#13;&#10;2 ... 5kHz&#13;&#10;3 ... 1000Hz(1kHz)&#13;&#10;4 ... 500Hz&#13;&#10;5 ... 100Hz&#13;&#10;6 ... 50Hz&#13;&#10;7 ... 25Hz&#13;&#10;8 ... 10Hz"/>
		<Client Name="AI4MaxValue" Required="true" Internal="false" DefValue="110000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-11V)&#13;&#10;As initvalue"/>
		<Client Name="AI4MinValue" Required="true" Internal="false" DefValue="-110000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-11V)&#13;&#10;As initvalue"/>
		<Client Name="SampleRate" Required="true" Internal="false" DefValue="0" Comment="Set amount of samples per mililsecond for each channel as init value!&#13;&#10;Minimum conversion time of all 4 analog inputs is 10 µsec.&#13;&#10;&#13;&#10;0 ... 1 sample per ms (1msec conversion time)&#13;&#10;1 ... 2 samples per ms (500µsec conversion time)&#13;&#10;2 ... 4 samples per ms (250µsec conversion time)&#13;&#10;3 ... 5 samples per ms (200µsec conversion time)&#13;&#10;4 ... 10 samples per ms (100µsec conversion time)&#13;&#10;5 ... 20 samples per ms (50µsec conversion time)&#13;&#10;6 ... 40 samples per ms (25µsec conversion time)&#13;&#10;7 ... 50 samples per ms (20µsec conversion time)&#13;&#10;8 ... 100 samples per ms (10µsec conversion time)"/>
		<Client Name="ValuesSize" Required="true" Internal="false" DefValue="1" Comment="set input value size&#13;&#10;0 ... 16 bit mode (2 byte value)&#13;&#10;1 ... 18 bit mode (4 byte value)&#13;&#10;"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FurDom"/>
		<Dokumentation Revision="1.8" Date="27.03.2020" Author="LanSte" Company="Sigmatek" Description="Fixed SyncOut0.usPeriodMulti for buscycle times smaller 1ms. This fixes an issue that the received data was sometimes inkonssitant."/>
		<Dokumentation Revision="1.7" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.6" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.5" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.4" Date="23.02.2018" Author="ZoePat&#13;&#10;PieSte" Company="Sigmatek" Description="Implemented NewInst command SDIAS_CLT_GET_ANALOG_DATA_BUFFER.&#13;&#10;Add numbers for the assignment of the log messages."/>
		<Dokumentation Revision="1.3" Date="23.01.2018&#13;&#10;01.02.2018" Author="RamAnd&#13;&#10;PieSte" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl.&#13;&#10;If an error occurs in AddAccesses (), it is triggered in ConnectEvent (). An unnecessary mutex has been removed."/>
		<Dokumentation Revision="1.2" Date="11.10.2017" Author="FurDom" Company="Sigmatek" Description="Added Flag &quot;ScaleAIx&quot; for check if a new calculation is necessary for AI1-4. -&gt; Realtime optimization. &#13;&#10;New calculation if Client AI_Min or AI_Max is not default."/>
		<Dokumentation Revision="1.1" Date="20.07.2017" Author="FurDom" Company="Sigmatek" Description="pDataCounter optionally added; "/>
		<Dokumentation Revision="1.0" Date="19.07.2017" Author="FurDom" Company="Sigmatek" Description="Initial Version"/>
	</RevDoku>
	<Network Name="AI046">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{DF465D76-0FC7-4452-ABC3-AFFE7BF93F51}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

AI046 : CLASS
: SdiasBase
	TYPE
#pragma pack(push, 1)
	  t_PDOReadModulInfo : STRUCT
	    BufferState : BINT
	    [
	      1 Ch1Full,
	      2 Ch2Full,
	      3 Ch3Full,
	      4 Ch4Full,
	      5 Ch1Empty,
	      6 Ch2Empty,
	      7 Ch3Empty,
	      8 Ch4Empty,
	      9 Ch1ReadEmptyBuffer,
	      10 Ch2ReadEmptyBuffer,
	      11 Ch3ReadEmptyBuffer,
	      12 Ch4ReadEmptyBuffer,
	      13 DC24NOKLatched,
	      14 DC24VOK,
	      15 Bit15,
	      16 Bit16,
	    ];
	    HardwareState : BSINT
	    [
	      1 Ch1UnderRange,
	      2 Ch2UnderRange,
	      3 Ch3UnderRange,
	      4 Ch4UnderRange,
	      5 Ch1OverRange,
	      6 Ch2OverRange,
	      7 Ch3OverRange,
	      8 Ch4OverRange,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PDOWriteData : STRUCT
	    ControlReg : BSINT
	    [
	      1 EnableCh1,
	      2 EnableCh2,
	      3 EnableCh3,
	      4 EnableCh4,
	      5 StartADC,
	      6 StartSynchronADC,
	      7 Bit7,
	      8 Bit8,
	    ];
	    LEDControlReg : BSINT
	    [
	      1 Led1Ch1,
	      2 Led2Ch1,
	      3 Led1Ch2,
	      4 Led2Ch2,
	      5 Led1Ch3,
	      6 Led2Ch3,
	      7 Led1Ch4,
	      8 Led2Ch4,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AccessReadData : STRUCT
	    pStateByte : t_SDIAS_pStateByte;
	    pControlByte : t_SDIAS_pControlByte;
	    AccessHandle : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AccessData : STRUCT
	    pReadDefaultAccess : ^t_PDOReadModulInfo;
	    pWriteDefaultAccess : ^t_PDOWriteData;
	    ReadAccessBuffer : ARRAY [0..AI046_MAX_ARRAY_ENTRYS-1] OF t_AccessReadData;
	    pReadBuffer : ARRAY [0..AI046_MAX_ARRAY_ENTRYS-1] OF ^INT;
	    usReadBufferDOActive : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_bChannels : STRUCT
	    Channel1 : BOOL;
	    Channel2 : BOOL;
	    Channel3 : BOOL;
	    Channel4 : BOOL;
	  END_STRUCT;
#pragma pack(pop)
	  t_bsBufferState : BSINT
	  [
	    1 Ch1Full,
	    2 Ch2Full,
	    3 Ch3Full,
	    4 Ch4Full,
	    5 Ch1Empty,
	    6 Ch2Empty,
	    7 Ch3Empty,
	    8 Ch4Empty,
	  ];
	  t_ConfigSSW :
	  (
	    _ConfigIdle,
	    _DeactivateConversion,
	    _WriteConfigSDO,
	    _ReadConfigSDO,
	    _ActivateConversion,
	    _FinishConfig,
	    _ErrorConfig
	  )$UDINT;
#pragma pack(push, 1)
	  t_Counter : STRUCT
	    ReadCnt : USINT;
	    WriteCnt : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_dChannels : STRUCT
	    Channel1 : DINT;
	    Channel2 : DINT;
	    Channel3 : DINT;
	    Channel4 : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_HWControlReg : BSINT
	  [
	    1 CurrentGain1,
	    2 CurrentGain2,
	    3 CurrentGain3,
	    4 reserved1,
	    5 CurrentSource1,
	    6 CurrentSource2,
	    7 reserved2,
	    8 reserved3,
	  ];
	  t_InitSSW :
	  (
	    _InitVariables,
	    _WriteHWConfig,
	    _DisablePll,
	    _ReadPll,
	    _SetPll,
	    _Wait4ADCReset,
	    _ActivateADC,
	    _Finish,
	    _InitError
	  )$UDINT;
#pragma pack(push, 1)
	  t_usChannels : STRUCT
	    Channel1 : USINT;
	    Channel2 : USINT;
	    Channel3 : USINT;
	    Channel4 : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_MeasureControl : STRUCT
	    MeasureActive : t_bChannels;
	    ArrayAssignment : STRUCT
	      ChArrayNr : t_usChannels;
	      ChArrayActivated : BSINT
	      [
	        1 Channel1,
	        2 Channel2,
	        3 Channel3,
	        4 Channel4,
	      ];
	      ChActivated : USINT;
	    END_STRUCT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SyncOut : STRUCT
	    uiOffset : UINT;
	    usPeriodMulti : USINT;
	    bsSyncStartDelay : BSINT
	    [
	      1 SyncStartDelay1,
	      2 SyncStartDelay2,
	      3 SyncStartDelay3,
	      4 SyncStartDelay4,
	    ];
	    hsSyncOutID : HSINT;
	    bsControlState : BSINT
	    [
	      1 SyncEnable,
	      2 StartDelayEnable,
	      3 SyncSelector,
	    ];
	    uiReserved : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PllRegister : STRUCT
	    udSystemPerTime : UDINT;
	    udSystemPerTimeMeasure : UDINT;
	    bsStateControlReg : BSINT
	    [
	      1 locked_res1,
	      2 unlocked_res2,
	      3 Soft_enable,
	      4 res3,
	      5 res4,
	      6 res5,
	      7 res6,
	      8 res7,
	    ];
	    usSystemPeriodeDividier : USINT;
	    bsCompDelay : BSINT
	    [
	    ];
	    usReserved : USINT;
	    SyncOut0 : t_SyncOut;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
#pragma pack(push, 1)
	  t_ScaleSetting : STRUCT
	    Divider : t_dChannels;
	    Multiplier : t_dChannels;
	    Offset : t_dChannels;
	    bRawValue : t_bChannels;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SDOHardwareControl : STRUCT
	    ConversionTime : UINT;
	    AmountofConversions : USINT;
	    FPGAOversample : BSINT  //! <Type Comment="FPGA Oversampling&#13;&#10;Bit 2..0: Oversampling through FPGA&#13;&#10;Number of Samples = 2^Oversampling&#13;&#10;Bit 7..3: reserved&#13;&#10;" Name="t_SDOHardwareControl.FPGAOversample"/>
	    [
	      1 OversampleBit1,
	      2 OversampleBit2,
	      3 OversampleBit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
#pragma pack(push, 2)
	    IIRFilter : STRUCT  //! <Type Comment="cut-off frequency IIR Filter channel 1 - 4 [Hz]&#13;&#10;0 = off, min. 10 Hz&#13;&#10;" Name="t_SDOHardwareControl.IIRFilter"/>
	      AI1FilterFreq : UINT;
	      AI2FilterFreq : UINT;
	      AI3FilterFreq : UINT;
	      AI4FilterFreq : UINT;
	    END_STRUCT;
#pragma pack(pop)
	    IOExpanderRegister : BSINT  //! <Type Comment="Bit 2..0: ADC Oversample Bits&#13;&#10;Bit 3: ADC Reset&#13;&#10;&#13;&#10;Für Strom wird automatisch die Verstärkung 10x gewählt und kann nicht verändert werden (Registerwert wird ignoriert), für Spannung kann zwischen 1x und 10x gewählt werden&#13;&#10;Bit 4: Strom-/Spannungsverstärkung Kanal 1 &#13;&#10;(0 = 1x, 1 = 10x Verstärkung)&#13;&#10;Bit 5: Strom-/Spannungsverstärkung Kanal 2 &#13;&#10;Bit 6: Strom-/Spannungsverstärkung Kanal 3 &#13;&#10;Bit 7: Strom-/Spannungsverstärkung Kanal 4&#13;&#10;" Name="t_SDOHardwareControl.IOExpanderRegister"/>
	    [
	      1 ADCOversampleBit1,
	      2 ADCOversampleBit2,
	      3 ADCOversampleBit3,
	      4 ADCReset,
	      5 GainCh1,
	      6 GainCh2,
	      7 GainCh3,
	      8 GainCh4,
	    ];
	    bsAIConfiguration : BSINT  //! <Type Comment="Enable lower threshold current module (4-20mA Mode)&#13;&#10;Bit 0: threshold detection channel 1 acitve&#13;&#10;Bit 1: threshold detection channel 2 acitve&#13;&#10;Bit 2: threshold detection channel 3 acitve&#13;&#10;Bit 3: threshold detection channel 4 acitve&#13;&#10;Bit 7..4: reserved&#13;&#10;" Name="t_SDOHardwareControl.bsAIConfiguration"/>
	    [
	      1 AI1Cfg,
	      2 AI2Cfg,
	      3 AI3Cfg,
	      4 AI4Cfg,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	    LowerCablebreakLimit : UDINT;  //! <Type Comment="(Sign Bit irrelevant)&#13;&#10;Bit 16..0: lower threshold&#13;&#10;Bit 31..17: Reserviert&#13;&#10;" Name="t_SDOHardwareControl.LowerCablebreakLimit"/>
	    StatusRegister : BSINT  //! <Type Comment="Fehler/Status Register&#13;&#10;Bit 0: Abgleichdaten konnten nicht gelesen werden&#13;&#10;Bit 1: Abgleichdaten ungültig (CRC Fehler) &#13;&#10;Bit 2: IIR Filterberechnung Fehler (verodert)&#13;&#10;Bit 3: µC Operational (1 = aktiv) (nur lesen)&#13;&#10;Bit 4: Strom- oder Spannungsmessung (1 = Strom, 0 = Spannung), Erkennung über Pin-Beschaltung/Bestückungsvariante, gefiltert&#13;&#10;Bit 7..5: Reserve&#13;&#10;" Name="t_SDOHardwareControl.StatusRegister"/>
	    [
	      1 NoCalibData,
	      2 CalibDataCRCError,
	      3 IIRCalculateError,
	      4 ControllerOP,
	      5 Voltage_Gain,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	    ControlRegister : BSINT  //! <Type Comment="Kontroll Register &#13;&#10;Bit 0: MicroBlaze Wertebereich zu FiFo (0 = 32 bit Zugriff mit 18 bit Wert, 1 = 16 bit Zugriff von 18 bit Wert die Bits 17:2) &#13;&#10;Bit 5..1: Reserve&#13;&#10;Bit 6: Konfiguration neu laden (1= Tick zu MicroBlaze, irq_config)&#13;&#10;Bit 7: MicroBlaze (µC) Reset (1 = MicroBlaze im Reset)&#13;&#10;" Name="t_SDOHardwareControl.ControlRegister"/>
	    [
	      1 Value18_16Bit,
	      2 Bit2,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 LoadConfigNew,
	      8 MicroBlazeReset,
	    ];
	    IIRFilterError : BSINT
	    [
	      1 OverflowCh1,
	      2 OverflowCh2,
	      3 OverflowCh3,
	      4 OverflowCh4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPIReadData : STRUCT
	    IDHeader : t_SPI_ListHeader;
	    udMaxDataLength : UDINT;
	    udActReadLength : UDINT;
	    udReadLength : UDINT;
	    udReadOffset : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPIWriteData : STRUCT
	    usBytesToWrite : USINT;
	    usBytesActWrite : USINT;
	    usWriteOffset : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_uiChannels : STRUCT
	    Channel1 : UINT;
	    Channel2 : UINT;
	    Channel3 : UINT;
	    Channel4 : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_WriteControlCh : STRUCT
	    ControlCh : BSINT
	    [
	      1 EnableCh1,
	      2 EnableCh2,
	      3 EnableCh3,
	      4 EnableCh4,
	    ];
	    StartCh : BSINT
	    [
	      1 StartCh1,
	      2 StartCh2,
	      3 StartCh3,
	      4 StartCh4,
	      5 StartSynchronCh1,
	      6 StartSynchronCh2,
	      7 StartSynchronCh3,
	      8 StartSynchronCh4,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ConfigValid 	: SvrCh_DINT;
	AI1 	: SvrCh_DINT;
	AI1Gain 	: SvrCh_DINT;
	AI1SetLed 	: SvrCh_DINT;
	AI2 	: SvrCh_DINT;
	AI2Gain 	: SvrCh_DINT;
	AI2SetLed 	: SvrCh_DINT;
	AI3 	: SvrCh_DINT;
	AI3Gain 	: SvrCh_DINT;
	AI3SetLed 	: SvrCh_DINT;
	AI4 	: SvrCh_DINT;
	AI4Gain 	: SvrCh_DINT;
	AI4SetLed 	: SvrCh_DINT;
	Voltage24V 	: SvrCh_DINT;
	OversampleMode 	: SvrCh_DINT;
	RangeError 	: SvrCh_BDINT;
  //Clients:
	AI1Active 	: CltCh_DINT;
	AI1MaxValue 	: CltCh_DINT;
	AI1MinValue 	: CltCh_DINT;
	AI1Freq 	: CltCh_UDINT;
	AI2Active 	: CltCh_DINT;
	AI2MaxValue 	: CltCh_DINT;
	AI2MinValue 	: CltCh_DINT;
	AI2Freq 	: CltCh_UDINT;
	AI3Active 	: CltCh_DINT;
	AI3MaxValue 	: CltCh_DINT;
	AI3MinValue 	: CltCh_DINT;
	AI3Freq 	: CltCh_UDINT;
	AI4Active 	: CltCh_DINT;
	AI4MaxValue 	: CltCh_DINT;
	AI4MinValue 	: CltCh_DINT;
	AI4Freq 	: CltCh_UDINT;
	SampleRate 	: CltCh_DINT;
	ValuesSize 	: CltCh_DINT;
  //Variables:
		sAccesses 	: t_AccessData;
		sMeasureControl 	: t_MeasureControl;
		sSPIReadData 	: t_SPIReadData;
		sSPIWriteData 	: t_SPIWriteData;
		sHWControlWrite 	: t_SDOHardwareControl;
		sHWControlRead 	: t_SDOHardwareControl;
		sWriteADCStart 	: t_WriteControlCh;
		sPLLRegister 	: t_PllRegister;
		eInitSSW 	: t_InitSSW;
		eInitSSWErrorStep 	: t_InitSSW;
		eConfigSSW 	: t_ConfigSSW;
		eConfigSSWErrorStep 	: t_ConfigSSW;
		eResponseState 	: t_ResponseState;
		udSDOTimeout 	: UDINT;
		udSDOWait4Config 	: UDINT;
		uiMaxValuesCycle 	: UINT;
		bInitConfig 	: BOOL;
		udBusCycleTimeMicroSec 	: UDINT;
		sScaleSettings 	: t_ScaleSetting;
		uiSampleRate 	: UINT;
		usOneValueSize 	: USINT;
		sControlReg 	: t_PDOWriteData;
		uiEmptyCycle 	: UINT;
		aEmptyCycleCnt : ARRAY [0..AI046_NUMBER_OF_ANALOG_IN-1] OF UINT;

		bConfigChanged 	: BOOL;
		AI1Old 	: DINT;
		AI2Old 	: DINT;
		AI3Old 	: DINT;
		AI4Old 	: DINT;
		udReadSDOStart 	: UDINT;
		aDataCnt : ARRAY [0..AI046_NUMBER_OF_ANALOG_IN-1] OF UDINT;

		ScaleAI1 	: BOOL;
		ScaleAI2 	: BOOL;
		ScaleAI3 	: BOOL;
		ScaleAI4 	: BOOL;
		sModuleState 	: t_PDOReadModulInfo;
		usPllSyncPeriodMulti 	: USINT;
  //Functions:
				//! <Function Comment="Constructor of Class" Name="AI046"/>
	FUNCTION AI046
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Cyclic Update Methode which runs in PostScan." Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION StartMeasure
		VAR_INPUT
			bStartStop 	: BOOL;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="methode is called to get data from fifo buffer." Name="GetData"/>
	FUNCTION GLOBAL GetData
		VAR_INPUT
			usChannelNr 	: USINT;			//! <Variable Comment="select analog input channel to read data (1-4)" Name="GetData.usChannelNr"/>
			uiDataLength 	: UINT;			//! <Variable Comment="length of requested data in bytes&#13;&#10;e.g. 10 requested values = 20bytes" Name="GetData.uiDataLength"/>
			pBufferData 	: ^void;			//! <Variable Comment="pointer to databuffer" Name="GetData.pBufferData"/>
			pDataCounter 	: ^UDINT := NIL;			//! <Variable Comment="if the pointer is valid and there are no errors in the method, the current data counter will be written to it&apos;s content to show if there are new data" Name="GetData.pDataCounter"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment=" 0..data is valid&#13;&#10;-1..requested channel is not activated&#13;&#10;-2..requested channel is not available&#13;&#10;-3..requested datalength is to long&#13;&#10;-4..data from channel is not valid" Name="GetData.dRetcode"/>
		END_VAR;
	
	FUNCTION HWConfigModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
	
	FUNCTION SetScale
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Lookup-Methode to get the Frequency-Setting for the µC" Name="SetFrequency"/>
	FUNCTION SetFrequency
		VAR_INPUT
			ClientValue 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Frequency 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI1Gain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI1SetLed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI2Gain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI2SetLed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI3Gain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI3SetLed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI4Gain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI4SetLed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OversampleMode::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AI046::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_AI046
1$UINT, 8$UINT, (SIZEOF(::AI046))$UINT, 
16$UINT, 18$UINT, 0$UINT, 
TO_UDINT(357962413), "AI046", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::AI046.ConfigValid.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3431042044), "ConfigValid", 
(::AI046.AI1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4269591187), "AI1", 
(::AI046.AI1Gain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(205681801), "AI1Gain", 
(::AI046.AI1SetLed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3430878002), "AI1SetLed", 
(::AI046.AI2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1735760681), "AI2", 
(::AI046.AI2Gain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1273106009), "AI2Gain", 
(::AI046.AI2SetLed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4254536111), "AI2SetLed", 
(::AI046.AI3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(275950527), "AI3", 
(::AI046.AI3Gain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1988241385), "AI3Gain", 
(::AI046.AI3SetLed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1541413403), "AI3SetLed", 
(::AI046.AI4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2383822364), "AI4", 
(::AI046.AI4Gain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3299015673), "AI4Gain", 
(::AI046.AI4SetLed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2655462549), "AI4SetLed", 
(::AI046.Voltage24V.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1674808318), "Voltage24V", 
(::AI046.OversampleMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2248018624), "OversampleMode", 
(::AI046.RangeError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(419930220), "RangeError", 
//Clients:
(::AI046.AI1Active.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(486731501), "AI1Active", 
(::AI046.AI1MaxValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3147612618), "AI1MaxValue", 
(::AI046.AI1MinValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1576824363), "AI1MinValue", 
(::AI046.AI1Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2334346300), "AI1Freq", 
(::AI046.AI2Active.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(753595504), "AI2Active", 
(::AI046.AI2MaxValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2182216975), "AI2MaxValue", 
(::AI046.AI2MinValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1685148398), "AI2MinValue", 
(::AI046.AI2Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3431151340), "AI2Freq", 
(::AI046.AI3Active.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2325610436), "AI3Active", 
(::AI046.AI3MaxValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2506811724), "AI3MaxValue", 
(::AI046.AI3MinValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1930053293), "AI3MinValue", 
(::AI046.AI3Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4058193756), "AI3Freq", 
(::AI046.AI4Active.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1329250634), "AI4Active", 
(::AI046.AI4MaxValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4044063877), "AI4MaxValue", 
(::AI046.AI4MinValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(392899428), "AI4MinValue", 
(::AI046.AI4Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1136902988), "AI4Freq", 
(::AI046.SampleRate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3384372301), "SampleRate", 
(::AI046.ValuesSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1367449737), "ValuesSize", 
END_FUNCTION


#define USER_CNT_AI046 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AI046] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AI046::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AI046;
	vmt.CmdTable.NewInstr		:= #ClassState::NewInst();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI1Gain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI1Gain::Write() );
	IF AI1Gain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI1SetLed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI1SetLed::Write() );
	IF AI1SetLed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI2Gain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI2Gain::Write() );
	IF AI2Gain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI2SetLed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI2SetLed::Write() );
	IF AI2SetLed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI3Gain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI3Gain::Write() );
	IF AI3Gain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI3SetLed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI3SetLed::Write() );
	IF AI3SetLed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI4Gain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI4Gain::Write() );
	IF AI4Gain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI4SetLed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI4SetLed::Write() );
	IF AI4SetLed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	OversampleMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #OversampleMode::Write() );
	IF OversampleMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AI046();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL AI046::UpdateRt
  VAR
    dTempAnalogIn : DINT;
  END_VAR
  
  sModuleState  := sAccesses.pReadDefaultAccess^;
  Voltage24V    := sModuleState.BufferState.DC24VOK;
  RangeError    := sModuleState.HardwareState AND 0xFF;
  
  //check Voltage supply
  if Voltage24V & ConfigValid then 
  
    //No update of adc values and states, while configuration isn't confirmed, check Overrange and Underrange
    if (sWriteADCStart.ControlCh.EnableCh1 = TRUE) & (sModuleState.HardwareState.Ch1UnderRange = FALSE) & (sModuleState.HardwareState.Ch1OverRange = FALSE) then
      //check Bufferstate
      if sModuleState.BufferState.Ch1Empty = FALSE then
        if sHWControlWrite.ControlRegister.Value18_16Bit = TRUE then
          //16Bit mode
          dTempAnalogIn := (sAccesses.pReadBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel1]+AI046_INPUT_RAW_VALUE_PLACE_16BIT)^;           
        else
          //18Bit mode
          dTempAnalogIn := ((sAccesses.pReadBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel1]+(AI046_INPUT_RAW_VALUE_PLACE_18BIT))^$DINT); 
        end_if;
        if ScaleAI1 then
          AI1 := ((dTempAnalogIn+sScaleSettings.Offset.Channel1) * sScaleSettings.Multiplier.Channel1)/sScaleSettings.Divider.Channel1;
        else
          AI1 := (dTempAnalogIn+sScaleSettings.Offset.Channel1);
        end_if;
        AI1Old := AI1; //Save value from AI1
        aEmptyCycleCnt[0] := 1;
        aDataCnt[0] += 1; // new data available
      else  //Buffer empty
        if aEmptyCycleCnt[0] < uiEmptyCycle then
          AI1 := AI1Old;
          aEmptyCycleCnt[0] += 1;
        else
          AI1 := AI046_INVALID_VALUE; 
        end_if;
      end_if;
    else
      AI1 := AI046_INVALID_VALUE; 
    end_if;
      
    //No update of adc values and states, while configuration isn't confirmed, check Overrange and Underrange
    if (sWriteADCStart.ControlCh.EnableCh2 = TRUE) & (sModuleState.HardwareState.Ch2UnderRange = FALSE) & (sModuleState.HardwareState.Ch2OverRange = FALSE) then
      //check Bufferstate
      if sModuleState.BufferState.Ch2Empty = FALSE then
        if sHWControlWrite.ControlRegister.Value18_16Bit = TRUE then
          //16Bit mode
          dTempAnalogIn := (sAccesses.pReadBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel2]+AI046_INPUT_RAW_VALUE_PLACE_16BIT)^;           
        else
          //18Bit mode
          dTempAnalogIn := ((sAccesses.pReadBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel2]+(AI046_INPUT_RAW_VALUE_PLACE_18BIT))^$DINT); 
        end_if;
        if ScaleAI2 then
          AI2 := ((dTempAnalogIn+sScaleSettings.Offset.Channel2) * sScaleSettings.Multiplier.Channel2)/sScaleSettings.Divider.Channel2;        
        else
          AI2 := (dTempAnalogIn+sScaleSettings.Offset.Channel2);
        end_if;
        AI2Old := AI2;
        aEmptyCycleCnt[1] := 1;
        aDataCnt[1] += 1; // new data available
      else  //Buffer empty
        if aEmptyCycleCnt[1] < uiEmptyCycle then
          AI2 := AI2Old;
          aEmptyCycleCnt[1] += 1;
        else
          AI2 := AI046_INVALID_VALUE; 
        end_if;
      end_if;
    else
      AI2 := AI046_INVALID_VALUE; 
    end_if;
    
    //No update of adc values and states, while configuration isn't confirmed, check Overrange and Underrange
    if (sWriteADCStart.ControlCh.EnableCh3 = TRUE) & (sModuleState.HardwareState.Ch3UnderRange = FALSE) & (sModuleState.HardwareState.Ch3OverRange = FALSE) then
      //check Bufferstate
      if sModuleState.BufferState.Ch3Empty = FALSE then
        if sHWControlWrite.ControlRegister.Value18_16Bit = TRUE then
          //16Bit mode
          dTempAnalogIn := (sAccesses.pReadBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel3]+AI046_INPUT_RAW_VALUE_PLACE_16BIT)^;           
        else
          //18Bit mode
          dTempAnalogIn := ((sAccesses.pReadBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel3]+(AI046_INPUT_RAW_VALUE_PLACE_18BIT))^$DINT); 
        end_if;
        if ScaleAI3 then
          AI3 := ((dTempAnalogIn+sScaleSettings.Offset.Channel3) * sScaleSettings.Multiplier.Channel3)/sScaleSettings.Divider.Channel3;        
        else
          AI3 := (dTempAnalogIn+sScaleSettings.Offset.Channel3);
        end_if;
        AI3Old := AI3;
        aEmptyCycleCnt[2] := 1;
        aDataCnt[2] += 1; // new data available
      else  //Buffer empty
        if aEmptyCycleCnt[2] < uiEmptyCycle then
          AI3 := AI3Old;
          aEmptyCycleCnt[2] += 1;
        else
          AI3 := AI046_INVALID_VALUE; 
        end_if;
      end_if;
    else
      AI3 := AI046_INVALID_VALUE; 
    end_if;

    //No update of adc values and states, while configuration isn't confirmed, check Overrange and Underrange
    if (sWriteADCStart.ControlCh.EnableCh4 = TRUE) & (sModuleState.HardwareState.Ch4UnderRange = FALSE) & (sModuleState.HardwareState.Ch4OverRange = FALSE) then
      //check Bufferstate
      if sModuleState.BufferState.Ch4Empty = FALSE then
        if sHWControlWrite.ControlRegister.Value18_16Bit = TRUE then
          //16Bit mode
          dTempAnalogIn := (sAccesses.pReadBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel4]+AI046_INPUT_RAW_VALUE_PLACE_16BIT)^;           
        else
          //18Bit mode
          dTempAnalogIn := ((sAccesses.pReadBuffer[sMeasureControl.ArrayAssignment.ChArrayNr.Channel4]+(AI046_INPUT_RAW_VALUE_PLACE_18BIT))^$DINT); 
        end_if;
        if ScaleAI4 then
          AI4 := ((dTempAnalogIn+sScaleSettings.Offset.Channel4) * sScaleSettings.Multiplier.Channel4)/sScaleSettings.Divider.Channel4;        
        else
          AI4 := (dTempAnalogIn+sScaleSettings.Offset.Channel4);
        end_if;
        AI4Old := AI4;
        aEmptyCycleCnt[3] := 1;
        aDataCnt[3] += 1; // new data available
      else  //Buffer empty
        if aEmptyCycleCnt[3] < uiEmptyCycle then
          AI4 := AI4Old;
          aEmptyCycleCnt[3] += 1;
        else
          AI4 := AI046_INVALID_VALUE; 
        end_if;
      end_if;
    else
      AI4 := AI046_INVALID_VALUE; 
    end_if;

  else
    AI1 := AI046_INVALID_VALUE; 
    AI2 := AI046_INVALID_VALUE;
    AI3 := AI046_INVALID_VALUE;
    AI4 := AI046_INVALID_VALUE;
  end_if;     
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::UpdateRtPostScan

  sAccesses.pWriteDefaultAccess^ := sControlReg;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::UpdateCy
  VAR
    dRetCode : iprStates;
  END_VAR

  if ClassState = _ClassOk 
  & Voltage24V then
    if bConfigChanged = TRUE | eConfigSSW <> _ConfigIdle then
      dRetCode := HWConfigModule();
      if dRetCode = Ready then
        ConfigValid := 1;
      end_if;
    end_if;    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	usCnt             : USINT;
    usDOCnt           : USINT;
    pHelp             : ^USINT;
    uiActDoLength     : UINT;
    uiNextDoLength    : UINT;
    uiConversionTime  : UINT;
    udtempPeriodMulti : UDINT;
  END_VAR
  
  usDOCnt := 0;
  
  //read clients
  AI1Active := AI1Active.Read();
  AI2Active := AI2Active.Read();
  AI3Active := AI3Active.Read();
  AI4Active := AI4Active.Read();  
  
  //analog input 1
  //*************************************************************************************************************
  if AI1Active then
    sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 := 1;
    sMeasureControl.ArrayAssignment.ChActivated += 1;
  end_if;
  
  //analog input 2
  //*************************************************************************************************************
  if AI2Active then
    sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 := 1;
    sMeasureControl.ArrayAssignment.ChActivated += 1;
  end_if;
  
  //analog input 3
  //*************************************************************************************************************
  if AI3Active then
    sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 := 1;
    sMeasureControl.ArrayAssignment.ChActivated += 1;
  end_if;
  
  //analog input 4
  //*************************************************************************************************************
  if AI4Active then
    sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 := 1;
    sMeasureControl.ArrayAssignment.ChActivated += 1;
  end_if; 

  if sMeasureControl.ArrayAssignment.ChActivated = 0 then  
    LogError("@0135 (AI046::AddAccesses) There is no channel activated.");    
  else
    //every channel can be converted every 10ms
    sMeasureControl.ArrayAssignment.ChActivated := 1;
  end_if;  
  
  SampleRate := SampleRate.Read();
  
  case SampleRate of
    0://every ms one sample
      uiSampleRate  := 1; 
    1://every ms 2 samples
      uiSampleRate  := 2;
    2://every ms 4 samples
      uiSampleRate  := 4;
    3://every ms 5 samples
      uiSampleRate  := 5;
    4://every ms 10 samples
      uiSampleRate  := 10;
    5://every ms 20 samples
      uiSampleRate  := 20;
    6://every ms 40 samples
      uiSampleRate  := 40;
    7://every ms 50 samples
      uiSampleRate  := 50;
    8://every ms 100 samples
      uiSampleRate  := 100;
  else
    //Default sample  
    //every ms one sample
    uiSampleRate  := 1;
  end_case;  
  
  //Get bus cycle time
  udBusCycleTimeMicroSec := udBusTime/1000;  // ns => us
  
  // Conversiontime is always per 1ms
  uiConversionTime := 1000/uiSampleRate;
  
  // Calc Pll Sync Multiplier
  usPllSyncPeriodMulti := 1;
  if udBusCycleTimeMicroSec < uiConversionTime then
    
    // Multipler is set so there is at least 1 sample per BusCycleTime * Multiplier
    udtempPeriodMulti := to_udint(uiConversionTime) / udBusCycleTimeMicroSec;
    if ( (uiConversionTime mod udBusCycleTimeMicroSec) = 0) & // Multiplier must be whole number
         (udtempPeriodMulti <= 16#FF) then                    // Multiplier/FPGA Register is 1 Byte
      
      usPllSyncPeriodMulti := udtempPeriodMulti$USINT;
    else

      HWC_LogPrintf(pThis:=this, format:= "@06AB (AI046::AddAccesses) Invalid combination of buscycle time %V4us and conversion time %V2us.",
                    p0:=#udBusCycleTimeMicroSec, p1:=#uiConversionTime);
      eModuleInitState := ERROR;
      eInitState       := _InvalidConfguration;
      return;
    end_if;
    
  elsif ((udBusCycleTimeMicroSec mod uiConversionTime) <> 0) then
    HWC_LogPrintf(pThis:=this, format:= "@06AB (AI046::AddAccesses) Invalid combination of buscycle time %V4us and conversion time %V2us.",
                  p0:=#udBusCycleTimeMicroSec, p1:=#uiConversionTime);
    eModuleInitState := ERROR;
    eInitState       := _InvalidConfguration;
    return;
  end_if;

  //get maximal filtervalues per cycle
  uiMaxValuesCycle := to_uint(udBusCycleTimeMicroSec/uiConversionTime);
  if uiMaxValuesCycle < 1 then
    uiMaxValuesCycle := 1;
    uiEmptyCycle := (uiConversionTime/udBusCycleTimeMicroSec$UINT);
    //check residual value
    if (uiConversionTime mod udBusCycleTimeMicroSec) <> 0 then
      uiEmptyCycle += 1;
    end_if;
  else
    uiEmptyCycle := 1;
  end_if;  
  ValuesSize := ValuesSize.Read();
  
  //18Bit mode
  if ValuesSize <> 0 then    
    if uiMaxValuesCycle > (AI046_FULL_BUFFERSIZE/AI046_SIZE_ONE_VALUE_18BIT) then
      LogError("@014D (AI046::AddAccesses) Client SampleRate is set too high!");        
      eModuleInitState := ERROR;
      eInitState       := _InvalidConfguration;
      return;
    end_if;
    usOneValueSize := AI046_SIZE_ONE_VALUE_18BIT;
    sHWControlWrite.ControlRegister.Value18_16Bit := FALSE;
  else	//16Bit mode
    if uiMaxValuesCycle > (AI046_FULL_BUFFERSIZE/AI046_SIZE_ONE_VALUE_16BIT) then
      LogError("@014D (AI046::AddAccesses) Client SampleRate is set too high!");        
      eModuleInitState := ERROR;
      eInitState       := _InvalidConfguration;
      return;
    end_if;  
    usOneValueSize := AI046_SIZE_ONE_VALUE_16BIT;
    sHWControlWrite.ControlRegister.Value18_16Bit := TRUE;
  end_if;
  
  usDOCnt := 0;
  
  pHelp := #sMeasureControl.ArrayAssignment.ChArrayNr.Channel1;
  for usCnt := 0 to AI046_NUMBER_OF_ANALOG_IN - 1 do 
    if ((sMeasureControl.ArrayAssignment.ChArrayActivated$USINT shr usCnt)AND 2#1 = TRUE) then
    
      pHelp^  := usDOCnt;
      pHelp   += sizeof(pHelp^);
      uiNextDoLength := (to_uint(uiMaxValuesCycle)) * usOneValueSize;
      while uiNextDoLength do
        if (uiNextDoLength) > AI046_MAX_LENGTH_ONE_READ then
          uiActDoLength := AI046_MAX_LENGTH_ONE_READ; 
        else  
          uiActDoLength := uiNextDoLength;
        end_if;
        
        eModuleInitState := AddRdAccess(hOffset       := AI046_MAX_LENGTH_ONE_READ * usCnt
                                      , uLength       := uiActDoLength
                                      , ppData        := #sAccesses.pReadBuffer[usDOCnt]
                                      , ppStateByte   := #sAccesses.ReadAccessBuffer[usDOCnt].pStateByte
                                      , ppControlByte := #sAccesses.ReadAccessBuffer[usDOCnt].pControlByte
                                      , pAccessHandle := #sAccesses.ReadAccessBuffer[usDOCnt].AccessHandle);
                                       
        if eModuleInitState <> READY then
          LogError("@013A (AI046::AddAccesses) Failed to add iso read access for SDIAS module.");          
          eModuleInitState := ERROR;
          eInitState       := _InvalidConfguration;
          return;
        end_if;
        uiNextDoLength -= uiActDoLength;
        usDOCnt += 1;
      end_while;        
    else
      pHelp^ := 16#FF;
      pHelp  += sizeof(pHelp^);
    end_if;
  end_for;
  sAccesses.usReadBufferDOActive  := usDOCnt;
  sHWControlWrite.ConversionTime  := uiConversionTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::ConnectEvent
  VAR
  	usCnt : USINT;
  END_VAR
  
  //start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  if DefaultAccesses.ReadAccess.pControlByte then
    sAccesses.pReadDefaultAccess := DefaultAccesses.ReadAccess.pData$^t_PDOReadModulInfo;
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  //start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  if DefaultAccesses.WriteAccess.pControlByte then
    sAccesses.pWriteDefaultAccess := DefaultAccesses.WriteAccess.pData$^t_PDOWriteData;
    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;

  //start the access for read buffer
  if sAccesses.usReadBufferDOActive then
    for usCnt := 0 to sAccesses.usReadBufferDOActive - 1 do  
      if sAccesses.ReadAccessBuffer[usCnt].pControlByte  then
        sAccesses.ReadAccessBuffer[usCnt].pControlByte^.EnableDO := TRUE;
      else    
        eInitState := _DOHandleInvalid;
        return;
      end_if;
    end_for;
  else  
    //if any channel is activated and no data object is active it is a error
    if AI1Active | AI2Active | AI3Active | AI4Active then
      eInitState := _DOHandleInvalid;
      return;      
    end_if;
  end_if; 
     
  //init adc values
  bInitConfig  := TRUE;
   
  //Set eInitState due to Plug&Play behaviour
  eInitState      := _NotInitialized;  
  eInitSSW        := _InitVariables; 
  eResponseState  := _idle;

END_FUNCTION


FUNCTION AI046::StartMeasure
	VAR_INPUT
		bStartStop 	      : BOOL;
	END_VAR
	VAR_OUTPUT
		dRetcode 	        : DINT;
	END_VAR
  VAR
  	bChannelAvailable : BOOL;
  END_VAR
  
  dRetcode          := 0;  
  bChannelAvailable := FALSE;
  
  //analog input 1
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 = TRUE then
    sControlReg.ControlReg.EnableCh1        := bStartStop;
    sWriteADCStart.ControlCh.EnableCh1      := bStartStop;
    sMeasureControl.MeasureActive.Channel1  := bStartStop;
    bChannelAvailable := TRUE;
  end_if;

  //analog input 2
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 = TRUE then
    sControlReg.ControlReg.EnableCh2        := bStartStop;
    sWriteADCStart.ControlCh.EnableCh2      := bStartStop;
    sMeasureControl.MeasureActive.Channel2  := bStartStop;
    bChannelAvailable := TRUE;
  end_if;
  
  //analog input 3
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 = TRUE then
    sControlReg.ControlReg.EnableCh3        := bStartStop;
    sWriteADCStart.ControlCh.EnableCh3      := bStartStop;
    sMeasureControl.MeasureActive.Channel3  := bStartStop;
    bChannelAvailable := TRUE;
  end_if;

  //analog input 4
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 = TRUE then
    sControlReg.ControlReg.EnableCh4        := bStartStop;
    sWriteADCStart.ControlCh.EnableCh4      := bStartStop;    
    sMeasureControl.MeasureActive.Channel4  := bStartStop;
    bChannelAvailable := TRUE;
  end_if; 
  
  if bChannelAvailable = FALSE then
    dRetcode := -1;     //channel is not activated
    return;
  end_if;
  sControlReg.ControlReg.StartSynchronADC := bStartStop;
  
END_FUNCTION


FUNCTION GLOBAL AI046::GetData
	VAR_INPUT
		usChannelNr 	: USINT;
		uiDataLength 	: UINT;
		pBufferData 	: ^void;
		pDataCounter 	: ^UDINT;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  VAR
  	uiTempBufferIndex : UINT;
    usDoCnt           : USINT;
    uiActReadData     : UINT;
    uiNextReadData    : UINT;
    uiReadOffset      : UINT;
  END_VAR
  
  dRetcode := 0;
  
  case usChannelNr of   
  //analog input 1
  //*************************************************************************************************************
    1: 
      if sMeasureControl.MeasureActive.Channel1 then
        if AI1 <> AI046_INVALID_VALUE then
          uiTempBufferIndex := sMeasureControl.ArrayAssignment.ChArrayNr.Channel1;
        else
          dRetcode := -4;  //data of analog input is not valid
        end_if;        
      else
        dRetcode := -1;   //channel is not activated
      end_if;        
    
  //analog input 2
  //*************************************************************************************************************
    2:  
      if sMeasureControl.MeasureActive.Channel2 then
        if AI2 <> AI046_INVALID_VALUE then
          uiTempBufferIndex := sMeasureControl.ArrayAssignment.ChArrayNr.Channel2;
        else
          dRetcode := -4;  //data of analog input is not valid
        end_if;        
      else
        dRetcode := -1;   //channel is not activated
      end_if;
    
  //analog input 3
  //*************************************************************************************************************
    3: 
      if sMeasureControl.MeasureActive.Channel3 then
        if AI3 <> AI046_INVALID_VALUE then
          uiTempBufferIndex := sMeasureControl.ArrayAssignment.ChArrayNr.Channel3;
        else
          dRetcode := -4;  //data of analog input is not valid
        end_if;        
      else
        dRetcode := -1;   //channel is not activated
      end_if; 
    
  //analog input 4
  //*************************************************************************************************************
    4:  
      if sMeasureControl.MeasureActive.Channel4 then
        if AI4 <> AI046_INVALID_VALUE then
          uiTempBufferIndex := sMeasureControl.ArrayAssignment.ChArrayNr.Channel4;
        else
          dRetcode := -4;  //data of analog input is not valid
        end_if;        
      else
        dRetcode := -1;   //channel is not activated
      end_if;    
      
  //*************************************************************************************************************
  else    
    dRetcode := -2;  //channel number is not available;
    return;
  end_case;
  
  if uiDataLength > (uiMaxValuesCycle*usOneValueSize) then
    dRetcode := -3;  //requested datalength is to long
    return;
  end_if;
   
  if dRetcode = 0 then
    usDoCnt         := 0;
    uiReadOffset    := 0;
    uiNextReadData  := uiDataLength;
    
    while uiNextReadData do
      uiActReadData := uiNextReadData;
      if uiActReadData > AI046_MAX_LENGTH_ONE_READ then
        uiActReadData := AI046_MAX_LENGTH_ONE_READ;
      end_if;
      
      _memcpy(ptr1:=pBufferData+uiReadOffset, ptr2:=sAccesses.pReadBuffer[uiTempBufferIndex+usDoCnt], cntr:=uiActReadData);

      uiNextReadData  -= uiActReadData;
      uiReadOffset    += uiActReadData;
      usDoCnt         += 1;
    end_while;

    // if pointer is valid
    if pDataCounter then
      // return the current data counter
      pDataCounter^ := aDataCnt[usChannelNr-1];
    end_if;

  end_if;
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode        : iprStates;
  END_VAR
  
  eModuleInitState := BUSY;
  
 //*****************************************************************************
 //** STATEMACHINE FOR INITIALIZATION OF THE MODULE                           **
 //*****************************************************************************

  case eInitSSW of
 //**********************************************************************************************************************************************************
    _InitVariables:    
      TmpRetcode := SetScale(); 
      if TmpRetcode = ERROR then
        eInitSSWErrorStep := eInitSSW;
        eInitSSW          := _InitError;
        return;
      end_if;
             
      //Set gain and current for first start
      AI1Gain.Write(input:=AI1Gain);
      AI2Gain.Write(input:=AI2Gain);
      AI3Gain.Write(input:=AI3Gain);
      AI4Gain.Write(input:=AI4Gain);
      
      //Settings for LED's
      AI1SetLed.Write(input:=AI1SetLed); 
      AI2SetLed.Write(input:=AI2SetLed);    
      AI3SetLed.Write(input:=AI3SetLed);    
      AI4SetLed.Write(input:=AI4SetLed); 
      
      //Get Client Values
      AI1Freq := AI1Freq.Read();
      AI2Freq := AI2Freq.Read();
      AI3Freq := AI3Freq.Read();
      AI4Freq := AI4Freq.Read();
      
      //Settings for IIR filter cut off frequency
      sHWControlWrite.IIRFilter.AI1FilterFreq := SetFrequency(AI1Freq);
      sHWControlWrite.IIRFilter.AI2FilterFreq := SetFrequency(AI2Freq);
      sHWControlWrite.IIRFilter.AI3FilterFreq := SetFrequency(AI3Freq);
      sHWControlWrite.IIRFilter.AI4FilterFreq := SetFrequency(AI4Freq);
      
      //Setting for Oversampling mode
      OversampleMode.Write(input:=OversampleMode);
            
      udSDOTimeout  := ops.tAbsolute;
      eInitSSW      := _WriteHWConfig;      
                   
//**********************************************************************************************************************************************************
    _WriteHWConfig:      
      TmpRetcode    := HWConfigModule();
      if TmpRetcode = Ready then
        eInitSSW         := _DisablePll;
        udSDOWait4Config := ops.tAbsolute;
      elsif TmpRetcode = ERROR then
        eModuleInitState := ERROR;
        LogError("@013F (AI046::InitModule) Failed to add write SDO for channel configuration, step DisablePll.");
        eInitState := _ClientNotready;        
      end_if;
                   
//**********************************************************************************************************************************************************
    _DisablePll:    
      case eResponseState of
        //*******************************************************
        _idle:
          sPllRegister.bsStateControlReg := 0;
          TmpRetcode := StartWriteSDO(hOffset     := AI046_PLL_CONTROL
                                    , usLength    := sizeof(sPllRegister.bsStateControlReg)
                                    , pWriteBuffer:= #sPllRegister.bsStateControlReg$USINT
                                    , eCommand    := SDIAS_SDO_CMD_CTRL_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@013F (AI046::InitModule) Failed to add write SDO for channel configuration, step DisablePll.");
            eInitState := _ClientNotready;
          end_if; 
        //*******************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI046_SDO_RESPONSE_TIMEOUT) then
            LogError("@0140 (AI046::InitModule) SDO Response timeout, step DisablePll.");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*******************************************************
        _valid:
          eInitSSW        := _ReadPll;
          eResponseState  := _idle;
      end_case;
              
//**********************************************************************************************************************************************************
    _ReadPll:
      case eResponseState of
        //*******************************************************
        _idle:           
          if sSPIReadData.udReadOffset < sizeof(sPllRegister) then          
            sSPIReadData.udReadLength := sizeof(sPllRegister) - sSPIReadData.udReadOffset;
            if sSPIReadData.udReadLength > SDIAS_MAX_SDO_READ_LENGTH then              
              sSPIReadData.udReadLength := SDIAS_MAX_SDO_READ_LENGTH;
            end_if;           
            TmpRetcode := StartReadSDO( hOffset   := AI046_PLL_OFFSET + sSPIReadData.udReadOffset$HINT
                                      , usLength  := sSPIReadData.udReadLength$USINT
                                      , eCommand  := SDIAS_SDO_CMD_CTRL_READ);   
            if TmpRetcode = READY then
              udSDOTimeout      := ops.tAbsolute;
              eResponseState    := _wait; 
            elsif TmpRetcode = ERROR then
              eModuleInitState := ERROR;
              LogError("@0141 (AI046::InitModule) Failed to add read SDO to read pll.");
              eInitState := _PllError;
            end_if; 
          else
            sSPIReadData.udReadOffset := 0;
            eInitSSW := _Finish;             
          end_if;         
        //*******************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > SDIAS_SDO_TIMEOUT*2) then
            LogError("@0142 (AI046::InitModule) SDO Response timeout read pll.");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW      := _InitError;
          end_if;
          
        //*******************************************************
        _valid:
          sSPIReadData.udReadOffset += sSPIReadData.udReadLength$USINT;
          eResponseState    := _idle;
          eInitSSW          := _SetPll;
      end_case;          
         
//**********************************************************************************************************************************************************
    _SetPll:
      case eResponseState of
        //*******************************************************
        _idle:                
          sSPIWriteData.usWriteOffset                           := 0; 
          sPllRegister.udSystemPerTime                          := udBusTime / 10;            // convert to 10*ns
          sPllRegister.bsStateControlReg                        := 0;
          sPllRegister.bsStateControlReg.Soft_enable            := 1;
          sPllRegister.usSystemPeriodeDividier                  := 1;
          //sPllRegister.CompensationDelay // Keep value
          sPLLRegister.SyncOut0.uiOffset                        := (udBusTime/1000)$UINT - AI046_PLL_OFFSETTIME;
          sPllRegister.SyncOut0.usPeriodMulti                   := usPllSyncPeriodMulti;
          sPllRegister.SyncOut0.bsSyncStartDelay                := 0;
          sPllRegister.SyncOut0.bsControlState.SyncEnable       := 1;
          sPllRegister.SyncOut0.bsControlState.StartDelayEnable := 0;
          sPllRegister.SyncOut0.bsControlState.SyncSelector     := 1;
          
          TmpRetcode  := StartWriteSDO( hOffset     :=AI046_PLL_OFFSET + sSPIWriteData.usWriteOffset
                                      , usLength    :=sizeof(sPLLRegister)
                                      , pWriteBuffer:=(#sPLLRegister+sSPIWriteData.usWriteOffset)$^USINT
                                      , eCommand    :=SDIAS_SDO_CMD_CTRL_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0143 (AI046::InitModule) Failed to add write SDO in step SetPll.");
            eInitState := _PllError;
          end_if;          
        //*******************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI046_SDO_RESPONSE_TIMEOUT) then
            LogError("@0144 (AI046::InitModule) SDO Response timeout SetPll.");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*******************************************************
        _valid:
          sSPIReadData.udReadOffset := 0;
          eInitSSW                  := _Wait4ADCReset;
          eResponseState            := _idle;
      end_case; 
          
//**********************************************************************************************************************************************************
    _Wait4ADCReset:
    if (ops.tAbsolute-udSDOWait4Config) >= 10 then
      udSDOWait4Config  := ops.tAbsolute-udSDOWait4Config;
      eInitSSW          := _ActivateADC;
      udSDOTimeout      := ops.tAbsolute;
    end_if;      
        
//**********************************************************************************************************************************************************
    _ActivateADC:
      TmpRetcode    := HWConfigModule();
      if TmpRetcode = Ready then
        eInitSSW     := _Finish;
      elsif TmpRetcode = ERROR then
        eModuleInitState := ERROR;
        LogError("@0143 (AI046::InitModule) Failed to add write SDO for channel configuration, step DisablePll.");
        eInitState := _ClientNotready;        
      end_if;
    
//**********************************************************************************************************************************************************
    _Finish:
      StartMeasure(bStartStop:=TRUE);
      ConfigValid      := TRUE;
      bConfigChanged   := FALSE;
      eInitSSW         := _InitVariables;
      eModuleInitState := READY;
      eInitState       := _ClassOk;
      
//**********************************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      if (eInitState <> _InvalidConfguration) then
        eInitState  := _ClientNotready;
      end_if;  
  end_case;

END_FUNCTION


FUNCTION AI046::HWConfigModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode        : iprStates;
  END_VAR
  
  eModuleInitState := BUSY;

  case eConfigSSW of
//**********************************************************************************************************************************************************
    _ConfigIdle:  
      //actual config is now invalid
      ConfigValid    := 0;
      bConfigChanged := FALSE;
     
      //switch off adc if first run
      if bInitConfig then
        eConfigSSW := _DeactivateConversion;
        bInitConfig := FALSE;
      else
        eConfigSSW := _WriteConfigSDO;
      end_if;
      sHWControlWrite.AmountofConversions             := 0;
      sHWControlWrite.ControlRegister.MicroBlazeReset := 0;
      sHWControlWrite.ControlRegister.LoadConfigNew   := 1;
      udSDOWait4Config                                := ops.tAbsolute;
      //set ADC Reset to reconfig Oversampling mode
      sHWControlWrite.IOExpanderRegister.ADCReset     := TRUE; 
    
//**********************************************************************************************************************************************************
    _DeactivateConversion:      
      case eResponseState of
        _idle:          
          //stop measure of module 
          StartMeasure(bStartStop:=FALSE);
          eConfigSSW                    := _WriteConfigSDO;  
      end_case;    
            
//**********************************************************************************************************************************************************
    _WriteConfigSDO:
      case eResponseState of
        //*******************************************************
        _idle:     
          TmpRetcode := StartWriteSDO(hOffset       := AI046_ADDR_HWCONTROL_REGISTER
                                    , usLength      := sizeof(sHWControlWrite)
                                    , pWriteBuffer  := #sHWControlWrite$USINT
                                    , eCommand      := SDIAS_SDO_CMD_MEM_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0145 (AI046::HWConfigModule) Failed to add write SDO for hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;          
        //*******************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI046_SDO_RESPONSE_TIMEOUT) then
            LogError("@0146 (AI046::HWConfigModule) SDO Response timeout hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;          
        //*******************************************************
        _valid:          
          udReadSDOStart := ops.tAbsolute;
          eConfigSSW     := _ReadConfigSDO;
          eResponseState := _idle;         
      end_case;

//**********************************************************************************************************************************************************
    _ReadConfigSDO:
      case eResponseState of
        //*******************************************************
        _idle:
          if (ops.tAbsolute-udReadSDOStart) > AI046_SDO_REQUEST_TIME then
            TmpRetcode := StartReadSDO( hOffset   := AI046_ADDR_HWCONTROL_REGISTER
                                      , usLength  := sizeof(sHWControlRead)
                                      , eCommand  := SDIAS_SDO_CMD_MEM_READ);
            
            if TmpRetcode = READY then
              udSDOTimeout  := ops.tAbsolute;
              eResponseState:= _wait; 
            elsif TmpRetcode = ERROR then
              eModuleInitState := ERROR;
              LogError("@0145 (AI046::HWConfigModule) Failed to add read SDO for hardware configuration.");
              eConfigSSWErrorStep := eConfigSSW;
              eConfigSSW          := _ErrorConfig;
            end_if;          
          end_if;

        //*******************************************************
        _wait:
          //wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI046_SDO_RESPONSE_TIMEOUT) then
            LogError("@0146 (AI046::HWConfigModule) SDO Response timeout hardware configuration.");
            eConfigSSWErrorStep := eConfigSSW;
            eConfigSSW          := _ErrorConfig;
          end_if;  
          
        //*******************************************************
        _valid: 
          if sHWControlRead.StatusRegister.ControllerOP = TRUE then
            eConfigSSW     := _ActivateConversion;
          else  
            //try again
            udReadSDOStart := ops.tAbsolute;
          end_if;
          eResponseState := _idle;         
      end_case;
     
//**********************************************************************************************************************************************************
    _ActivateConversion:    
       //start measure of module
       StartMeasure(bStartStop:=True);           
       eConfigSSW      := _FinishConfig; 
      
//**********************************************************************************************************************************************************
    _FinishConfig:
      eConfigSSW       := _ConfigIdle;
      eModuleInitState := READY;
      
//**********************************************************************************************************************************************************
    _ErrorConfig:
      ConfigValid      := -1;
      eModuleInitState := ERROR; 
      eConfigSSW       := _ConfigIdle; 

//**********************************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION VIRTUAL AI046::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	        : t_SDIAS_SDO_Cmd;
		hOffset 	        : HINT;
		usLength 	        : USINT;
		eResult 	        : iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	  : USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);
   
  //spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;    
  
  if eResult = READY then
    
    case eCommand of                
//**********************************************************************************************************************************************************
      //Memory Write
      SDIAS_SDO_CMD_MEM_WRITE:
        if eResponseState = _wait then
          eResponseState := _valid;
        end_if;                 
                
//**********************************************************************************************************************************************************
      //Memory Read
      SDIAS_SDO_CMD_MEM_READ:    
        if hOffset = AI046_ADDR_HWCONTROL_REGISTER then
          if eResponseState = _wait then
            eResponseState := _valid;
            sHWControlRead := pResponseBuffer^$t_SDOHardwareControl;
          end_if;
        end_if;
          
//**********************************************************************************************************************************************************
      //Control Read
      SDIAS_SDO_CMD_CTRL_READ:
        if (hOffset >= AI046_PLL_OFFSET) 
         & (hOffset < (AI046_PLL_OFFSET+sizeof(sPllRegister))) then          
          if eResponseState = _wait then
            eResponseState := _valid;
            _memcpy(ptr1:= (#sPllRegister + sSPIReadData.udReadOffset), ptr2:=pResponseBuffer, cntr:=sSPIReadData.udReadLength);
          end_if;            
        end_if;  
       
//**********************************************************************************************************************************************************
      //Control write
      SDIAS_SDO_CMD_CTRL_WRITE:        
        if eResponseState = _wait then
          eResponseState := _valid;
        end_if;       

//**********************************************************************************************************************************************************
    end_case;
    
    if eResponseState <> _valid then
      LogError("@0147 (AI046::ReceiveSDOResponse) Error in response data of SDO.");
      eInitSSW := _InitError;      
    end_if;
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@0148 (AI046::ReceiveSDOResponse) Error while writing configuration over sdo.");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@0149 (AI046::ReceiveSDOResponse) Error while reading configuration over sdo.");
      SDIAS_SDO_CMD_CTRL_READ:  
        LogError("@014A (AI046::ReceiveSDOResponse) Error while reading the pll configuration.");
      SDIAS_SDO_CMD_CTRL_WRITE:  
        LogError("@014B (AI046::ReceiveSDOResponse) Error while writing the pll configuration.");
    end_case;
    eInitSSW := _InitError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//look if it is right hardware
	if ( udID2Check <> DEVICE_ID_AI046 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;

END_FUNCTION


FUNCTION VIRTUAL AI046::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR
  
  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_CY OR SDIAS_TASK_MASK_RT_POST ;

END_FUNCTION


FUNCTION AI046::AI046
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_AI046;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::AI1Gain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR  
  
  //restrict to valid range 
  if input <> 0 then
    input := 1;    
  end_if;
  
  if (((input <> AI1Gain) & (ConfigValid <> 0)) | bInitConfig)  
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 = TRUE)  then
    AI1Gain                                    := input;
    sHWControlWrite.IOExpanderRegister.GainCh1 := AI1Gain$BOOL;
    bConfigChanged                             := TRUE;    
    result                                     := AI1Gain;    
  else
    result := ACCESS_DENIED;    
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::AI2Gain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //restrict to valid range  
  if input <> 0 then
    input := 1;    
  end_if;
  
  if (((input <> AI2Gain) & (ConfigValid <> 0)) | bInitConfig) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 = TRUE)  then
    AI2Gain                                     := input;
    sHWControlWrite.IOExpanderRegister.GainCh2  := AI2Gain$BOOL;
    bConfigChanged                              := TRUE;
    result                                      := AI2Gain;    
  else
    result := ACCESS_DENIED;    
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::AI3Gain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //restrict to valid range 
  if input <> 0 then
    input := 1;    
  end_if;
  
  if (((input <> AI3Gain) & (ConfigValid <> 0)) | bInitConfig) 
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 = TRUE)  then
    AI3Gain                                     := input;
    sHWControlWrite.IOExpanderRegister.GainCh3  := AI3Gain$BOOL;
    bConfigChanged                              := TRUE;
    result                                      := AI3Gain;    
  else
    result := ACCESS_DENIED;    
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::AI4Gain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
	
  //restrict to valid range 
  if input <> 0 then
    input := 1;    
  end_if;
    
  if (((input <> AI4Gain) & (ConfigValid <> 0)) | bInitConfig)  
  & (sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 = TRUE) then
    AI4Gain                                     := input;
    sHWControlWrite.IOExpanderRegister.GainCh4  := AI4Gain$BOOL;
    bConfigChanged                              := TRUE;
    result                                      := AI4Gain;    
  else
    result := ACCESS_DENIED;    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::DisconnectEvent

  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION AI046::SetScale
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
    dScale            : DINT;
  END_VAR
  
  eModuleInitState := READY;
  
  //analog input 1
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel1 then 
    AI1MaxValue  := AI1MaxValue.Read();
    AI1MinValue  := AI1MinValue.Read(); 
    
    //check if calculation is necessary
    if ((ValuesSize = 0) & ((AI1MaxValue <> AI046_FIRMWARE_MAX_16BIT) | (AI1MinValue <> AI046_FIRMWARE_MIN_16BIT)))
    | ((ValuesSize = 1) & ((AI1MaxValue <> AI046_FIRMWARE_MAX_18BIT) | (AI1MinValue <> AI046_FIRMWARE_MIN_18BIT)))  then
    
      ScaleAI1 := TRUE;
      
      dScale := AI1MaxValue-AI1MinValue;    
      
      if dScale = 0 then
        eModuleInitState := ERROR;
        eInitState := _InvalidConfguration;
        LogValue("@014C (AI046::SetScale) Invalid minimal and maximal value settings for channel {0}. The values must not be the same.",1);
        return;
      end_if;
      
      sScaleSettings.Multiplier.Channel1 := dScale;
      
      if sHWControlWrite.ControlRegister.Value18_16Bit = TRUE then
        //16Bit mode
        sScaleSettings.Divider.Channel1 := (AI046_FIRMWARE_MAX_16BIT - AI046_FIRMWARE_MIN_16BIT);      
        sScaleSettings.Offset.Channel1  := (AI1MinValue * sScaleSettings.Divider.Channel1)/(sScaleSettings.Multiplier.Channel1) - AI046_FIRMWARE_MIN_16BIT;
      else
        //18Bit mode
        sScaleSettings.Divider.Channel1 := (AI046_FIRMWARE_MAX_18BIT - AI046_FIRMWARE_MIN_18BIT);      
        sScaleSettings.Offset.Channel1  := (AI1MinValue * sScaleSettings.Divider.Channel1)/(sScaleSettings.Multiplier.Channel1) - AI046_FIRMWARE_MIN_18BIT;
      end_if;    
    else // The value does not have to be scaled and the offset is set to 0.
      sScaleSettings.Offset.Channel1 := 0;
    end_if;
  end_if;
  
  //analog input 2
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel2 then 
    AI2MaxValue  := AI2MaxValue.Read();
    AI2MinValue  := AI2MinValue.Read(); 
    
    //check if calculation is necessary
    if ((ValuesSize = 0) & ((AI2MaxValue <> AI046_FIRMWARE_MAX_16BIT) | (AI2MinValue <> AI046_FIRMWARE_MIN_16BIT)))
    | ((ValuesSize = 1) & ((AI2MaxValue <> AI046_FIRMWARE_MAX_18BIT) | (AI2MinValue <> AI046_FIRMWARE_MIN_18BIT)))  then
    
      ScaleAI2 := TRUE;
    
      dScale := AI2MaxValue-AI2MinValue;

      if dScale = 0 then
        eModuleInitState := ERROR;
        eInitState := _InvalidConfguration;
        LogValue("@014C (AI046::SetScale) Invalid minimal and maximal value settings for channel {0}. The values must not be the same.",2); 
        return;
      end_if;

      sScaleSettings.Multiplier.Channel2 := dScale;
      
      if sHWControlWrite.ControlRegister.Value18_16Bit = TRUE then
        //16Bit mode
        sScaleSettings.Divider.Channel2 := (AI046_FIRMWARE_MAX_16BIT - AI046_FIRMWARE_MIN_16BIT);      
        sScaleSettings.Offset.Channel2  := (AI2MinValue * sScaleSettings.Divider.Channel2)/(sScaleSettings.Multiplier.Channel2) - AI046_FIRMWARE_MIN_16BIT;
      else
        //18Bit mode
        sScaleSettings.Divider.Channel2 := (AI046_FIRMWARE_MAX_18BIT - AI046_FIRMWARE_MIN_18BIT);      
        sScaleSettings.Offset.Channel2  := (AI2MinValue * sScaleSettings.Divider.Channel2)/(sScaleSettings.Multiplier.Channel2) - AI046_FIRMWARE_MIN_18BIT;
      end_if;
    else // The value does not have to be scaled and the offset is set to 0.
      sScaleSettings.Offset.Channel2 := 0;
    end_if;
  end_if;  
    
  //analog input 3
  //*************************************************************************************************************  
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel3 then 
    AI3MaxValue  := AI3MaxValue.Read();
    AI3MinValue  := AI3MinValue.Read();
    
    //check if calculation is necessary
    if ((ValuesSize = 0) & ((AI3MaxValue <> AI046_FIRMWARE_MAX_16BIT) | (AI3MinValue <> AI046_FIRMWARE_MIN_16BIT)))
    | ((ValuesSize = 1) & ((AI3MaxValue <> AI046_FIRMWARE_MAX_18BIT) | (AI3MinValue <> AI046_FIRMWARE_MIN_18BIT)))  then
    
      ScaleAI3 := TRUE;
    
      dScale := AI3MaxValue-AI3MinValue;

      if dScale = 0 then
        eModuleInitState := ERROR;
        eInitState := _InvalidConfguration;
        LogValue("@014C (AI046::SetScale) Invalid minimal and maximal value settings for channel {0}. The values must not be the same.",3); 
        return;
      end_if;
      
      sScaleSettings.Multiplier.Channel3 := dScale;
      
      if sHWControlWrite.ControlRegister.Value18_16Bit = TRUE then
        //16Bit mode
        sScaleSettings.Divider.Channel3 := (AI046_FIRMWARE_MAX_16BIT - AI046_FIRMWARE_MIN_16BIT);      
        sScaleSettings.Offset.Channel3  := (AI3MinValue * sScaleSettings.Divider.Channel3)/(sScaleSettings.Multiplier.Channel3) - AI046_FIRMWARE_MIN_16BIT;
      else
        //18Bit mode
        sScaleSettings.Divider.Channel3 := (AI046_FIRMWARE_MAX_18BIT - AI046_FIRMWARE_MIN_18BIT);      
        sScaleSettings.Offset.Channel3  := (AI3MinValue * sScaleSettings.Divider.Channel3)/(sScaleSettings.Multiplier.Channel3) - AI046_FIRMWARE_MIN_18BIT;
      end_if;
    else // The value does not have to be scaled and the offset is set to 0.
      sScaleSettings.Offset.Channel3 := 0;
    end_if;    
  end_if;  
  
  //analog input 4
  //*************************************************************************************************************
  if sMeasureControl.ArrayAssignment.ChArrayActivated.Channel4 then 
    AI4MaxValue  := AI4MaxValue.Read();
    AI4MinValue  := AI4MinValue.Read(); 
    
    //check if calculation is necessary
    if ((ValuesSize = 0) & ((AI4MaxValue <> AI046_FIRMWARE_MAX_16BIT) | (AI4MinValue <> AI046_FIRMWARE_MIN_16BIT)))
    | ((ValuesSize = 1) & ((AI4MaxValue <> AI046_FIRMWARE_MAX_18BIT) | (AI4MinValue <> AI046_FIRMWARE_MIN_18BIT)))  then
    
      ScaleAI4 := TRUE;

      dScale := AI4MaxValue-AI4MinValue;

      if dScale = 0 then
        eModuleInitState := ERROR;
        eInitState := _InvalidConfguration;
        LogValue("@014C (AI046::SetScale) Invalid minimal and maximal value settings for channel {0}. The values must not be the same.",4);  
        return;
      end_if;
      
      sScaleSettings.Multiplier.Channel4 := dScale;
      
      if sHWControlWrite.ControlRegister.Value18_16Bit = TRUE then
        //16Bit mode
        sScaleSettings.Divider.Channel4 := (AI046_FIRMWARE_MAX_16BIT - AI046_FIRMWARE_MIN_16BIT);      
        sScaleSettings.Offset.Channel4  := (AI4MinValue * sScaleSettings.Divider.Channel4)/(sScaleSettings.Multiplier.Channel4) - AI046_FIRMWARE_MIN_16BIT;
      else
        //18Bit mode
        sScaleSettings.Divider.Channel4 := (AI046_FIRMWARE_MAX_18BIT - AI046_FIRMWARE_MIN_18BIT);      
        sScaleSettings.Offset.Channel4  := (AI4MinValue * sScaleSettings.Divider.Channel4)/(sScaleSettings.Multiplier.Channel4) - AI046_FIRMWARE_MIN_18BIT;
      end_if;
    else // The value does not have to be scaled and the offset is set to 0.
      sScaleSettings.Offset.Channel4 := 0;
    end_if;    
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::AI1SetLed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //restrict to valid range
  if input < 0 then
    input := 0;
  elsif input > 2 then
    input := 2;
  end_if;
  
  if ((input <> AI1SetLed) | bInitConfig) then
    AI1SetLed  := input;
    case input of
      //LED HW state
      0: sControlReg.LEDControlReg.Led1Ch1 := FALSE;
         sControlReg.LEDControlReg.Led2Ch1 := FALSE;
      //LED on
      1: sControlReg.LEDControlReg.Led1Ch1 := TRUE;
         sControlReg.LEDControlReg.Led2Ch1 := TRUE;
      //LED off
      2: sControlReg.LEDControlReg.Led1Ch1 := TRUE;
         sControlReg.LEDControlReg.Led2Ch1 := FALSE;
    end_case;
    
    result:= AI1SetLed;        
  else
    result := input;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::AI2SetLed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //restrict to valid range
  if input < 0 then
    input := 0;
  elsif input > 2 then
    input := 2;
  end_if;
    
  if ((input <> AI2SetLed) | bInitConfig) then
    AI2SetLed  := input;
    case input of
      //LED HW state
      0: sControlReg.LEDControlReg.Led1Ch2 := FALSE;
         sControlReg.LEDControlReg.Led2Ch2 := FALSE;
      //LED on
      1: sControlReg.LEDControlReg.Led1Ch2 := TRUE;
         sControlReg.LEDControlReg.Led2Ch2 := TRUE;
      //LED off
      2: sControlReg.LEDControlReg.Led1Ch2 := TRUE;
         sControlReg.LEDControlReg.Led2Ch2 := FALSE;
    end_case;
    
    result:= AI2SetLed;        
  else
    result := input;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::AI3SetLed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //restrict to valid range
	if input < 0 then
    input := 0;
  elsif input > 2 then
    input := 2;
  end_if;
    
  if ((input <> AI3SetLed) | bInitConfig) then
    AI3SetLed  := input;
    case input of 
      //LED HW state
      0: sControlReg.LEDControlReg.Led1Ch3 := FALSE;
         sControlReg.LEDControlReg.Led2Ch3 := FALSE;
      //LED on
      1: sControlReg.LEDControlReg.Led1Ch3 := TRUE;
         sControlReg.LEDControlReg.Led2Ch3 := TRUE;
      //LED off
      2: sControlReg.LEDControlReg.Led1Ch3 := TRUE;
         sControlReg.LEDControlReg.Led2Ch3 := FALSE;
    end_case;
    
    result:= AI3SetLed;      
  else
    result := input;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::AI4SetLed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //restrict to valid range
	if input < 0 then
    input := 0;
  elsif input > 2 then
    input := 2;
  end_if;
  
  if ((input <> AI4SetLed) | bInitConfig) then
    AI4SetLed  := input;
    case input of 
      //LED HW state
      0: sControlReg.LEDControlReg.Led1Ch4 := FALSE;
         sControlReg.LEDControlReg.Led2Ch4 := FALSE;
      //LED on
      1: sControlReg.LEDControlReg.Led1Ch4 := TRUE;
         sControlReg.LEDControlReg.Led2Ch4 := TRUE;
      //LED off
      2: sControlReg.LEDControlReg.Led1Ch4 := TRUE;
         sControlReg.LEDControlReg.Led2Ch4 := FALSE;
    end_case;    
    
    result := AI4SetLed;       
  else
    result := input;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI046::OversampleMode::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //restrict to valid range
  if input <> 0 then
    input := 1;    
  end_if;
  
  if ((input <> OversampleMode) | bInitConfig)  then
    OversampleMode    := input;
    bConfigChanged    := TRUE;
    
    if input = 0 then // FPGA Oversampling
      case SampleRate of
        0://every ms one sample, FPGA OVS 64
          sHWControlWrite.FPGAOversample.OversampleBit1 := FALSE;    
          sHWControlWrite.FPGAOversample.OversampleBit2 := TRUE;
          sHWControlWrite.FPGAOversample.OversampleBit3 := TRUE;     
        1://every ms 2 samples, FPGA OVS 32
          sHWControlWrite.FPGAOversample.OversampleBit1 := TRUE;
          sHWControlWrite.FPGAOversample.OversampleBit2 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit3 := TRUE;
        2://every ms 4 samples, FPGA OVS 16
          sHWControlWrite.FPGAOversample.OversampleBit1 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit2 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit3 := TRUE;
        3://every ms 5 samples, FPGA OVS 16
          sHWControlWrite.FPGAOversample.OversampleBit1 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit2 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit3 := TRUE;
        4://every ms 10 samples, FPGA OVS 8
          sHWControlWrite.FPGAOversample.OversampleBit1 := TRUE;   
          sHWControlWrite.FPGAOversample.OversampleBit2 := TRUE;    
          sHWControlWrite.FPGAOversample.OversampleBit3 := FALSE;    
        5://every ms 20 samples, FPGA OVS 4
          sHWControlWrite.FPGAOversample.OversampleBit1 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit2 := TRUE;
          sHWControlWrite.FPGAOversample.OversampleBit3 := FALSE;
        6://every ms 40 samples, FPGA OVS 2
          sHWControlWrite.FPGAOversample.OversampleBit1 := TRUE;
          sHWControlWrite.FPGAOversample.OversampleBit2 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit3 := FALSE;  
        7://every ms 50 samples, FPGA OVS 2
          sHWControlWrite.FPGAOversample.OversampleBit1 := TRUE;
          sHWControlWrite.FPGAOversample.OversampleBit2 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit3 := FALSE;
        8://every ms 100 samples, FPGA OVS 1
          sHWControlWrite.FPGAOversample.OversampleBit1 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit2 := FALSE;
          sHWControlWrite.FPGAOversample.OversampleBit3 := FALSE;  
      end_case; 
      
      sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := FALSE;
      sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := FALSE;
      sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := FALSE; 
      
    else //ADC Oversampling
      sHWControlWrite.FPGAOversample.OversampleBit1 := FALSE;
      sHWControlWrite.FPGAOversample.OversampleBit2 := FALSE;
      sHWControlWrite.FPGAOversample.OversampleBit3 := FALSE;
      
      case SampleRate of
        0://every ms one sample, ADC OVS 64 + FPGA OVS 2
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := FALSE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := TRUE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := TRUE;
          sHWControlWrite.FPGAOversample.OversampleBit1        := TRUE;
        1://every ms 2 samples, ADC OVS 64
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := FALSE;   
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := TRUE;    
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := TRUE;    
        2://every ms 4 samples, ADC OVS 32
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := TRUE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := FALSE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := TRUE;
        3://every ms 5 samples, ADC OVS 32
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := TRUE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := FALSE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := TRUE;
        4://every ms 10 samples, ADC OVS 16
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := FALSE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := FALSE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := TRUE;
        5://every ms 20 samples, ADC OVS 8
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := TRUE;    
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := TRUE;     
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := FALSE; 
        6://every ms 40 samples, ADC OVS 4
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := FALSE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := TRUE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := FALSE; 
        7://every ms 50 samples, ADC OVS 2
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := TRUE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := FALSE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := FALSE;
        8://every ms 100 samples, ADC OVS 1
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit1 := FALSE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit2 := FALSE;
          sHWControlWrite.IOExpanderRegister.ADCOversampleBit3 := FALSE;    
      end_case;
    end_if;
    
    result := OversampleMode; 
  else
    result := ACCESS_DENIED;    
  end_if; 
  
END_FUNCTION


FUNCTION AI046::SetFrequency
	VAR_INPUT
		ClientValue 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Frequency 	  : UINT;
	END_VAR
  
  //lookup table for cut off frequency
  case ClientValue of
    1:  Frequency := 10000;
    2:  Frequency := 5000;
    3:  Frequency := 1000;
    4:  Frequency := 500;
    5:  Frequency := 100;
    6:  Frequency := 50;
    7:  Frequency := 25;  
    8:  Frequency := 10;
  else
        Frequency := 0; //default value
  end_case;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL AI046::ClassState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  VAR
  	udActDataCount  : UDINT;
  END_VAR

	CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
    SDIAS_CLT_GET_ANALOG_DATA_BUFFER:
      // init with error, ok is set later
      ret_code := ERROR;
      
      if pPara^.aPara[0] = 1 then
        // request is version 1
      
        // check valid channel nr
        if (pPara^.aPara[1] >= 1) & (pPara^.aPara[1] <= 4) then
          
          // init result
          ret_code := READY;
          pResult^.aData[0x0]       := 1; //version 1
          pResult^.aData[0x1]       := usOneValueSize;
          pResult^.aData[0x2]$UDINT := to_udint(uiMaxValuesCycle);
          pResult^.aData[0x6]$UDINT := 0; // copied amount is set later
          pResult^.aData[0xA]$UDINT := 1; // no counter
          pResult^.aData[0xB]$UDINT := aDataCnt[pPara^.aPara[1]-1]; // always give back the datacounter, so copy can be called only if new data is avaliable
          
          // copy requested data amount, limit to avaliable data
          if (pPara^.aPara[2] <> NIL) & (pPara^.aPara[3]$UDINT > 0) then
            udActDataCount := pPara^.aPara[3]$UDINT;
            if (udActDataCount AND 1) = 1 then
              if (udActDataCount AND 3) = 3 then
                udActDataCount -= 3; // only whole values
              else
                udActDataCount -= 1; // only whole values
              end_if;
            end_if;
            if udActDataCount > (uiMaxValuesCycle*usOneValueSize) then
              udActDataCount := (uiMaxValuesCycle*usOneValueSize);
            end_if;
            if GetData(usChannelNr:= pPara^.aPara[1]$USINT, uiDataLength:=udActDataCount$UINT, pBufferData:=pPara^.aPara[2]$^INT, pDataCounter:=NIL) = 0 then
              pResult^.aData[6]$UDINT := udActDataCount / usOneValueSize;
            //else
              // no data copied, probably data is INVALID
            end_if;
          //else
            //no data requested
          end_if;
        //else
          // wrong channel
        end_if;
      //else
        // unknown version of the request
      end_if;

//**********************************************************************************************************************************************************
  ELSE
    // we forward this message to the base class
		ret_code := SdiasBase::NewInst(pPara, pResult);
	END_CASE;

END_FUNCTION