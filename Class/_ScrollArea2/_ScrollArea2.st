//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_ScrollArea2"
	Revision           = "0.8"
	GUID               = "{81244ED8-C9B8-42A6-9A2A-BA97C8E4658E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(480,360)"
	Comment            = "provides functionality to do unrestricted scroll list">
	<Channels>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.8" Date="2016-11-11" Author="kolott" Company="sigmatek" Description="betterment to ensure compatibility to some existing derivations"/>
		<Dokumentation Revision="0.7" Date="2016-11-03" Author="kolott" Company="sigmatek" Description="sa35969: ability to move control in carousell"/>
		<Dokumentation Revision="0.6" Date="2013-01-10" Author="kolott" Company="sigmatek" Description="dr1830: new client to set lineheight in pixel"/>
		<Dokumentation Revision="0.5" Date="2011-02-23" Author="kolott" Company="sigmatek" Description="bugfix: Init vs. Init32"/>
		<Dokumentation Revision="0.4" Date="2011-01-11" Author="kolott" Company="sigmatek" Description="more than 65536 lines are possible"/>
	</RevDoku>
	<Network Name="_ScrollArea2">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{320FDD86-597C-43AD-A600-2F311A5C5FC2}"
				Class      = "_ScrollArea"
				Position   = "(210,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ActPos"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="ExtendedScrollBar"/>
					<Client Name="LineHighness"/>
					<Client Name="LineWidth"/>
					<Client Name="Lse"/>
					<Client Name="VerticalLevel"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(968,210),(796,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(968,270),(796,270),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(210,210),(38,210),"/>
			<Connection Source="_base.VerticalLevel" Destination="this.VerticalLevel" Vertices="(210,270),(38,270),"/>
			<Connection Source="_base.LineWidth" Destination="this.LineWidth" Vertices="(210,330),(38,330),"/>
			<Connection Source="_base.ExtendedScrollBar" Destination="this.ExtendedScrollBar" Vertices="(210,450),(38,450),"/>
			<Connection Source="this.ActPos" Destination="_base.ActPos" Vertices="(968,330),(796,330),"/>
			<Connection Source="_base.LineHighness" Destination="this.LineHighness" Vertices="(210,390),(38,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _ScrollArea

_ScrollArea2 : CLASS
: _ScrollArea
  //Servers:
  //Clients:
  //Variables:
		InitXYPix 	: _DOT;
		InitXYPixValid 	: BOOL;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to redraw the io&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;pr ........ pointer to result information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL Out
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR;
	
	FUNCTION MovePosition
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _ScrollArea2::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__SCROLLAREA2
0$UINT, 8$UINT, (SIZEOF(::_ScrollArea2))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2779823616), "_ScrollArea2", //Class
TO_UDINT(3043040051), "_ScrollArea", 0$UINT, 15$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT__ScrollArea2 23

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__ScrollArea2] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _ScrollArea2::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _ScrollArea::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__ScrollArea2;
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #Out();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma using _Lse

#pragma warning (disable: 73)

FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea2::Draw
VAR_INPUT
	pio		: ^_IO;
	pr		: ^_RESULT;
	pv		: ^_VARIABLE;
	input		: BOOL;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  MovePosition(pio);
  Out(pio); 
  retcode := _IDIDIT; 

END_FUNCTION 


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea2::IF_Run
VAR_INPUT
	pio		: ^_IO;
	input		: BOOL;
END_VAR

  if(Focus = TRUE) then
    if(DrawBeam = TRUE) then
      ActBeam_SCROLL(#Scroll, TRUE);  
      DrawBeam := FALSE; 
    end_if;

    Run_SCROLL(#Scroll, NIL);
  end_if; 

  if(LetsDraw = TRUE) then
    LetsDraw := FALSE; 
    Refresh.Write(1); 
    Refresh := 1; 
  end_if; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea2::IF_Start
VAR_INPUT
	pio		: ^_IO;
	firsttime		: BOOL;
END_VAR

  if(firsttime = TRUE) then
    LetsDraw := TRUE; 
  end_if; 

  if(firsttime = TRUE) then
    InitScroll(pio, Scroll.position.no$uint);
    InitXYPix := pio^.space.xy2; // initialposition
    InitXYPixValid := true; // initialposition valid
    //InitScroll32(pio, Scroll.position.no);
  end_if;
  
  pio^.bRefreshAct := TRUE; 
  Scroll.frametype := pio^.frametype; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea2::Out
VAR_INPUT
  pio : ^_IO; 
END_VAR
VAR
  col : _COLOR;
END_VAR

  if(pio^.is_dyncolor = TRUE) then
    Scroll.color_inactiv := Graphic.MakeColor(GetPenColor(pio^.refcolback), GetPenColor(pio^.refcoltxt));
    Scroll.color_activ := Graphic.MakeColor(GetEditColorBack(_EDITACTIVE), GetEditColorTxt(_EDITACTIVE));
    Scroll.frame_out := pio^.refcolframe;
    Scroll.frame_scroll := pio^.refcolframe;
    col := GetBackColor(Scroll.color_inactiv); 
    Scroll.level.color       := Graphic.MakeColor(col, col);
    Scroll.level.frame_color := pio^.refcolframe;
    Scroll.hlevel.color      := Scroll.level.color; 
    Scroll.hlevel.frame_color := pio^.refcolframe;
  end_if;
 
  Draw_SCROLL(#Scroll, Focus);

END_FUNCTION


FUNCTION _ScrollArea2::MovePosition
VAR_INPUT
	pio 	: ^_IO;
END_VAR
VAR
  dxx, dyy : int;
END_VAR

  if(InitXYPixValid = true) then

    dxx := to_int(pio^.space.xy2.x - InitXYPix.x);
    dyy := to_int(pio^.space.xy2.y - InitXYPix.y);

    if((dxx <> 0) | (dyy <> 0)) then
      Scroll.out_room.xy1.x    += dxx;
      Scroll.out_room.xy1.y    += dyy;
      Scroll.out_room.xy2.x    += dxx;
      Scroll.out_room.xy2.y    += dyy;
    
      Scroll.scroll_room.xy1.x += dxx;
      Scroll.scroll_room.xy1.y += dyy;
      Scroll.scroll_room.xy2.x += dxx;
      Scroll.scroll_room.xy2.y += dyy;
    
      Scroll.level.room.xy1.x  += dxx;
      Scroll.level.room.xy1.y  += dyy;
      Scroll.level.room.xy2.x  += dxx;
      Scroll.level.room.xy2.y  += dyy;
    
      Scroll.hlevel.room.xy1.x += dxx;
      Scroll.hlevel.room.xy1.y += dyy;
      Scroll.hlevel.room.xy2.x += dxx;
      Scroll.hlevel.room.xy2.y += dyy;
    
      InitXYPix := pio^.space.xy2;
    end_if;
  end_if;
  
END_FUNCTION
