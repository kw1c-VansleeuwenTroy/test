//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define SSDCIM_SDO_LOCK    16#1B3D5F2A
#define SSDCIM_SDO_UNLOCK  16#2E9A3C57
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Source\BusInterface.h"
#include "..\..\Class\SdiasSDCIMaster\SdiasSDCIMaster.h"

(*!
<Class
	Name               = "SdiasSDCIMaster"
	Revision           = "1.14"
	GUID               = "{8830CD78-3D0B-4EA6-8C49-10FBE95E042B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(538,120)">
	<Channels>
		<Server Name="ClassState">
		</Server>
		<Server Name="CycleTime" GUID="{14D955B9-01D1-44BD-9233-6903F184831C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Calculated cycle time (in µs) of the SDCI system based on the SDIAS cycle time.&#13;&#10;The cycle time equals the SDIAS cylce time if it is on 1ms or higher.&#13;&#10;&#13;&#10;For example:&#13;&#10;A SDIAS cycle time of  250µs will lead to a SDCI cycle time of 1ms, &#13;&#10;while a SDIAS cycle time of 3ms leads to a SDCI cycle time of also 3ms."/>
		<Server Name="FirmwareVersion" GUID="{4E9C595E-316D-41B9-8785-9CD673DEB6FC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Server shows the actual FW Version of the Module in the format xx.yy&#13;&#10;&#13;&#10;e.g. 16#0130 means v01.30"/>
		<Server Name="NbrOfEventsAvailable" GUID="{B83BF077-FDA8-4EF0-84E1-9499C9D4F1AC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Number of master events available&#13;&#10;&#13;&#10;The events can be fetched one by one (beginning with the oldest) via method GetEvent()"/>
		<Server Name="PowerSupply" GUID="{8452F465-7DD6-4F56-885F-EED7CAE60AA4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of the power supply:&#13;&#10;&#13;&#10;Bit0..Port 1 Voltage Ok&#13;&#10;Bit1..Port 2 Voltage Ok&#13;&#10;Bit2..Port 3 Voltage Ok&#13;&#10;Bit3..Port 4 Voltage Ok&#13;&#10;Bit4..External Voltage Ok"/>
		<Client Name="HWKVarSizeFIFO1" Required="true" Internal="true"/>
		<Client Name="MaxBufferSize" Required="true" Internal="false" DefValue="1024" Comment="Size of the FIFO buffer for the asyncronous commands in byte. &#13;&#10;(As Init Value)&#13;&#10;The individual entries in the buffer have a variable size. &#13;&#10;One entry consists of 24Byte header + 0-232 Byte data."/>
		<Client Name="PdoProtection" Required="true" Internal="true"/>
		<Client Name="StartInInit" Required="false" Internal="false" DefValue="1" Comment="1 ... init of sensors is done in initialization  phase (default value)&#13;&#10;0 ... init of sensors is done in cyclic task&#13;&#10;&#13;&#10;Values from the sensors are valid only after ClassState=ClassOk!"/>
		<Client Name="WaitTimeReconnect" Required="true" Internal="false" DefValue="500" Comment="With this setting the minimum wait time in [msec] between start of a new port scan can be defined. (As Init Value)&#13;&#10;It is only used if a SDCIDevice has auto connect activated.&#13;&#10;500  ... default value&#13;&#10;0-1000  ... value range"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\BusInterface.h" Include="true"/>
			<File Path=".\Class\SdiasSDCIMaster\SdiasSDCIMaster.h" Include="true"/>
			<File Path=".\Class\VaranManager_Base\VaranManager_Base.h" Include="false"/>
			<File Path=".\Source\interfaces\lsl_st_varan.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.14" Date="24.08.2021" Author="RamAnd" Company="Sigmatek" Description="Added possibility to override the minimum cycle time of a device."/>
		<Dokumentation Revision="1.13" Date="04.06.2020" Author="PieSte" Company="Sigmatek" Description="Add client at SDCIDevice (Version &gt;= 1.7) to set wait time after port activation for communication with SDCI Device.&#13;&#10;Add client &quot;WaitTimeReconnect&quot; to set minimal wait time for next port scan if auto reconnect is activated.&#13;&#10;Reduced data to read from SDCI Device at init."/>
		<Dokumentation Revision="1.12" Date="19.06.2020" Author="LanSte" Company="Sigmatek" Description="Add support for the SDCIDevice methods GetReadPdoDataBit und SetWritePdoDataBit."/>
		<Dokumentation Revision="1.11" Date="24.03.2020" Author="PieSte" Company="Sigmatek" Description="Added support to scan and connect SDCI Devices automatically with setting of new AutoConnectTime client at SDCIDevice (&gt;=v1.5) or derived classes (SA 54052)."/>
		<Dokumentation Revision="1.10" Date="08.07.2019" Author="LanSte" Company="Sigmatek" Description="Added support to endianswap asy data."/>
		<Dokumentation Revision="1.9" Date="24.06.2019" Author="LanSte" Company="Sigmatek" Description="Added buffer for SDOs.&#13;&#10;Made asy commands threadsafe."/>
		<Dokumentation Revision="1.8" Date="04.04.2019" Author="HaeTho" Company="Sigmatek" Description="sensors may now be initialized either in init phase (as it was until now) or in cyclic task"/>
		<Dokumentation Revision="1.7" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.6" Date="06.03.2018" Author="EisMic" Company="Sigmatek" Description="Attached header files no longer point to the installation directory of LASAL but instead now point to the the source/interfaces folder."/>
		<Dokumentation Revision="1.5" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.4" Date="03.07.2017" Author="RamAnd" Company="Sigmatek" Description="Added support for SDIAS simple master (CP101/CP102)"/>
		<Dokumentation Revision="1.3" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error.&#13;&#10;Corrected port number check in newinst to prevent an access exception if a user connects the SDCI device on the wrong server."/>
		<Dokumentation Revision="1.2" Date="20.03.2017" Author="RamAnd" Company="Sigmatek" Description="Added the possibility to connect a module during runtime (call Reconnect() method of SDCIDevice).&#13;&#10;Added the possibility to skip the endian swap of the PDO data in both directions."/>
		<Dokumentation Revision="1.1" Date="03.03.2017" Author="ZoePat" Company="Sigmatek" Description="Changed message counter handling to avoid errors after restarting the application."/>
		<Dokumentation Revision="1.0" Date="14.02.2017" Author="ZoePat" Company="Sigmatek" Description="first release version."/>
	</RevDoku>
	<Network Name="SdiasSDCIMaster">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{EFB64040-67FE-4D24-9B06-12BE7F1FA92D}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "HWKVarSizeFIFO1"
				GUID       = "{24FF9822-823F-4F6B-8F01-847FAFCA97F5}"
				Class      = "HWKVarSizeFIFO"
				Position   = "(240,870)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassState"/>
					<Client Name="MaxBufferSize" Value="1024"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "PdoProtection"
				GUID       = "{682CD3A2-8381-4DBB-9D2F-615B5528BCBC}"
				Class      = "CriticalSection"
				Position   = "(240,690)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(1088,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(1088,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(1088,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(1088,390),(632,390),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(1088,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(1088,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(1088,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.PdoProtection" Destination="PdoProtection.ClassSvr"/>
			<Connection Source="this.HWKVarSizeFIFO1" Destination="HWKVarSizeFIFO1.ClassState"/>
			<Connection Source="HWKVarSizeFIFO1.MaxBufferSize" Destination="this.MaxBufferSize" Vertices="(240,1020),(38,690),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

SdiasSDCIMaster : CLASS
: SdiasBase
	TYPE
#pragma pack(push, 1)
	  t_SingleAccess : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : ^t_SDIAS_ControlByte;
	    pStateByte : ^t_SDIAS_StateByte;
	  END_STRUCT;
#pragma pack(pop)
	  t_FlagsRdy2OpAndOperating : BSINT
	  [
	    1 Port1Rdy2Op,
	    2 Port2Rdy2Op,
	    3 Port3Rdy2Op,
	    4 Port4Rdy2Op,
	    5 Port1Operating,
	    6 Port2Operating,
	    7 Port3Operating,
	    8 Port4Operating,
	  ];
	  t_FlagsOdeAndPde : BSINT
	  [
	    1 Port1OdeState,
	    2 Port2OdeState,
	    3 Port3OdeState,
	    4 Port4OdeState,
	    5 Port1PdeState,
	    6 Port2PdeState,
	    7 Port3PdeState,
	    8 Port4PdeState,
	  ];
	  t_FlagsDuAndDsUploaded : BSINT
	  [
	    1 Port1DuState,
	    2 Port2DuState,
	    3 Port3DuState,
	    4 Port4DuState,
	    5 Port1DsUploaded,
	    6 Port2DsUploaded,
	    7 Port3DsUploaded,
	    8 Port4DsUploaded,
	  ];
	  t_FaultFlagsTotal : BINT
	  [
	    1 Port1FaultFlag0,
	    2 Port1FaultFlag1,
	    3 Port1FaultFlag2,
	    4 Port1FaultFlag3,
	    5 Port2FaultFlag0,
	    6 Port2FaultFlag1,
	    7 Port2FaultFlag2,
	    8 Port2FaultFlag3,
	    9 Port3FaultFlag0,
	    10 Port3FaultFlag1,
	    11 Port3FaultFlag2,
	    12 Port3FaultFlag3,
	    13 Port4FaultFlag0,
	    14 Port4FaultFlag1,
	    15 Port4FaultFlag2,
	    16 Port4FaultFlag3,
	  ];
	  t_RtInfoBits : BSINT
	  [
	    1 Port1DataValid,
	    2 Port2DataValid,
	    3 Port3DataValid,
	    4 Port4DataValid,
	    5 EventAvailableAtPort1,
	    6 EventAvailableAtPort2,
	    7 EventAvailableAtPort3,
	    8 EventAvailableAtPort4,
	  ];
	  t_EventInfo : BINT
	  [
	    1 InstanceBit0,
	    2 InstanceBit1,
	    3 InstanceBit2,
	    4 InstanceBit3,
	    5 ModeBit0,
	    6 ModeBit1,
	    7 ModeBit2,
	    8 ModeBit3,
	    9 TypeBit0,
	    10 TypeBit1,
	    11 TypeBit2,
	    12 TypeBit3,
	    13 OriginBit0,
	    14 OriginBit1,
	    15 OriginBit2,
	    16 OriginBit3,
	  ];
	  t_EventCodes :
	  (
	    E_EVENT_NO_MALFUNCTION:=0,
	    E_EVENT_GENERAL_MALFUNCTION:=4096,
	    E_EVENT_EXCESS_AMBIENT_TEMPERATURE:=16656,
	    E_EVENT_TOO_LOW_AMBIENT_TEMPERATURE:=16672,
	    E_EVENT_EXCESS_DEVICE_TEMPERATURE:=16912,
	    E_EVENT_TOO_LOW_DEVICE_TEMPERATURE:=16928,
	    E_EVENT_EXCESS_PERIPHERY_TEMPERATURE:=17168,
	    E_EVENT_TOO_LOW_PERIPHERY_TEMPERATURE:=17184,
	    E_EVENT_HW_COMPONENT_MALFUNCTION:=20496,
	    E_EVENT_LOW_SUPPLY_VOLTAGE_15V:=20753,
	    E_EVENT_LOW_SUPPLY_VOLTAGE_24V:=20754,
	    E_EVENT_LOW_SUPPLY_VOLTAGE_5V:=20755,
	    E_EVENT_SHORT_CIRCUIT:=20817,
	    E_EVENT_OUTPUT_STAGE:=21520,
	    E_EVENT_FUSE_S1:=21585,
	    E_EVENT_FUSE_S2:=21586,
	    E_EVENT_FUSE_S3:=21587,
	    E_EVENT_SW_RESET_WATCHDOG:=24592,
	    E_EVENT_LOSS_OF_PARAMETER:=25360,
	    E_EVENT_PARAMETER_ERROR:=25376,
	    E_EVENT_PARAMETER_NOT_INITIALIZED:=25392,
	    E_EVENT_PARAMETER_NON_SPECIFIC:=25408,
	    E_EVENT_PARAMETER_CHANGED:=25424,
	    E_EVENT_PROCESS_DATA_MONITORING:=33040,
	    E_EVENT_EXCESS_PROCESS_VARIABLE_RANGE:=35856,
	    E_EVENT_EXCESS_MEASUREMENT_RANGE:=35872,
	    E_EVENT_TOO_LOW_PROCESS_VARIABLE_RANGE:=35888,
	    E_EVENT_ADVANCE_WARNING:=35904,
	    E_EVENT_EXTERNAL_MALFUNCTION:=36864,
	    E_EVENT_UV33UNDERVOLTAGE:=49409,
	    E_EVENT_OVERTEMPERATURE:=49410,
	    E_EVENT_UV24UNDERVOLTAGE:=49411,
	    E_EVENT_CQSHORTCUT:=49412,
	    E_EVENT_DSACCESSERROR:=49665,
	    E_EVENT_NEW_SLAVE:=65313,
	    E_EVENT_DEV_COM_LOST:=65314,
	    E_EVENT_DS_IDENT_MISMATCH:=65315,
	    E_EVENT_DS_BUFFER_OVERFLOW:=65316,
	    E_EVENT_DS_ACCESS_DENIED:=65317,
	    E_EVENT_DS_INCORRECT_EVENT:=65329,
	    E_EVENT_DS_UPLOAD_REQ:=65425
	  )$UINT;
#pragma pack(push, 1)
	  t_SDCIEventDetails : STRUCT  //! <Type Public="true" Comment="Instance (0..Unknown, 4..Application)&#13;&#10;Mode (1..Single shot, 2..Disappeared, 3..Appeared)&#13;&#10;Type (1..Notification, 2..Warning, 3..Error)&#13;&#10;Origin (0..Remote, 1..Local)" Name="t_SDCIEventDetails"/>
	    EventInfo : SdiasSDCIMaster::t_EventInfo;
	    EventCode : SdiasSDCIMaster::t_EventCodes;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_EventReadData : STRUCT
	    EventDatastate : BSINT
	    [
	      1 EventCntBit0,
	      2 EventCntBit1,
	      3 EventCntBit2,
	      4 EventCntBit3,
	      8 ValidityState,
	    ];
	    PortNumber : USINT;
	    EventsLeft : USINT;
	    EventDetails : SdiasSDCIMaster::t_SDCIEventDetails;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_CyclicReadInfo : STRUCT
	    FlagsRdy2OpAndOperating : SdiasSDCIMaster::t_FlagsRdy2OpAndOperating;
	    FlagsOdeAndPde : SdiasSDCIMaster::t_FlagsOdeAndPde;
	    FlagsDuAndDsUploaded : SdiasSDCIMaster::t_FlagsDuAndDsUploaded;
	    FaultFlags : SdiasSDCIMaster::t_FaultFlagsTotal;
	    RtInfoBits : SdiasSDCIMaster::t_RtInfoBits;
	    VoltageState : BSINT
	    [
	      1 Pwr24VPort1Ok,
	      2 Pwr24VPort2Ok,
	      3 Pwr24VPort3Ok,
	      4 Pwr24VPort4Ok,
	      5 Pwr24VExternalOk,
	    ];
	    DigInState : BSINT
	    [
	      1 InputPort1,
	      2 InputPort2,
	      3 InputPort3,
	      4 InputPort4,
	    ];
	    EventData : SdiasSDCIMaster::t_EventReadData;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_Accesses : STRUCT
	    pPDOReadData : ^void;
	    PDOReadDataAccessExtra : SdiasSDCIMaster::t_SingleAccess;
	    pCyclicReadInfo : ^SdiasSDCIMaster::t_CyclicReadInfo;
	    CyclicReadInfoAccessOrCombined : SdiasSDCIMaster::t_SingleAccess;
	    pPDOWriteData : ^void;
	    PDOWriteDataAccess : SdiasSDCIMaster::t_SingleAccess;
	  END_STRUCT;
#pragma pack(pop)
	  t_BusIFRetvalErrorcode :
	  (
	    _BUS_IF_RETVAL_OK,
	    _BUS_IF_RETVAL_ERROR_DO_LIST_FULL,
	    _BUS_IF_RETVAL_ERROR_CREATE_DO_FAILED,
	    _BUS_IF_RETVAL_ERROR_INVALID_POINTER,
	    _BUS_IF_RETVAL_ERROR_INVALID_HANDLE,
	    _BUS_IF_RETVAL_ERROR_UPDATEDO_DOLENGTH,
	    _BUS_IF_RETVAL_ERROR_BUSCYCLE_TIME_NOT_AVAILABLE,
	    _BUS_IF_RETVAL_ERROR_INVALID_SYNC,
	    _BUS_IF_RETVAL_ERROR_INVALID_DATA,
	    _BUS_IF_RETVAL_ERROR_NOT_SUPPORTED,
	    _BUS_IF_RETVAL_ERROR_CREATE_MUTEX_FAILED,
	    _BUS_IF_RETVAL_ERROR_DIRECT_ACCESS_FAILED,
	    _BUS_IF_RETVAL_ERROR_MOVE_DO_LIST_FULL,
	    _BUS_IF_RETVAL_ERROR_CREATE_MOVE_DO_FAILED,
	    _BUS_IF_RETVAL_ERROR_UPDATE_MOVE_DO_FAILED,
	    _BUS_IF_RETVAL_ERROR_NO_CALLBACK_INSTALLED
	  )$UDINT;
	  t_AccessInfoRet : STRUCT
	    retcode : SdiasSDCIMaster::t_BusIFRetvalErrorcode;
	    ud_handle : UDINT;
	    ud_addressoff : HDINT;
	    p_dataDPRAM : ^void;
	  END_STRUCT;
	  t_BusIFRDWR :
	  (
	    _BUS_IF_READ,
	    _BUS_IF_WRITE,
	    _BUS_IF_READ_WRITE
	  )$UINT;
	  t_BusIFPriority :
	  (
	    _BUS_IF_ISO,
	    _BUS_IF_ASY,
	    _BUS_IF_ISO_MOVE,
	    _BUS_IF_ASY_MOVE
	  )$UINT;
	  t_AddDOCfg : STRUCT
	    ui_length_read : UINT;
	    ud_addressoff_read : HDINT;
	    ui_length_write : UINT;
	    ud_addressoff_write : HDINT;
	    RdWr : SdiasSDCIMaster::t_BusIFRDWR;
	    Priority : SdiasSDCIMaster::t_BusIFPriority;
	    b_DOIsChangable : BOOL;
	    ppDataRead : ^void;
	    ppDataWrite : ^void;
	    ud_WaitForAccessHandle : UDINT;
	    b_UseLocalCopy : BOOL;
	  END_STRUCT;
	  t_AddDORet : STRUCT
	    retcode : SdiasSDCIMaster::t_BusIFRetvalErrorcode;
	    sd_retval : DINT;
	    Handle : UDINT;
	    pDataRead : ^void;
	    pDataWrite : ^void;
	    AccessHandle : UDINT;
	  END_STRUCT;
	  t_AddMoveDOCfg : STRUCT
	    ud_length_move : UINT;
	    ud_handle_source : UDINT;
	    ud_addressoff_source : HDINT;
	    p_sourcedata : ^void;
	    ud_handle_dest : UDINT;
	    ud_addressoff_dest : HDINT;
	    p_destdata : ^void;
	    Priority : SdiasSDCIMaster::t_BusIFPriority;
	  END_STRUCT;
	  t_AddMoveDORet : STRUCT
	    retcode : SdiasSDCIMaster::t_BusIFRetvalErrorcode;
	    sd_retval : DINT;
	    Handle : UDINT;
	  END_STRUCT;
	  t_AsyCmdType :
	  (
	    SingleAsyTransfer,
	    ModeChange,
	    Reconnect,
	    DelayedEnable
	  )$UDINT;
	  t_AsySSW :
	  (
	    _Idle,
	    _StartDelayedEnable,
	    _StartReconnect,
	    _StartModeChange,
	    _RecoDisablePortBe4ScanMode,
	    _RecoSwitchToDisableModeBe4ScanMode,
	    _RecoWait4DisableModeBe4ScanMode,
	    _RecoSetScanMode,
	    _RecoSwitchToScanMode,
	    _RecoWait4ScanMode,
	    _RecoGetDeviceInfos,
	    _RecoUpdateDeviceObjInfo,
	    _RecoCheckDownloadParameters,
	    _RecoDownloadParameters,
	    _SetPortInactive,
	    _SwitchToDisableMode,
	    _Wait4DisableMode,
	    _ConfigurePort,
	    _SwitchToNewMode,
	    _Wait4NewMode,
	    _SetOperateAndPdOutValid,
	    _Wait4Operate,
	    _UpdateClassState,
	    _Finished,
	    _AsyError
	  )$UDINT;
#pragma pack(push, 1)
	  t_BitInfo : STRUCT
	    BitOffset : UINT;
	    BitLength : UINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_BusIFAddCallback : STRUCT
	    pthis : ^VirtualBase;
	  END_STRUCT;
	  t_BusIFRunState :
	  (
	    _BUS_IF_RUN_STATE_NO_RUN,
	    _BUS_IF_RUN_STATE_SINGLE_RUN,
	    _BUS_IF_RUN_STATE_CONT_RUN
	  )$USINT;
	  t_BusIFType :
	  (
	    _BUS_IF_TYPE_VARAN,
	    _BUS_IF_TYPE_SDIAS,
	    _BUS_IF_TYPE_LOCAL
	  )$UDINT;
#pragma pack(push, 1)
	  t_ConfigTable : STRUCT
	    TotalTableSize : UDINT;
	    IOLK_Mark : ARRAY [0..3] OF CHAR;
	    Version : UDINT;
	    DeviceID : UDINT;
	    VendorID : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_ParaAccessType :
	  (
	    rw,
	    ro,
	    wo
	  )$USINT;
	  t_ParaDataType :
	  (
	    _None,
	    _BoolBit,
	    _BoolByte,
	    _Float32,
	    _Int8,
	    _Int16,
	    _Int32,
	    _Int64,
	    _Uint8,
	    _Uint16,
	    _Uint32,
	    _Uint64,
	    _Text
	  )$USINT;
#pragma pack(push, 1)
	  t_ConfigTablePara : STRUCT
	    ParaID : UDINT;
	    ParaSubID : UDINT;
	    AccessType : SdiasSDCIMaster::t_ParaAccessType;
	    DataType : SdiasSDCIMaster::t_ParaDataType;
	    DataLength : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_ControlFlags : BINT
	  [
	    1 DsActivationStop,
	    2 DsActivationStart,
	    3 PdOutInvalid,
	    4 PdOutValid,
	    5 EventAcknowledge,
	    6 DsDelete,
	    7 Start2Operate,
	    8 OperatingMode,
	    11 PdStop,
	    12 PdStart,
	    13 DuStop,
	    14 DuStart,
	    15 OdStop,
	    16 OdStart,
	  ];
#pragma pack(push, 1)
	  t_DeviceInfoAnswer : STRUCT
	    MasterCmd : USINT;
	    MasterCycleTime : USINT;
	    MinCycleTime : USINT;
	    MSequenceCompatibility : USINT;
	    RevisionID : USINT;
	    ProcessDataIn : USINT;
	    ProcessDataOut : USINT;
	    VendorIdMsb : USINT;
	    VendorIdLsb : USINT;
	    DeviceIdMsb : USINT;
	    DeviceIdMiddleByte : USINT;
	    DeviceIdLsb : USINT;
	    FunctionIdMsb : USINT;
	    FunctionIdLsb : USINT;
	    Reserved : USINT;
	    SystemCommand : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_DOCfg : STRUCT
	    pHandle : ^LSL_VARANFRAME;
	    pDataRead : ^void;
	    pDataWrite : ^void;
	    lengthRead : UINT;
	    lengthWrite : UINT;
	    maxLengthRead : UINT;
	    maxLengthWrite : UINT;
	    AddrOffsetRead : HDINT;
	    AddrOffsetWrite : HDINT;
	    RdWr : SdiasSDCIMaster::t_BusIFRDWR;
	    Priority : SdiasSDCIMaster::t_BusIFPriority;
	    OldRetryCounter : USINT;
	    Enable : USINT;
	    EnableFlag : USINT;
	    PreScaler : USINT;
	    IsLongDO : BOOL;
	    pLongDOSettings : ^t_VaranDOSettingsLong;
	    b_DOIsRunning : t_SingleRunState;
	    b_DOIsChangable : BOOL;
	    pLocalRdMem : ^void;
	    pLocalWrMem : ^void;
	  END_STRUCT;
	  t_DOMoveCfg : STRUCT
	    pHandle : ^LSL_VARANFRAME;
	    sourceDOHandle : UDINT;
	    pSourceDOData : ^void;
	    sourceDOOffset : UDINT;
	    destDOHandle : UDINT;
	    pDestDOData : ^void;
	    destDOOffset : UDINT;
	    lengthMove : UINT;
	    lengthMoveMax : UINT;
	    Priority : SdiasSDCIMaster::t_BusIFPriority;
	    b_DOIsRunning : t_SingleRunState;
	    p_MovSettings : ^t_VaranDOSettingsMov;
	  END_STRUCT;
#pragma pack(push, 1)
	  t_FirmwareInfoData : STRUCT
	    Version : HINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_FirmwareInfo : STRUCT
	    CRC : HINT;
	    LengthOfData : UINT;
	    Data : SdiasSDCIMaster::t_FirmwareInfoData;
	  END_STRUCT;
#pragma pack(pop)
	  t_FunctionIDs :
	  (
	    E_FNCID_GETINFO,
	    E_FNCID_SETPDI,
	    E_FNCID_GETPDI,
	    E_FNCID_CNTSTA,
	    E_FNCID_SETPORTCNFPAR,
	    E_FNCID_GETPORTCNFPAR,
	    E_FNCID_SETDSHDR,
	    E_FNCID_GETDSHDR,
	    E_FNCID_UPLDS,
	    E_FNCID_DWNDS,
	    E_FNCID_ISDUREQ,
	    E_FNCID_ISDUGET,
	    E_FNCID_RDEVENT,
	    E_FNCID_SWITCHOFF,
	    E_FNCID_SWITCHON,
	    E_FNCID_UPLDS_SHORT:=24,
	    E_FNCID_DWNDS_SHORT:=25,
	    E_FNCID_GETCOMPLETEINFO:=32
	  )$USINT;
	  t_GetBusCycleTime : STRUCT
	    retcode : SdiasSDCIMaster::t_BusIFRetvalErrorcode;
	    udBusCycleTime : UDINT;
	    udIsoStartPoint : UDINT;
	    udMainTimer : UDINT;
	  END_STRUCT;
	  t_InitSSW :
	  (
	    _InitVariables,
	    _GetFwInfo,
	    _GetActMessageCnt,
	    _Set24VSupplyOn,
	    _DisablePorts,
	    _SwitchToDisableMode,
	    _Wait4DisableMode,
	    _ConfigurePorts,
	    _EnableMasterServices,
	    _SwitchToNewMode,
	    _Wait4NewMode,
	    _GetDeviceInfos,
	    _UpdateDeviceObjInfo,
	    _CheckDownloadParameters,
	    _DownloadParameters,
	    _DisableSdciPorts,
	    _SwitchToDisableMode2,
	    _Wait4DisableMode2,
	    _Configure2StartUpMode,
	    _EnableDigIOStartUpModes,
	    _SetCycleTimes,
	    _ResetOutputImage,
	    _Finished,
	    _Error
	  )$UDINT;
	  t_LogErrorMsg : STRUCT
	    e_msg : ^CHAR;
	    p_extThis1 : ^VirtualBase;
	    p_extThis2 : ^VirtualBase;
	  END_STRUCT;
	  t_LogValue : STRUCT
	    e_msg : ^CHAR;
	    p_extThis : ^VirtualBase;
	    val1 : UDINT;
	    val2 : UDINT;
	    val3 : UDINT;
	  END_STRUCT;
	  t_OpModeStates :
	  (
	    E_OPMODE_INACTIVE,
	    E_OPMODE_DO,
	    E_OPMODE_DI,
	    E_OPMODE_FIXEDMODE,
	    E_OPMODE_SCANMODE
	  )$USINT;
	  t_PdoBuf : ARRAY [0..127] OF USINT;
#pragma pack(push, 1)
	  t_PdoMapping : STRUCT
	    ReadDataStartAddress : HINT;
	    ReadDataLength : USINT;
	    ReadDataBitLength : USINT;
	    WriteDataStartAddress : HINT;
	    WriteDataLength : USINT;
	    WriteDataBitLength : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_PortCycle :
	  (
	    E_PORTCYCLE_FREERN,
	    E_PORTCYCLE_FIXVAL,
	    E_PORTCYCLE_MSGSYN
	  )$USINT;
	  t_SDCIPortMode :  //! <Type Public="true" Name="t_SDCIPortMode"/>
	  (
	    _Inactive,
	    _DigitalInput,
	    _DigitalOutput,
	    _SDCI
	  )$UDINT;
	  t_SDCIPortStateBits : BDINT  //! <Type Public="true" Name="t_SDCIPortStateBits"/>
	  [
	    1 Operating,
	    2 ReadyToOperate,
	    3 InputProcessDataValid,
	    4 EventAvailable,
	    5 OdeState,
	    6 PdeState,
	    7 DuState,
	    8 DsUploaded,
	  ];
#pragma pack(push, 1)
	  t_PortInfo : STRUCT
	    CfgPortMode : t_SDCIPortMode;  //! <Type Comment="The port mode of the configuration (LogIn of the device)" Name="t_PortInfo.CfgPortMode"/>
	    StartUpMode : t_SDCIPortMode;  //! <Type Comment="The selected mode to switch to after startup (only possible if CfgPortMode is SDCI)" Name="t_PortInfo.StartUpMode"/>
	    ActPortMode : t_SDCIPortMode;  //! <Type Comment="The current mode of this port (can be switched during runtime)" Name="t_PortInfo.ActPortMode"/>
	    pThis : ^SDCIDevice;
	    PdoMapping : SdiasSDCIMaster::t_PdoMapping;
	    pInputServer : ^void;
	    pOutputServer : ^void;
	    pPortStateBits : ^SdiasSDCIMaster::t_SDCIPortStateBits;
	    pFaultFlags : ^UDINT;
	    udOldFaultFlag : UDINT;
	    pDirectInputServer : ^void;
	    pCfgTable : ^SdiasSDCIMaster::t_ConfigTable;
	    NoOfParameters : UDINT;
	    pFirstPara : ^SdiasSDCIMaster::t_ConfigTablePara;
	    ActParaNo : UDINT;
	    pActPara : ^SdiasSDCIMaster::t_ConfigTablePara;
	    pReadData : ^void;
	    pWriteData : ^void;
	    PhysicallyAvailable : BOOL;
	    MinCycleTime_us : UDINT;
	    OverrideMinCycleTime_us : UDINT;
	    DeviceID : UDINT;
	    VendorID : UINT;
	    RevisionID : USINT;
	    PdInBitInfoNo : DINT;
	    pFirstPdIn : ^SdiasSDCIMaster::t_BitInfo;
	    PdOutBitInfoNo : DINT;
	    pFirstPdOut : ^SdiasSDCIMaster::t_BitInfo;
	    SkipEndianSwap : BOOL;
	    SkipEndianSwapAsy : BOOL;
	    Required : DINT;
	    udAutoConnectTime : UDINT;
	    udModeChangeTime : UDINT;
	    udStartConnect : UDINT;
	    udStartConnTimeDiff : UDINT;
	    aDeviceInfo : ARRAY [0..SIOL_DEVICEINFO_SIZE-1] OF USINT;
	    biDeviceInfoSub : BINT
	    [
	      1 MasterCmd,
	      2 MasterCycleTime,
	      3 MinCycleTime,
	      4 MSequenceCompatibility,
	      5 RevisionID,
	      6 ProcessDataIn,
	      7 ProcessDataOut,
	      8 VendorIdMsb,
	      9 VendorIdLsb,
	      10 DeviceIdMsb,
	      11 DeviceIdMiddleByte,
	      12 DeviceIdLsb,
	      13 FunctionIdMsb,
	      14 FunctionIdLsb,
	      15 Reserved,
	      16 SystemCommand,
	    ];
	    usActSubIndex : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PortStateBitsTotal : STRUCT
	    ReadyAndOperating : SdiasSDCIMaster::t_FlagsRdy2OpAndOperating;
	    RtInfo : SdiasSDCIMaster::t_RtInfoBits;
	    OdeAndPde : SdiasSDCIMaster::t_FlagsOdeAndPde;
	    DuAndDsUploaded : SdiasSDCIMaster::t_FlagsDuAndDsUploaded;
	  END_STRUCT;
#pragma pack(pop)
	  t_RDWRDOCfg : STRUCT
	    ud_AddOffset : HDINT;
	    ud_length : UDINT;
	    p_ud_data : ^void;
	  END_STRUCT;
	  t_ReponseState :
	  (
	    _PrepareSendData,
	    _SendData,
	    _Wait4SendResponse,
	    _GotSendResponse,
	    _ReadData,
	    _Wait4ReceiveData,
	    _GotReceiveData,
	    _GotAllReceiveData
	  )$UDINT;
	  t_ResetDOCfg : STRUCT
	    Handle : UDINT;
	  END_STRUCT;
#pragma pack(push, 1)
	  t_SDCIEventBuffer : STRUCT  //! <Type Public="true" Name="t_SDCIEventBuffer"/>
	    EventWrIndex : USINT;
	    EventRdIndex : USINT;
	    aEvents : ARRAY [0..SIOL_EVENT_BUFFER_SIZE-1] OF SdiasSDCIMaster::t_SDCIEventDetails;
	  END_STRUCT;
#pragma pack(pop)
	  t_SDCIRetCode :  //! <Type Public="true" Name="t_SDCIRetCode"/>
	  (
	    SDCI_Busy:=1,
	    SDCI_Ready_Ok:=0,
	    SDCI_InvalidPointer:=4294967295,
	    SDCI_InvalidLength:=4294967294,
	    SDCI_InvalidLengthOffsetCombination:=4294967293,
	    SDCI_NoReadDataAtModule:=4294967292,
	    SDCI_NoWriteDataAtModule:=4294967291,
	    SDCI_NotAvailableAtThisPort:=4294967290,
	    SDCI_ModuleNotAvailable:=4294967289,
	    SDCI_ReadDataCurrentlyNotValid:=4294967288,
	    SDCI_PortNbrNotSupported:=4294967287,
	    SDCI_UnspecifiedError:=4294967286,
	    SDCI_TimeoutInComToMicroCtrl:=4294967285,
	    SDCI_InvalidChecksumFromMicroCtrl:=4294967284,
	    SDCI_MicroCtrl_ApplicationError:=4294967283,
	    SDCI_MicroCtrl_InvalidChkSum:=4294967282,
	    SDCI_MicroCtrl_FunctionIdNotSupported:=4294967281,
	    SDCI_MicroCtrl_InvalidParamUsage:=4294967280,
	    SDCI_MicroCtrl_ServiceNotAvailable:=4294967279,
	    SDCI_MicroCtrl_RspLengthTooBig:=4294967278,
	    SDCI_MicroCtrl_UnexpectedRspLength:=4294967277,
	    SDCI_MicroCtrl_UnexpectedRspData:=4294967276
	  )$DINT;
	  t_SDIASDOCfg : STRUCT
	    pControlByte : ^t_SDIAS_ControlByte;
	    pStatusByte : ^t_SDIAS_StateByte;
	    pDataRead : ^void;
	    pDataWrite : ^void;
	    lengthRead : UINT;
	    lengthWrite : UINT;
	    AddrOffsetRead : HDINT;
	    AddrOffsetWrite : HDINT;
	    RdWr : SdiasSDCIMaster::t_BusIFRDWR;
	    Priority : SdiasSDCIMaster::t_BusIFPriority;
	    Enable : USINT;
	    EnableFlag : USINT;
	    b_DOIsRunning : t_SingleRunState;
	    AccessHandle : UDINT;
	  END_STRUCT;
	  t_SDIASSDORequest : STRUCT
	    ud_Command : UDINT;
	    ud_SDIAS_Addr : HDINT;
	    ud_DataLength : UDINT;
	    p_RequestBuffer : ^void;
	    p_SDO_Handle : ^UDINT;
	  END_STRUCT;
	  t_SDIASSDOResponse : STRUCT
	    ud_SDO_Handle : UDINT;
	    ud_BufferLength : UDINT;
	    p_ResponseBuffer : ^void;
	    p_ResponseLength : ^UDINT;
	  END_STRUCT;
	  t_ServiceDataUsage :
	  (
	    _Invalid,
	    _ReadParaData,
	    _WriteParaData,
	    _SendFunctionCode,
	    _SendCycleTimeInfo
	  )$USINT;
	  t_ServiceDataFwRetcode :
	  (
	    _FwOk,
	    _FunctionIdNotSupported,
	    _InvalidUsageParameter,
	    _InvalidChecksum,
	    _ApplicationError,
	    _ServiceNotAvailable,
	    _InvalidRetcode:=255
	  )$USINT;
#pragma pack(push, 1)
	  t_ServiceDataArea : STRUCT
	    aData : ARRAY [0..SIOL_MAX_SDO_DATA_SIZE-1] OF USINT;
	    ParaIndex : UINT;
	    ParaSubIndex : USINT;
	    PortSelection : USINT;
	    LengthOfData : USINT;
	    wo_ActUsage : SdiasSDCIMaster::t_ServiceDataUsage;
	    wo_Checksum : USINT;
	    wo_MessageCnt : USINT;
	    ro_RetCode : SdiasSDCIMaster::t_ServiceDataFwRetcode;
	    ro_Checksum : USINT;
	    ro_MessageCnt : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SdoData : STRUCT
	    eResponseState : SdiasSDCIMaster::t_ReponseState;
	    eInitSSW : SdiasSDCIMaster::t_InitSSW;
	    eAsySSW : SdiasSDCIMaster::t_AsySSW;
	    AsyState : t_SDCIRetCode;  //! <Type Comment="  1..busy&#13;&#10;  0..ready&#13;&#10;&lt;0..error" Name="t_SdoData.AsyState"/>
	    AsyErrorCode : t_SDCIRetCode;
	    AsyCmdType : SdiasSDCIMaster::t_AsyCmdType;
	    TargetMode : SdiasSDCIMaster::t_SDCIPortMode;
	    TimeoutStart : UDINT;
	    ResponseTimeoutStart : UDINT;
	    pActData : ^void;
	    DataLock : UDINT;
	    pCallBackFun : pVoid;
	    pCallBackThis : pVirtualBase;
	    RetryCnt : USINT;
	    ActDataSize : USINT;
	    RemainingDataSize : USINT;
	    ActPortSelection : USINT;
	    SdoReadData : SdiasSDCIMaster::t_ServiceDataArea;
	    SdoWriteData : SdiasSDCIMaster::t_ServiceDataArea;
	    SdoReadDataSwapped : ARRAY [0..SIOL_MAX_SDO_DATA_SIZE-1] OF USINT;
	    bSingleAsyTransferReady : BOOL;
	    udSingleAsyTransferReady : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SDOFIFOHeader : STRUCT
	    NewInstCmd : UINT;
	    ParaIndex : UINT;
	    ParaSubIndex : USINT;
	    PortSelection : USINT;
	    LengthOfData : USINT;
	    pThis : pVirtualBase;
	    pCallBackFunction : pVoid;
	  END_STRUCT;
#pragma pack(pop)
	  t_SetDoPrescaler : STRUCT
	    Handle : UDINT;
	    Prescaler : USINT;
	  END_STRUCT;
	  t_SetOnlineCfg : STRUCT
	    val : DINT;
	  END_STRUCT;
	  t_SetRunStateCfg : STRUCT
	    handle : UDINT;
	    newRunState : SdiasSDCIMaster::t_BusIFRunState;
	  END_STRUCT;
#pragma pack(push, 1)
	  t_SingleDynamicAccess : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : ^t_SDIAS_ControlStructDynamic;
	    pStateByte : ^t_SDIAS_StateByte;
	  END_STRUCT;
#pragma pack(pop)
	  t_StatusFlags : BINT
	  [
	    1 DsUploaded,
	    2 PdeStatus,
	    3 DuStatus,
	    4 OdeStatus,
	    5 PdInStatus,
	    6 EventIndication,
	    7 Operating,
	    8 Ready2Operate,
	    9 IsduStateBit0,
	    10 IsduStateBit1,
	    11 IsduStateBit2,
	    12 IsduStateBit3,
	    13 FaultBit0,
	    14 FaultBit1,
	    15 FaultBit2,
	    16 FaultBit3,
	  ];
	  t_SyncData : STRUCT
	    us_sync_nr : USINT;
	    sd_offset : DINT;
	    us_period_multiplier : USINT;
	    us_frame_count_threshold : USINT;
	    us_enable_frame_count : USINT;
	    b_use_divider_sync : BOOL;
	  END_STRUCT;
	  t_TaskCfg : STRUCT
	    Priority : SdiasSDCIMaster::t_BusIFPriority;
	    pthis : UDINT;
	    callOptions : USINT;
	  END_STRUCT;
	  t_TaskPreScaler : STRUCT
	    Prescaler : USINT;
	    RtPreScanTrigger : USINT;
	    RtPostScanTrigger : USINT;
	    CyTrigger : USINT;
	  END_STRUCT;
	  t_UpdateDOCfg : STRUCT
	    Handle : UDINT;
	    ud_length_read : UINT;
	    ud_addressoff_read : HDINT;
	    ud_length_write : UINT;
	    ud_addressoff_write : HDINT;
	  END_STRUCT;
	  t_UpdateDOMoveCfg : STRUCT
	    Handle : UDINT;
	    ud_length_move : UINT;
	    ud_handle_source : UDINT;
	    ud_addressoff_source : HDINT;
	    p_sourcedata : ^void;
	    ud_handle_dest : UDINT;
	    ud_addressoff_dest : HDINT;
	    p_destdata : ^void;
	  END_STRUCT;
#pragma pack(push, 1)
	  ts_AutoConnectVars : STRUCT
	    bAutoConnectActive : BOOL;
	    udLastReconnectTry : UDINT;
	    usActPortNbr : USINT;
	    bReConnectStarted : BOOL;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	CycleTime 	: SvrCh_UDINT;
	PowerSupply 	: SvrCh_BDINT;
	NbrOfEventsAvailable 	: SvrCh_DINT;
  //Clients:
	PdoProtection 	: CltChCmd_CriticalSection;
	StartInInit 	: CltCh_DINT;
	MaxBufferSize 	: CltCh_UDINT;
	WaitTimeReconnect 	: CltCh_UDINT;
	HWKVarSizeFIFO1 	: CltChCmd_HWKVarSizeFIFO;
  //Variables:
		TotalMappingWriteSize 	: USINT;
		TotalMappingReadSize 	: USINT;
		LocalReadPDOBuf 	: SdiasSDCIMaster::t_PdoBuf;
		LocalWritePDOBuf 	: SdiasSDCIMaster::t_PdoBuf;
		aPortInfo : ARRAY [0..SIOL_MAX_PORTS_SUPPORTED-1] OF SdiasSDCIMaster::t_PortInfo;

		sAccesses 	: SdiasSDCIMaster::t_Accesses;
		sSdoData 	: SdiasSDCIMaster::t_SdoData;
		FwInfo 	: SdiasSDCIMaster::t_FirmwareInfo;
		OldEventCounter 	: USINT;
		EventBuffer 	: SdiasSDCIMaster::t_SDCIEventBuffer;
		EventDropCounter 	: UDINT;
		ParaDownloadTime 	: UDINT;
		DownloadTimeStart 	: UDINT;
		SetFixedModeStartTime 	: UDINT;
		Wait4DeviceDisableStartTime 	: UDINT;
		CyclicInfoTotal 	: t_CyclicReadInfo;
		OldStep 	: SdiasSDCIMaster::t_InitSSW;
		StepTimes : ARRAY [0..99] OF UDINT;

		OldAsyStep 	: SdiasSDCIMaster::t_AsySSW;
		AsyStepTimes : ARRAY [0..99] OF UDINT;

		DelayedEnablePorts : BSINT
		[
		  8 FirstTime,
		];

		b_DoTheInit 	: BOOL;
		b_LogAsyCalls : BDINT
		[
		  1 DirectAsyAccessUsed,
		  2 BufferAsyAccessUsed,
		  3 AsyWarnLogDone,
		];

		sAutoConnectVars 	: ts_AutoConnectVars;
  //Functions:
				//! <Function Comment="Init-Methode of Class.&#13;&#10;&#13;&#10;This Methode needs to get called. In case the Methode gets overwritten, a call needs to bet installed." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Cyclic Update Methode which runs in PostScan." Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION CalcChecksum
		VAR_INPUT
			Mode 	: DINT;			//! <Variable Comment="0..ReadData&#13;&#10;1..WriteData" Name="CalcChecksum.Mode"/>
		END_VAR
		VAR_OUTPUT
			Result 	: USINT;			//! <Variable Comment="Returns the calculated checksum&#13;&#10;&#13;&#10;At the read data (mode 0) this should be 0 because the received checksum is already considered&#13;&#10;At the write data (mode 1) this is the value that should be stored in the checksum field" Name="CalcChecksum.Result"/>
		END_VAR;
	
	FUNCTION InitializeCyclicSSW
		VAR_INPUT
			pPara 	: ^CmdStruct;
			Usage 	: SdiasSDCIMaster::t_ServiceDataUsage;
		END_VAR
		VAR_OUTPUT
			retcode 	: iprStates;
		END_VAR;
	
	FUNCTION InitializeSdoWriteData
		VAR_INPUT
			Usage 	: SdiasSDCIMaster::t_ServiceDataUsage;
			ParaIndex 	: UINT;
			ParaSubIndex 	: USINT;
			PortSelection 	: USINT;
			LengthOfData 	: USINT;
			pData 	: ^void;
			pParaInfo 	: ^t_ConfigTablePara := nil;
		END_VAR
		VAR_OUTPUT
			retcode 	: iprStates;
		END_VAR;
	
	FUNCTION GetSdoReadData
		VAR_INPUT
			pLength 	: ^USINT;
			pData 	: ^void;
			bDoEndianSwap 	: BOOL := FALSE;
		END_VAR;
	
	FUNCTION HandleSdoDataTransfer
		VAR_OUTPUT
			retcode 	: iprStates;
		END_VAR;
	
	FUNCTION GetNextParaFromTable
		VAR_INPUT
			pActPortInfo 	: ^SdiasSDCIMaster::t_PortInfo;
		END_VAR;
	
	FUNCTION SelectNextDownloadPara
		VAR_INPUT
			AlsoSearchOtherPorts 	: BOOL := TRUE;			//! <Variable Comment="TRUE..select next port if no more parameters on this one&#13;&#10;FALSE..stop searching and do not select the next port if there are no more parameters" Name="SelectNextDownloadPara.AlsoSearchOtherPorts"/>
		END_VAR
		VAR_OUTPUT
			Success 	: BOOL;
		END_VAR;
	
	FUNCTION AddEventToBuffer
		VAR_INPUT
			pEventDetails 	: ^SdiasSDCIMaster::t_SDCIEventDetails;
		END_VAR;
				//! <Function Comment="Fetch oldest available event" Name="GetEvent"/>
	FUNCTION VIRTUAL GLOBAL GetEvent
		VAR_OUTPUT
			OldestEventAvailable 	: SdiasSDCIMaster::t_SDCIEventDetails;			//! <Variable Comment="Returns the oldest available event in the buffer or an event code and info of 0 if there are no events" Name="GetEvent.OldestEventAvailable"/>
		END_VAR;
	
	FUNCTION PrepareParaTabAccess
		VAR_INPUT
			pPortInfo 	: ^SdiasSDCIMaster::t_PortInfo;
		END_VAR;
	
	FUNCTION ExtendPostInitTime
		VAR_INPUT
			AdditionalTime 	: UDINT;
		END_VAR;
	
	FUNCTION SetRequiredError;
	
	FUNCTION AsySSW;
	
	FUNCTION ChangeModeIsPossible
		VAR_INPUT
			TargetPort 	: USINT;
			TargetMode 	: SdiasSDCIMaster::t_SDCIPortMode;
		END_VAR
		VAR_OUTPUT
			ChangeIsPossible 	: BOOL;
		END_VAR;
	
	FUNCTION InitTheModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL HandleSDOFifo;
	
	FUNCTION VIRTUAL HandleSDOCallback;
	
	FUNCTION FindParaInTable
		VAR_INPUT
			pActPortInfo 	: ^SdiasSDCIMaster::t_PortInfo;
			ParaID 	: UDINT;
			ParaSubID 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pParaInfo 	: ^t_ConfigTablePara;
		END_VAR;
	
	FUNCTION VIRTUAL CheckEndianSwapNeeded
		VAR_INPUT
			pParaInfo 	: ^t_ConfigTablePara;
			PortSelection 	: USINT;
		END_VAR
		VAR_OUTPUT
			bCheckEndianSwapNeeded 	: BOOL;
		END_VAR;
	
	FUNCTION EndianSwap
		VAR_INPUT
			pDst 	: ^USINT;
			pSrc 	: ^USINT;
			LengthOfData 	: USINT;
		END_VAR;
	
	FUNCTION HandleAutoConnect
		VAR_INPUT
			usPortNbr 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
		END_VAR;
	
	FUNCTION TAB BitMask;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using CriticalSection
#pragma using HWKVarSizeFIFO


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SdiasSDCIMaster::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SDIASSDCIMASTER
1$UINT, 14$UINT, (SIZEOF(::SdiasSDCIMaster))$UINT, 
4$UINT, 5$UINT, 0$UINT, 
TO_UDINT(2874110376), "SdiasSDCIMaster", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::SdiasSDCIMaster.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::SdiasSDCIMaster.CycleTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2924485542), "CycleTime", 
(::SdiasSDCIMaster.PowerSupply.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(749722340), "PowerSupply", 
(::SdiasSDCIMaster.NbrOfEventsAvailable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2952604227), "NbrOfEventsAvailable", 
//Clients:
(::SdiasSDCIMaster.PdoProtection.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(802900649), "PdoProtection", TO_UDINT(794617671), "CriticalSection", 0$UINT, 4$UINT, 
(::SdiasSDCIMaster.StartInInit.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(761620976), "StartInInit", 
(::SdiasSDCIMaster.MaxBufferSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(194656658), "MaxBufferSize", 
(::SdiasSDCIMaster.WaitTimeReconnect.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1272646408), "WaitTimeReconnect", 
(::SdiasSDCIMaster.HWKVarSizeFIFO1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1979188593), "HWKVarSizeFIFO1", TO_UDINT(2647432661), "HWKVarSizeFIFO", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_SdiasSDCIMaster 29

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SdiasSDCIMaster] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SdiasSDCIMaster::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SdiasSDCIMaster;
	vmt.CmdTable.NewInstr		:= #ClassState::NewInst();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #HandleSDOFifo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #HandleSDOCallback();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #CheckEndianSwapNeeded();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd SDCIDevice

//{{LSL_IMPLEMENTATION
FUNCTION GLOBAL AsyCallBackSdiasSDCIMaster
VAR_INPUT
  pThis         : pVoid;
  AsyState      : SdiasSDCIMaster::t_SDCIRetCode;
  LengthOfData  : USINT;
  pData         : ^USINT;
END_VAR;

FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::Init
  VAR
  	i       : DINT;
    pPort   : ^t_PortInfo;
  	MyPara  : CmdStruct;
    MyResult: results;
  END_VAR

  SdiasBase::Init();

  // in the first init the SDCI devices log themselves in, so the master starts working in the second here
  if usInitCounter = 2 then
    // initialize the event counter with an invalid value
    OldEventCounter := 255;
    
    pPort := #aPortInfo[0];
    for i := 0 to (SIOL_MAX_PORTS_SUPPORTED-1) do
      
      // if any module is required => the master is too
      if pPort^.Required & (Required = 0) then
        Required := 1;

        MyPara.uiCmd := _BUS_IF_SET_REQUIRED;

        SdiasIn.NewInst(pPara:=#MyPara, pResult:=#MyResult);
      end_if;
      
      // create the dynamic mapping info
      if pPort^.PdoMapping.ReadDataLength then
        pPort^.PdoMapping.ReadDataStartAddress  := SIOL_OFFSET_RT_READ_DATA + TotalMappingReadSize;
        TotalMappingReadSize                    += pPort^.PdoMapping.ReadDataLength;
      end_if;

      if pPort^.PdoMapping.WriteDataLength then
        pPort^.PdoMapping.WriteDataStartAddress := SIOL_OFFSET_RT_WRITE_DATA + TotalMappingWriteSize;
        TotalMappingWriteSize                   += pPort^.PdoMapping.WriteDataLength;
      end_if;
            
      pPort += sizeof(t_PortInfo);
    end_for;
    
    // Unlock is set after InitTheModule completed
    sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_LOCK);
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::ClassState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	ActPortNo     : UDINT;
    pHelpDst      : pVoid;
    pHelpSrc      : pVoid;
    ActLength     : USINT;
    ActOffset     : USINT;
    pPort         : ^t_PortInfo;
  	localSDOLock : UDINT;
    sSDOFIFOHeader : t_SDOFIFOHeader;
    retval        : DINT;
    bEndianSwapNeeded : BOOL;
    pParaInfo   : ^t_ConfigTablePara;
    LengthByte 	: UDINT;
    FullBytes   : UDINT;
    OffsetByte  : UDINT;
    LengthBit   : UDINT;
    OffsetBit   : UDINT;
    OffsetBitEnd: UDINT;
    ExtraByte   : UDINT;
    i           : DINT;
    tmpvar      : USINT;
    pBitMask    : ^USINT;
    ink  : DINT;
  END_VAR

  // if not changed by the command addressed, we return error (this covers also unknown commands)
  ret_code := ERROR;

  // check for the command area of SDIAS SDCI
  if ((pPara^.uiCmd >= CMD_SIOL_DEFINES_MIN) & 
      (pPara^.uiCmd <= CMD_SIOL_DEFINES_MAX)) | 
     ((pPara^.uiCmd >= CMD_SIOL_DEFINES_MIN2) & 
      (pPara^.uiCmd <= CMD_SIOL_DEFINES_MAX2)) then
    
    // without _ClassOk-State only the login is allowed
    if (ClassState <> _ClassOk) & (pPara^.uiCmd <> CMD_SIOL_DEVICE_OBJECT_LOGIN) then
      // class is not ok => no features available
      return;
    end_if;
     
    case pPara^.uiCmd of
//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_OBJECT_LOGIN:
        if pPara^.aPara[MAXCMDPARA-1] < SIOL_MAX_PORTS_SUPPORTED then
        
          // before accepting the data => check the pointers for input and output server (needed for update in realtime)
          case pPara^.aPara[1]$t_SDCIPortMode of
          //**********************************************************************************************************************************************************
            _DigitalInput:
              if pPara^.aPara[4]$pVoid = NIL then
                pResult^.uiLng := sizeof(t_SDCIRetCode);
                pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidPointer;
                LogError("@04E8 (SdiasSDCIMaster::ClassState::NewInst) Trying to log in an object as digital input module, but with an invalid pointer to the input server!");
                ret_code := ERROR;
                return;
              end_if;
              
          //**********************************************************************************************************************************************************
            _DigitalOutput:
              if pPara^.aPara[5]$pVoid = NIL then
                pResult^.uiLng := sizeof(t_SDCIRetCode);
                pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidPointer;
                LogError("@04E9 (SdiasSDCIMaster::ClassState::NewInst) Trying to log in an object as digital output module, but with an invalid pointer to the output server!");
                ret_code := ERROR;
                return;
              end_if;

          //**********************************************************************************************************************************************************           
          end_case;

          ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

          aPortInfo[ActPortNo].pThis                          := pPara^.aPara[ 0]$^SDCIDevice;
          aPortInfo[ActPortNo].CfgPortMode                    := pPara^.aPara[ 1]$t_SDCIPortMode;
          aPortInfo[ActPortNo].PdoMapping.ReadDataLength      := pPara^.aPara[ 2]$USINT;
          aPortInfo[ActPortNo].PdoMapping.WriteDataLength     := pPara^.aPara[ 3]$USINT;
          aPortInfo[ActPortNo].pInputServer                   := pPara^.aPara[ 4]$pVoid;
          aPortInfo[ActPortNo].pOutputServer                  := pPara^.aPara[ 5]$pVoid;
          aPortInfo[ActPortNo].pCfgTable                      := pPara^.aPara[ 6]$^t_ConfigTable;
          aPortInfo[ActPortNo].pFaultFlags                    := pPara^.aPara[ 7]$^UDINT;
          aPortInfo[ActPortNo].pDirectInputServer             := pPara^.aPara[ 8]$pVoid;
          aPortInfo[ActPortNo].PdoMapping.ReadDataBitLength   := pPara^.aPara[ 9]$USINT;
          aPortInfo[ActPortNo].PdoMapping.WriteDataBitLength  := pPara^.aPara[10]$USINT;         
          aPortInfo[ActPortNo].Required                       := pPara^.aPara[11]$USINT;         
          aPortInfo[ActPortNo].pPortStateBits                 := pPara^.aPara[12]$^t_SDCIPortStateBits;
          aPortInfo[ActPortNo].StartUpMode                    := pPara^.aPara[13]$t_SDCIPortMode;
          aPortInfo[ActPortNo].SkipEndianSwap                 := to_bool(pPara^.aPara[14] AND 1);
          if pPara^.aPara[15] = 2 then  // Only set false when 2. 
            aPortInfo[ActPortNo].SkipEndianSwapAsy := FALSE;
          else
            aPortInfo[ActPortNo].SkipEndianSwapAsy := TRUE; 
          end_if;
          
          //if SDCIDevice has an older version the para[16] is initialized with zero = not used
          aPortInfo[ActPortNo].udAutoConnectTime := pPara^.aPara[16]$UDINT;
          
          //if SDCIDevice has an older version the para[17] is initialized with zero = not used
          if (pPara^.aPara[17] shr 31 and 1) then
            //take value from device
            aPortInfo[ActPortNo].udModeChangeTime := (pPara^.aPara[17] and 0x7FFFFFFF)$UDINT;
          else
            aPortInfo[ActPortNo].udModeChangeTime := SIOL_WAIT_FOR_DISABLE;
          end_if;
          
          aPortInfo[ActPortNo].OverrideMinCycleTime_us := pPara^.aPara[18]$UDINT;
          
          // check the config table
          if aPortInfo[ActPortNo].pCfgTable & (aPortInfo[ActPortNo].pCfgTable^.TotalTableSize >= sizeof(t_ConfigTable.IOLK_Mark)) then
            // check the first entry of the table if it's a valid Table
            if _memcmp(ptr1:=#aPortInfo[ActPortNo].pCfgTable^.IOLK_Mark[0], ptr2:="IOLK", cntr:=sizeof(t_ConfigTable.IOLK_Mark)) then
            
              // invalid table => invalidate the pointer as well
              aPortInfo[ActPortNo].pCfgTable := NIL;
            else
              // check the rest of the table
              if aPortInfo[ActPortNo].pCfgTable^.Version = 1 then
                // in version 1 it is a fixed header => check for a valid size
                if aPortInfo[ActPortNo].pCfgTable & (aPortInfo[ActPortNo].pCfgTable^.TotalTableSize >= (sizeof(t_ConfigTable.IOLK_Mark) + sizeof(t_ConfigTable.Version) + sizeof(t_ConfigTable.DeviceID) + sizeof(t_ConfigTable.VendorID))) then
                  aPortInfo[ActPortNo].NoOfParameters := (aPortInfo[ActPortNo].pCfgTable$^UDINT + 20)^;
                  aPortInfo[ActPortNo].pFirstPara     := aPortInfo[ActPortNo].pCfgTable$^t_ConfigTablePara + 24;
                else
                  // invalid table => invalidate the pointer as well
                  aPortInfo[ActPortNo].pCfgTable := NIL;
                end_if;
              elsif aPortInfo[ActPortNo].pCfgTable^.Version = 2 then
                // at version 2 there is a dynamic part for the endian swap information => check for a valid size (number of swap info in and swap info out)
                if aPortInfo[ActPortNo].pCfgTable & (aPortInfo[ActPortNo].pCfgTable^.TotalTableSize >= (sizeof(t_ConfigTable.IOLK_Mark) + sizeof(t_ConfigTable.Version) + sizeof(t_ConfigTable.DeviceID) + sizeof(t_ConfigTable.VendorID) + 2*sizeof(UINT))) then
                  PrepareParaTabAccess(#aPortInfo[ActPortNo]);
                else
                  // invalid table => invalidate the pointer as well
                  aPortInfo[ActPortNo].pCfgTable := NIL;
                end_if;
              else
                // unknown table version
                pResult^.uiLng := sizeof(t_SDCIRetCode);
                pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_UnspecifiedError;
                LogError("@04EA (SdiasSDCIMaster::ClassState::NewInst) Trying to log in an object with an unknown parameter table version!");
                ret_code := ERROR;
                return;
              end_if;
            end_if;
          end_if;
          
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;
          
          if aPortInfo[ActPortNo].udAutoConnectTime then
            //one or more ports have auto connect activated
            sAutoConnectVars.bAutoConnectActive := TRUE;
          end_if;

          ret_code := READY;
        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          // port number too high
          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_GET_PDO_DATA:
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        // check port number, pointer to user memory, pointer to read data, if module is available and if the input process data of this module are valid
        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) & pPara^.aPara[0] & aPortInfo[ActPortNo].pReadData & 
            aPortInfo[ActPortNo].PhysicallyAvailable & ((CyclicInfoTotal.RtInfoBits$USINT SHR ActPortNo) AND 1) then

          pPort := #aPortInfo[ActPortNo];
          ActLength := pPara^.aPara[1]$USINT;
          ActOffset := pPara^.aPara[2]$USINT;
          
          // in SDCI mode we can have multiple bytes to read
          if pPort^.ActPortMode = t_SDCIPortMode::_SDCI then
          
            // check if length and offset are valid
            if ActLength & ((ActLength + ActOffset) <= pPort^.PdoMapping.ReadDataLength) then

              PdoProtection.SectionStart();

              // copy memory inverted if more than 1 byte to copy
              if pPort^.PdoMapping.ReadDataLength > 1 then
                if pPort^.SkipEndianSwap then
                  _memcpy(ptr1:=pPara^.aPara[0]$pVoid, ptr2:=pPort^.pReadData + ActOffset, cntr:=ActLength);
                else
                  // copy inverted: source pointer to the end of the read memory - offset and the destination pointer to the beginning of the user memory
                  pHelpSrc:= pPort^.pReadData + pPort^.PdoMapping.ReadDataLength-1 - ActOffset;
                  pHelpDst:= pPara^.aPara[0]$pVoid; // no offset at the users pointer!
                  
                  while ActLength do
                  
                    // source pointer from the end, destination pointer from the beginning
                    pHelpDst^$USINT := pHelpSrc^$USINT;
                  
                    pHelpDst += 1;
                    pHelpSrc -= 1;
                  
                    ActLength -= 1;
                    
                  end_while;
                end_if;

              
              else
              
                // copy only the 1 byte
                (pPara^.aPara[0]$^USINT)^ := pPort^.pReadData^$USINT;
                
              end_if;

              PdoProtection.SectionStop();          
            
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;

              ret_code := READY;
            else
              // the offset/length combination is invalid
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidLengthOffsetCombination;

              ret_code := ERROR;
            end_if;  
          else
            // error
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NotAvailableAtThisPort;
          end_if;
        else
          // error
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          
          if pPara^.aPara[0] = 0 then
            // pointer to user memory is NIL
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidPointer;
          elsif aPortInfo[ActPortNo].PhysicallyAvailable = FALSE then
            // module is not available
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_ModuleNotAvailable;
          elsif ((CyclicInfoTotal.RtInfoBits$USINT SHR ActPortNo) AND 1) = 0 then
            // the input process data of this module are not valid
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_ReadDataCurrentlyNotValid;
          elsif (ActPortNo >= SIOL_MAX_PORTS_SUPPORTED) then
            // the port number is too high
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;
          else
            // the module does not have read data
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NoReadDataAtModule;
          end_if;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_SET_PDO_DATA:
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        // check port number, pointer to user memory, pointer to write data and if module is available
        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) & pPara^.aPara[0] & aPortInfo[ActPortNo].pWriteData & 
            aPortInfo[ActPortNo].PhysicallyAvailable then

          pPort := #aPortInfo[ActPortNo];
          ActLength := pPara^.aPara[1]$USINT;
          ActOffset := pPara^.aPara[2]$USINT;

          // in SDCI mode we can have multiple bytes to write
          if pPort^.ActPortMode = t_SDCIPortMode::_SDCI then

            // check if length and offset are valid
            if ActLength & ((ActLength + ActOffset) <= pPort^.PdoMapping.WriteDataLength) then

              PdoProtection.SectionStart();

              // copy memory inverted if more than 1 byte to copy
              if pPort^.PdoMapping.WriteDataLength > 1 then
                if pPort^.SkipEndianSwap then
                  _memcpy(ptr1:=pPort^.pWriteData + ActOffset, ptr2:=pPara^.aPara[0]$pVoid, cntr:=ActLength);
                else
                  // copy inverted: source pointer to beginning of the user memory and the destination pointer to the end of the write memory - offset
                  pHelpSrc:= pPara^.aPara[0]$pVoid; // no offset at the users pointer!
                  pHelpDst:= pPort^.pWriteData + pPort^.PdoMapping.WriteDataLength-1 - ActOffset;
                  
                  while ActLength do
                  
                    // source pointer from the end, destination pointer from the beginning
                    pHelpDst^$USINT := pHelpSrc^$USINT;
                  
                    pHelpDst -= 1;
                    pHelpSrc += 1;
                  
                    ActLength -= 1;
                    
                  end_while;
                end_if;
              else
              
                // copy only the 1 byte
                pPort^.pWriteData^$USINT := (pPara^.aPara[0]$^USINT)^;
                
              end_if;

              PdoProtection.SectionStop();

              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;

              ret_code := READY;
            else
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidLengthOffsetCombination;
              
              // the offset/length combination is invalid
              ret_code := ERROR;
            end_if;            
          else
            // error
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NotAvailableAtThisPort;
          end_if;
        else
          // error
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          
          if pPara^.aPara[0] = 0 then
            // pointer to user memory is NIL
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidPointer;
          elsif aPortInfo[ActPortNo].PhysicallyAvailable = FALSE then
            // module is not available
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_ModuleNotAvailable;
          elsif (ActPortNo >= SIOL_MAX_PORTS_SUPPORTED) then
            // the port number is too high
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;
          else
            // the module does not have write data
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NoWriteDataAtModule;
          end_if;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_GET_ASY_PARA:
      
        b_LogAsyCalls.DirectAsyAccessUsed := TRUE;
        
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) then
          // if module on this port is operating
          if aPortInfo[ActPortNo].pPortStateBits^.Operating then

            // initialize the data structure for the asynchronous transmission
            ret_code := InitializeCyclicSSW(pPara, _ReadParaData);

            if ret_code = READY then
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;
            elsif ret_code = BUSY then
              // already busy
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Busy;

              ret_code := ERROR;
            else
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_UnspecifiedError;
            end_if;
            
          else
            // service not available, because module is not operating
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_MicroCtrl_ServiceNotAvailable;

            ret_code := ERROR;
          end_if;
        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_SET_ASY_PARA:
      
        b_LogAsyCalls.DirectAsyAccessUsed := TRUE;
        
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) then
          // if module on this port is operating
          if aPortInfo[ActPortNo].pPortStateBits^.Operating then            
              
            // initialize the data structure for the asynchronous transmission
            ret_code := InitializeCyclicSSW(pPara, _WriteParaData);

            if ret_code = READY then
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;
            elsif ret_code = BUSY then
              // already busy
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Busy;

              ret_code := ERROR;
            else
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_UnspecifiedError;
            end_if;
            
          else
            // service not available, because module is not operating
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_MicroCtrl_ServiceNotAvailable;

            ret_code := ERROR;
          end_if;
        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_ASY_FUNCTION_ID:
        
        b_LogAsyCalls.DirectAsyAccessUsed := TRUE;
        
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) then
          // if module on this port is operating
          if aPortInfo[ActPortNo].pPortStateBits^.Operating then
              
            // initialize the data structure for the asynchronous transmission
            ret_code := InitializeCyclicSSW(pPara, _SendFunctionCode);
            
            if ret_code = READY then
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;
            elsif ret_code = BUSY then 
              // already busy
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Busy;

              ret_code := ERROR;
            else
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_UnspecifiedError;
            end_if;
            
          else
            // service not available, because module is not operating
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_MicroCtrl_ServiceNotAvailable;

            ret_code := ERROR;
          end_if;
        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_GET_ASY_STATE:
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) then
          case sSdoData.AsyState of
          //***************************************************************************************************
            t_SDCIRetCode::SDCI_Busy:  // busy => only busy state
              pResult^.uiLng                  := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := sSdoData.AsyState;
            
          //***************************************************************************************************
  //          0:  // ready => if the last access returned data, forward them

          //***************************************************************************************************
          else // ready (0) or error (<0) => return data of access (result of firmware)
              pResult^.uiLng                  := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := sSdoData.AsyState;
              
              // if we have returndata or there is an application error
              if sSdoData.SdoReadData.LengthOfData then
                if sSdoData.SdoReadData.LengthOfData <= SIOL_MAX_SDO_DATA_SIZE then
                  pResult^.uiLng         := sizeof(t_SDCIRetCode) + 2*sizeof(DINT);
                  
                  // add length and pointer to data
                  pResult^.aData[4]$DINT := sSdoData.SdoReadData.LengthOfData;
                  
                  // Get the infomation bEndianSwapNeeded
                  bEndianSwapNeeded := FALSE;    
                  if ( sSdoData.SdoReadData.PortSelection < SIOL_MAX_PORTS_SUPPORTED) then
                  
                    // Get parameter information
                    pParaInfo := FindParaInTable( pActPortInfo := #aPortInfo[sSdoData.SdoReadData.PortSelection]
                                                , ParaID       := sSdoData.SdoReadData.ParaIndex
                                                , ParaSubID    := sSdoData.SdoReadData.ParaSubIndex);
                    
                    // Check if parameter needes endianswap
                    bEndianSwapNeeded := CheckEndianSwapNeeded( pParaInfo     := pParaInfo
                                                              , PortSelection := sSdoData.SdoReadData.PortSelection);
                  end_if;
                  
                  if bEndianSwapNeeded = TRUE then

                    EndianSwap( pDst          := #sSdoData.SdoReadDataSwapped[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData]
                              , pSrc          := #sSdoData.SdoReadData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData]
                              , LengthOfData  := sSdoData.SdoReadData.LengthOfData);
                    pResult^.aData[8]$DINT := (#sSdoData.SdoReadDataSwapped[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData])$DINT;
                  else
                    pResult^.aData[8]$DINT := (#sSdoData.SdoReadData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData])$DINT;
                  end_if;
                  
                else
                  pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_MicroCtrl_RspLengthTooBig;
                end_if;
                
                //reset received flag of asy data
                sSdoData.bSingleAsyTransferReady := FALSE;
              end_if;
          
          //***************************************************************************************************
          end_case;

          ret_code := READY;
        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_SET_PORT_MODE:
      
        b_LogAsyCalls.DirectAsyAccessUsed := TRUE;
        
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) then

          // if not busy
          localSDOLock := sigclib_atomic_cmpxchgU32(pValue:=#sSdoData.DataLock, cmpVal := SSDCIM_SDO_UNLOCK, newVal := SSDCIM_SDO_LOCK);    
          if localSDOLock = SSDCIM_SDO_UNLOCK then
            
            sSdoData.ActPortSelection := ActPortNo$USINT;
            sSdoData.TargetMode       := pPara^.aPara[0]$t_SDCIPortMode;
            
            // check if changing to target mode is possible
            if ChangeModeIsPossible(TargetPort:=sSdoData.ActPortSelection, TargetMode:=sSdoData.TargetMode) then
              // we're busy now
              sSdoData.AsyState         := t_SDCIRetCode::SDCI_Busy;
              
              sSdoData.AsyCmdType       := t_AsyCmdType::ModeChange;
              sSdoData.eAsySSW          := t_AsySSW::_StartModeChange;
              sSdoData.eResponseState   := t_ReponseState::_SendData;
              sSdoData.AsyErrorCode     := t_SDCIRetCode::SDCI_UnspecifiedError;
              
              sSdoData.pCallBackThis  := NIL;
              sSdoData.pCallBackFun   := NIL; 

              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;

              ret_code := READY;
            else
              // changing to this mode is not possible on this port
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NotAvailableAtThisPort;
              
              // Unlock SDO Channel
              sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);

              ret_code := ERROR;
            end_if;                        
          else
            // already busy
            ret_code := ERROR;
          end_if;

        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_RECONNECT:
        
        b_LogAsyCalls.DirectAsyAccessUsed := TRUE;
        
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) then        
        
          // if not busy
          localSDOLock := sigclib_atomic_cmpxchgU32(pValue:=#sSdoData.DataLock, cmpVal := SSDCIM_SDO_UNLOCK, newVal := SSDCIM_SDO_LOCK);    
          if localSDOLock = SSDCIM_SDO_UNLOCK then
            // we're busy now
            sSdoData.AsyState         := t_SDCIRetCode::SDCI_Busy;
            
            sSdoData.ActPortSelection := ActPortNo$USINT;

            sSdoData.AsyCmdType       := t_AsyCmdType::Reconnect;
            sSdoData.eAsySSW          := t_AsySSW::_StartReconnect;
            sSdoData.eResponseState   := t_ReponseState::_SendData;
            sSdoData.AsyErrorCode     := t_SDCIRetCode::SDCI_UnspecifiedError;
            
            sSdoData.pCallBackThis  := NIL;
            sSdoData.pCallBackFun   := NIL; 

            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;

            ret_code := READY;
          else
            // already busy
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Busy;

            ret_code := ERROR;
          end_if;
         
        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_RECONNECT_BUFFERED:
        
        b_LogAsyCalls.BufferAsyAccessUsed := TRUE;
        
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) then
        
          sSDOFIFOHeader.NewInstCmd         := pPara^.uiCmd;
          sSDOFIFOHeader.ParaIndex          := 0;
          sSDOFIFOHeader.ParaSubIndex       := 0;
          sSDOFIFOHeader.PortSelection      := ActPortNo$USINT;
          sSDOFIFOHeader.LengthOfData       := 0;
          sSDOFIFOHeader.pThis              := pPara^.aPara[0]$pVirtualBase;
          sSDOFIFOHeader.pCallBackFunction  := pPara^.aPara[1]$pVoid;
          
          // Only header is needed for reconnect
          retval := HWKVarSizeFIFO1.AddData (pData  := (#sSDOFIFOHeader)$^HSINT, size  := sizeof(t_SDOFIFOHeader) );
          
          if retval = 0 then
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;              
            ret_code := READY;
            
          elsif retval = -3 then 
            // Buffer full
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Busy;
            ret_code := ERROR;
            
          else
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_UnspecifiedError;              
            ret_code := ERROR;
            
          end_if;
        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_SET_PORT_MODE_BUFFERED:
      
        b_LogAsyCalls.BufferAsyAccessUsed := TRUE;
        
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) then
        // check if changing to target mode is possible
          if ChangeModeIsPossible(TargetPort:= ActPortNo$USINT, TargetMode:=pPara^.aPara[0]$t_SDCIPortMode) then
            
            sSDOFIFOHeader.NewInstCmd         := pPara^.uiCmd;
            sSDOFIFOHeader.ParaIndex          := 0;
            sSDOFIFOHeader.ParaSubIndex       := 0;
            sSDOFIFOHeader.PortSelection      := ActPortNo$USINT;
            sSDOFIFOHeader.LengthOfData       := 0;
            sSDOFIFOHeader.pThis              := pPara^.aPara[1]$pVirtualBase;
            sSDOFIFOHeader.pCallBackFunction  := pPara^.aPara[2]$pVoid;
            
            retval := HWKVarSizeFIFO1.AddData2(  pData  := (#sSDOFIFOHeader)$^HSINT,  size := sizeof(t_SDOFIFOHeader)
                                                , pData2 := (#pPara^.aPara[0])$^HSINT, size2:= sizeof(t_SDCIPortMode) );  // pdata2^ := sSdoData.TargetMode
            if retval = 0 then
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;              
            ret_code := READY;
            
            elsif retval = -3 then 
              // Buffer full
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Busy;
              ret_code := ERROR;
              
            else
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_UnspecifiedError;              
              ret_code := ERROR;
              
            end_if;
            
          else
            // changing to this mode is not possible on this port
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NotAvailableAtThisPort;

            ret_code := ERROR;
          end_if;
        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          ret_code := ERROR;
        end_if;  
          
//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_GET_ASY_PARA_BUFFERED,
      CMD_SIOL_DEVICE_SET_ASY_PARA_BUFFERED,
      CMD_SIOL_DEVICE_ASY_FUNCTION_ID_BUFFERED:
      
        b_LogAsyCalls.BufferAsyAccessUsed := TRUE;
      
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) then
          // if module on this port is operating
          if aPortInfo[ActPortNo].pPortStateBits^.Operating then
          
            sSDOFIFOHeader.NewInstCmd     := pPara^.uiCmd;
            sSDOFIFOHeader.ParaIndex      := pPara^.aPara[0]$UINT;
            sSDOFIFOHeader.ParaSubIndex   := pPara^.aPara[1]$USINT;            
            sSDOFIFOHeader.PortSelection  := ActPortNo$USINT;
            if pPara^.aPara[2] = SIOL_MASTER_PORT_NO then
              sSDOFIFOHeader.PortSelection  := SIOL_MASTER_PORT_NO;
            end_if;            
            sSDOFIFOHeader.LengthOfData       := pPara^.aPara[3]$USINT;            
            sSDOFIFOHeader.pThis              := pPara^.aPara[5]$pVirtualBase;
            sSDOFIFOHeader.pCallBackFunction  := pPara^.aPara[6]$pVoid;
            
            if sSDOFIFOHeader.LengthOfData then
              retval := HWKVarSizeFIFO1.AddData2(pData  := (#sSDOFIFOHeader)$^HSINT, size  := sizeof(t_SDOFIFOHeader)
                                                , pData2 := (pPara^.aPara[4])$^HSINT, size2 := sSDOFIFOHeader.LengthOfData);
            else
              retval := HWKVarSizeFIFO1.AddData (pData  := (#sSDOFIFOHeader)$^HSINT, size  := sizeof(t_SDOFIFOHeader) );
            end_if;
            
            if retval = 0 then
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;              
              ret_code := READY;
              
            elsif retval = -3 then 
              // Buffer full
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Busy;
              ret_code := ERROR;
              
            else
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_UnspecifiedError;              
              ret_code := ERROR;
              
            end_if;
            
          else
            // service not available, because module is not operating
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_MicroCtrl_ServiceNotAvailable;

            ret_code := ERROR;
          end_if;
        else
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;

          ret_code := ERROR;
        end_if;      
        
//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_GET_PDO_DATA_BIT:
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        // check port number, pointer to user memory, pointer to read data, if module is available and if the input process data of this module are valid
        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) & pPara^.aPara[0] & aPortInfo[ActPortNo].pReadData & 
            aPortInfo[ActPortNo].PhysicallyAvailable & ((CyclicInfoTotal.RtInfoBits$USINT SHR ActPortNo) AND 1) then

          pPort := #aPortInfo[ActPortNo];
          LengthBit := pPara^.aPara[1]$UDINT;
          OffsetBit := pPara^.aPara[2]$UDINT;
          
          // in SDCI mode we can have multiple bytes to read
          if pPort^.ActPortMode = t_SDCIPortMode::_SDCI then
          
            // calculate needed length and offset
            LengthByte  := LengthBit / 8;
            LengthBit   :=  LengthBit MOD 8; //get the rest of the length
            if LengthBit then
              LengthByte += 1;                    //get the extra byte with the remaining bits
            end_if;
            OffsetByte := OffsetBit / 8;      //get the byte aligned start
            OffsetBit  := OffsetBit MOD 8; //get the rest of the offset
            ExtraByte := 0;
            if ((OffsetBit + LengthBit) > 8) | 
               (OffsetBit > 0 & LengthBit = 0)  then
              ExtraByte := 1;                    //if the bit offset and the rest of the bits is more then 1 byte, we need to get an extra byte
            end_if;          
          
            // check if length and offset are valid
            if LengthByte & ((LengthByte + ExtraByte + OffsetByte) <= pPort^.PdoMapping.ReadDataLength) then

              PdoProtection.SectionStart();
              
              pHelpDst:= pPara^.aPara[0]$pVoid;
              
              pHelpSrc := pPort^.pReadData + OffsetByte + LengthByte + ExtraByte -1; // Start at the end!
              ink      := sizeof(USINT);
              if pPort^.SkipEndianSwap = FALSE then
                pHelpSrc  := pPort^.pReadData + pPort^.PdoMapping.ReadDataLength-1 - (OffsetByte + LengthByte + ExtraByte -1);
                ink       := -ink;
              end_if;

              pBitMask := #BitMask() + sizeof(UDINT);
              tmpvar := 0;
              if ExtraByte then
                tmpvar := pHelpSrc^$USINT AND (pBitMask + OffsetBit)$^USINT^; //get the bits from the extra byte (ActLength-1 + 1)
                pHelpSrc -= ink;
              end_if;
              for i := to_dint(LengthByte-1) to 0 by -1 do
                (pHelpDst + i)$^USINT^ := (pHelpSrc^$USINT SHR OffsetBit) OR (tmpvar SHL (8 - OffsetBit)); // shift data and add left over bits (0 = no left over bits, shift all out)
                tmpvar := pHelpSrc^$USINT AND (pBitMask + OffsetBit)$^USINT^; //remember the bits we didnt use (0 means all bits, but irrelevant because all get shifted out)
                pHelpSrc -= ink;
              end_for;
              (pHelpDst + (LengthByte-1))$^USINT^ := (pHelpDst + (LengthByte-1))$^USINT^ AND (pBitMask + LengthBit)$^USINT^; // fix msb´s (this is why 0 is mask 0xFF)
              
              PdoProtection.SectionStop();
            
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;

              ret_code := READY;
            else
              // the offset/length combination is invalid
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidLengthOffsetCombination;

              ret_code := ERROR;
            end_if;
            
          else
            // error
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NotAvailableAtThisPort;
          end_if;
        else
          // error
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          
          if pPara^.aPara[0] = 0 then
            // pointer to user memory is NIL
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidPointer;
          elsif aPortInfo[ActPortNo].PhysicallyAvailable = FALSE then
            // module is not available
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_ModuleNotAvailable;
          elsif ((CyclicInfoTotal.RtInfoBits$USINT SHR ActPortNo) AND 1) = 0 then
            // the input process data of this module are not valid
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_ReadDataCurrentlyNotValid;
          elsif (ActPortNo >= SIOL_MAX_PORTS_SUPPORTED) then
            // the port number is too high
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;
          else
            // the module does not have read data
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NoReadDataAtModule;
          end_if;

          ret_code := ERROR;
        end_if;

//**********************************************************************************************************************************************************
      CMD_SIOL_DEVICE_SET_PDO_DATA_BIT:
        // take the port from the SDCIPort object
        ActPortNo := pPara^.aPara[MAXCMDPARA-1]$UDINT;

        // check port number, pointer to user memory, pointer to write data and if module is available
        if (ActPortNo < SIOL_MAX_PORTS_SUPPORTED) & pPara^.aPara[0] & aPortInfo[ActPortNo].pWriteData & 
            aPortInfo[ActPortNo].PhysicallyAvailable then

          pPort := #aPortInfo[ActPortNo];
          LengthBit     := pPara^.aPara[1]$UDINT;
          OffsetBit     := pPara^.aPara[2]$UDINT;
          
          // in SDCI mode we can have multiple bytes to write
          if pPort^.ActPortMode = t_SDCIPortMode::_SDCI then
          
            // check if length and offset are valid
            if (LengthBit$DINT > 0)  &  // Check for negativ values because udint sum can overflow
               (OffsetBit$DINT >= 0) &  // Check for negativ values because udint sum can overflow
               ( (OffsetBit + LengthBit) <= (pPort^.PdoMapping.WriteDataLength*8) ) then
            
              OffsetByte    := OffsetBit / 8;    //get the byte aligned start
              OffsetBit     := OffsetBit MOD 8;  //get the rest of the offset
              
              OffsetBitEnd  := (LengthBit + OffsetBit) mod 8; //get the byte aligned end
              
              // Calculate the no of bytes that will be complettly overwritten in pHelpDst
              FullBytes     := 0;
              if LengthBit >= 8 then 
                FullBytes := LengthBit;
                if OffsetBit then
                  FullBytes -= (8 - OffsetBit);
                end_if;
                FullBytes -= OffsetBitEnd;
                FullBytes /= 8;
              end_if;

              PdoProtection.SectionStart();

              pHelpSrc  := pPara^.aPara[0]$pVoid;
              
              pHelpDst  := pPort^.pWriteData + OffsetByte;
              ink       := sizeof(USINT);
              if pPort^.SkipEndianSwap = FALSE then
                pHelpDst  := pPort^.pWriteData + pPort^.PdoMapping.WriteDataLength-1 - OffsetByte;
                ink       := -ink;
              end_if;
              
              pBitMask := #BitMask() + sizeof(UDINT);
              tmpvar := 0;
              if (OffsetBit >= OffsetBitEnd) | 
                 (LengthBit >= 8) then // Need more than one destination byte
                
                // First part byte
                if OffsetBit then
                  pHelpDst^$USINT := pHelpDst^$USINT AND (pBitMask + (OffsetBit))^;         // Clear bits
                  pHelpDst^$USINT := pHelpDst^$USINT OR (pHelpSrc^$USINT SHL (OffsetBit) ); // Set new bit values
                  tmpvar          := pHelpSrc^$USINT SHR (8 - OffsetBit);                   // remember remaining  bits to write
                  pHelpDst += ink;
                  pHelpSrc += sizeof(USINT);
                end_if;
                
                // Full bytes
                if FullBytes then
                  if OffsetBit then
                    for i := 0 to to_dint(FullBytes - 1) do
                      pHelpDst^$USINT := (pHelpSrc^$USINT SHL OffsetBit) OR tmpvar;         // Set new bit values
                      tmpvar          := pHelpSrc^$USINT SHR (8 - OffsetBit);               // Remember remaining bits to write
                      pHelpDst += ink;
                      pHelpSrc += sizeof(USINT);
                    end_for;
                  else
                    for i := 0 to to_dint(FullBytes - 1) do
                      pHelpDst^$USINT := pHelpSrc^$USINT;
                      
                      pHelpDst += ink;
                      pHelpSrc += sizeof(USINT);
                    
                    end_for;
                    
                    // tmpvar := pHelpSrc^$USINT; // Not needed; OffsetBit = 0; => (pHelpSrc^$USINT SHL OffsetBit) = pHelpSrc^$USINT; see "Last part byte"
                  end_if;
                end_if;
                
                // Last part byte
                if OffsetBitEnd then  
                  pHelpDst^$USINT := pHelpDst^$USINT AND NOT((pBitMask + OffsetBitEnd)^);   // Clear bits in destination
                  tmpvar          := (pHelpSrc^$USINT SHL OffsetBit) OR tmpvar;             // Combine new bit values
                  tmpvar          := tmpvar AND ((pBitMask + OffsetBitEnd)^);               // Mask new bit values
                  pHelpDst^$USINT := pHelpDst^$USINT OR tmpvar;                             // Set new bit values
                end_if;
              
              else
                
                // Only one Byte in destination needed
                if OffsetBit then
                  pHelpDst^$USINT := pHelpDst^$USINT AND                                    ((pBitMask + (OffsetBit))^ OR NOT((pBitMask + OffsetBitEnd)^)); // Clear bits in destination
                else
                  pHelpDst^$USINT := pHelpDst^$USINT AND                                                                  NOT((pBitMask + OffsetBitEnd)^);  // Clear bits in destination
                end_if;
                
                pHelpDst^$USINT := pHelpDst^$USINT OR  ( (pHelpSrc^$USINT shl OffsetBit) AND (* Not needed because shl *)    ((pBitMask + OffsetBitEnd)^) );// Set new bit values
              
              end_if;
              
              PdoProtection.SectionStop();

              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_Ready_Ok;

              ret_code := READY;
            else
              pResult^.uiLng := sizeof(t_SDCIRetCode);
              pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidLengthOffsetCombination;
              
              // the offset/length combination is invalid
              ret_code := ERROR;
            end_if;
          else
            // error
            pResult^.uiLng := sizeof(t_SDCIRetCode);
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NotAvailableAtThisPort;
          end_if;
        else
          // error
          pResult^.uiLng := sizeof(t_SDCIRetCode);
          
          if pPara^.aPara[0] = 0 then
            // pointer to user memory is NIL
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_InvalidPointer;
          elsif aPortInfo[ActPortNo].PhysicallyAvailable = FALSE then
            // module is not available
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_ModuleNotAvailable;
          elsif (ActPortNo >= SIOL_MAX_PORTS_SUPPORTED) then
            // the port number is too high
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_PortNbrNotSupported;
          else
            // the module does not have write data
            pResult^.aData[0]$t_SDCIRetCode := t_SDCIRetCode::SDCI_NoWriteDataAtModule;
          end_if;

          ret_code := ERROR;
        end_if;
//**********************************************************************************************************************************************************
    end_case;
  else
    ret_code := SdiasBase::NewInst(pPara, pResult);
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR

  // if there are PDO write data
  if TotalMappingWriteSize then
    // create an access for all the write data
    if AddWrAccess(hOffset              := SIOL_OFFSET_RT_WRITE_DATA
                 , uLength              := TotalMappingWriteSize
                 , ppData               := #sAccesses.pPDOWriteData
                 , ppStateByte          := #sAccesses.PDOWriteDataAccess.pStateByte
                 , ppControlByte        := #sAccesses.PDOWriteDataAccess.pControlByte
                 , pAccessHandle        := #sAccesses.PDOWriteDataAccess.AccessHandle
                 ) <> READY then
      LogError("@04EB (SdiasSDCIMaster::AddAccesses) Adding write memory access failed");
      eModuleInitState := ERROR;
      return;
    end_if;
  end_if;

  // check if an extra access for the header is necessary
  if TotalMappingReadSize + sizeof(t_CyclicReadInfo) > 128 then
    // create an access for all the read data
    if AddRdAccess(hOffset              := SIOL_OFFSET_RT_READ_DATA
                 , uLength              := TotalMappingReadSize
                 , ppData               := #sAccesses.pPDOReadData
                 , ppStateByte          := #sAccesses.PDOReadDataAccessExtra.pStateByte
                 , ppControlByte        := #sAccesses.PDOReadDataAccessExtra.pControlByte
                 , pAccessHandle        := #sAccesses.PDOReadDataAccessExtra.AccessHandle
                 ) <> READY then
      LogError("@04ED (SdiasSDCIMaster::AddAccesses) Adding read memory access failed");
      eModuleInitState := ERROR;
      return;
    end_if;

    // create an access for the cyclic read info
    if AddRdAccess(hOffset              := SIOL_OFFSET_RT_READ_HEADER
                 , uLength              := sizeof(t_CyclicReadInfo)
                 , ppData               := #sAccesses.pCyclicReadInfo
                 , ppStateByte          := #sAccesses.CyclicReadInfoAccessOrCombined.pStateByte
                 , ppControlByte        := #sAccesses.CyclicReadInfoAccessOrCombined.pControlByte
                 , pAccessHandle        := #sAccesses.CyclicReadInfoAccessOrCombined.AccessHandle
                 ) <> READY then
      LogError("@04EE (SdiasSDCIMaster::AddAccesses) Adding read memory access failed (cyclic read info)");
      eModuleInitState := ERROR;
      return;
    end_if;
  else
    // one access for both is enough
    if AddRdAccess(hOffset              := SIOL_OFFSET_RT_READ_HEADER
                 , uLength              := TotalMappingReadSize + sizeof(t_CyclicReadInfo)
                 , ppData               := #sAccesses.pCyclicReadInfo
                 , ppStateByte          := #sAccesses.CyclicReadInfoAccessOrCombined.pStateByte
                 , ppControlByte        := #sAccesses.CyclicReadInfoAccessOrCombined.pControlByte
                 , pAccessHandle        := #sAccesses.CyclicReadInfoAccessOrCombined.AccessHandle
                 ) <> READY then
      LogError("@04EF (SdiasSDCIMaster::AddAccesses) Adding read memory access failed (combined cyclic read info)");
      eModuleInitState := ERROR;
      return;
    end_if;
  end_if;

  eModuleInitState := READY;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  
  if StartInInit = 0 then

    // remember that initialization has still to be done
    b_DoTheInit := TRUE;
    // return that initialization is ready so that next step in SdiasManager can begin
    eModuleInitState := READY;

  else
  
    eModuleInitState := InitTheModule();

  end_if;
  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::ConnectEvent
  VAR
  	i       : DINT;
    pPort   : ^t_PortInfo;
  END_VAR

  // if we have a seperate read data access => start both read accesses
  if sAccesses.PDOReadDataAccessExtra.pControlByte then
    if sAccesses.CyclicReadInfoAccessOrCombined.pControlByte then      
      sAccesses.CyclicReadInfoAccessOrCombined.pControlByte^.EnableDO := TRUE;
    else
      eInitState := _DOHandleInvalid;
      return;
    end_if;

    if sAccesses.PDOReadDataAccessExtra.pControlByte then      
      sAccesses.PDOReadDataAccessExtra.pControlByte^.EnableDO := TRUE;
    else
      eInitState := _DOHandleInvalid;
      return;
    end_if;
  else
    if sAccesses.CyclicReadInfoAccessOrCombined.pControlByte then
      // if there are any PDO read data
      if TotalMappingReadSize then
        // remember the pointer to the PDO data and start the combined access
        sAccesses.pPDOReadData := sAccesses.pCyclicReadInfo + sizeof(t_CyclicReadInfo);
      end_if;

      sAccesses.CyclicReadInfoAccessOrCombined.pControlByte^.EnableDO := TRUE;
    else
      eInitState := _DOHandleInvalid;
      return;
    end_if;
  end_if;

  if sAccesses.pPDOWriteData then
    // start the write access
    if sAccesses.PDOWriteDataAccess.pControlByte then      
      sAccesses.PDOWriteDataAccess.pControlByte^.EnableDO := TRUE;
    else
      eInitState := _DOHandleInvalid;
      return;
    end_if;
  end_if;

  // set the pointers of the single ports
  pPort := #aPortInfo[0];
  for i := 0 to (SIOL_MAX_PORTS_SUPPORTED-1) do
    // if this port has read data => set the pointer to it
    if pPort^.PdoMapping.ReadDataLength then
      pPort^.pReadData := #LocalReadPDOBuf[0] + pPort^.PdoMapping.ReadDataStartAddress - SIOL_OFFSET_RT_READ_DATA;
    end_if;

    // if this port has write data => set the pointer to it
    if pPort^.PdoMapping.WriteDataLength then
      pPort^.pWriteData := #LocalWritePDOBuf[0] + pPort^.PdoMapping.WriteDataStartAddress - SIOL_OFFSET_RT_WRITE_DATA;
    end_if;

    pPort += sizeof(t_PortInfo);
  end_for;  
  
  //read client value
  StartInInit := StartInInit.Read() <> 0;

  sSdoData.eInitSSW         := t_InitSSW::_InitVariables;
  
  eInitState := ClassState  := _NotInitialized;
  

END_FUNCTION


FUNCTION VIRTUAL SdiasSDCIMaster::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  // we need a call in realtime prescan, realtime postscan and cyclic
  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST OR SDIAS_TASK_MASK_CY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::UpdateRt
  VAR
  	i           : USINT;
    pPort       : ^t_PortInfo;
    TempEvent   : t_EventReadData;
  	MyPara      : CmdStruct;
    MyResult    : results;
    PortState   : t_SDCIPortStateBits;
  END_VAR

  // if there is an input pdo => update the pdo input image
  if TotalMappingReadSize then
  
    PdoProtection.SectionStart();
    
    _memcpy(ptr1:=#LocalReadPDOBuf[0], ptr2:=sAccesses.pPDOReadData, cntr:=TotalMappingReadSize);

    PdoProtection.SectionStop();
  end_if;

  // save all data local for faster handling and also for using the bits in other methods
  CyclicInfoTotal := sAccesses.pCyclicReadInfo^;

  // things that need to be done with all connected ports / objects
  pPort := #aPortInfo[0];
  for i := 0 to (SIOL_MAX_PORTS_SUPPORTED-1) do
    if pPort^.pThis & (pPort^.ActPortMode <> _Inactive) then
      // if it's a digital input
      if pPort^.pReadData & (pPort^.ActPortMode = _DigitalInput) & pPort^.pInputServer then
        // update the server value
        pPort^.pInputServer^$DINT := pPort^.pReadData^$SINT AND 1;
      end_if;

      // show port state bits
      if pPort^.pPortStateBits then
        PortState := 0; // reset all the higher bits
        PortState.Operating             := to_bool((CyclicInfoTotal.FlagsRdy2OpAndOperating SHR (4 + i)) AND 1);
        PortState.ReadyToOperate        := to_bool((CyclicInfoTotal.FlagsRdy2OpAndOperating SHR      i ) AND 1);
        PortState.InputProcessDataValid := to_bool((CyclicInfoTotal.RtInfoBits              SHR      i ) AND 1);
        PortState.EventAvailable        := to_bool((CyclicInfoTotal.RtInfoBits              SHR (4 + i)) AND 1);
        PortState.OdeState              := to_bool((CyclicInfoTotal.FlagsOdeAndPde          SHR      i ) AND 1);
        PortState.PdeState              := to_bool((CyclicInfoTotal.FlagsOdeAndPde          SHR (4 + i)) AND 1);
        PortState.DuState               := to_bool((CyclicInfoTotal.FlagsDuAndDsUploaded    SHR      i ) AND 1);
        PortState.DsUploaded            := to_bool((CyclicInfoTotal.FlagsDuAndDsUploaded    SHR (4 + i)) AND 1);
      
        pPort^.pPortStateBits^ := PortState;
      end_if;

      // show fault bits
      if pPort^.pFaultFlags then
        pPort^.pFaultFlags^ := ((CyclicInfoTotal.FaultFlags$UINT SHR (i * 4)) AND 16#F);
        
        if pPort^.pFaultFlags^ & pPort^.pFaultFlags^ <> pPort^.udOldFaultFlag then 
        
          MyPara.uiCmd    := CMD_SIOL_DEVICE_INFO_UPDATE;
          MyPara.aPara[1] := aPortInfo[i].VendorID;
          MyPara.aPara[2] := aPortInfo[i].DeviceID$DINT;
          
          // check if a user override is active
          if aPortInfo[i].OverrideMinCycleTime_us then
            MyPara.aPara[3] := aPortInfo[i].OverrideMinCycleTime_us$DINT;
          else
            MyPara.aPara[3] := aPortInfo[i].MinCycleTime_us$DINT;
          end_if;
          MyPara.aPara[4] := aPortInfo[i].ActPortMode$DINT;
            
          if aPortInfo[i].Required then
            // show required error on SDCI device
            MyPara.aPara[0] := _RequiredError$DINT;
            
            aPortInfo[i].pThis^.NewInst(#MyPara, #MyResult);

            // crash
            SetRequiredError();
          else
            // show disconnect on class state
            MyPara.aPara[0] := _NoHardware$DINT;
            
            aPortInfo[i].pThis^.NewInst(#MyPara, #MyResult);
            //there is no sdci hardware at port
            pPort^.PhysicallyAvailable := FALSE;
          end_if;
        end_if;
        //save old state of fault flags
        pPort^.udOldFaultFlag := pPort^.pFaultFlags^;
      end_if;
      
      // show direct input (always available when there's an object)
      pPort^.pDirectInputServer^$DINT := (CyclicInfoTotal.DigInState SHR i) AND 1;     
    end_if;
    
    pPort += sizeof(t_PortInfo);
  end_for; 
  
  // show voltage bits
  PowerSupply := CyclicInfoTotal.VoltageState$USINT;

  // save the events (if there is an object for the port of the eventsource)
  TempEvent := CyclicInfoTotal.EventData;
  
  // if it's a valid event
  if TempEvent.EventDatastate.ValidityState then
    if (TempEvent.EventDatastate AND SIOL_EVENT_COUNTER_MASK) <> OldEventCounter then
      // new event => check if we put it into the local buffer or send it to a port object
      if TempEvent.PortNumber = SIOL_MASTER_PORT_NO then
        // add it to the local buffer
        AddEventToBuffer(#TempEvent.EventDetails);
      else
        // check if there is an object
        if (TempEvent.PortNumber < SIOL_MAX_PORTS_SUPPORTED) & aPortInfo[TempEvent.PortNumber].pThis then
          // add it to an object buffer
          MyPara.uiCmd    := CMD_SIOL_DEVICE_ADD_EVENT;
          
          // pointer to the event details
          MyPara.aPara[0] := (#TempEvent.EventDetails)$DINT;

          aPortInfo[TempEvent.PortNumber].pThis^.NewInst(#MyPara, #MyResult);
        else
          // event dropped, because there is no object for this port or the given portnumber is too high
          EventDropCounter += 1;
        end_if;
      end_if;
      
      // remember the event counter
      OldEventCounter := TempEvent.EventDatastate AND SIOL_EVENT_COUNTER_MASK;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::UpdateRtPostScan
  VAR
  	i       : DINT;
    pPort   : ^t_PortInfo;
  END_VAR

  if TotalMappingWriteSize then
  
    PdoProtection.SectionStart();
    
    _memcpy(ptr1:=sAccesses.pPDOWriteData, ptr2:=#LocalWritePDOBuf[0], cntr:=TotalMappingWriteSize);
    
    PdoProtection.SectionStop();

    pPort := #aPortInfo[0];
    for i := 0 to (SIOL_MAX_PORTS_SUPPORTED-1) do
      // if it's a digital output
      if pPort^.pWriteData & (pPort^.ActPortMode = _DigitalOutput) & pPort^.pOutputServer then
        // get the current server value
        pPort^.pWriteData^$SINT := to_sint(pPort^.pOutputServer^$DINT AND 1);
      end_if;
      pPort += sizeof(t_PortInfo);
    end_for;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::UpdateCy
  VAR
  	RetcodeIPR : iprStates;
    RetCodeSDCI : t_SDCIRetCode;
  END_VAR

  if b_DoTheInit then
    
    RetcodeIPR := InitTheModule();
    
    if RetcodeIPR = ERROR then
#ifdef HWC_LogValue1
      HWC_LogValue1(this, "@0063 (SdiasSDCIMaster::UpdateCy) Failed to initialize module on SDIAS Place 0x{0} via InitModule-Interface", Place);
#endif
      
      // if it's an required module => error
      if Required then
        SetRequiredError();
      else
        // set init phase over - another try for initialization is NOT done
        b_DoTheInit := FALSE;
      end_if;
      
      ClassState := _NotInitialized;
      
    elsif RetcodeIPR = READY then
      // initialization is successful - no more initialization necessary
      b_DoTheInit := FALSE;
      ClassState := _ClassOk;
    else
      // InitTheModule returns BUSY
    end_if;
      
  else
  
    if ClassState = _ClassOk then
      sAutoConnectVars.bReConnectStarted := FALSE;

      // if busy with a service data command
      if sSdoData.AsyState = t_SDCIRetCode::SDCI_Busy then
        case sSdoData.AsyCmdType of
        //***************************************************************************************************
          t_AsyCmdType::SingleAsyTransfer:
            case sSdoData.eResponseState of
            //***************************************************************************************************
              t_ReponseState::_PrepareSendData: // start the sending action (done in newinst)

            //***************************************************************************************************
              t_ReponseState::_SendData,
              t_ReponseState::_Wait4SendResponse,
              t_ReponseState::_GotSendResponse,
              t_ReponseState::_ReadData,
              t_ReponseState::_Wait4ReceiveData,
              t_ReponseState::_GotReceiveData:
                if HandleSdoDataTransfer() = ERROR then
                  // set to idle step
                  sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
                end_if;

            //***************************************************************************************************
              t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

                case sSdoData.SdoReadData.ro_RetCode of
                  _FwOk:
                    // ready
                    sSdoData.AsyState := t_SDCIRetCode::SDCI_Ready_Ok;
                      
                  _InvalidChecksum:
                    // error in request CRC detected by firmware
                    sSdoData.AsyState := t_SDCIRetCode::SDCI_MicroCtrl_InvalidChkSum;
                      
                  _FunctionIdNotSupported:
                    // function not supported by firmware
                    sSdoData.AsyState := t_SDCIRetCode::SDCI_MicroCtrl_FunctionIdNotSupported;
                      
                  _InvalidUsageParameter:
                    // invalid usage of parameters detected by firmware
                    sSdoData.AsyState := t_SDCIRetCode::SDCI_MicroCtrl_InvalidParamUsage;

                  _ServiceNotAvailable:
                    // parameter data transfer not possible
                    sSdoData.AsyState := t_SDCIRetCode::SDCI_MicroCtrl_ServiceNotAvailable;

                  _ApplicationError:
                    // error at the SDCI device
                    sSdoData.AsyState := t_SDCIRetCode::SDCI_MicroCtrl_ApplicationError;

                end_case;
                
                // set to idle step
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
                
                // Handle Asy Callback 
                if sSdoData.pCallBackThis & sSdoData.pCallBackFun then                  
                  HandleSDOCallback();
                else                
                  //save received flag of asy data only if it was no callback
                  sSdoData.bSingleAsyTransferReady  := TRUE;
                  sSdoData.udSingleAsyTransferReady := ops.tAbsolute;
                end_if;
                
                // Unlock SDO Data
                sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);                 

            //***************************************************************************************************
            end_case;      
            
        //***************************************************************************************************
          t_AsyCmdType::ModeChange,
          t_AsyCmdType::Reconnect,
          t_AsyCmdType::DelayedEnable:
            AsySSW();
            
        //***************************************************************************************************
        end_case;
      else //if sSdoData.AsyState is not busy
        
        //if autoconnect is activated it has priority to HandleSDOFifo() -> between each autoconnect are timeslots for other communication (SIOL_MINIMUM_WAIT4RECONNECT_TIME)
        if sAutoConnectVars.bAutoConnectActive = TRUE then
          //check if a new port scan must be started.
          RetCodeSDCI := HandleAutoConnect(sAutoConnectVars.usActPortNbr mod SIOL_MAX_PORTS_SUPPORTED);
          //if reconnect failed because asy communication is busy, wait for asy communication is available
          if RetCodeSDCI <> SDCI_Busy then
            //go to next port
            sAutoConnectVars.usActPortNbr += 1;
          end_if;
        end_if;
        
        // Check if there are SDOs in the FIFO
        HandleSDOFifo();        
      
      end_if;// if busy with a service data command
      
      if (b_LogAsyCalls.AsyWarnLogDone      = FALSE) &
         (b_LogAsyCalls.DirectAsyAccessUsed = TRUE)  & 
         (b_LogAsyCalls.BufferAsyAccessUsed = TRUE) then
         
        b_LogAsyCalls.AsyWarnLogDone := TRUE;
        LogError(pMsg:= "@0534 (SdiasSDCIMaster::UpdateCy) WARNING: A combination of buffered and unbuffered asynchronous calls has been detected.");
         
      end_if;
 
    end_if; // if ClassState = _ClassOk
  end_if; // if b_DoTheInit

END_FUNCTION


FUNCTION SdiasSDCIMaster::CalcChecksum
	VAR_INPUT
		Mode 	: DINT;
	END_VAR
	VAR_OUTPUT
		Result 	: USINT;
	END_VAR
  VAR
  	i     : UDINT;
    pHelp : ^USINT;
    ForEnd: USINT;
  END_VAR

(*
Checksum calculation:
All of the affected bytes are XOR processed byte by byte. The checksum byte is included with value 0.

The validity of the received telegram can be checked by XOR processing all bytes including the checksum byte. The result must be equal to 0.

*)

  Result := 0;

  // depending on the mode the checksum is calculated over a different memory (and also a different part of it)
  case Mode of
//**********************************************************************************************************************************************************
    0: // read => used to verify received data! the returned value of Result has to be 0 to indicate consistent data
      if sSdoData.SdoReadData.LengthOfData <= SIOL_MAX_SDO_DATA_SIZE then
        if sSdoData.SdoReadData.LengthOfData then
          pHelp   := #sSdoData.SdoReadData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData];
        else
          pHelp   := (#sSdoData.SdoReadData.ParaIndex)$^USINT;
        end_if;
        
        ForEnd  := sSdoData.SdoReadData.LengthOfData + sizeof(t_ServiceDataArea.ParaIndex) + sizeof(t_ServiceDataArea.ParaSubIndex) + sizeof(t_ServiceDataArea.PortSelection) + sizeof(t_ServiceDataArea.LengthOfData);

        // calculate over data and access info
        for i := 0 to ForEnd-1 do
          Result := Result XOR pHelp^;
          pHelp  += 1;
        end_for;
        
        // calculate over msg counter, returncode and checksum (should result in 0 if the data are consistent)
        Result := Result XOR sSdoData.SdoReadData.ro_RetCode$USINT XOR sSdoData.SdoReadData.ro_Checksum XOR sSdoData.SdoReadData.ro_MessageCnt;
      else
        LogError("@04F0 (SdiasSDCIMaster::CalcChecksum) Invalid data length value in SDO response");
      end_if;

//**********************************************************************************************************************************************************   
    1: // write => used to fill the checksum field when sending data (therefore the checksum is not included in the calculation)
      if sSdoData.SdoWriteData.LengthOfData <= SIOL_MAX_SDO_DATA_SIZE then
        if sSdoData.SdoWriteData.LengthOfData then
          pHelp   := #sSdoData.SdoWriteData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoWriteData.LengthOfData];
        else
          pHelp   := (#sSdoData.SdoWriteData.ParaIndex)$^USINT;
        end_if;
        
        ForEnd  := sSdoData.SdoWriteData.LengthOfData + sizeof(t_ServiceDataArea.ParaIndex) + sizeof(t_ServiceDataArea.ParaSubIndex) + sizeof(t_ServiceDataArea.PortSelection) + sizeof(t_ServiceDataArea.LengthOfData) + sizeof(t_ServiceDataArea.wo_ActUsage);

        // calculate over data, access info, usage and msg counter
        for i := 0 to ForEnd-1 do
          Result := Result XOR pHelp^;
          pHelp  += 1;
        end_for;
        
        Result := Result XOR sSdoData.SdoWriteData.wo_MessageCnt;
      else
        LogError("@04F1 (SdiasSDCIMaster::CalcChecksum) Invalid data length value in SDO request");
      end_if;

//**********************************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION SdiasSDCIMaster::InitializeCyclicSSW
	VAR_INPUT
		pPara 	: ^CmdStruct;
		Usage 	: SdiasSDCIMaster::t_ServiceDataUsage;
	END_VAR
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR
  VAR
  	localSDOLock : UDINT;
  END_VAR

  retcode := BUSY;
  
  // If not busy
  localSDOLock := sigclib_atomic_cmpxchgU32(pValue:=#sSdoData.DataLock, cmpVal := SSDCIM_SDO_UNLOCK, newVal := SSDCIM_SDO_LOCK);  
  if localSDOLock = SSDCIM_SDO_UNLOCK then

    // if it's not the master port
    if pPara^.aPara[2]$USINT <> SIOL_MASTER_PORT_NO then
      // take the port from the SDCIPort object
      pPara^.aPara[2] := pPara^.aPara[MAXCMDPARA-1];
    end_if;

    // reset some parts of the readdata structure
    sSdoData.SdoReadData.LengthOfData   := 0;
    sSdoData.SdoReadData.ro_Checksum    := 0;

    retcode := InitializeSdoWriteData(Usage:=Usage, ParaIndex:=pPara^.aPara[0]$UINT, ParaSubIndex:=pPara^.aPara[1]$USINT, PortSelection:=pPara^.aPara[2]$USINT, LengthOfData:=pPara^.aPara[3]$USINT, pData:=pPara^.aPara[4]$pVoid);
    
    sSdoData.pCallBackThis  := NIL;
    sSdoData.pCallBackFun   := NIL;

    if retcode = ERROR then      
      // Unlock SDO Channel
      sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);
      return;
    end_if;

    // we're busy now
    sSdoData.AsyState       := t_SDCIRetCode::SDCI_Busy;
    sSdoData.AsyCmdType     := t_AsyCmdType::SingleAsyTransfer;
    sSdoData.eResponseState := t_ReponseState::_SendData;
  
  end_if;

END_FUNCTION


FUNCTION SdiasSDCIMaster::GetNextParaFromTable
	VAR_INPUT
		pActPortInfo 	: ^SdiasSDCIMaster::t_PortInfo;
	END_VAR
  
  // if the next parameter still would be valid
  if pActPortInfo^.ActParaNo+1 < pActPortInfo^.NoOfParameters then
    // set the pointer to the next parameter
    pActPortInfo^.pActPara += sizeof(t_ConfigTablePara) + pActPortInfo^.pActPara^.DataLength;
    pActPortInfo^.ActParaNo += 1;
  else
    // otherwise we're done here
    pActPortInfo^.pActPara := NIL;
  end_if;

END_FUNCTION

FUNCTION SdiasSDCIMaster::FindParaInTable
	VAR_INPUT
		pActPortInfo 	: ^SdiasSDCIMaster::t_PortInfo;
		ParaID 	: UDINT;
		ParaSubID 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pParaInfo 	: ^t_ConfigTablePara;    
	END_VAR
  VAR
  	pActPara    : ^t_ConfigTablePara;
    ActParaNo   : UDINT;
  END_VAR
  
  // Default return value no info available
  pParaInfo := NIL;
  
  // Start the search at the start of the table
  pActPara  := pActPortInfo^.pFirstPara;
  ActParaNo := 0;
  
  while ( ( pActPara) & 
          ( pActPara^.ParaID <= ParaID) ) do
  
    // Check if paramter was found
    if ( (pActPara^.ParaID    = ParaID) &
         (pActPara^.ParaSubID = ParaSubID) ) then
      
      // Return the parameter info
      pParaInfo := pActPara;
      return;      
      
    end_if;
    
    // Get next parameter
    // Do not use GetNextParaFromTable() because pActPortInfo^.pActPara is manupilated in that method.    
    // if the next parameter still would be valid
    if ActParaNo+1 < pActPortInfo^.NoOfParameters then
      // set the pointer to the next parameter
      pActPara += sizeof(t_ConfigTablePara) + pActPara^.DataLength;
      ActParaNo += 1;
    else
      // otherwise we're done here
      pActPara := NIL;
    end_if;
  
  end_while;  

END_FUNCTION


FUNCTION VIRTUAL SdiasSDCIMaster::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR

  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);

  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;

  if eResult = READY then
    
    case eCommand of
    //*****************************************************************************
      SDIAS_SDO_CMD_MEM_WRITE:
        if sSdoData.eResponseState = _Wait4SendResponse then
          sSdoData.eResponseState := _GotSendResponse;
        else
          LogError("@04F2 (SdiasSDCIMaster::ReceiveSDOResponse) Unexpected SDO response received (object is not waiting for a write memory response)");
        end_if;           
        
    //*****************************************************************************
      SDIAS_SDO_CMD_MEM_READ:
        if sSdoData.eResponseState = _Wait4ReceiveData then
          if ResponseLength & (ResponseLength <= SDIAS_MAX_SDO_READ_LENGTH) then
            if ResponseLength = sSdoData.ActDataSize then
              _memcpy(ptr1:=sSdoData.pActData, ptr2:=pResponseBuffer, cntr:=ResponseLength);
              sSdoData.eResponseState := _GotReceiveData;
            else
              LogError("@04F3 (SdiasSDCIMaster::ReceiveSDOResponse) Received unexpected length of SDO Data");  
            end_if;
          else
            LogError("@04F4 (SdiasSDCIMaster::ReceiveSDOResponse) Invalid length in SDO response received");  
          end_if;
        else
          LogError("@04F5 (SdiasSDCIMaster::ReceiveSDOResponse) Unexpected SDO response received (object is not waiting for a read memory response)");
        end_if;           
    //*****************************************************************************
    end_case;
    
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@04F7 (SdiasSDCIMaster::ReceiveSDOResponse) Error at write access!");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@04F8 (SdiasSDCIMaster::ReceiveSDOResponse) Error at read access!");
    end_case;
  end_if;
  
END_FUNCTION


FUNCTION SdiasSDCIMaster::InitializeSdoWriteData
	VAR_INPUT
		Usage 	: SdiasSDCIMaster::t_ServiceDataUsage;
		ParaIndex 	: UINT;
		ParaSubIndex 	: USINT;
		PortSelection 	: USINT;
		LengthOfData 	: USINT;
		pData 	: ^void;
		pParaInfo 	: ^t_ConfigTablePara;(* := nil *)
	END_VAR
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR

  // initialize variables for the cyclic state machine
  sSdoData.SdoWriteData.ParaIndex     := ParaIndex;
  sSdoData.SdoWriteData.ParaSubIndex  := ParaSubIndex;
  sSdoData.SdoWriteData.PortSelection := PortSelection;
  sSdoData.SdoWriteData.LengthOfData  := LengthOfData;
  if sSdoData.SdoWriteData.LengthOfData then
    if pData then
      if sSdoData.SdoWriteData.LengthOfData <= SIOL_MAX_SDO_DATA_SIZE then
      
        if pParaInfo = NIL & PortSelection < SIOL_MAX_PORTS_SUPPORTED then
          pParaInfo := FindParaInTable( pActPortInfo  := #aPortInfo[PortSelection]
                                      , ParaID        := ParaIndex
                                      , ParaSubID     := ParaSubIndex);
        end_if;
        
        if CheckEndianSwapNeeded( pParaInfo     := pParaInfo
                                , PortSelection := PortSelection) then
          EndianSwap( pDst := #sSdoData.SdoWriteData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoWriteData.LengthOfData], pSrc:=pData$^USINT, LengthOfData := sSdoData.SdoWriteData.LengthOfData);
        else
          _memcpy(    ptr1 := #sSdoData.SdoWriteData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoWriteData.LengthOfData], ptr2:=pData,                cntr := sSdoData.SdoWriteData.LengthOfData); 
        end_if;        
        
      else
        LogError("@04F9 (SdiasSDCIMaster::InitializeSdoWriteData) Invalid LengthOfData");
        retcode := ERROR;
        return;
      end_if;
    else
      LogError("@04FA (SdiasSDCIMaster::InitializeSdoWriteData) Invalid pointer");
      retcode := ERROR;
      return;
    end_if;
  end_if;
  
  sSdoData.SdoWriteData.wo_ActUsage   := Usage;
  sSdoData.SdoWriteData.wo_MessageCnt += 1;
  sSdoData.SdoWriteData.wo_Checksum   := CalcChecksum(Mode:=1);

  // set RemainingDataSize, pActData and ActDataSize correctly for the first send package
  
  // at the initialisation we set the remaining size to the complete package that needs to be transferred
  sSdoData.RemainingDataSize  := sSdoData.SdoWriteData.LengthOfData + sizeof(t_ServiceDataArea) - sizeof(t_ServiceDataArea.aData) - sizeof(t_ServiceDataArea.ro_MessageCnt) - sizeof(t_ServiceDataArea.ro_RetCode) - sizeof(t_ServiceDataArea.ro_Checksum);
  sSdoData.pActData           := #sSdoData.SdoWriteData + SIOL_MAX_SDO_DATA_SIZE - sSdoData.SdoWriteData.LengthOfData;
  if sSdoData.RemainingDataSize > SDIAS_MAX_SDO_WRITE_LENGTH then
    // limit the act size to it's maximum
    sSdoData.ActDataSize := SDIAS_MAX_SDO_WRITE_LENGTH;
  else
    // we only need one package
    sSdoData.ActDataSize := sSdoData.RemainingDataSize;
  end_if;

  retcode := READY;

END_FUNCTION


FUNCTION SdiasSDCIMaster::GetSdoReadData
	VAR_INPUT
		pLength 	: ^USINT;
		pData 	: ^void;
		bDoEndianSwap 	: BOOL;(* := FALSE *)
	END_VAR

  // if pointer to length and data is valid
  if pLength & pData then
    pLength^ := sSdoData.SdoReadData.LengthOfData;
    
    // if there has been returndata at the SDO transfer
    if sSdoData.SdoReadData.LengthOfData then
      // if the length is valid
      if sSdoData.SdoReadData.LengthOfData <= SIOL_MAX_SDO_DATA_SIZE then
      
        if bDoEndianSwap = TRUE then
          // Endianswap the returndata to the data pointer
          EndianSwap(pDst := pData$^USINT, pSrc := #sSdoData.SdoReadData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData], LengthOfData := sSdoData.SdoReadData.LengthOfData);
        else
          // copy the returndata to the data pointer
          _memcpy(   ptr1 := pData,        ptr2 := #sSdoData.SdoReadData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData],         cntr := sSdoData.SdoReadData.LengthOfData);
        end_if;
        
      else
        LogError("@04F9 (SdiasSDCIMaster::GetSdoReadData) Invalid LengthOfData");
        pLength^ := 0;
      end_if;
    end_if;  
  end_if;

END_FUNCTION


FUNCTION SdiasSDCIMaster::HandleSdoDataTransfer
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR

  retcode := READY;

  case sSdoData.eResponseState of
  //***************************************************************************************************
//  t_ReponseState::_PrepareSendData: // preparing the send data is done individually outside of the transfer method


  //***************************************************************************************************
    t_ReponseState::_SendData:
      // send data to the module
      StartWriteSDO(hOffset:=SIOL_OFFSET_SERVICE_DATA_AREA + (sSdoData.pActData$UDINT - (#sSdoData.SdoWriteData.aData)$UDINT)$UINT, usLength:=sSdoData.ActDataSize, pWriteBuffer:=sSdoData.pActData$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
      sSdoData.TimeoutStart   := ops.tAbsolute;
      sSdoData.eResponseState := t_ReponseState::_Wait4SendResponse;
      
  //***************************************************************************************************
    t_ReponseState::_Wait4SendResponse: // wait for the confirmation of the SDIAS Manager
      // check for a timeout
      if (ops.tAbsolute - sSdoData.TimeoutStart) > SIOL_SDO_TIMEOUT then
        LogError("@04FC (SdiasSDCIMaster::HandleSdoDataTransfer) Timeout at writing SDO command (no response at SDIAS received)");
        sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_TimeoutInComToMicroCtrl;
        retcode := ERROR;
      end_if;

  //***************************************************************************************************
    t_ReponseState::_GotSendResponse: // we enter this step, when we received the answer
      // here we decide if more packages need to be sent
      sSdoData.RemainingDataSize -= sSdoData.ActDataSize;
      sSdoData.pActData          += sSdoData.ActDataSize;
      
      // if there is more to send
      if sSdoData.RemainingDataSize then
        // another write access is necessary, prepare the variables
        if sSdoData.RemainingDataSize > SDIAS_MAX_SDO_WRITE_LENGTH then
          // limit the act size to it's maximum
          sSdoData.ActDataSize := SDIAS_MAX_SDO_WRITE_LENGTH;
        else
          // last package
          sSdoData.ActDataSize := sSdoData.RemainingDataSize;
        end_if;

        sSdoData.eResponseState := t_ReponseState::_SendData;
      else
        // finished with writing => go to reading the answer
        
        sSdoData.ResponseTimeoutStart := ops.tAbsolute;
        
        // reset the retry counter
        sSdoData.RetryCnt             := 0;
        
        // at the first reading we try to get as much as we can before checking the real length of the receivedata
        sSdoData.RemainingDataSize := 255; // 255 to signal it is the access to check the real size
        sSdoData.ActDataSize       := SDIAS_MAX_SDO_READ_LENGTH;
        sSdoData.pActData          := #sSdoData.SdoReadData + sizeof(t_ServiceDataArea) - SDIAS_MAX_SDO_READ_LENGTH; // set the pointer to the last block
        
        sSdoData.eResponseState := t_ReponseState::_ReadData;
      end_if;

  //***************************************************************************************************
    t_ReponseState::_ReadData:// we enter this step to start the read access
      // read data from the module
      StartReadSDO(hOffset:=SIOL_OFFSET_SERVICE_DATA_AREA + (sSdoData.pActData$UDINT - (#sSdoData.SdoReadData.aData)$UDINT)$UINT, usLength:=sSdoData.ActDataSize, eCommand:=SDIAS_SDO_CMD_MEM_READ);
      sSdoData.TimeoutStart   := ops.tAbsolute;
      sSdoData.eResponseState := t_ReponseState::_Wait4ReceiveData;

  //***************************************************************************************************
    t_ReponseState::_Wait4ReceiveData:// we wait for the read data
      // check for a timeout
      if (ops.tAbsolute - sSdoData.TimeoutStart) > SIOL_SDO_TIMEOUT then
        LogError("@04FD (SdiasSDCIMaster::HandleSdoDataTransfer) Timeout at reading SDO response (no response at SDIAS received)");
        sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_TimeoutInComToMicroCtrl;
        retcode := ERROR;
      end_if;

  //***************************************************************************************************
    t_ReponseState::_GotReceiveData:// we enter this step, when we received the answer with the data
      // here we decide if more packages need to be read
      
      // check if it's the first access to check the real size
      if sSdoData.RemainingDataSize = 255 then
        // first we check for the mirrored message counter (if the received one is the same, we have an answer from the µC)
        if sSdoData.SdoReadData.ro_MessageCnt = sSdoData.SdoWriteData.wo_MessageCnt then

          // check if we're missing something
          if sSdoData.SdoReadData.LengthOfData > (SDIAS_MAX_SDO_READ_LENGTH - (sizeof(t_ServiceDataArea) - sizeof(t_ServiceDataArea.aData))) then
            sSdoData.RemainingDataSize := sSdoData.SdoReadData.LengthOfData - (SDIAS_MAX_SDO_READ_LENGTH - (sizeof(t_ServiceDataArea) - sizeof(t_ServiceDataArea.aData)));

            // start at the lowest address and work our way up
            sSdoData.pActData -= sSdoData.RemainingDataSize;

            if sSdoData.RemainingDataSize > SDIAS_MAX_SDO_READ_LENGTH then
              // limit the act size to it's maximum
              sSdoData.ActDataSize := SDIAS_MAX_SDO_READ_LENGTH;
            else
              // we only need one package
              sSdoData.ActDataSize := sSdoData.RemainingDataSize;
            end_if;

            sSdoData.eResponseState := t_ReponseState::_ReadData;
          else
            if (CalcChecksum(Mode:=0) = 0) then
              // we got everything already
              sSdoData.eResponseState := t_ReponseState::_GotAllReceiveData;
            else
              if sSdoData.RetryCnt = 0 then
                // try 1 more time, because on simple master (CP101/CP102) it could be that the firmware was writing the message while the OS was reading and therefore we got inconsistent data
                sSdoData.RetryCnt += 1;
                
                // read everything again
                sSdoData.ResponseTimeoutStart := ops.tAbsolute;
                                
                // at the first reading we try to get as much as we can before checking the real length of the receivedata
                sSdoData.RemainingDataSize := 255; // 255 to signal it is the access to check the real size
                sSdoData.ActDataSize       := SDIAS_MAX_SDO_READ_LENGTH;
                sSdoData.pActData          := #sSdoData.SdoReadData + sizeof(t_ServiceDataArea) - SDIAS_MAX_SDO_READ_LENGTH; // set the pointer to the last block
                
                sSdoData.eResponseState    := t_ReponseState::_ReadData;
              else
                LogError("@04FE (SdiasSDCIMaster::HandleSdoDataTransfer) Incorrect checksum of response data from firmware detected");
                sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_InvalidChecksumFromMicroCtrl;
                retcode := ERROR;
              end_if;
            end_if;
          end_if;
        else
          // no answer yet => check timeout and then try again
          if (ops.tAbsolute - sSdoData.ResponseTimeoutStart) > SIOL_SDO_RESPONSE_TIMEOUT then
            LogError("@04FF (SdiasSDCIMaster::HandleSdoDataTransfer) Timeout while waiting for answer of SDCI master firmware");
            sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_TimeoutInComToMicroCtrl;
            retcode := ERROR;
          else
            // try again

            // at the first reading we try to get as much as we can before checking the real length of the receivedata
            sSdoData.RemainingDataSize := 255; // 255 to signal it is the access to check the real size
            sSdoData.ActDataSize       := SDIAS_MAX_SDO_READ_LENGTH;
            sSdoData.pActData          := #sSdoData.SdoReadData + sizeof(t_ServiceDataArea) - SDIAS_MAX_SDO_READ_LENGTH; // set the pointer to the last block

            sSdoData.eResponseState    := t_ReponseState::_ReadData;
          end_if;
        end_if;
      else
        // here it's not the first access to read data from the module
        sSdoData.RemainingDataSize -= sSdoData.ActDataSize;
        sSdoData.pActData          += sSdoData.ActDataSize;
        
        // if there is more to read
        if sSdoData.RemainingDataSize then
          // another read access is necessary, prepare the variables
          if sSdoData.RemainingDataSize > SDIAS_MAX_SDO_READ_LENGTH then
            // limit the act size to it's maximum
            sSdoData.ActDataSize := SDIAS_MAX_SDO_READ_LENGTH;
          else
            // last package
            sSdoData.ActDataSize := sSdoData.RemainingDataSize;
          end_if;

          sSdoData.eResponseState := t_ReponseState::_ReadData;
        else
          if (CalcChecksum(Mode:=0) = 0) then
            // finished with reading
            sSdoData.eResponseState := t_ReponseState::_GotAllReceiveData;
          else
            if sSdoData.RetryCnt = 0 then
              // try 1 more time, because on simple master (CP101/CP102) it could be that the firmware was writing the message while the OS was reading and therefore we got inconsistent data
              sSdoData.RetryCnt += 1;
              
              // read everything again
              sSdoData.ResponseTimeoutStart := ops.tAbsolute;
                              
              // at the first reading we try to get as much as we can before checking the real length of the receivedata
              sSdoData.RemainingDataSize := 255; // 255 to signal it is the access to check the real size
              sSdoData.ActDataSize       := SDIAS_MAX_SDO_READ_LENGTH;
              sSdoData.pActData          := #sSdoData.SdoReadData + sizeof(t_ServiceDataArea) - SDIAS_MAX_SDO_READ_LENGTH; // set the pointer to the last block
              
              sSdoData.eResponseState    := t_ReponseState::_ReadData;
            else
              LogError("@0501 (SdiasSDCIMaster::HandleSdoDataTransfer) Incorrect checksum of response data from firmware detected");
              sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_InvalidChecksumFromMicroCtrl;
              retcode := ERROR;
            end_if;
          end_if;
        end_if;        
      end_if;
      

  //***************************************************************************************************
//  t_ReponseState::_GotAllReceiveData:// handling of the receive data is done individually outside of the transfer method

  //***************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION SdiasSDCIMaster::AddEventToBuffer
	VAR_INPUT
		pEventDetails 	: ^SdiasSDCIMaster::t_SDCIEventDetails;
	END_VAR
  
  PdoProtection.SectionStart();

  // always add the new event to the buffer at the write index
  EventBuffer.aEvents[EventBuffer.EventWrIndex] := pEventDetails^;
  
  EventBuffer.EventWrIndex += 1;
  
  if EventBuffer.EventWrIndex = SIOL_EVENT_BUFFER_SIZE then
    EventBuffer.EventWrIndex := 0;
  end_if;

  // if the buffer has already been full
  if NbrOfEventsAvailable = SIOL_EVENT_BUFFER_SIZE then
    // also set the read index to the write index (because that is where the oldest entry is now)
    EventBuffer.EventRdIndex := EventBuffer.EventWrIndex;
  else
    // if not => increase the number of entries
    NbrOfEventsAvailable += 1;
  end_if;

  PdoProtection.SectionStop();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::GetEvent
	VAR_OUTPUT
		OldestEventAvailable 	: SdiasSDCIMaster::t_SDCIEventDetails;
	END_VAR

  PdoProtection.SectionStart();

  // if there are events
  if NbrOfEventsAvailable then
    // get the oldest
    OldestEventAvailable := EventBuffer.aEvents[EventBuffer.EventRdIndex];
    
    // increment the read pointer of the ring buffer
    EventBuffer.EventRdIndex += 1;
    if EventBuffer.EventRdIndex = SIOL_EVENT_BUFFER_SIZE then
      EventBuffer.EventRdIndex := 0;
    end_if;

    // show that there are less events in the buffer
    NbrOfEventsAvailable -= 1;
  else
    // no event available => set the whole return variable to 0
    _memset(dest:=#OldestEventAvailable, usByte:=0, cntr:=sizeof(OldestEventAvailable));
  end_if;

  PdoProtection.SectionStop();

END_FUNCTION


FUNCTION SdiasSDCIMaster::PrepareParaTabAccess
	VAR_INPUT
		pPortInfo 	: ^SdiasSDCIMaster::t_PortInfo;
	END_VAR
  VAR
  	pHelp     : ^UINT;
    Temp      : UINT;
    pBitHelp  : ^t_BitInfo;
  END_VAR

  // extract PDO info (bit offsets and length of every entry) and set data elements of port info (NoOfParameters & pFirstPara)
  
  // set pointer on info for process data in
  pHelp := pPortInfo^.pCfgTable + sizeof(t_ConfigTable);
  
  // number of bit infos for process data in
  Temp := pHelp^;
  pHelp += sizeof(UINT);
  
  if Temp then
    // allocate memory for the info
    pPortInfo^.pFirstPdIn$pVoid := ToStdLib.Malloc(size:=Temp * sizeof(t_BitInfo));
    pBitHelp := pPortInfo^.pFirstPdIn;

    // if there is a pointer => save the number
    if pBitHelp then
      pPortInfo^.PdInBitInfoNo := Temp;
    end_if;

    while Temp do
      // if we have a memory
      if pBitHelp then
        // store the data there
        pBitHelp^ := pHelp^$t_BitInfo;
        pBitHelp += sizeof(t_BitInfo);
      end_if;

      pHelp += sizeof(t_BitInfo);
      Temp -= 1;
    end_while;
  end_if;
  

  // number of bit infos for process data out
  Temp := pHelp^;
  pHelp += sizeof(UINT);
  if Temp then
    // allocate memory for the info
    pPortInfo^.pFirstPdOut$pVoid := ToStdLib.Malloc(size:=Temp * sizeof(t_BitInfo));
    pBitHelp := pPortInfo^.pFirstPdOut;

    // if there is a pointer => save the number
    if pBitHelp then
      pPortInfo^.PdOutBitInfoNo := Temp;
    end_if;
    
    while Temp do
      // if we have a memory
      if pBitHelp then
        // store the data there
        pBitHelp^ := pHelp^$t_BitInfo;
        pBitHelp += sizeof(t_BitInfo);
      end_if;

      pHelp += sizeof(t_BitInfo);
      Temp -= 1;
    end_while;
  end_if;

  // pHelp points to the number of parameters (UDINT)
  pPortInfo^.NoOfParameters := pHelp^$UDINT;
  pHelp += sizeof(UDINT);
  
  // pHelp points to the first parameter
  pPortInfo^.pFirstPara := pHelp$^t_ConfigTablePara;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSDCIMaster::DisconnectEvent
  VAR
  	i           : USINT;
    pPort       : ^t_PortInfo;
  	MyPara      : CmdStruct;
    MyResult    : results;
  END_VAR

  // update own state
  SdiasBase::DisconnectEvent();


  FirmwareVersion     := 0;
  CycleTime           := 0;
  PowerSupply         := 0;
  
  // reset eventbuffer
  NbrOfEventsAvailable     := 0;
  EventBuffer.EventWrIndex := 0;
  EventBuffer.EventRdIndex := 0;
  
  
  // update state to NoHardware
  MyPara.uiCmd        := CMD_SIOL_DEVICE_INFO_UPDATE;
  MyPara.aPara[0]     := _NoHardware$DINT;

  // reset the rest of the module info
  _memset(dest:=#MyPara.aPara[1], usByte:=0, cntr:=4*sizeof(DINT));

  // update state of connected modules
  pPort := #aPortInfo[0];
  for i := 0 to (SIOL_MAX_PORTS_SUPPORTED-1) do    
    // if there is an object
    if pPort^.pThis then
      // send the command to reset the device info
      pPort^.pThis^.NewInst(#MyPara, #MyResult);         
    end_if;
    
    pPort += sizeof(t_PortInfo);
  end_for;
  
  // Unlock is set after InitTheModule completed    
  sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_LOCK);
  
  HWKVarSizeFIFO1.Disable();
  
END_FUNCTION


FUNCTION SdiasSDCIMaster::ExtendPostInitTime
	VAR_INPUT
		AdditionalTime 	: UDINT;
	END_VAR
  VAR
  	MyPara          : CmdStruct;
    MyResult        : results;
  END_VAR

  MyPara.uiCmd    := CMD_EXTEND_POST_INIT_TIME;
  MyPara.aPara[0] := AdditionalTime$DINT;
  
  SdiasIn.NewInst(#MyPara, #MyResult);
  
END_FUNCTION


FUNCTION SdiasSDCIMaster::SetRequiredError
  VAR
  	MyPara          : CmdStruct;
    MyResult        : results;
  END_VAR

  // show required error also on SDCI master module
  ClassState := _RequiredError;

  // set required error
  MyPara.uiCmd     := _BUS_IF_SET_REQUIRED_ERROR;
  
  SdiasIn.NewInst(pPara:=#MyPara, pResult:=#MyResult);
  if MyResult.aData[0]$UDINT then
    LogError("@0502 (SdiasSDCIMaster::SetRequiredError) Failed to set required error to BusInterface");
  end_if;    

END_FUNCTION


FUNCTION SdiasSDCIMaster::SelectNextDownloadPara
	VAR_INPUT
		AlsoSearchOtherPorts 	: BOOL;(* := TRUE *)
	END_VAR
	VAR_OUTPUT
		Success 	: BOOL;
	END_VAR

  // in this function we select the next download parameter, if there are no more downloadparameters the pActPara at the current port points to NIL

  Success := TRUE;

  // if we already have a valid pointer => choose the next parameter
  if aPortInfo[sSdoData.ActPortSelection].pActPara then
    GetNextParaFromTable(#aPortInfo[sSdoData.ActPortSelection]);
  end_if;

  if aPortInfo[sSdoData.ActPortSelection].pActPara = NIL then
    // if first parameter or module not available => check for skipping
    if (aPortInfo[sSdoData.ActPortSelection].ActParaNo = 0) | (aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable = FALSE) then
      // while we're not at the end and there is nothing to download (no sdci port, not physically available or no config parameters) => skip the module
      while (sSdoData.ActPortSelection < SIOL_MAX_PORTS_SUPPORTED) & 
            ((aPortInfo[sSdoData.ActPortSelection].CfgPortMode <> _SDCI) | (aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable = FALSE) | 
             (aPortInfo[sSdoData.ActPortSelection].pCfgTable = NIL)      | (aPortInfo[sSdoData.ActPortSelection].NoOfParameters = 0)) do
        
        if AlsoSearchOtherPorts = FALSE then
          Success := FALSE;
          return;
        end_if;

        sSdoData.ActPortSelection += 1;
      end_while;

      // if we're behind the last possible port => nothing more to initialize
      if sSdoData.ActPortSelection = SIOL_MAX_PORTS_SUPPORTED then
        // tell the caller that we're finished here
        Success := FALSE;
        return;        
      end_if;
    end_if;

    // now we are on the first parameter and we have a module that is available => set the pointer to the first parameter
    aPortInfo[sSdoData.ActPortSelection].pActPara := aPortInfo[sSdoData.ActPortSelection].pFirstPara;    
  end_if;

  // now skip through the parameters until we find a download parameter or there are no more parameters
  while aPortInfo[sSdoData.ActPortSelection].pActPara &
     (((aPortInfo[sSdoData.ActPortSelection].pActPara^.AccessType <> t_ParaAccessType::rw) &
       (aPortInfo[sSdoData.ActPortSelection].pActPara^.AccessType <> t_ParaAccessType::wo)) |
       (aPortInfo[sSdoData.ActPortSelection].pActPara^.DataLength = 0))
       do
       
    GetNextParaFromTable(#aPortInfo[sSdoData.ActPortSelection]);
  
  end_while;

  // now if the pointer is still NIL and we're not yet on the last port => call the method again
  if (aPortInfo[sSdoData.ActPortSelection].pActPara = NIL) then
    // if we're already on the last port => there are no more ports to find download parameters, so we can stop searching
    if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
      Success := FALSE;
    else
      // more ports available => try again with the next port
      if AlsoSearchOtherPorts = FALSE then
        Success := FALSE;
        return;
      end_if;

      sSdoData.ActPortSelection += 1;

      Success := SelectNextDownloadPara();
    end_if;
  end_if;

END_FUNCTION


FUNCTION SdiasSDCIMaster::AsySSW
  VAR
  	TempData            : ARRAY [0..SIOL_MAX_SDO_DATA_SIZE-1] OF USINT;
    TempDataLen         : USINT;
    TempFlags           : t_ControlFlags;
    TempStateFlags      : t_StatusFlags;
  	MyPara              : CmdStruct;
    MyResult            : results;
    TempCycleTime       : UINT;
    i                   : DINT;
  END_VAR

  case sSdoData.eAsySSW of
  //**********************************************************************************************************************************************************
    t_AsySSW::_Idle: // nothing: wait for a command

  //**********************************************************************************************************************************************************
    t_AsySSW::_StartDelayedEnable:
      if DelayedEnablePorts then
        // at the first time we enter here
        if DelayedEnablePorts.FirstTime then
          // reset the port number
          sSdoData.ActPortSelection := 0;
          DelayedEnablePorts.FirstTime := FALSE;
        end_if;

        if DelayedEnablePorts AND 1 then
          // head into the step where the enable takes place
          sSdoData.eAsySSW   := t_AsySSW::_SwitchToNewMode;

          // reset response state machine
          sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
        else
          DelayedEnablePorts := DelayedEnablePorts SHR 1;
          sSdoData.ActPortSelection += 1;
        end_if;
      else
        // we're finished
        sSdoData.eAsySSW  := t_AsySSW::_Finished;        
      end_if;

  //**********************************************************************************************************************************************************
    t_AsySSW::_StartReconnect:
      // disable port, enable in scanmode, scan for device, if found => disable again, enable in fixed mode and set operate and pdout valid
      sSdoData.eAsySSW   := t_AsySSW::_RecoDisablePortBe4ScanMode;

      // update state to _NotInitialized
      MyPara.uiCmd        := CMD_SIOL_DEVICE_INFO_UPDATE;
      MyPara.aPara[0]     := _NotInitialized$DINT;

      // reset the rest of the module info
      aPortInfo[sSdoData.ActPortSelection].VendorID := 0;
      aPortInfo[sSdoData.ActPortSelection].DeviceID := 0;
      aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us := 0;

      // vendor ID
      MyPara.aPara[1] := aPortInfo[sSdoData.ActPortSelection].VendorID;

      // device ID
      MyPara.aPara[2] := aPortInfo[sSdoData.ActPortSelection].DeviceID$DINT;

      // minimum cycle time
      if aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us then
        MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us$DINT;
      else
        MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us$DINT;
      end_if;

      // actual port mode (still Inactive during initialisation)
      MyPara.aPara[4] := t_SDCIPortMode::_Inactive;

      _memset(dest:=#MyPara.aPara[1], usByte:=0, cntr:=4*sizeof(DINT));

      // send the command to reset the device info
      aPortInfo[sSdoData.ActPortSelection].pThis^.NewInst(#MyPara, #MyResult);  


      sSdoData.TargetMode      := aPortInfo[sSdoData.ActPortSelection].StartUpMode;


      // reset response state machine
      sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

  //**********************************************************************************************************************************************************
    t_AsySSW::_StartModeChange:
      // if the port is inactive (mode is inactive and operating is false)
      if (aPortInfo[sSdoData.ActPortSelection].ActPortMode = _Inactive) & ((CyclicInfoTotal.FlagsRdy2OpAndOperating SHR (4+sSdoData.ActPortSelection) AND 1) = FALSE) then
        // directly set new mode
        if sSdoData.TargetMode = _Inactive then
          // if we are already inactive but the user wants to switch again to inactive => start the normal routine (set it inactive again)
          sSdoData.eAsySSW := t_AsySSW::_SetPortInactive;
        else
          // continue setting the new mode
          sSdoData.eAsySSW   := t_AsySSW::_ConfigurePort;
        end_if;
      else
        // first of all we need to deactivate the port 
        sSdoData.eAsySSW := t_AsySSW::_SetPortInactive;
      end_if;

      // reset response state machine
      sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

//**********************************************************************************************************************************************************
  	t_AsySSW::_RecoDisablePortBe4ScanMode:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          
          // prepare the sdo buffer
          TempData[0]       := E_FNCID_SETPORTCNFPAR; // function ID
          TempData[1]       := sSdoData.ActPortSelection; // port number
          TempData[2]       := t_OpModeStates::E_OPMODE_INACTIVE; // operating mode
          TempData[3]       := t_PortCycle::E_PORTCYCLE_FREERN; // port cycle
          TempData[4]$UINT  := 0; // cycle time
          TempData[6]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataLength$USINT; // PDConfig LenIn
          TempData[7]       := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataStartAddress - SIOL_OFFSET_RT_READ_DATA)$USINT; // PdConfig PosIn
          TempData[8]       := 0; // PdConfig SrcOffsetIn
          TempData[9]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength$USINT; // PDConfig LenOut
          TempData[10]      := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataStartAddress - SIOL_OFFSET_RT_WRITE_DATA)$USINT; // PdConfig PosOut
          TempData[11]      := 0; // PdConfig SrcOffsetOut
          TempData[12]$UINT := 0; // VendorID
          TempData[14]$UDINT:= 0; // DeviceID
//          _strcpy(dest:=#TempData[18], src:="0000000000000000"); // serial number as string
          _memset(dest:=#TempData[18], usByte:=0, cntr:=16); // serial number as string
          TempData[34]      := 0; // Inspection level
          TempData[35]      := 0; // DS activation state
          TempData[36]      := 0; // DS download enable
          TempData[37]      := 0; // DS upload enable
          TempData[38]      := 16#11; // revision ID (v1.1 should work with both device types, v1.0 doesn't work with v1.1 devices)

          TempDataLen := 39;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;          

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 3 then
            // check response data
            if (TempData[0] = (E_FNCID_SETPORTCNFPAR)$USINT) & // check function ID
               (TempData[1] = sSdoData.ActPortSelection)              // check port number
               then
               
              if (TempData[2] = 0) then // check status code seperately
                // reset response state machine
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

                // finished, continue with next step
                sSdoData.eAsySSW := t_AsySSW::_RecoSwitchToDisableModeBe4ScanMode;
              else
                // error at return code
                LogError("@0503 (SdiasSDCIMaster::AsySSW) Error at status code in answer from µC (_DisablePorts)");
                sSdoData.eAsySSW := _AsyError;
                return;
              end_if;
            else
              // unexpected answer data
              LogError("@0504 (SdiasSDCIMaster::AsySSW) Unexpected data in answer from µC: wrong function ID or port number (_DisablePorts)");
              sSdoData.eAsySSW := _AsyError;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@0505 (SdiasSDCIMaster::AsySSW) Invalid data length in answer from µC (_DisablePorts)");
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
      end_case;


//**********************************************************************************************************************************************************
  	t_AsySSW::_RecoSwitchToDisableModeBe4ScanMode,
    t_AsySSW::_RecoWait4DisableModeBe4ScanMode:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          if sSdoData.eAsySSW = t_AsySSW::_RecoSwitchToDisableModeBe4ScanMode then
  //          TempFlags.Start2Operate := TRUE; // only makes sense if the port is active in SDCI mode
            TempFlags.OperatingMode := TRUE;
          end_if;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID
          for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
            // activate the disabled mode for our port
            if i = sSdoData.ActPortSelection then
              TempData[1 + i*sizeof(UINT)]$UINT := TempFlags;
            else
              TempData[1 + i*sizeof(UINT)]$UINT := 0;
            end_if;
          end_for;

          if TotalMappingWriteSize then
            _memset(dest:=#TempData[9], usByte:=0, cntr:=TotalMappingWriteSize);          
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID
              // reset response state machine
              sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

              // if the operating flag is cleared we can continue
              TempStateFlags := TempData[1 + sSdoData.ActPortSelection*sizeof(t_StatusFlags)]$t_StatusFlags;

              // if any operating bit is still set => go to wait for disabled
              if TempStateFlags.Operating = TRUE then

                // set the time mark the first time we send the command to not wait unnecessary
                if sSdoData.eAsySSW = t_AsySSW::_RecoSwitchToDisableModeBe4ScanMode then
                  Wait4DeviceDisableStartTime := ops.tAbsolute;
                end_if;
                
                sSdoData.eAsySSW   := t_AsySSW::_RecoWait4DisableModeBe4ScanMode;
              else
                // finished, continue with next step
                sSdoData.eAsySSW   := t_AsySSW::_RecoSetScanMode;
              end_if;
            else
              // unexpected answer data
              LogError("@0506 (SdiasSDCIMaster::AsySSW) Unexpected data in answer from µC: wrong function ID or port number (_SwitchToDisableMode)");
              sSdoData.eAsySSW := _AsyError;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@0507 (SdiasSDCIMaster::AsySSW) Invalid data length in answer from µC (_SwitchToDisableMode)");
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
      end_case;
      
//**********************************************************************************************************************************************************
  	t_AsySSW::_RecoSetScanMode:
      // if it's a SDCI port, we must wait the time (according to the specification), because some sensors might need it
      if (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI) & ((ops.tAbsolute - Wait4DeviceDisableStartTime) < aPortInfo[sSdoData.ActPortSelection].udModeChangeTime) then
        return;
      end_if;

      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          
          // prepare the sdo buffer
          TempData[0]       := E_FNCID_SETPORTCNFPAR; // function ID
          TempData[1]       := sSdoData.ActPortSelection; // port number
          TempData[2]       := t_OpModeStates::E_OPMODE_SCANMODE; // operating mode
          TempData[3]       := t_PortCycle::E_PORTCYCLE_FREERN; // port cycle
          TempData[4]$UINT  := 0; // cycle time
          TempData[6]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataLength$USINT; // PDConfig LenIn
          TempData[7]       := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataStartAddress - SIOL_OFFSET_RT_READ_DATA)$USINT; // PdConfig PosIn
          TempData[8]       := 0; // PdConfig SrcOffsetIn
          TempData[9]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength$USINT; // PDConfig LenOut
          TempData[10]      := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataStartAddress - SIOL_OFFSET_RT_WRITE_DATA)$USINT; // PdConfig PosOut
          TempData[11]      := 0; // PdConfig SrcOffsetOut
          TempData[12]$UINT := 0; // VendorID
          TempData[14]$UDINT:= 0; // DeviceID
//          _strcpy(dest:=#TempData[18], src:="0000000000000000"); // serial number as string
          _memset(dest:=#TempData[18], usByte:=0, cntr:=16); // serial number as string
          TempData[34]      := 0; // Inspection level (0 = don't care about vendor or device id)
          TempData[35]      := 0; // DS activation state
          TempData[36]      := 0; // DS download enable
          TempData[37]      := 0; // DS upload enable
          TempData[38]      := 16#11; // revision ID (v1.1 should work with both device types, v1.0 doesn't work with v1.1 devices)

          TempDataLen := 39;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 3 then
            // check response data
            if (TempData[0] = (E_FNCID_SETPORTCNFPAR)$USINT) & // check function ID
               (TempData[1] = sSdoData.ActPortSelection)              // check port number
               then
               
              if (TempData[2] = 0) then // check status code seperately
                // reset response state machine
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

                // finished, continue with next step
                sSdoData.eAsySSW := t_AsySSW::_RecoSwitchToScanMode;
              else
                // error at return code
                LogError("@0508 (SdiasSDCIMaster::AsySSW) Error at status code in answer from µC (_ConfigurePorts)");
                sSdoData.eAsySSW := _AsyError;
                return;
              end_if;
            else
              // unexpected answer data
              LogError("@0509 (SdiasSDCIMaster::AsySSW) Unexpected data in answer from µC: wrong function ID or port number (_ConfigurePorts)");
              sSdoData.eAsySSW := _AsyError;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@050B (SdiasSDCIMaster::AsySSW) Invalid data length in answer from µC  (_ConfigurePorts)");
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
  	t_AsySSW::_RecoSwitchToScanMode,
    t_AsySSW::_RecoWait4ScanMode:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          if sSdoData.eAsySSW = t_AsySSW::_RecoSwitchToScanMode then
            TempFlags.Start2Operate := TRUE;
            TempFlags.OperatingMode := TRUE;
          end_if;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID
          for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
            if i = sSdoData.ActPortSelection then
              // activate the disabled mode for this port
              TempData[1 + i*sizeof(UINT)]$UINT := TempFlags;
            else
              TempData[1 + i*sizeof(UINT)]$UINT := 0;
            end_if;
          end_for;

          if TotalMappingWriteSize then
            _memset(dest:=#TempData[9], usByte:=0, cntr:=TotalMappingWriteSize);          
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
          
            // reset response state machine
            sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
            
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID

              // if the operating flag is cleared we can continue
              TempStateFlags := TempData[1 + sSdoData.ActPortSelection*sizeof(t_StatusFlags)]$t_StatusFlags;
              
              // if the operating bit is not set and there is also no fault => go to wait again
              if (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI) & (TempStateFlags.Operating = FALSE) &
                 ((TempStateFlags AND 16#F000) = 0) then // no fault
                sSdoData.eAsySSW   := t_AsySSW::_RecoWait4ScanMode; // wait until fault or operating
              else
                aPortInfo[sSdoData.ActPortSelection].biDeviceInfoSub := SIOL_DEVICEINFO_READSUBINDEXES;
                aPortInfo[sSdoData.ActPortSelection].usActSubIndex   := 2; //first Subindex for read of Device Info data
                // finished, continue with next step
                sSdoData.eAsySSW   := t_AsySSW::_RecoGetDeviceInfos;
              end_if;
            else
              // unexpected answer data
              LogError("@050C (SdiasSDCIMaster::AsySSW) Unexpected data in answer from µC: wrong function ID or port number (_SwitchToNewMode)");
              sSdoData.eAsySSW := _AsyError;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@050D (SdiasSDCIMaster::AsySSW) Invalid data length in answer from µC (_SwitchToNewMode)");
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;            

      //***************************************************************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    t_AsySSW::_RecoGetDeviceInfos:

      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          // read direct parameter page 1 (device info)
          InitializeSdoWriteData(Usage:=_ReadParaData, ParaIndex:=0, ParaSubIndex:=aPortInfo[sSdoData.ActPortSelection].usActSubIndex+1, PortSelection:=sSdoData.ActPortSelection, LengthOfData:=0, pData:=NIL);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          // reset response state machine
          sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
          // initialize next step of ssw -> is changed if more parameters must be read
          sSdoData.eAsySSW := t_AsySSW::_RecoUpdateDeviceObjInfo;

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if (sSdoData.SdoReadData.ro_RetCode = _ServiceNotAvailable) | (TempDataLen = 0) then
            // maybe the port is not connected => select next port (after this if block)
            aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := FALSE;
          
          else
#ifdef SIOL_ENABLE_DEBUG_LOGGING
if TempData$t_DeviceInfoAnswer.ProcessDataIn <> aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataBitLength then
  LogValue("@DBG (SdiasSDCIMaster::AsySSW) Info: Configured bit size of read PDO 0x{0} does not match the expected size from the module 0x{1}. SDCI Port 0x{2}", udValue:=aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataBitLength, udValue2:=TempData$t_DeviceInfoAnswer.ProcessDataIn, udValue3:=sSdoData.ActPortSelection);
end_if;
if TempData$t_DeviceInfoAnswer.ProcessDataOut <> aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataBitLength then
  LogValue("@DBG (SdiasSDCIMaster::AsySSW) Info: Configured bit size of write PDO 0x{0} does not match the expected size from the module 0x{1}. SDCI Port 0x{2}", udValue:=aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataBitLength, udValue2:=TempData$t_DeviceInfoAnswer.ProcessDataOut, udValue3:=sSdoData.ActPortSelection);
end_if;
#endif
            //store act device info read data
            aPortInfo[sSdoData.ActPortSelection].aDeviceInfo[aPortInfo[sSdoData.ActPortSelection].usActSubIndex] := TempData[0];
            //set to next subindex
            aPortInfo[sSdoData.ActPortSelection].usActSubIndex += 1;
  
            //check for next subindex which must be read
            while aPortInfo[sSdoData.ActPortSelection].usActSubIndex < sizeof(t_DeviceInfoAnswer) do
              if (aPortInfo[sSdoData.ActPortSelection].biDeviceInfoSub shr aPortInfo[sSdoData.ActPortSelection].usActSubIndex) and 0x0001 = TRUE then
                //found next subindex to read
                exit;
              end_if;
              //set entry to next subindex
              aPortInfo[sSdoData.ActPortSelection].usActSubIndex += 1;
            end_while;
            
            if aPortInfo[sSdoData.ActPortSelection].usActSubIndex < sizeof(t_DeviceInfoAnswer) then
              //read next parameter
              sSdoData.eAsySSW := t_AsySSW::_RecoGetDeviceInfos;
            else
              //finished get device infos
              // MIN CYCLE TIME
              case aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.MinCycleTime SHR 6 of
                0: // base of  100µs (Multiplier x time base)
                  aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us :=  100 * (aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.MinCycleTime AND 16#3F);

                1: // base of  400µs (Multiplier x time base) +  6400µs
                  aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us :=  400 * (aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.MinCycleTime AND 16#3F) +  6400;

                2: // base of 1600µs (Multiplier x time base) + 32000µs
                  aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us := 1600 * (aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.MinCycleTime AND 16#3F) + 32000;

                3: // this is reserved for future use
                  LogError("@050E (SdiasSDCIMaster::AsySSW) Invalid time base 3 received at minimum cycle time of device (_GetDeviceInfos)");
                  sSdoData.eAsySSW := _AsyError;
                  return;
              end_case;
             
              // VENDOR ID
              aPortInfo[sSdoData.ActPortSelection].VendorID := aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.VendorIdLsb OR (aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.VendorIdMsb SHL 8);
              
              // DEVICE ID
              aPortInfo[sSdoData.ActPortSelection].DeviceID := aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.DeviceIdLsb OR (aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.DeviceIdMiddleByte SHL 8) OR (aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.DeviceIdMsb SHL 16);
              
              // Revision ID
              aPortInfo[sSdoData.ActPortSelection].RevisionID := aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer.RevisionID;

            end_if;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
    t_AsySSW::_RecoUpdateDeviceObjInfo:

      // show the info at the object and also set the class state server

      // reset act parameter number for next init step
      aPortInfo[sSdoData.ActPortSelection].ActParaNo := 0;
      
      // if there is an object to update
      if aPortInfo[sSdoData.ActPortSelection].pThis then
      
        // command for the newinst call
        MyPara.uiCmd    := CMD_SIOL_DEVICE_INFO_UPDATE;
      
        // if it's SDCI device
        if (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI) then
         
          // if there is an IODD file
          if aPortInfo[sSdoData.ActPortSelection].pCfgTable then
            // class state
            if (aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us | aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us) & aPortInfo[sSdoData.ActPortSelection].VendorID & aPortInfo[sSdoData.ActPortSelection].DeviceID then

              // device available => check if it's the right one
              if (aPortInfo[sSdoData.ActPortSelection].VendorID = aPortInfo[sSdoData.ActPortSelection].pCfgTable^.VendorID) & (aPortInfo[sSdoData.ActPortSelection].DeviceID = aPortInfo[sSdoData.ActPortSelection].pCfgTable^.DeviceID) then
                // show that we are still initializing
                MyPara.aPara[0] := _NotInitialized$DINT;
                aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := TRUE;
              else
                // wrong device
                MyPara.aPara[0] := _WrongHardware$DINT;
                
                // with this it doesn't get enabled when the fixed mode is set on all ports (doesn't make sense if it's the wrong module)
                aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := FALSE;
              end_if;          
            else
              // device not available
              MyPara.aPara[0] := _NoHardware$DINT;
              
              aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := FALSE;
            end_if;
          else
            // no IODD file => any device is ok if one of the Device Infos is available
            if aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us | aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us | aPortInfo[sSdoData.ActPortSelection].VendorID | aPortInfo[sSdoData.ActPortSelection].DeviceID then
              // show that we are still initializing
              MyPara.aPara[0] := _NotInitialized$DINT;
              aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := TRUE;
            else
              // no device infos available
              MyPara.aPara[0] := _NoHardware$DINT;
              
              aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := FALSE;
            end_if;
          end_if;

          // vendor ID
          MyPara.aPara[1] := aPortInfo[sSdoData.ActPortSelection].VendorID;

          // device ID
          MyPara.aPara[2] := aPortInfo[sSdoData.ActPortSelection].DeviceID$DINT;

          // minimum cycle time
          // check if a user override is active         
          if aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us then
            MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us$DINT;
          else
            MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us$DINT;
          end_if;
          
          // actual port mode (still Inactive during initialisation)
          MyPara.aPara[4] := t_SDCIPortMode::_Inactive;

          if aPortInfo[sSdoData.ActPortSelection].Required & (MyPara.aPara[0] <> _NotInitialized$DINT) then
            // show required error on SDCI device
            MyPara.aPara[0] := _RequiredError$DINT;
            aPortInfo[sSdoData.ActPortSelection].pThis^.NewInst(#MyPara, #MyResult);
            
            SetRequiredError();
          else
            aPortInfo[sSdoData.ActPortSelection].pThis^.NewInst(#MyPara, #MyResult);
          end_if;

        elsif (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _DigitalInput) | (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _DigitalOutput) then
          // it's always ok here
          MyPara.aPara[0] := _ClassOk$DINT;
          aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := TRUE;

          // we're in the desired mode
          aPortInfo[i].ActPortMode := aPortInfo[i].CfgPortMode;

          // the extra info does not exist here
          MyPara.aPara[1] := 0;
          MyPara.aPara[2] := 0;
          MyPara.aPara[3] := 0;

          // actual port mode is already valid here (no further changes on the setting of this port)
          MyPara.aPara[4] := aPortInfo[sSdoData.ActPortSelection].ActPortMode$DINT;

          aPortInfo[sSdoData.ActPortSelection].pThis^.NewInst(#MyPara, #MyResult);         
        end_if;
      else
        // no object available => just like if the module was not physically availabe
        aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := FALSE;
      end_if;
      
      if aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable = TRUE then
        sSdoData.eAsySSW := t_AsySSW::_RecoCheckDownloadParameters;
        
        DownloadTimeStart := ops.tAbsolute;

        // if the first pointer is not valid, skip until we find a valid pointer
        if aPortInfo[sSdoData.ActPortSelection].pActPara = NIL then
          if SelectNextDownloadPara(FALSE) = FALSE then
            // no download parameters available

            // go to next step
            sSdoData.eAsySSW := t_AsySSW::_SetPortInactive;
            
            // reset response state machine
            sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
          end_if;
        end_if;
      else
        // we switch the port to inactive
        sSdoData.TargetMode := _Inactive;

        sSdoData.eAsySSW := t_AsySSW::_SetPortInactive;
      end_if;

//**********************************************************************************************************************************************************
    t_AsySSW::_RecoCheckDownloadParameters:
    
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action

          // get the details to write the parameter
          if aPortInfo[sSdoData.ActPortSelection].pActPara then
            
            if aPortInfo[sSdoData.ActPortSelection].pActPara^.AccessType = t_ParaAccessType::wo then
              // Do not read write only parameters and write the parameter directly
              sSdoData.eAsySSW := t_AsySSW::_RecoDownloadParameters;
            else
              // read the parameter first (to check if it already matches the desired value)
              InitializeSdoWriteData(Usage:=_ReadParaData, ParaIndex:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID$UINT, ParaSubIndex:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID$USINT, PortSelection:=sSdoData.ActPortSelection, LengthOfData:=0, pData:=NIL);
              
              sSdoData.eResponseState := t_ReponseState::_SendData;
            end_if;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          // extend the post init time by the reaction time of the µC (otherwise we would exceed the timeout of the post init if there are many parameters)
          ExtendPostInitTime(AdditionalTime:=ops.tAbsolute - sSdoData.ResponseTimeoutStart);

          // reset response state machine
          sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

          // check response data
          if (sSdoData.SdoReadData.ro_RetCode = _FwOk) then // check returncode
            
            // check if the value matches our init value
            GetSdoReadData( pLength       := #TempDataLen
                          , pData         := #TempData[0]
                          , bDoEndianSwap := CheckEndianSwapNeeded( pParaInfo     := aPortInfo[sSdoData.ActPortSelection].pActPara
                                                                  , PortSelection := sSdoData.ActPortSelection) );

            // if it's a string, we add the termination 0 to the uploaded data (for the comparison), because we also have it in the table
            if aPortInfo[sSdoData.ActPortSelection].pActPara^.DataType = _Text then
              TempData[TempDataLen] := 0;
              TempDataLen += 1;
            end_if;

            if (aPortInfo[sSdoData.ActPortSelection].pActPara^.DataLength = TempDataLen) then
              if _memcmp(ptr1:=#TempData[0], ptr2:=aPortInfo[sSdoData.ActPortSelection].pActPara + sizeof(t_ConfigTablePara), cntr:=TempDataLen) = 0 then
                // value match => no download necessary
#ifdef SIOL_ENABLE_DEBUG_LOGGING
LogValue("@DBG (SdiasSDCIMaster::AsySSW) Value and length match already, no download needed. ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
#endif  
              else

                // it's not the same value => download the parameter
                sSdoData.eAsySSW := t_AsySSW::_RecoDownloadParameters;

#ifdef SIOL_ENABLE_DEBUG_LOGGING
LogValue("@DBG (SdiasSDCIMaster::AsySSW) Value mismatch => download new value. ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
#endif

                // skip selecting the next parameter, because we need to send the current parameter in the downloadparameters step
                return;
              end_if;
            else
              // length mismatch
              
              // if it's a string, we send the new value
              if aPortInfo[sSdoData.ActPortSelection].pActPara^.DataType = _Text then

                // it's not the same value => download the parameter
                sSdoData.eAsySSW := t_AsySSW::_RecoDownloadParameters;

#ifdef SIOL_ENABLE_DEBUG_LOGGING
LogValue("@DBG (SdiasSDCIMaster::AsySSW) Length mismatch at string => download new value. ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
#endif

                // skip selecting the next parameter, because we need to send the current parameter in the downloadparameters step
                return;
              else
                LogValue("@050F (SdiasSDCIMaster::AsySSW) Length mismatch (type is not string) => value not downloaded. ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
              end_if;
            end_if;

            if SelectNextDownloadPara(FALSE) = FALSE then
              // no more download parameters available
               
              // go to next step                
              sSdoData.eAsySSW := t_AsySSW::_SetPortInactive;
            end_if;
          else
            if (sSdoData.SdoReadData.ro_RetCode = _ApplicationError) then
              // if it's an application error, we also have an error code
              LogValue("@0510 (SdiasSDCIMaster::AsySSW) Error at reading parameter(_CheckDownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}, ErrorCode: {2}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID, udValue3:=sSdoData.SdoReadData.aData[230]$HINT);
            else
              LogValue("@0510 (SdiasSDCIMaster::AsySSW) Error at reading parameter(_CheckDownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);              
            end_if;
            
            // continue with the next parameter
            if SelectNextDownloadPara(FALSE) = FALSE then
              // no more download parameters available

              // go to next step
              sSdoData.eAsySSW := t_AsySSW::_SetPortInactive;
            end_if;
          end_if;

      //***************************************************************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    t_AsySSW::_RecoDownloadParameters:
    
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action

          // get the details to write the parameter
          if aPortInfo[sSdoData.ActPortSelection].pActPara then

            // prepare everything to send the parameter
            TempDataLen := aPortInfo[sSdoData.ActPortSelection].pActPara^.DataLength;
            _memcpy(ptr1:=#TempData[0], ptr2:=aPortInfo[sSdoData.ActPortSelection].pActPara + sizeof(t_ConfigTablePara), cntr:=TempDataLen);
            
            InitializeSdoWriteData( Usage         := _WriteParaData
                                  , ParaIndex     := aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID$UINT
                                  , ParaSubIndex  := aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID$USINT
                                  , PortSelection := sSdoData.ActPortSelection, LengthOfData:=TempDataLen, pData:=#TempData[0]
                                  , pParaInfo     := aPortInfo[sSdoData.ActPortSelection].pActPara);
            
            sSdoData.eResponseState := t_ReponseState::_SendData;
          else
            sSdoData.eAsySSW := _AsyError;
            LogError("@0511 (SdiasSDCIMaster::AsySSW) Conditions for parameter download not met. No valid parameter pointer!");
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          // extend the post init time by the reaction time of the µC (otherwise we would exceed the timeout of the post init if there are many parameters)
          ExtendPostInitTime(AdditionalTime:=ops.tAbsolute - sSdoData.ResponseTimeoutStart);

          // in general we go back to check the next parameter (unless there are no more parameters)
          sSdoData.eAsySSW := t_AsySSW::_RecoCheckDownloadParameters;

          // reset response state machine
          sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

          // check response data
          if (sSdoData.SdoReadData.ro_RetCode = _FwOk) then // check returncode

#ifdef SIOL_ENABLE_DEBUG_LOGGING
LogValue("@DBG (SdiasSDCIMaster::AsySSW) Successfully downloaded parameter (_DownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
#endif

          elsif (sSdoData.SdoReadData.ro_RetCode = _ApplicationError) then
            // if it's an application error, we also have an error code
            LogValue("@0512 (SdiasSDCIMaster::AsySSW) Error at writing parameter(_DownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}, ErrorCode: {2}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID, udValue3:=sSdoData.SdoReadData.aData[230]$HINT);
          else
            LogValue("@0512 (SdiasSDCIMaster::AsySSW) Error at writing parameter(_DownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);              
          end_if;
          
          // select the next parameter
          if SelectNextDownloadPara(FALSE) = FALSE then
            // no more download parameters available

            // go to next step
            sSdoData.eAsySSW := t_AsySSW::_SetPortInactive;
            
          end_if;

      //***************************************************************************************************
      end_case;
      
//**********************************************************************************************************************************************************
  	t_AsySSW::_SetPortInactive:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          
          // prepare the sdo buffer
          TempData[0]       := E_FNCID_SETPORTCNFPAR; // function ID
          TempData[1]       := sSdoData.ActPortSelection; // port number
          TempData[2]       := t_OpModeStates::E_OPMODE_INACTIVE; // operating mode
          TempData[3]       := t_PortCycle::E_PORTCYCLE_FREERN; // port cycle
          TempData[4]$UINT  := 0; // cycle time
          TempData[6]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataLength$USINT; // PDConfig LenIn
          TempData[7]       := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataStartAddress - SIOL_OFFSET_RT_READ_DATA)$USINT; // PdConfig PosIn
          TempData[8]       := 0; // PdConfig SrcOffsetIn
          TempData[9]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength$USINT; // PDConfig LenOut
          TempData[10]      := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataStartAddress - SIOL_OFFSET_RT_WRITE_DATA)$USINT; // PdConfig PosOut
          TempData[11]      := 0; // PdConfig SrcOffsetOut
          TempData[12]$UINT := 0; // VendorID
          TempData[14]$UDINT:= 0; // DeviceID
//          _strcpy(dest:=#TempData[18], src:="0000000000000000"); // serial number as string
          _memset(dest:=#TempData[18], usByte:=0, cntr:=16); // serial number as string
          TempData[34]      := 0; // Inspection level
          TempData[35]      := 0; // DS activation state
          TempData[36]      := 0; // DS download enable
          TempData[37]      := 0; // DS upload enable
          TempData[38]      := 16#11; // revision ID (v1.1 should work with both device types, v1.0 doesn't work with v1.1 devices)

          TempDataLen := 39;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;          

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 3 then
            // check response data
            if (TempData[0] = (E_FNCID_SETPORTCNFPAR)$USINT) & // check function ID
               (TempData[1] = sSdoData.ActPortSelection)       // check port number
               then
               
              if (TempData[2] = 0) then // check status code seperately
                // reset response state machine
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

                sSdoData.eAsySSW := t_AsySSW::_SwitchToDisableMode;
              else
                // error at return code
                sSdoData.eAsySSW := _AsyError;
                sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspData;
                LogError("@503 (SdiasSDCIMaster::AsySSW) Error at status code in answer from µC (_DisablePorts)");
                return;
              end_if;
            else
              // unexpected answer data
              sSdoData.eAsySSW := _AsyError;
              sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspData;
              LogError("@0504 (SdiasSDCIMaster::AsySSW) Unexpected data in answer from µC: wrong function ID or port number (_DisablePorts)");
              return;
            end_if;
          else
            // invalid length of answer data
            sSdoData.eAsySSW := _AsyError;
            sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspLength;
            LogError("@0505 (SdiasSDCIMaster::AsySSW) Invalid data length in answer from µC (_DisablePorts)");
            return;
          end_if;

      //***************************************************************************************************
      end_case;


//**********************************************************************************************************************************************************
  	t_AsySSW::_SwitchToDisableMode:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          if sSdoData.eAsySSW = t_AsySSW::_SwitchToDisableMode then
  //          TempFlags.Start2Operate := TRUE; // only makes sense if the port is active in SDCI mode
            TempFlags.OperatingMode := TRUE;
          end_if;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID

          // reset the area for all devices before setting for the specific
          _memset(dest:=#TempData[1], usByte:=0, cntr:=SIOL_MAX_PORTS_SUPPORTED * sizeof(TempFlags));

          // activate the disabled mode for the selected port
          TempData[1 + sSdoData.ActPortSelection*sizeof(UINT)]$UINT := TempFlags;

          if TotalMappingWriteSize then
            _memcpy(ptr1:=#TempData[9], ptr2:=#LocalWritePDOBuf[0], cntr:=TotalMappingWriteSize);
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID
              // reset response state machine
              sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
             
              Wait4DeviceDisableStartTime := ops.tAbsolute;
                                
              sSdoData.eAsySSW   := t_AsySSW::_Wait4DisableMode;
            else
              // unexpected answer data
              sSdoData.eAsySSW := _AsyError;
              sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspData;
              LogError("@0506 (SdiasSDCIMaster::AsySSW) Unexpected data in answer from µC: wrong function ID or port number (_SwitchToDisableMode)");
              return;
            end_if;
          else
            // invalid length of answer data
            sSdoData.eAsySSW := _AsyError;
            sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspLength;
            LogError("@0507 (SdiasSDCIMaster::AsySSW) Invalid data length in answer from µC (_SwitchToDisableMode)");
            return;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
    t_AsySSW::_Wait4DisableMode:
      // if it's a SDCI Portmode, we have to wait for the operating bit to be cleared (maximum time, if it does not get cleared)
      if (aPortInfo[sSdoData.ActPortSelection].CfgPortMode <> _SDCI) |
         ((CyclicInfoTotal.FlagsRdy2OpAndOperating SHR (4+sSdoData.ActPortSelection) AND 1) = FALSE) |
         ((ops.tAbsolute - Wait4DeviceDisableStartTime) > aPortInfo[sSdoData.ActPortSelection].udModeChangeTime) then

        // finished, continue with next step
        if sSdoData.TargetMode = _Inactive then
          // we're on our target state => show it on the class
          sSdoData.eAsySSW   := t_AsySSW::_UpdateClassState;
        else   
          // continue setting the new mode
          sSdoData.eAsySSW   := t_AsySSW::_ConfigurePort;
        end_if;
      end_if;

//**********************************************************************************************************************************************************
  	t_AsySSW::_ConfigurePort:
      // if it's a SDCI port, we must wait the time (according to the specification), because some sensors might need it
      if (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI) & ((ops.tAbsolute - Wait4DeviceDisableStartTime) < aPortInfo[sSdoData.ActPortSelection].udModeChangeTime) then
        return;
      end_if;

      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          
          // prepare the sdo buffer
          TempData[0]       := E_FNCID_SETPORTCNFPAR; // function ID
          TempData[1]       := sSdoData.ActPortSelection; // port number
          case sSdoData.TargetMode of
          //***************************************************************************************************
            _Inactive:
              TempData[2]       := t_OpModeStates::E_OPMODE_INACTIVE; // operating mode

          //***************************************************************************************************
            _DigitalInput:
              TempData[2]       := t_OpModeStates::E_OPMODE_DI; // operating mode           

          //***************************************************************************************************
            _DigitalOutput:
              TempData[2]       := t_OpModeStates::E_OPMODE_DO; // operating mode
            
          //***************************************************************************************************
            _SDCI:
              TempData[2]       := t_OpModeStates::E_OPMODE_FIXEDMODE; // operating mode
              
          //***************************************************************************************************
          end_case;

          TempData[3]       := t_PortCycle::E_PORTCYCLE_FIXVAL; // port cycle

          // check if a user override is active
          if aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us then
            // recalculate cycle time from [µs] to [100µs]
            TempCycleTime     := to_uint(aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us / 100);
          else
            // recalculate cycle time from [µs] to [100µs]
            TempCycleTime     := to_uint(aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us / 100);
          end_if;

          // make endian swap
          TempCycleTime     := ((TempCycleTime SHR 8) AND 16#FF) OR ((TempCycleTime SHL 8) AND 16#FF00);

          TempData[4]$UINT  := TempCycleTime; // cycle time
          TempData[6]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataLength$USINT; // PDConfig LenIn
          TempData[7]       := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataStartAddress - SIOL_OFFSET_RT_READ_DATA)$USINT; // PdConfig PosIn
          TempData[8]       := 0; // PdConfig SrcOffsetIn
          TempData[9]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength$USINT; // PDConfig LenOut
          TempData[10]      := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataStartAddress - SIOL_OFFSET_RT_WRITE_DATA)$USINT; // PdConfig PosOut
          TempData[11]      := 0; // PdConfig SrcOffsetOut
          TempData[12]      := (aPortInfo[sSdoData.ActPortSelection].VendorID SHR 8)$USINT; // VendorID
          TempData[13]      :=  aPortInfo[sSdoData.ActPortSelection].VendorID$USINT; // VendorID
          TempData[14]      := (aPortInfo[sSdoData.ActPortSelection].DeviceID SHR 24)$USINT; // DeviceID
          TempData[15]      := (aPortInfo[sSdoData.ActPortSelection].DeviceID SHR 16)$USINT; // DeviceID
          TempData[16]      := (aPortInfo[sSdoData.ActPortSelection].DeviceID SHR  8)$USINT; // DeviceID
          TempData[17]      := (aPortInfo[sSdoData.ActPortSelection].DeviceID       )$USINT; // DeviceID
//          _strcpy(dest:=#TempData[18], src:="0000000000000000"); // serial number as string
          _memset(dest:=#TempData[18], usByte:=0, cntr:=16); // serial number as string
          TempData[34]      := 1; // Inspection level (1 = device and vendor id have to match)
          TempData[35]      := 0; // DS activation state
          TempData[36]      := 0; // DS download enable
          TempData[37]      := 0; // DS upload enable
          TempData[38]      := aPortInfo[sSdoData.ActPortSelection].RevisionID; // revision ID

          TempDataLen := 39;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 3 then
            // check response data
            if (TempData[0] = (E_FNCID_SETPORTCNFPAR)$USINT) & // check function ID
               (TempData[1] = sSdoData.ActPortSelection)              // check port number
               then
               
              if (TempData[2] = 0) then // check status code seperately
                // reset response state machine
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

                sSdoData.eAsySSW := t_AsySSW::_SwitchToNewMode;
              else
                // error at return code
                sSdoData.eAsySSW := _AsyError;
                sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspData;
                LogError("@0508 (SdiasSDCIMaster::AsySSW) Error at status code in answer from µC (_ConfigurePorts)");
                return;
              end_if;
            else
              // unexpected answer data
              sSdoData.eAsySSW := _AsyError;
              sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspData;
              LogError("@0509 (SdiasSDCIMaster::AsySSW) Unexpected data in answer from µC: wrong function ID or port number (_ConfigurePorts)");
              return;
            end_if;
          else
            // invalid length of answer data
            sSdoData.eAsySSW := _AsyError;
            sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspLength;
            LogError("@050B (SdiasSDCIMaster::AsySSW) Invalid data length in answer from µC  (_ConfigurePorts)");
            return;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
  	t_AsySSW::_SwitchToNewMode:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          TempFlags.Start2Operate := TRUE;
          TempFlags.OperatingMode := TRUE;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID

          // reset the area for all devices before setting for the specific
          _memset(dest:=#TempData[1], usByte:=0, cntr:=SIOL_MAX_PORTS_SUPPORTED * sizeof(TempFlags));

          // activate the new mode for the selected port
          TempData[1 + sSdoData.ActPortSelection*sizeof(UINT)]$UINT := TempFlags;

          if TotalMappingWriteSize then
            _memcpy(ptr1:=#TempData[9], ptr2:=#LocalWritePDOBuf[0], cntr:=TotalMappingWriteSize);
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID
              // reset response state machine
              sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
                              
              // remember when we started to wait
              sSdoData.TimeoutStart   := ops.tAbsolute;

              sSdoData.eAsySSW   := t_AsySSW::_Wait4NewMode; // wait until fault or operating
            else
              // unexpected answer data
              sSdoData.eAsySSW := _AsyError;
              sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspData;
              LogError("@050C (SdiasSDCIMaster::AsySSW) Unexpected data in answer from µC: wrong function ID or port number (_SwitchToNewMode)");
              return;
            end_if;
          else
            // invalid length of answer data
            sSdoData.eAsySSW := _AsyError;
            sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspLength;
            LogError("@050D (SdiasSDCIMaster::AsySSW) Invalid data length in answer from µC (_SwitchToNewMode)");
            return;
          end_if;            

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
    t_AsySSW::_Wait4NewMode:
      // if mode is not SDCI or operating or fault
      if (sSdoData.TargetMode <> _SDCI) |
         ((CyclicInfoTotal.FlagsRdy2OpAndOperating SHR (4+sSdoData.ActPortSelection) AND 1) = TRUE) | 
         ((CyclicInfoTotal.FaultFlags$UINT SHR (sSdoData.ActPortSelection * 4)) AND 16#F) then
        if (sSdoData.TargetMode = _SDCI) & aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength then
          // we need to enable the output data also
          sSdoData.eAsySSW   := t_AsySSW::_SetOperateAndPdOutValid;                
        else
          // show the class state
          sSdoData.eAsySSW   := t_AsySSW::_UpdateClassState;
        end_if;
      elsif (ops.tAbsolute - sSdoData.TimeoutStart) > SIOL_SDO_RESPONSE_TIMEOUT  then
        sSdoData.eAsySSW := _AsyError;
        sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_TimeoutInComToMicroCtrl;
        LogError("@0513 (SdiasSDCIMaster::AsySSW) Timeout when waiting for operate when switching the port mode (_Wait4NewMode)");
      end_if;

//**********************************************************************************************************************************************************
  	t_AsySSW::_SetOperateAndPdOutValid:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          TempFlags.Start2Operate := TRUE;
          TempFlags.OperatingMode := TRUE;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID

          TempFlags.PdOutValid := aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength <> 0;

          // reset the area for all devices before setting for the specific
          _memset(dest:=#TempData[1], usByte:=0, cntr:=SIOL_MAX_PORTS_SUPPORTED * sizeof(TempFlags));
          
          TempData[1 + sSdoData.ActPortSelection*sizeof(UINT)]$UINT := TempFlags;

          if TotalMappingWriteSize then
            _memset(dest:=#TempData[9], usByte:=0, cntr:=TotalMappingWriteSize);          
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eAsySSW := _AsyError;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data
          
          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID
              // reset response state machine
              sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

              // if the operating flag is cleared we can continue
              TempStateFlags := TempData[1 + sSdoData.ActPortSelection*sizeof(t_StatusFlags)]$t_StatusFlags;

              sSdoData.eAsySSW   := t_AsySSW::_Wait4Operate; // wait until fault or operating
            else
              // unexpected answer data
              sSdoData.eAsySSW := _AsyError;
              sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspData;
              LogError("@0515 (SdiasSDCIMaster::AsySSW) Unexpected data in answer from µC: wrong function ID or port number (_ActivatePdOut)");
              return;
            end_if;
          else
            // invalid length of answer data
            sSdoData.eAsySSW := _AsyError;
            sSdoData.AsyErrorCode := t_SDCIRetCode::SDCI_MicroCtrl_UnexpectedRspLength;
            LogError("@0516 (SdiasSDCIMaster::AsySSW) Invalid data length in answer from µC (_ActivatePdOut)");
            return;
          end_if;            

      //***************************************************************************************************
      end_case;

  //**********************************************************************************************************************************************************
    t_AsySSW::_Wait4Operate:
      // if operating or fault
      if ((CyclicInfoTotal.FlagsRdy2OpAndOperating SHR (4+sSdoData.ActPortSelection) AND 1) = TRUE) | 
         ((CyclicInfoTotal.FaultFlags$UINT SHR (sSdoData.ActPortSelection * 4)) AND 16#F) then

        // show class state
        sSdoData.eAsySSW   := t_AsySSW::_UpdateClassState;
      end_if;

  //**********************************************************************************************************************************************************
    t_AsySSW::_UpdateClassState:
      // if it's a reconnect and the device is not available, we're only here because we wanted to deactivate the port
      if (sSdoData.AsyCmdType = Reconnect) & (aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable = FALSE) then
        // the object already shows the correct state
      else
        // in all other cases, show the device state at the object

        // save target mode to current mode
        aPortInfo[sSdoData.ActPortSelection].ActPortMode := sSdoData.TargetMode;

        // if there is an object to update
        if aPortInfo[sSdoData.ActPortSelection].pThis then

          // set the command
          MyPara.uiCmd    := CMD_SIOL_DEVICE_INFO_UPDATE;

          // if it's SDCI
          if (aPortInfo[sSdoData.ActPortSelection].ActPortMode = _SDCI) then
            
            // if there is an IODD file
            if aPortInfo[sSdoData.ActPortSelection].pCfgTable then
            
              // class state
              if (aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us | aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us) & aPortInfo[sSdoData.ActPortSelection].VendorID & aPortInfo[sSdoData.ActPortSelection].DeviceID then

                // device available => check if it's the right one
                if (aPortInfo[sSdoData.ActPortSelection].VendorID = aPortInfo[sSdoData.ActPortSelection].pCfgTable^.VendorID) & (aPortInfo[sSdoData.ActPortSelection].DeviceID = aPortInfo[sSdoData.ActPortSelection].pCfgTable^.DeviceID) then
                  // we're good here
                  MyPara.aPara[0] := _ClassOk$DINT;
                  aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := TRUE;
                else
                  // wrong device
                  MyPara.aPara[0] := _WrongHardware$DINT;
                  
                  // with this it doesn't get enabled when the fixed mode is set on all ports (doesn't make sense if it's the wrong module)
                  aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := FALSE;
                end_if;          
              else
                // device not available
                MyPara.aPara[0] := _NoHardware$DINT;
                
                aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := FALSE;
              end_if;
            else
              // no IODD file => any device is ok if one of the Device Infos is available
              if aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us | aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us | aPortInfo[sSdoData.ActPortSelection].VendorID | aPortInfo[sSdoData.ActPortSelection].DeviceID then
                // we're good here
                MyPara.aPara[0] := _ClassOk$DINT;
                aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := TRUE;
              else
                // no device infos available
                MyPara.aPara[0] := _NoHardware$DINT;
                
                aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := FALSE;
              end_if;
            end_if;

            // vendor ID
            MyPara.aPara[1] := aPortInfo[sSdoData.ActPortSelection].VendorID;

            // device ID
            MyPara.aPara[2] := aPortInfo[sSdoData.ActPortSelection].DeviceID$DINT;

            // minimum cycle time
            // check if a user override is active
            if aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us then
              MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us$DINT;
            else
              MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us$DINT;
            end_if;

            // actual port mode
            MyPara.aPara[4] := t_SDCIPortMode::_SDCI;

            if aPortInfo[sSdoData.ActPortSelection].Required & (MyPara.aPara[0] <> _NotInitialized$DINT) then
              // show required error on SDCI device
              MyPara.aPara[0] := _RequiredError$DINT;
              aPortInfo[sSdoData.ActPortSelection].pThis^.NewInst(#MyPara, #MyResult);
              
              SetRequiredError();
            else
              aPortInfo[sSdoData.ActPortSelection].pThis^.NewInst(#MyPara, #MyResult);
            end_if;

          else
            // it's always ok here
            MyPara.aPara[0] := _ClassOk$DINT;
            aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := TRUE;

            // vendor ID
            MyPara.aPara[1] := aPortInfo[sSdoData.ActPortSelection].VendorID;

            // device ID
            MyPara.aPara[2] := aPortInfo[sSdoData.ActPortSelection].DeviceID$DINT;

            // minimum cycle time
            // check if a user override is active
            if aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us then
              MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us$DINT;
            else
              MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us$DINT;
            end_if;

            // actual port mode is already valid here (no further changes on the setting of this port)
            MyPara.aPara[4] := aPortInfo[sSdoData.ActPortSelection].ActPortMode$DINT;

            aPortInfo[sSdoData.ActPortSelection].pThis^.NewInst(#MyPara, #MyResult);         
          end_if;
        end_if;      
      end_if;    

      if sSdoData.AsyCmdType = DelayedEnable then
        // remove the bit from the current port from the ToDo-list and go to the next port
        DelayedEnablePorts := DelayedEnablePorts SHR 1;
        sSdoData.ActPortSelection += 1;

        // check if there are more modules to enable
        sSdoData.eAsySSW  := t_AsySSW::_StartDelayedEnable;
      else
        //last reconnect of one port
        sAutoConnectVars.udLastReconnectTry := ops.tAbsolute;
        // we're finished
        sSdoData.eAsySSW := t_AsySSW::_Finished;
      end_if;
      
  //**********************************************************************************************************************************************************
  t_AsySSW::_Finished:
      sSdoData.eAsySSW  := t_AsySSW::_Idle;
      sSdoData.AsyState := t_SDCIRetCode::SDCI_Ready_Ok;
      
      // Handle Asy Callback 
      if sSdoData.pCallBackThis & sSdoData.pCallBackFun then
        HandleSDOCallback();
      end_if;
      
      // Unlock SDO Channel
      sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);
  
  //**********************************************************************************************************************************************************
    t_AsySSW::_AsyError:
      sSdoData.eAsySSW  := t_AsySSW::_Idle;

      // use the stored error code
      sSdoData.AsyState := sSdoData.AsyErrorCode;
      
      // Handle Asy Callback 
      if sSdoData.pCallBackThis & sSdoData.pCallBackFun then                  
        HandleSDOCallback();
      end_if;
      
      // Unlock SDO Channel
      sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);

  //**********************************************************************************************************************************************************
  end_case;

#ifdef SIOL_ENABLE_DEBUG_LOGGING
  if sSdoData.eAsySSW <> OldAsyStep then
    AsyStepTimes[OldAsyStep$DINT] := ops.tAbsolute;
    OldAsyStep := sSdoData.eAsySSW;
  end_if;
#pragma message("RamAnd 31.01.2017 10:41 \ testweise die Zeit der einzelnen Steps messen")
#endif

END_FUNCTION


FUNCTION SdiasSDCIMaster::ChangeModeIsPossible
	VAR_INPUT
		TargetPort 	: USINT;
		TargetMode 	: SdiasSDCIMaster::t_SDCIPortMode;
	END_VAR
	VAR_OUTPUT
		ChangeIsPossible 	: BOOL;
	END_VAR
  
  if (TargetMode = _DigitalInput) & (aPortInfo[TargetPort].PdoMapping.ReadDataLength = 0) then
    // cannot change to digital input mode if there is no possibility to transfer the input value
    ChangeIsPossible := FALSE;  
  elsif (TargetMode = _DigitalOutput) & (aPortInfo[TargetPort].PdoMapping.WriteDataLength = 0) then
    // cannot change to digital output mode if there is no possibility to transfer the output value
    ChangeIsPossible := FALSE;  
  else
    ChangeIsPossible := TRUE;  
  end_if;

END_FUNCTION


FUNCTION SdiasSDCIMaster::InitTheModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TempData            : ARRAY [0..SIOL_MAX_SDO_DATA_SIZE-1] OF USINT;
    TempDataLen         : USINT;
    TempFlags           : t_ControlFlags;
    TempStateFlags      : t_StatusFlags;
    i                   : DINT;
  	MyPara              : CmdStruct;
    MyResult            : results;
    TempCycleTime       : UINT;
    SDCIPortAvailable   : BOOL;
    DigStartUpAvailable : BOOL;
  END_VAR

  // if the returncode isn't changed to ERROR or READY, we return busy
  eModuleInitState := BUSY;

  case sSdoData.eInitSSW of
//**********************************************************************************************************************************************************
  	t_InitSSW::_InitVariables:

      // reset asy state machine variables
      sSdoData.AsyState         := t_SDCIRetCode::SDCI_Ready_Ok;
      sSdoData.eAsySSW          := _Idle;
      
      // prepare initialisation
      sSdoData.ActPortSelection := 0;
      sSdoData.eResponseState   := t_ReponseState::_ReadData;
      sSdoData.eInitSSW         := t_InitSSW::_GetFwInfo;
            
      //get value for waittime between reconnects
      WaitTimeReconnect := WaitTimeReconnect.Read();
      if WaitTimeReconnect > SIOL_MINIMUM_WAIT4RECONNECT_TIME*2 then
        WaitTimeReconnect := SIOL_MINIMUM_WAIT4RECONNECT_TIME*2;
      end_if;              
      
//**********************************************************************************************************************************************************
    t_InitSSW::_GetFwInfo:

      case sSdoData.eResponseState of
        //***************************************************************************************************
          t_ReponseState::_ReadData:// we enter this step to start the read access

            sSdoData.ActDataSize       := sizeof(t_FirmwareInfo);
            sSdoData.pActData          := #FwInfo;

            StartReadSDO(hOffset:=SIOL_OFFSET_INFO_FOR_PLC, usLength:=sSdoData.ActDataSize, eCommand:=SDIAS_SDO_CMD_MEM_READ);
            sSdoData.TimeoutStart   := ops.tAbsolute;
            sSdoData.eResponseState := t_ReponseState::_Wait4ReceiveData;

        //***************************************************************************************************
          t_ReponseState::_Wait4ReceiveData:// we wait for the read data
            if (ops.tAbsolute - sSdoData.TimeoutStart) > SIOL_SDO_TIMEOUT then
              LogError("@0517 (SdiasSDCIMaster::InitTheModule) Timeout at reading firmware info from module");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;

        //***************************************************************************************************
          t_ReponseState::_GotReceiveData:// we enter this step, when we received the answer with the data
            // receivedata in the right place => continue with the next step
            
            // show the version at the server if the crc is correct
            if (FwInfo.LengthOfData = 0) | (CheckSum_16(pData:=#FwInfo.Data.Version, uiDataLength:=FwInfo.LengthOfData, uiCRCStart:=16#FFFF) <> FwInfo.CRC) then
              if FwInfo.LengthOfData = 0 then
                LogError("@0518 (SdiasSDCIMaster::InitTheModule) No firmware available!");
                sSdoData.eInitSSW := _Error;
                return;
              else
                LogError("@0519 (SdiasSDCIMaster::InitTheModule) Incorrect checksum of info from µC detected!");
              end_if;
            end_if;
            
            FirmwareVersion := FwInfo.Data.Version;
            
            sSdoData.eResponseState   := t_ReponseState::_ReadData;
            sSdoData.eInitSSW         := t_InitSSW::_GetActMessageCnt;
            
        //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
    t_InitSSW::_GetActMessageCnt:
      
      case sSdoData.eResponseState of
          
        //***************************************************************************************************
          t_ReponseState::_ReadData:// we enter this step to start the read access

            sSdoData.ActDataSize       := sizeof(t_ServiceDataArea.wo_MessageCnt);
            sSdoData.pActData          := #sSdoData.SdoWriteData.wo_MessageCnt;

            StartReadSDO(hOffset:=SIOL_OFFSET_SERVICE_DATA_AREA + t_ServiceDataArea.wo_MessageCnt, usLength:=sSdoData.ActDataSize, eCommand:=SDIAS_SDO_CMD_MEM_READ);
            sSdoData.TimeoutStart   := ops.tAbsolute;
            sSdoData.eResponseState := t_ReponseState::_Wait4ReceiveData;

        //***************************************************************************************************
          t_ReponseState::_Wait4ReceiveData:// we wait for the read data
            if (ops.tAbsolute - sSdoData.TimeoutStart) > SIOL_SDO_TIMEOUT then
              LogError("@051A (SdiasSDCIMaster::InitTheModule) Timeout at reading actual message counter from module");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;

        //***************************************************************************************************
          t_ReponseState::_GotReceiveData:// we enter this step, when we received the answer with the data
            // receivedata in the right place => continue with the next step
            
            // take the read counter as first write counter (continue counting after reset/run of the PLC)
            sSdoData.SdoReadData.ro_MessageCnt := sSdoData.SdoWriteData.wo_MessageCnt;
            
            sSdoData.eResponseState   := t_ReponseState::_PrepareSendData;
            sSdoData.eInitSSW         := t_InitSSW::_Set24VSupplyOn;

        //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
    t_InitSSW::_Set24VSupplyOn:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          
          // prepare the sdo buffer
          TempData[0]       := E_FNCID_SWITCHON; // function ID
          TempData[1]       := sSdoData.ActPortSelection; // port number
          
          TempDataLen := 2;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 2 then
            // check response data
            if (TempData[0] = (E_FNCID_SWITCHON)$USINT) then // check function ID
              if (TempData[1] = 0) then                                     // check status code seperately
                // reset response state machine
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

                // already the last port?
                if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
                  // finished, continue with next step
                  sSdoData.ActPortSelection := 0;
                  
                  sSdoData.eInitSSW := t_InitSSW::_DisablePorts;
                else
                  // repeat the step with the next port
                  sSdoData.ActPortSelection += 1;
                end_if;
              else
                // error at return code
                LogError("@051B (SdiasSDCIMaster::InitTheModule) Error at status code in answer from µC (_Set24VSupplyOn)");
                sSdoData.eInitSSW := _Error;
                return;
              end_if;
            else
              // unexpected answer data
              LogError("@051C (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID  (_Set24VSupplyOn)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@051D (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC  (_Set24VSupplyOn)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
  	t_InitSSW::_DisablePorts:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          
          // prepare the sdo buffer
          TempData[0]       := E_FNCID_SETPORTCNFPAR; // function ID
          TempData[1]       := sSdoData.ActPortSelection; // port number
          TempData[2]       := t_OpModeStates::E_OPMODE_INACTIVE; // operating mode
          TempData[3]       := t_PortCycle::E_PORTCYCLE_FREERN; // port cycle
          TempData[4]$UINT  := 0; // cycle time
          TempData[6]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataLength$USINT; // PDConfig LenIn
          TempData[7]       := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataStartAddress - SIOL_OFFSET_RT_READ_DATA)$USINT; // PdConfig PosIn
          TempData[8]       := 0; // PdConfig SrcOffsetIn
          TempData[9]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength$USINT; // PDConfig LenOut
          TempData[10]      := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataStartAddress - SIOL_OFFSET_RT_WRITE_DATA)$USINT; // PdConfig PosOut
          TempData[11]      := 0; // PdConfig SrcOffsetOut
          TempData[12]$UINT := 0; // VendorID
          TempData[14]$UDINT:= 0; // DeviceID
//          _strcpy(dest:=#TempData[18], src:="0000000000000000"); // serial number as string
          _memset(dest:=#TempData[18], usByte:=0, cntr:=16); // serial number as string
          TempData[34]      := 0; // Inspection level
          TempData[35]      := 0; // DS activation state
          TempData[36]      := 0; // DS download enable
          TempData[37]      := 0; // DS upload enable
          TempData[38]      := 16#11; // revision ID (v1.1 should work with both device types, v1.0 doesn't work with v1.1 devices)

          TempDataLen := 39;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;          

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 3 then
            // check response data
            if (TempData[0] = (E_FNCID_SETPORTCNFPAR)$USINT) & // check function ID
               (TempData[1] = sSdoData.ActPortSelection)              // check port number
               then
               
              if (TempData[2] = 0) then // check status code seperately
                // reset response state machine
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

                // already the last port?
                if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
                  // finished, continue with next step
                  sSdoData.ActPortSelection := 0;
                  sSdoData.eInitSSW := t_InitSSW::_SwitchToDisableMode;
                else
                  // repeat the steps with the next port
                  sSdoData.ActPortSelection += 1;
                end_if;
              else
                // error at return code
                LogError("@0503 (SdiasSDCIMaster::InitTheModule) Error at status code in answer from µC (_DisablePorts)");
                sSdoData.eInitSSW := _Error;
                return;
              end_if;
            else
              // unexpected answer data
              LogError("@0504 (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID or port number (_DisablePorts)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@0505 (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC (_DisablePorts)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
      end_case;


//**********************************************************************************************************************************************************
  	t_InitSSW::_SwitchToDisableMode,
    t_InitSSW::_Wait4DisableMode:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          if sSdoData.eInitSSW = t_InitSSW::_SwitchToDisableMode then
  //          TempFlags.Start2Operate := TRUE; // only makes sense if the port is active in SDCI mode
            TempFlags.OperatingMode := TRUE;
          end_if;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID
          for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
            // activate the disabled mode for all ports
            TempData[1 + i*sizeof(UINT)]$UINT := TempFlags;
          end_for;

          if TotalMappingWriteSize then
            _memset(dest:=#TempData[9], usByte:=0, cntr:=TotalMappingWriteSize);          
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID
              // reset response state machine
              sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

              // if the operating flags are cleared we can continue
              for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
                TempStateFlags := TempData[1 + i*sizeof(t_StatusFlags)]$t_StatusFlags;

                // if any operating bit is still set => go to wait for disabled
                if TempStateFlags.Operating = TRUE then

                  // set the time mark the first time we send the command to not wait unnecessary
                  if sSdoData.eInitSSW = t_InitSSW::_SwitchToDisableMode then
                    Wait4DeviceDisableStartTime := ops.tAbsolute;
                  end_if;
                  
                  sSdoData.eInitSSW   := t_InitSSW::_Wait4DisableMode;

                  return;
                end_if;
              end_for;                

              // finished, continue with next step
              sSdoData.eInitSSW   := t_InitSSW::_ConfigurePorts;
            else
              // unexpected answer data
              LogError("@0506 (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID or port number (_SwitchToDisableMode)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@0507 (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC (_SwitchToDisableMode)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
      end_case;
      
//**********************************************************************************************************************************************************
  	t_InitSSW::_ConfigurePorts:
      // if it's a SDCI port, we must wait the time (according to the specification), because some sensors might need it
      if (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI) & ((ops.tAbsolute - Wait4DeviceDisableStartTime) < aPortInfo[sSdoData.ActPortSelection].udModeChangeTime) then
        return;
      end_if;

      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          
          // prepare the sdo buffer
          TempData[0]       := E_FNCID_SETPORTCNFPAR; // function ID
          TempData[1]       := sSdoData.ActPortSelection; // port number
          case aPortInfo[sSdoData.ActPortSelection].CfgPortMode of
          //***************************************************************************************************
            _Inactive:
              TempData[2]       := t_OpModeStates::E_OPMODE_INACTIVE; // operating mode

          //***************************************************************************************************
            _DigitalInput:
              TempData[2]       := t_OpModeStates::E_OPMODE_DI; // operating mode           

          //***************************************************************************************************
            _DigitalOutput:
              TempData[2]       := t_OpModeStates::E_OPMODE_DO; // operating mode
            
          //***************************************************************************************************
            _SDCI:
              TempData[2]       := t_OpModeStates::E_OPMODE_SCANMODE; // operating mode

          //***************************************************************************************************
          end_case;

          TempData[3]       := t_PortCycle::E_PORTCYCLE_FREERN; // port cycle
          TempData[4]$UINT  := 0; // cycle time
          TempData[6]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataLength$USINT; // PDConfig LenIn
          TempData[7]       := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataStartAddress - SIOL_OFFSET_RT_READ_DATA)$USINT; // PdConfig PosIn
          TempData[8]       := 0; // PdConfig SrcOffsetIn
          TempData[9]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength$USINT; // PDConfig LenOut
          TempData[10]      := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataStartAddress - SIOL_OFFSET_RT_WRITE_DATA)$USINT; // PdConfig PosOut
          TempData[11]      := 0; // PdConfig SrcOffsetOut
          TempData[12]$UINT := 0; // VendorID
          TempData[14]$UDINT:= 0; // DeviceID
//          _strcpy(dest:=#TempData[18], src:="0000000000000000"); // serial number as string
          _memset(dest:=#TempData[18], usByte:=0, cntr:=16); // serial number as string
          TempData[34]      := 0; // Inspection level (0 = don't care about vendor or device id)
          TempData[35]      := 0; // DS activation state
          TempData[36]      := 0; // DS download enable
          TempData[37]      := 0; // DS upload enable
          TempData[38]      := 16#11; // revision ID (v1.1 should work with both device types, v1.0 doesn't work with v1.1 devices)

          TempDataLen := 39;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 3 then
            // check response data
            if (TempData[0] = (E_FNCID_SETPORTCNFPAR)$USINT) & // check function ID
               (TempData[1] = sSdoData.ActPortSelection)              // check port number
               then
               
              if (TempData[2] = 0) then // check status code seperately
                // reset response state machine
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

                // already the last port?
                if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
                  // finished, continue with next step
                  sSdoData.ActPortSelection := 0;
                  sSdoData.eInitSSW := t_InitSSW::_EnableMasterServices;
                else
                  // repeat the steps with the next port
                  sSdoData.ActPortSelection += 1;
                end_if;
              else
                // error at return code
                LogError("@0508 (SdiasSDCIMaster::InitTheModule) Error at status code in answer from µC (_ConfigurePorts)");
                sSdoData.eInitSSW := _Error;
                return;
              end_if;
            else
              // unexpected answer data
              LogError("@0509 (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID or port number (_ConfigurePorts)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@050B (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC  (_ConfigurePorts)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
  	t_InitSSW::_EnableMasterServices:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          TempFlags.OdStart       := TRUE;
          TempFlags.DuStart       := TRUE;
          TempFlags.PdStart       := TRUE;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID
          for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
            // activate the master services for all ports
            TempData[1 + i*sizeof(UINT)]$UINT := TempFlags;
          end_for;
          
          if TotalMappingWriteSize then
            _memset(dest:=#TempData[9], usByte:=0, cntr:=TotalMappingWriteSize);          
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID
              // reset response state machine
              sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

              for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
                if aPortInfo[i].pThis then
                  aPortInfo[i].PhysicallyAvailable := TRUE;
                else
                  aPortInfo[i].PhysicallyAvailable := FALSE;
                end_if;
              end_for;

              // continue with next step
              sSdoData.eInitSSW := t_InitSSW::_SwitchToNewMode;
            else
              // unexpected answer data
              LogError("@051F (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID or port number (_EnableMasterServices)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@0520 (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC (_EnableMasterServices)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************

  	t_InitSSW::_SwitchToNewMode,
    t_InitSSW::_Wait4NewMode:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          if sSdoData.eInitSSW = t_InitSSW::_SwitchToNewMode then
            TempFlags.Start2Operate := TRUE;
            TempFlags.OperatingMode := TRUE;
          end_if;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID
          for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
          
            // activate the disabled mode for all ports
            TempData[1 + i*sizeof(UINT)]$UINT := TempFlags;

          end_for;

          if TotalMappingWriteSize then
            _memset(dest:=#TempData[9], usByte:=0, cntr:=TotalMappingWriteSize);          
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
          
            // reset response state machine
            sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
            
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID

              // if the operating flags are cleared we can continue
              for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
                TempStateFlags := TempData[1 + i*sizeof(t_StatusFlags)]$t_StatusFlags;
                
                // if any operating bit is not set and there is also no fault => go to wait again
                if (aPortInfo[i].CfgPortMode = _SDCI) & (TempStateFlags.Operating = FALSE) &
                   ((TempStateFlags AND 16#F000) = 0) then // no fault
                  sSdoData.eInitSSW   := t_InitSSW::_Wait4NewMode; // wait until fault or operating
                  return;
                end_if;
              end_for;                

              // finished, continue with next step
              sSdoData.eInitSSW   := t_InitSSW::_GetDeviceInfos;
            else
              // unexpected answer data
              LogError("@050C (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID or port number (_SwitchToNewMode)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@050D (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC (_SwitchToNewMode)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;            

      //***************************************************************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    t_InitSSW::_GetDeviceInfos:

      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          if aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI then
          
            // read direct parameter page 1 (device info)
            InitializeSdoWriteData(Usage:=_ReadParaData, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=sSdoData.ActPortSelection, LengthOfData:=0, pData:=NIL);
            
            sSdoData.eResponseState := t_ReponseState::_SendData;

          else
            // already the last port?
            if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
              // finished, continue with next step
              sSdoData.ActPortSelection := 0;

              sSdoData.eInitSSW := t_InitSSW::_UpdateDeviceObjInfo;
            else
              // repeat the step with the next port
              sSdoData.ActPortSelection += 1;
            end_if;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          // reset response state machine
          sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if (sSdoData.SdoReadData.ro_RetCode = _ServiceNotAvailable) | (TempDataLen = 0) then
            // maybe the port is not connected => select next port (after this if block)
            aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable := FALSE;
          
          else
#ifdef SIOL_ENABLE_DEBUG_LOGGING
if TempData$t_DeviceInfoAnswer.ProcessDataIn <> aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataBitLength then
  LogValue("@DBG (SdiasSDCIMaster::InitTheModule) Info: Configured bit size of read PDO 0x{0} does not match the expected size from the module 0x{1}. SDCI Port 0x{2}", udValue:=aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataBitLength, udValue2:=TempData$t_DeviceInfoAnswer.ProcessDataIn, udValue3:=sSdoData.ActPortSelection);
end_if;
if TempData$t_DeviceInfoAnswer.ProcessDataOut <> aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataBitLength then
  LogValue("@DBG (SdiasSDCIMaster::InitTheModule) Info: Configured bit size of write PDO 0x{0} does not match the expected size from the module 0x{1}. SDCI Port 0x{2}", udValue:=aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataBitLength, udValue2:=TempData$t_DeviceInfoAnswer.ProcessDataOut, udValue3:=sSdoData.ActPortSelection);
end_if;
#endif

            // MIN CYCLE TIME
            case TempData$t_DeviceInfoAnswer.MinCycleTime SHR 6 of
              0: // base of  100µs (Multiplier x time base)
                aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us :=  100 * (TempData$t_DeviceInfoAnswer.MinCycleTime AND 16#3F);

              1: // base of  400µs (Multiplier x time base) +  6400µs
                aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us :=  400 * (TempData$t_DeviceInfoAnswer.MinCycleTime AND 16#3F) +  6400;

              2: // base of 1600µs (Multiplier x time base) + 32000µs
                aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us := 1600 * (TempData$t_DeviceInfoAnswer.MinCycleTime AND 16#3F) + 32000;

              3: // this is reserved for future use
                LogError("@050E (SdiasSDCIMaster::InitTheModule) Invalid time base 3 received at minimum cycle time of device (_GetDeviceInfos)");
                sSdoData.eInitSSW := _Error;
                return;
            end_case;
            
            // VENDOR ID
            aPortInfo[sSdoData.ActPortSelection].VendorID := TempData$t_DeviceInfoAnswer.VendorIdLsb OR (TempData$t_DeviceInfoAnswer.VendorIdMsb SHL 8);
            
            // DEVICE ID
            aPortInfo[sSdoData.ActPortSelection].DeviceID := TempData$t_DeviceInfoAnswer.DeviceIdLsb OR (TempData$t_DeviceInfoAnswer.DeviceIdMiddleByte SHL 8) OR (TempData$t_DeviceInfoAnswer.DeviceIdMsb SHL 16);
            
            // Revision ID
            aPortInfo[sSdoData.ActPortSelection].RevisionID := TempData$t_DeviceInfoAnswer.RevisionID;
            
            aPortInfo[sSdoData.ActPortSelection].aDeviceInfo$t_DeviceInfoAnswer := TempData$t_DeviceInfoAnswer;
          end_if;
          
          // already the last port?
          if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
            // finished, continue with next step
            sSdoData.ActPortSelection := 0;

            sSdoData.eInitSSW := t_InitSSW::_UpdateDeviceObjInfo;
          else
            // repeat the step with the next port
            sSdoData.ActPortSelection += 1;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
    t_InitSSW::_UpdateDeviceObjInfo:

      // if the SDIAS bus is too fast for the SDCI master
      if (udBusTime/1000) < SIOL_MINIMUM_MASTER_CYCLE_TIME then
        // go to the lowest possible value that is a multiple of the bus time
        if SIOL_MINIMUM_MASTER_CYCLE_TIME MOD (udBusTime/1000) then
          // if there is a rest => add 1 to the multiplier
          CycleTime := (udBusTime / 1000)$UINT * ((SIOL_MINIMUM_MASTER_CYCLE_TIME / (udBusTime / 1000)$UINT) + 1);
        else
          // otherwise use the bustime directly to get to the minimum master cycle time
//          CycleTime := (udBusTime / 1000)$UINT * ((SIOL_MINIMUM_MASTER_CYCLE_TIME / (udBusTime / 1000)$UINT)    );
          CycleTime := SIOL_MINIMUM_MASTER_CYCLE_TIME;
        end_if;
      else
        // otherwise take the SDIAS bus time
        CycleTime := (udBusTime / 1000)$UINT;
      end_if;

      SDCIPortAvailable := FALSE;

      // the same command for all objects
      MyPara.uiCmd    := CMD_SIOL_DEVICE_INFO_UPDATE;

      // show the info at the objects and also set the class state server
      for i := 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
        // reset act parameter number for next init step
        aPortInfo[i].ActParaNo := 0;
        
        // if there is an object to update
        if aPortInfo[i].pThis then
        
          // if it's SDCI
          if (aPortInfo[i].CfgPortMode = _SDCI) then

            SDCIPortAvailable := TRUE;
            
            // if there is an IODD file
            if aPortInfo[i].pCfgTable then
              // class state
              if (aPortInfo[i].MinCycleTime_us | aPortInfo[i].OverrideMinCycleTime_us) & aPortInfo[i].VendorID & aPortInfo[i].DeviceID then

                // device available => check if it's the right one
                if (aPortInfo[i].VendorID = aPortInfo[i].pCfgTable^.VendorID) & (aPortInfo[i].DeviceID = aPortInfo[i].pCfgTable^.DeviceID) then
                  // show that we are still initializing
                  MyPara.aPara[0] := _NotInitialized$DINT;
                else
                  // wrong device
                  MyPara.aPara[0] := _WrongHardware$DINT;
                  
                  // with this it doesn't get enabled when the fixed mode is set on all ports (doesn't make sense if it's the wrong module)
                  aPortInfo[i].PhysicallyAvailable := FALSE;
                end_if;          
              else
                // device not available
                MyPara.aPara[0] := _NoHardware$DINT;
                
                aPortInfo[i].PhysicallyAvailable := FALSE;
              end_if;
            else
              // no IODD file => any device is ok if one of the Device Infos is available
              if aPortInfo[i].MinCycleTime_us | aPortInfo[i].OverrideMinCycleTime_us | aPortInfo[i].VendorID | aPortInfo[i].DeviceID then
                // show that we are still initializing
                MyPara.aPara[0] := _NotInitialized$DINT;
              else
                // no device infos available
                MyPara.aPara[0] := _NoHardware$DINT;
                
                aPortInfo[i].PhysicallyAvailable := FALSE;
              end_if;
            end_if;

            // vendor ID
            MyPara.aPara[1] := aPortInfo[i].VendorID;

            // device ID
            MyPara.aPara[2] := aPortInfo[i].DeviceID$DINT;

            // minimum cycle time
            // check if a user override is active
            if aPortInfo[i].OverrideMinCycleTime_us then
              MyPara.aPara[3] := aPortInfo[i].OverrideMinCycleTime_us$DINT;
            else
              MyPara.aPara[3] := aPortInfo[i].MinCycleTime_us$DINT;
            end_if;

            // actual port mode (still Inactive during initialisation)
            MyPara.aPara[4] := t_SDCIPortMode::_Inactive;

            if aPortInfo[i].Required & (MyPara.aPara[0] <> _NotInitialized$DINT) then
              // show required error on SDCI device
              MyPara.aPara[0] := _RequiredError$DINT;
              aPortInfo[i].pThis^.NewInst(#MyPara, #MyResult);
              
              SetRequiredError();
            else
              aPortInfo[i].pThis^.NewInst(#MyPara, #MyResult);
            end_if;

          elsif (aPortInfo[i].CfgPortMode = _DigitalInput) | (aPortInfo[i].CfgPortMode = _DigitalOutput) then
            // it's always ok here
            MyPara.aPara[0] := _ClassOk$DINT;

            // we're in the desired mode
            aPortInfo[i].ActPortMode := aPortInfo[i].CfgPortMode;

            // the extra info does not exist here
            MyPara.aPara[1] := 0;
            MyPara.aPara[2] := 0;
            MyPara.aPara[3] := 0;

            // actual port mode is already valid here (no further changes on the setting of this port)
            MyPara.aPara[4] := aPortInfo[i].ActPortMode$DINT;

            aPortInfo[i].pThis^.NewInst(#MyPara, #MyResult);         
          end_if;
        end_if;
      end_for;
      
      if SDCIPortAvailable then
          sSdoData.eInitSSW := t_InitSSW::_CheckDownloadParameters;
        
        DownloadTimeStart := ops.tAbsolute;

        // if the first pointer is not valid, skip until we find a valid pointer
        if aPortInfo[sSdoData.ActPortSelection].pActPara = NIL then
          if SelectNextDownloadPara() = FALSE then
            // no download parameters available

            sSdoData.ActPortSelection := 0;

            // go to next step
            sSdoData.eInitSSW := t_InitSSW::_DisableSdciPorts;
            // reset response state machine
            sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
          end_if;
        end_if;
      else
        DelayedEnablePorts := 0;
        
        // no SDCI ports available => skip switching off/on and downloading parameters
        sSdoData.eInitSSW := t_InitSSW::_SetCycleTimes;
      end_if;

//**********************************************************************************************************************************************************
    t_InitSSW::_CheckDownloadParameters:

      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action

          // get the details to write the parameter
          if aPortInfo[sSdoData.ActPortSelection].pActPara then
          
            if aPortInfo[sSdoData.ActPortSelection].pActPara^.AccessType = t_ParaAccessType::wo then
              // Do not read write only parameters and write the parameter directly
              sSdoData.eInitSSW := t_InitSSW::_DownloadParameters;
            else
              // read the parameter first (to check if it already matches the desired value)
              InitializeSdoWriteData(Usage:=_ReadParaData, ParaIndex:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID$UINT, ParaSubIndex:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID$USINT, PortSelection:=sSdoData.ActPortSelection, LengthOfData:=0, pData:=NIL);
              
              sSdoData.eResponseState := t_ReponseState::_SendData;
            end_if;
            
          end_if;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          // extend the post init time by the reaction time of the µC (otherwise we would exceed the timeout of the post init if there are many parameters)
          ExtendPostInitTime(AdditionalTime:=ops.tAbsolute - sSdoData.ResponseTimeoutStart);

          // reset response state machine
          sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

          // check response data
          if (sSdoData.SdoReadData.ro_RetCode = _FwOk) then // check returncode

            // check if the value matches our init value            
            GetSdoReadData( pLength       := #TempDataLen
                          , pData         := #TempData[0]
                          , bDoEndianSwap := CheckEndianSwapNeeded( pParaInfo     := aPortInfo[sSdoData.ActPortSelection].pActPara
                                                                  , PortSelection := sSdoData.ActPortSelection) );

            // if it's a string, we add the termination 0 to the uploaded data (for the comparison), because we also have it in the table
            if aPortInfo[sSdoData.ActPortSelection].pActPara^.DataType = _Text then
              TempData[TempDataLen] := 0;
              TempDataLen += 1;
            end_if;

            if (aPortInfo[sSdoData.ActPortSelection].pActPara^.DataLength = TempDataLen) then
              if _memcmp(ptr1:=#TempData[0], ptr2:=aPortInfo[sSdoData.ActPortSelection].pActPara + sizeof(t_ConfigTablePara), cntr:=TempDataLen) = 0 then
                // value match => no download necessary
#ifdef SIOL_ENABLE_DEBUG_LOGGING
LogValue("@DBG (SdiasSDCIMaster::InitTheModule) Value and length match already, no download needed. ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
#endif  
              else

                // it's not the same value => download the parameter
                sSdoData.eInitSSW := t_InitSSW::_DownloadParameters;

#ifdef SIOL_ENABLE_DEBUG_LOGGING
LogValue("@DBG (SdiasSDCIMaster::InitTheModule) Value mismatch => download new value. ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
#endif

                // skip selecting the next parameter, because we need to send the current parameter in the downloadparameters step
                return;
              end_if;
            else
              // length mismatch
              
              // if it's a string, we send the new value
              if aPortInfo[sSdoData.ActPortSelection].pActPara^.DataType = _Text then

                // it's not the same value => download the parameter
                sSdoData.eInitSSW := t_InitSSW::_DownloadParameters;

#ifdef SIOL_ENABLE_DEBUG_LOGGING
LogValue("@DBG (SdiasSDCIMaster::InitTheModule) Length mismatch at string => download new value. ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
#endif

                // skip selecting the next parameter, because we need to send the current parameter in the downloadparameters step
                return;
              else
                LogValue("@050F (SdiasSDCIMaster::InitTheModule) Length mismatch (type is not string) => value not downloaded. ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
              end_if;
            end_if;

            if SelectNextDownloadPara() = FALSE then
              // no more download parameters available

              sSdoData.ActPortSelection := 0;
               
              // go to next step                
              sSdoData.eInitSSW := t_InitSSW::_DisableSdciPorts;
            end_if;
          else
            if (sSdoData.SdoReadData.ro_RetCode = _ApplicationError) then
              // if it's an application error, we also have an error code
              LogValue("@0510 (SdiasSDCIMaster::InitTheModule) Error at reading parameter(_CheckDownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}, ErrorCode: {2}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID, udValue3:=sSdoData.SdoReadData.aData[230]$HINT);
            else
              LogValue("@0510 (SdiasSDCIMaster::InitTheModule) Error at reading parameter(_CheckDownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);              
            end_if;
            
            // continue with the next parameter
            if SelectNextDownloadPara() = FALSE then
              // no more download parameters available

              sSdoData.ActPortSelection := 0;

              // go to next step
              sSdoData.eInitSSW := t_InitSSW::_DisableSdciPorts;
            end_if;
          end_if;

      //***************************************************************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    t_InitSSW::_DownloadParameters:
    
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action

          // get the details to write the parameter
          if aPortInfo[sSdoData.ActPortSelection].pActPara then

            // prepare everything to send the parameter
            TempDataLen := aPortInfo[sSdoData.ActPortSelection].pActPara^.DataLength;
            _memcpy(ptr1:=#TempData[0], ptr2:=aPortInfo[sSdoData.ActPortSelection].pActPara + sizeof(t_ConfigTablePara), cntr:=TempDataLen);
            
            InitializeSdoWriteData( Usage         := _WriteParaData
                                  , ParaIndex     := aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID$UINT
                                  , ParaSubIndex  := aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID$USINT
                                  , PortSelection := sSdoData.ActPortSelection
                                  , LengthOfData  := TempDataLen
                                  , pData         := #TempData[0]
                                  , pParaInfo     := aPortInfo[sSdoData.ActPortSelection].pActPara);
            
            sSdoData.eResponseState := t_ReponseState::_SendData;
          else
            sSdoData.eInitSSW := _Error;
            LogError("@0521 (SdiasSDCIMaster::InitTheModule) Conditions for parameter download not met. No valid parameter pointer!");
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          // extend the post init time by the reaction time of the µC (otherwise we would exceed the timeout of the post init if there are many parameters)
          ExtendPostInitTime(AdditionalTime:=ops.tAbsolute - sSdoData.ResponseTimeoutStart);

          // in general we go back to check the next parameter (unless there are no more parameters)
          sSdoData.eInitSSW := t_InitSSW::_CheckDownloadParameters;

          // reset response state machine
          sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

          // check response data
          if (sSdoData.SdoReadData.ro_RetCode = _FwOk) then // check returncode

#ifdef SIOL_ENABLE_DEBUG_LOGGING
LogValue("@DBG (SdiasSDCIMaster::InitTheModule) Successfully downloaded parameter (_DownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);
#endif

          elsif (sSdoData.SdoReadData.ro_RetCode = _ApplicationError) then
            // if it's an application error, we also have an error code
            LogValue("@0512 (SdiasSDCIMaster::InitTheModule) Error at writing parameter(_DownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}, ErrorCode: {2}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID, udValue3:=sSdoData.SdoReadData.aData[230]$HINT);
          else
            LogValue("@0512 (SdiasSDCIMaster::InitTheModule) Error at writing parameter(_DownloadParameters). ParameterIndex: {0}, ParameterSubIndex: {1}", udValue:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaID, udValue2:=aPortInfo[sSdoData.ActPortSelection].pActPara^.ParaSubID);              
          end_if;
          
          // select the next parameter
          if SelectNextDownloadPara() = FALSE then
            // no more download parameters available

            sSdoData.ActPortSelection := 0;

            // go to next step
            sSdoData.eInitSSW := t_InitSSW::_DisableSdciPorts;
            
          end_if;

      //***************************************************************************************************
      end_case;
      
//**********************************************************************************************************************************************************
  	t_InitSSW::_DisableSdciPorts:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          
          // only if the port is of type SDCI
          if aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI then
            // prepare the sdo buffer
            TempData[0]       := E_FNCID_SETPORTCNFPAR; // function ID
            TempData[1]       := sSdoData.ActPortSelection; // port number
            TempData[2]       := t_OpModeStates::E_OPMODE_INACTIVE; // operating mode
            TempData[3]       := t_PortCycle::E_PORTCYCLE_FREERN; // port cycle
            TempData[4]$UINT  := 0; // cycle time
            TempData[6]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataLength$USINT; // PDConfig LenIn
            TempData[7]       := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataStartAddress - SIOL_OFFSET_RT_READ_DATA)$USINT; // PdConfig PosIn
            TempData[8]       := 0; // PdConfig SrcOffsetIn
            TempData[9]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength$USINT; // PDConfig LenOut
            TempData[10]      := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataStartAddress - SIOL_OFFSET_RT_WRITE_DATA)$USINT; // PdConfig PosOut
            TempData[11]      := 0; // PdConfig SrcOffsetOut
            TempData[12]$UINT := 0; // VendorID
            TempData[14]$UDINT:= 0; // DeviceID
  //          _strcpy(dest:=#TempData[18], src:="0000000000000000"); // serial number as string
            _memset(dest:=#TempData[18], usByte:=0, cntr:=16); // serial number as string
            TempData[34]      := 0; // Inspection level
            TempData[35]      := 0; // DS activation state
            TempData[36]      := 0; // DS download enable
            TempData[37]      := 0; // DS upload enable
            TempData[38]      := 16#11; // revision ID (v1.1 should work with both device types, v1.0 doesn't work with v1.1 devices)

            TempDataLen := 39;

            InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
            
            sSdoData.eResponseState := t_ReponseState::_SendData;          
          else
            // already the last port?
            if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
              // finished, continue with next step
              sSdoData.ActPortSelection := 0;

              sSdoData.eInitSSW := t_InitSSW::_SwitchToDisableMode2;

            else
              // repeat the step with the next port
              sSdoData.ActPortSelection += 1;
            end_if;
          end_if;         

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 3 then
            // check response data
            if (TempData[0] = (E_FNCID_SETPORTCNFPAR)$USINT) & // check function ID
               (TempData[1] = sSdoData.ActPortSelection)              // check port number
               then
               
              if (TempData[2] = 0) then // check status code seperately
                // reset response state machine
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

                // already the last port?
                if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
                  // finished, continue with next step
                  sSdoData.ActPortSelection := 0;
                  sSdoData.eInitSSW := t_InitSSW::_SwitchToDisableMode2;
                else
                  // repeat the steps with the next port
                  sSdoData.ActPortSelection += 1;
                end_if;
              else
                // error at return code
                LogError("@0522 (SdiasSDCIMaster::InitTheModule) Error at status code in answer from µC (_DisableSdciPorts)");
                sSdoData.eInitSSW := _Error;
                return;
              end_if;
            else
              // unexpected answer data
              LogError("@0523 (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID or port number (_DisableSdciPorts)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@0524 (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC (_DisableSdciPorts)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;
          
          // reset response state machine
          sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
  	t_InitSSW::_SwitchToDisableMode2,
    t_InitSSW::_Wait4DisableMode2:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          if sSdoData.eInitSSW = t_InitSSW::_SwitchToDisableMode2 then
  //          TempFlags.Start2Operate := TRUE; // only makes sense if the port is active in SDCI mode
            TempFlags.OperatingMode := TRUE;

            Wait4DeviceDisableStartTime := ops.tAbsolute;
          end_if;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID
          for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
            // activate the disabled mode for all SDCI ports
            if aPortInfo[i].CfgPortMode = _SDCI then
              TempData[1 + i*sizeof(UINT)]$UINT := TempFlags;
            else
              TempData[1 + i*sizeof(UINT)]$UINT := 0;
            end_if;
          end_for;

          if TotalMappingWriteSize then
            _memset(dest:=#TempData[9], usByte:=0, cntr:=TotalMappingWriteSize);          
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID
              // reset response state machine
              sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
                            
              // if the operating flags are cleared we can continue
              for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
                TempStateFlags := TempData[1 + i*sizeof(t_StatusFlags)]$t_StatusFlags;

                // if any operating bit of the SDCI ports is still set and we did not exceed the timeout => go to wait for disabled
                if (aPortInfo[i].CfgPortMode = _SDCI) & (TempStateFlags.Operating = TRUE) &
                   ((ops.tAbsolute - Wait4DeviceDisableStartTime) < aPortInfo[sSdoData.ActPortSelection].udModeChangeTime) then
                   
                  sSdoData.eInitSSW   := t_InitSSW::_Wait4DisableMode2;
                  return;
                end_if;
              end_for;
              
              // finished, continue with next step
              sSdoData.eInitSSW   := t_InitSSW::_Configure2StartUpMode;

            else
              // unexpected answer data
              LogError("@0525 (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID or port number (_SwitchToDisableMode2)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@0526 (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC (_SwitchToDisableMode2)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
  	t_InitSSW::_Configure2StartUpMode:
      // if it's an SDCI port and physically available, we must wait the time (according to the specification), because some sensors might need it
      if (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI) & 
          aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable  & 
         ((ops.tAbsolute - Wait4DeviceDisableStartTime) < aPortInfo[sSdoData.ActPortSelection].udModeChangeTime) then
        return;
      end_if;

      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          
          // only if the port is of type SDCI and the device is physically available
          if (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI) & aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable &
             (aPortInfo[sSdoData.ActPortSelection].StartUpMode <> _Inactive) then
             
            // prepare the sdo buffer
            TempData[0]       := E_FNCID_SETPORTCNFPAR; // function ID
            TempData[1]       := sSdoData.ActPortSelection; // port number

            case aPortInfo[sSdoData.ActPortSelection].StartUpMode of
            //***************************************************************************************************
              _DigitalInput:
                TempData[2]       := t_OpModeStates::E_OPMODE_DI; // operating mode           

            //***************************************************************************************************
              _DigitalOutput:
                TempData[2]       := t_OpModeStates::E_OPMODE_DO; // operating mode
              
            //***************************************************************************************************
              _SDCI:
                TempData[2]       := t_OpModeStates::E_OPMODE_FIXEDMODE; // operating mode
                
            //***************************************************************************************************
            end_case;

            TempData[3]       := t_PortCycle::E_PORTCYCLE_FIXVAL; // port cycle

            // check if a user override is active
            if aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us then
              // recalculate cycle time from [µs] to [100µs]
              TempCycleTime     := to_uint(aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us / 100);
            else
              // recalculate cycle time from [µs] to [100µs]
              TempCycleTime     := to_uint(aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us / 100);
            end_if;

            // make endian swap
            TempCycleTime     := ((TempCycleTime SHR 8) AND 16#FF) OR ((TempCycleTime SHL 8) AND 16#FF00);

            TempData[4]$UINT  := TempCycleTime; // cycle time
            TempData[6]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataLength$USINT; // PDConfig LenIn
            TempData[7]       := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.ReadDataStartAddress - SIOL_OFFSET_RT_READ_DATA)$USINT; // PdConfig PosIn
            TempData[8]       := 0; // PdConfig SrcOffsetIn
            TempData[9]       :=  aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataLength$USINT; // PDConfig LenOut
            TempData[10]      := (aPortInfo[sSdoData.ActPortSelection].PdoMapping.WriteDataStartAddress - SIOL_OFFSET_RT_WRITE_DATA)$USINT; // PdConfig PosOut
            TempData[11]      := 0; // PdConfig SrcOffsetOut
            TempData[12]      := (aPortInfo[sSdoData.ActPortSelection].VendorID SHR 8)$USINT; // VendorID
            TempData[13]      :=  aPortInfo[sSdoData.ActPortSelection].VendorID$USINT; // VendorID
            TempData[14]      := (aPortInfo[sSdoData.ActPortSelection].DeviceID SHR 24)$USINT; // DeviceID
            TempData[15]      := (aPortInfo[sSdoData.ActPortSelection].DeviceID SHR 16)$USINT; // DeviceID
            TempData[16]      := (aPortInfo[sSdoData.ActPortSelection].DeviceID SHR  8)$USINT; // DeviceID
            TempData[17]      := (aPortInfo[sSdoData.ActPortSelection].DeviceID       )$USINT; // DeviceID
  //          _strcpy(dest:=#TempData[18], src:="0000000000000000"); // serial number as string
            _memset(dest:=#TempData[18], usByte:=0, cntr:=16); // serial number as string
            TempData[34]      := 1; // Inspection level (1 = device and vendor id have to match)
            TempData[35]      := 0; // DS activation state
            TempData[36]      := 0; // DS download enable
            TempData[37]      := 0; // DS upload enable
            TempData[38]      := aPortInfo[sSdoData.ActPortSelection].RevisionID; // revision ID

            TempDataLen := 39;

            InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
            
            sSdoData.eResponseState := t_ReponseState::_SendData;          
          else
            if (aPortInfo[sSdoData.ActPortSelection].CfgPortMode = _SDCI) & (aPortInfo[sSdoData.ActPortSelection].StartUpMode = _Inactive) & 
                aPortInfo[sSdoData.ActPortSelection].PhysicallyAvailable then
              // the current mode is now the startupmode
              aPortInfo[sSdoData.ActPortSelection].ActPortMode := aPortInfo[sSdoData.ActPortSelection].StartUpMode;
            
              // it's always ok here
              MyPara.aPara[0] := _ClassOk$DINT;

              // vendor ID
              MyPara.aPara[1] := aPortInfo[sSdoData.ActPortSelection].VendorID;

              // device ID
              MyPara.aPara[2] := aPortInfo[sSdoData.ActPortSelection].DeviceID$DINT;

              // minimum cycle time
              // check if a user override is active
              if aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us then
                MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].OverrideMinCycleTime_us$DINT;
              else
                MyPara.aPara[3] := aPortInfo[sSdoData.ActPortSelection].MinCycleTime_us$DINT;
              end_if;

              // actual port mode is already valid here (no further changes on the setting of this port)
              MyPara.aPara[4] := aPortInfo[sSdoData.ActPortSelection].ActPortMode$DINT;

              aPortInfo[sSdoData.ActPortSelection].pThis^.NewInst(#MyPara, #MyResult);         
            end_if;
          
            // already the last port?
            if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
              // finished, continue with next step
              sSdoData.ActPortSelection := 0;
              DelayedEnablePorts        := 0;
              DigStartUpAvailable       := FALSE;
              
              for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
                if (aPortInfo[i].CfgPortMode = _SDCI) & aPortInfo[i].PhysicallyAvailable then
                  if (aPortInfo[i].StartUpMode = _SDCI) then
                    DelayedEnablePorts := DelayedEnablePorts OR (1 SHL i$USINT);
                  elsif (aPortInfo[i].StartUpMode = _DigitalInput) | (aPortInfo[i].StartUpMode = _DigitalOutput) then
                    DigStartUpAvailable := TRUE;
                  end_if;
                end_if;
              end_for;
              
              if DelayedEnablePorts then                      
                // block the asynchron communication channel already
                sSdoData.AsyState             := t_SDCIRetCode::SDCI_Busy;
                sSdoData.TargetMode           := _SDCI;
                sSdoData.AsyCmdType           := t_AsyCmdType::DelayedEnable;
                sSdoData.eAsySSW              := t_AsySSW::_StartDelayedEnable;
                DelayedEnablePorts.FirstTime  := TRUE; // this is set to reset the port number on the first entrace in cyclic
              end_if;

              if DigStartUpAvailable then
                sSdoData.eInitSSW   := t_InitSSW::_EnableDigIOStartUpModes;
              else
                sSdoData.eInitSSW   := t_InitSSW::_SetCycleTimes;
              end_if;
            else
              // repeat the steps with the next port
              sSdoData.ActPortSelection += 1;
            end_if;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 3 then
            // check response data
            if (TempData[0] = (E_FNCID_SETPORTCNFPAR)$USINT) & // check function ID
               (TempData[1] = sSdoData.ActPortSelection)              // check port number
               then
               
              if (TempData[2] = 0) then // check status code seperately
                // reset response state machine
                sSdoData.eResponseState := t_ReponseState::_PrepareSendData;

                // already the last port?
                if sSdoData.ActPortSelection = (SIOL_MAX_PORTS_SUPPORTED-1) then
                  // finished, continue with next step
                  sSdoData.ActPortSelection := 0;
                  DelayedEnablePorts        := 0;
                  DigStartUpAvailable       := FALSE;
                  
                  for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
                    if (aPortInfo[i].StartUpMode = _SDCI) & aPortInfo[i].PhysicallyAvailable then
                      DelayedEnablePorts := DelayedEnablePorts OR (1 SHL i$USINT);
                    elsif (aPortInfo[i].CfgPortMode = _SDCI)         &  aPortInfo[i].PhysicallyAvailable &
                         ((aPortInfo[i].StartUpMode = _DigitalInput) | (aPortInfo[i].StartUpMode = _DigitalOutput)) then
                      DigStartUpAvailable := TRUE;
                    end_if;
                  end_for;
                  
                  if DelayedEnablePorts then                      
                    // block the asynchron communication channel already
                    sSdoData.AsyState             := t_SDCIRetCode::SDCI_Busy;
                    sSdoData.TargetMode           := _SDCI;
                    sSdoData.AsyCmdType           := t_AsyCmdType::DelayedEnable;
                    sSdoData.eAsySSW              := t_AsySSW::_StartDelayedEnable;
                    DelayedEnablePorts.FirstTime  := TRUE; // this is set to reset the port number on the first entrace in cyclic
                  end_if;

                  if DigStartUpAvailable then
                    sSdoData.eInitSSW   := t_InitSSW::_EnableDigIOStartUpModes;
                  else
                    sSdoData.eInitSSW   := t_InitSSW::_SetCycleTimes;
                  end_if;
                else
                  // repeat the steps with the next port
                  sSdoData.ActPortSelection += 1;
                end_if;
              else
                // error at return code
                LogError("@0527 (SdiasSDCIMaster::InitTheModule) Error at status code in answer from µC (_Configure2StartUpMode)");
                sSdoData.eInitSSW := _Error;
                return;
              end_if;
            else
              // unexpected answer data
              LogError("@0529 (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID or port number (_ReEnableWithFixedMode)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@052A (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC (_Configure2StartUpMode)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
  	t_InitSSW::_EnableDigIOStartUpModes:
      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action
          TempFlags := 0;
          TempFlags.Start2Operate := TRUE;
          TempFlags.OperatingMode := TRUE;

          // prepare the sdo buffer
          TempData[0]       := E_FNCID_CNTSTA; // function ID
          for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
            
            // if the startup mode is digin or digout => enable this mode now
            if (aPortInfo[i].CfgPortMode = _SDCI)         &  aPortInfo[i].PhysicallyAvailable &
              ((aPortInfo[i].StartUpMode = _DigitalInput) | (aPortInfo[i].StartUpMode = _DigitalOutput)) then
              TempData[1 + i*sizeof(UINT)]$UINT := TempFlags;
            else
              // otherwise don't do anything at this port
              TempData[1 + i*sizeof(UINT)]$UINT := 0;
            end_if;
          end_for;

          if TotalMappingWriteSize then
            _memset(dest:=#TempData[9], usByte:=0, cntr:=TotalMappingWriteSize);          
          end_if;

          TempDataLen := 9 + TotalMappingWriteSize;

          InitializeSdoWriteData(Usage:=_SendFunctionCode, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 9 then
          
            // reset response state machine
            sSdoData.eResponseState := t_ReponseState::_PrepareSendData;
            
            // check response data
            if (TempData[0] = (E_FNCID_CNTSTA)$USINT) then // check function ID

              // update the state of the object
              for i:= 0 to SIOL_MAX_PORTS_SUPPORTED-1 do
                
                // if the startup mode is digin or digout => show classok and current mode
                if (aPortInfo[i].CfgPortMode = _SDCI)         &  aPortInfo[i].PhysicallyAvailable 
                & ((aPortInfo[i].StartUpMode = _DigitalInput) | (aPortInfo[i].StartUpMode = _DigitalOutput))
                  then
                  // the current mode is now the startupmode
                  aPortInfo[i].ActPortMode := aPortInfo[i].StartUpMode;
                
                  // it's always ok here
                  MyPara.aPara[0] := _ClassOk$DINT;

                  // vendor ID
                  MyPara.aPara[1] := aPortInfo[i].VendorID;

                  // device ID
                  MyPara.aPara[2] := aPortInfo[i].DeviceID$DINT;

                  // minimum cycle time
                  // check if a user override is active
                  if aPortInfo[i].OverrideMinCycleTime_us then
                    MyPara.aPara[3] := aPortInfo[i].OverrideMinCycleTime_us$DINT;
                  else
                    MyPara.aPara[3] := aPortInfo[i].MinCycleTime_us$DINT;
                  end_if;

                  // actual port mode is already valid here (no further changes on the setting of this port)
                  MyPara.aPara[4] := aPortInfo[i].ActPortMode$DINT;

                  aPortInfo[i].pThis^.NewInst(#MyPara, #MyResult);         
                end_if;
              end_for;

              // finished, continue with next step
              sSdoData.eInitSSW   := t_InitSSW::_SetCycleTimes;

            else
              // unexpected answer data
              LogError("@050C (SdiasSDCIMaster::InitTheModule) Unexpected data in answer from µC: wrong function ID or port number (_SwitchToNewMode)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@050D (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC (_SwitchToNewMode)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;            

      //***************************************************************************************************
      end_case;
      
//**********************************************************************************************************************************************************
  	t_InitSSW::_SetCycleTimes:

      case sSdoData.eResponseState of         
      //***************************************************************************************************
        t_ReponseState::_PrepareSendData: // start the sending action

          // take the time from the parameter download process
          ParaDownloadTime := ops.tAbsolute - DownloadTimeStart;

          TempData[0]$UINT  := (udBusTime / 1000)$UINT; // SDIAS Bus cycle time
          TempData[2]$UINT  := CycleTime$UINT;

          TempDataLen    := 2 * sizeof(UINT);

          InitializeSdoWriteData(Usage:=_SendCycleTimeInfo, ParaIndex:=0, ParaSubIndex:=0, PortSelection:=SIOL_MASTER_PORT_NO, LengthOfData:=TempDataLen, pData:=#TempData[0]);
          
          sSdoData.eResponseState := t_ReponseState::_SendData;

      //***************************************************************************************************
        t_ReponseState::_SendData,
        t_ReponseState::_Wait4SendResponse,
        t_ReponseState::_GotSendResponse,
        t_ReponseState::_ReadData,
        t_ReponseState::_Wait4ReceiveData,
        t_ReponseState::_GotReceiveData:
          if HandleSdoDataTransfer() = ERROR then
            sSdoData.eInitSSW := _Error;
            return;
          end_if;

      //***************************************************************************************************
        t_ReponseState::_GotAllReceiveData:// we enter this step, when we received the answer with the data

          GetSdoReadData(pLength:=#TempDataLen, pData:=#TempData[0]);
          if TempDataLen = 0 then
            // check response data
            if (sSdoData.SdoReadData.ro_RetCode = _FwOk) then // check returncode
              // reset response state machine
              sSdoData.eResponseState := t_ReponseState::_SendData;

              sSdoData.RemainingDataSize := SIOL_MAX_PORTS_SUPPORTED * SIOL_MAX_PDO_SIZE;
              sSdoData.ActDataSize       := SDIAS_MAX_SDO_WRITE_LENGTH;
              sSdoData.pActData          := #LocalWritePDOBuf;

              // finished, continue with next step
              sSdoData.eInitSSW   := t_InitSSW::_ResetOutputImage;
            else
              // error
              LogError("@052A (SdiasSDCIMaster::InitTheModule) Error reported by µC (_SetCycleTimes)");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;
          else
            // invalid length of answer data
            LogError("@052B (SdiasSDCIMaster::InitTheModule) Invalid data length in answer from µC (_SetCycleTimes)");
            sSdoData.eInitSSW := _Error;
            return;
          end_if;            

      //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
  	t_InitSSW::_ResetOutputImage:
      case sSdoData.eResponseState of
        //***************************************************************************************************
          t_ReponseState::_SendData:// we enter this step to start the read access

            StartWriteSDO(hOffset:=SIOL_OFFSET_RT_WRITE_DATA, usLength:=sSdoData.ActDataSize, pWriteBuffer:=sSdoData.pActData$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);

            sSdoData.TimeoutStart   := ops.tAbsolute;
            sSdoData.eResponseState := t_ReponseState::_Wait4SendResponse;

        //***************************************************************************************************
          t_ReponseState::_Wait4SendResponse:// we wait for the read data
            if (ops.tAbsolute - sSdoData.TimeoutStart) > SIOL_SDO_TIMEOUT then
              LogError("@052C (SdiasSDCIMaster::InitTheModule) Timeout at resetting output image at module");
              sSdoData.eInitSSW := _Error;
              return;
            end_if;

        //***************************************************************************************************
          t_ReponseState::_GotSendResponse:// we enter this step, when we received the answer with the data

            // here we decide if more packages need to be sent
            sSdoData.RemainingDataSize -= sSdoData.ActDataSize;
            sSdoData.pActData          += sSdoData.ActDataSize;
            
            if sSdoData.RemainingDataSize then
              // another write access is necessary, prepare the variables
              if sSdoData.RemainingDataSize > SDIAS_MAX_SDO_WRITE_LENGTH then
                // limit the act size to it's maximum
                sSdoData.ActDataSize := SDIAS_MAX_SDO_WRITE_LENGTH;
              else
                // last package
                sSdoData.ActDataSize := sSdoData.RemainingDataSize;
              end_if;

              // send the next package
              sSdoData.eResponseState := t_ReponseState::_SendData;
            else
              // finished with writing => go to reading the answer
              sSdoData.eResponseState   := t_ReponseState::_PrepareSendData;
              sSdoData.eInitSSW   := t_InitSSW::_Finished;
            end_if;
            
        //***************************************************************************************************
      end_case;

//**********************************************************************************************************************************************************
  	t_InitSSW::_Finished:
      
      // Enable Buffer
      HWKVarSizeFIFO1.Enable();
      
      // Unlock SDO Channel
      sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);
    
      eModuleInitState := READY;
      eInitState       := _ClassOk;

//**********************************************************************************************************************************************************
  	t_InitSSW::_Error:
    
      // Do not unlock SDO Channel module is not working!
      eModuleInitState := ERROR;
      if eInitState = _NotInitialized then
        eInitState    := _InvalidConfguration;
      end_if;

//**********************************************************************************************************************************************************
  end_case;

#ifdef SIOL_ENABLE_DEBUG_LOGGING
  if sSdoData.eInitSSW <> OldStep then
    StepTimes[OldStep$DINT] := ops.tAbsolute;
    OldStep := sSdoData.eInitSSW;
  end_if;
#pragma message("RamAnd 31.01.2017 10:41 \ testweise die Zeit der einzelnen Steps messen")
#endif

END_FUNCTION


FUNCTION VIRTUAL SdiasSDCIMaster::HandleSDOFifo
  VAR
  	localSDOLock : UDINT;
    datasize : DINT;
    sSDOFIFOHeader : t_SDOFIFOHeader;
    aDatatmp    : array [0..SIOL_MAX_SDO_DATA_SIZE - 1] of USINT;
    bEndianSwapNeeded : BOOL;
    pParaInfo   : ^t_ConfigTablePara;
  END_VAR
  
  localSDOLock := sigclib_atomic_cmpxchgU32(pValue:=#sSdoData.DataLock, cmpVal := SSDCIM_SDO_UNLOCK, newVal := SSDCIM_SDO_LOCK);
  
  // Get Lock on SDO Channel
  if localSDOLock = SSDCIM_SDO_UNLOCK then
    
    // Get next sSDOFIFOHeader from buffer
    datasize := HWKVarSizeFIFO1.ReadData(pData := (#sSDOFIFOHeader)$^HSINT, size := sizeof(sSDOFIFOHeader));
    
    // Check if header is valid
    if datasize = sizeof(sSDOFIFOHeader) then
      
      // Always safe callback pointers
      sSdoData.pCallBackThis  := sSDOFIFOHeader.pThis;
      sSdoData.pCallBackFun   := sSDOFIFOHeader.pCallBackFunction;
    
      case sSDOFIFOHeader.NewInstCmd of
      
//**********************************************************************************************************************************************************
        CMD_SIOL_DEVICE_SET_PORT_MODE_BUFFERED:
          
          sSdoData.ActPortSelection := sSDOFIFOHeader.PortSelection;
          
          datasize := HWKVarSizeFIFO1.GetData(pData   := (#sSdoData.TargetMode)$^HSINT
                                            , size    := sizeof(t_SDCIPortMode)
                                            , offset  := sizeof(sSDOFIFOHeader));                                                    
          
          if (datasize <> sizeof(t_SDCIPortMode) ) then
            
            LogValue(pString := "@052D (SdiasSDCIMaster::HandleSDOFifo) Invalid LengthOfData 0x{0} in Fifo, Command = 0x{1}", udValue:=datasize$UDINT, udValue2:= sSDOFIFOHeader.NewInstCmd);
            // Unlock SDO Channel
            sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);
            return;          

//          else            
//            // Data Ok
          end_if;
                
          // we're busy now
          sSdoData.AsyState         := t_SDCIRetCode::SDCI_Busy;
          
          sSdoData.AsyCmdType       := t_AsyCmdType::ModeChange;
          sSdoData.eAsySSW          := t_AsySSW::_StartModeChange;
          sSdoData.eResponseState   := t_ReponseState::_SendData;
          sSdoData.AsyErrorCode     := t_SDCIRetCode::SDCI_UnspecifiedError;          

//**********************************************************************************************************************************************************        
        CMD_SIOL_DEVICE_RECONNECT_BUFFERED:
        
          // we're busy now
          sSdoData.AsyState         := t_SDCIRetCode::SDCI_Busy;
          
          sSdoData.ActPortSelection := sSDOFIFOHeader.PortSelection;

          sSdoData.AsyCmdType       := t_AsyCmdType::Reconnect;
          sSdoData.eAsySSW          := t_AsySSW::_StartReconnect;
          sSdoData.eResponseState   := t_ReponseState::_SendData;
          sSdoData.AsyErrorCode     := t_SDCIRetCode::SDCI_UnspecifiedError;
          
          HWKVarSizeFIFO1.RemoveData();

//**********************************************************************************************************************************************************        
        CMD_SIOL_DEVICE_GET_ASY_PARA_BUFFERED,
        CMD_SIOL_DEVICE_SET_ASY_PARA_BUFFERED,
        CMD_SIOL_DEVICE_ASY_FUNCTION_ID_BUFFERED:
        
            // reset some parts of the readdata structure      
            sSdoData.SdoReadData.ro_Checksum    := 0;
            
            // initialize variables for the cyclic state machine
            sSdoData.SdoWriteData.ParaIndex     := sSDOFIFOHeader.ParaIndex;
            sSdoData.SdoWriteData.ParaSubIndex  := sSDOFIFOHeader.ParaSubIndex;
            sSdoData.SdoWriteData.PortSelection := sSDOFIFOHeader.PortSelection;
            sSdoData.SdoWriteData.LengthOfData  := sSDOFIFOHeader.LengthOfData;
            
            if sSdoData.SdoWriteData.LengthOfData then
            
              if sSdoData.SdoWriteData.LengthOfData <= SIOL_MAX_SDO_DATA_SIZE then
              
                // Get the infomation bEndianSwapNeeded
                bEndianSwapNeeded := FALSE;    
                if ( sSdoData.SdoWriteData.PortSelection < SIOL_MAX_PORTS_SUPPORTED) then
                
                  // Get parameter information
                  pParaInfo := FindParaInTable( pActPortInfo := #aPortInfo[sSdoData.SdoWriteData.PortSelection]
                                              , ParaID       := sSdoData.SdoWriteData.ParaIndex
                                              , ParaSubID    := sSdoData.SdoWriteData.ParaSubIndex);
                  
                  // Check if parameter needes endianswap
                  bEndianSwapNeeded := CheckEndianSwapNeeded( pParaInfo     := pParaInfo
                                                            , PortSelection := sSdoData.SdoWriteData.PortSelection);
                end_if;
              
                if ( bEndianSwapNeeded = TRUE) then
                
                  // Get temp write data directly from buffer
                  datasize := HWKVarSizeFIFO1.GetData(  pData   := #aDatatmp[0]
                                                      , size    := sSdoData.SdoWriteData.LengthOfData
                                                      , offset  := sizeof(sSDOFIFOHeader));
                
                  if (datasize = sSdoData.SdoWriteData.LengthOfData) then
                    // Endianswap write data
                    EndianSwap( pDst          := #sSdoData.SdoWriteData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoWriteData.LengthOfData]
                              , pSrc          := #aDatatmp[0]
                              , LengthOfData  := sSdoData.SdoWriteData.LengthOfData);
                  // else
                  //   LogValue(pString := "@052D (SdiasSDCIMaster::HandleSDOFifo) Invalid LengthOfData 0x{0} in Fifo, Command = 0x{1}", udValue:=datasize$UDINT, udValue2:= sSDOFIFOHeader.NewInstCmd);  
                  end_if;
                  
                else
                  // Get write data directly from buffer
                  datasize := HWKVarSizeFIFO1.GetData(  pData   := #sSdoData.SdoWriteData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoWriteData.LengthOfData]
                                                      , size    := sSdoData.SdoWriteData.LengthOfData
                                                      , offset  := sizeof(sSDOFIFOHeader));
                end_if;
                                                    
                if (datasize <> sSdoData.SdoWriteData.LengthOfData) then      
            
                  LogValue(pString := "@052D (SdiasSDCIMaster::HandleSDOFifo) Invalid LengthOfData 0x{0} in Fifo, Command = 0x{1}", udValue:=datasize$UDINT, udValue2:= sSDOFIFOHeader.NewInstCmd);
                  // Unlock SDO Channel
                  sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);
                  return;          

      //          else            
      //            // Data Ok
                end_if;

              else
                LogValue(pString := "@052D (SdiasSDCIMaster::HandleSDOFifo) Invalid LengthOfData 0x{0} in Fifo, Command = 0x{1}", udValue:=datasize$UDINT, udValue2:= sSDOFIFOHeader.NewInstCmd);
                
                // Remove Invalid Data from Fifo
                HWKVarSizeFIFO1.RemoveData();
                // Unlock SDO Channel
                sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);
                return;
              end_if;
            else
              HWKVarSizeFIFO1.RemoveData();
            end_if;
          
            case sSDOFIFOHeader.NewInstCmd of
            
              CMD_SIOL_DEVICE_GET_ASY_PARA_BUFFERED:
                
                sSdoData.SdoWriteData.wo_ActUsage   := _ReadParaData;
                
              CMD_SIOL_DEVICE_SET_ASY_PARA_BUFFERED:  
              
                sSdoData.SdoWriteData.wo_ActUsage   := _WriteParaData;
                
              CMD_SIOL_DEVICE_ASY_FUNCTION_ID_BUFFERED:
            
                sSdoData.SdoWriteData.wo_ActUsage   := _SendFunctionCode;
              
            end_case;      
            
            sSdoData.SdoWriteData.wo_MessageCnt += 1;
            sSdoData.SdoWriteData.wo_Checksum   := CalcChecksum(Mode:=1);

            // set RemainingDataSize, pActData and ActDataSize correctly for the first send package
            
            // at the initialisation we set the remaining size to the complete package that needs to be transferred
            sSdoData.RemainingDataSize  := sSdoData.SdoWriteData.LengthOfData + sizeof(t_ServiceDataArea) - sizeof(t_ServiceDataArea.aData) - sizeof(t_ServiceDataArea.ro_MessageCnt) - sizeof(t_ServiceDataArea.ro_RetCode) - sizeof(t_ServiceDataArea.ro_Checksum);
            sSdoData.pActData           := #sSdoData.SdoWriteData + SIOL_MAX_SDO_DATA_SIZE - sSdoData.SdoWriteData.LengthOfData;
            if sSdoData.RemainingDataSize > SDIAS_MAX_SDO_WRITE_LENGTH then
              // limit the act size to it's maximum
              sSdoData.ActDataSize := SDIAS_MAX_SDO_WRITE_LENGTH;
            else
              // we only need one package
              sSdoData.ActDataSize := sSdoData.RemainingDataSize;
            end_if;
            
            sSdoData.AsyState       := t_SDCIRetCode::SDCI_Busy;
            sSdoData.AsyCmdType     := t_AsyCmdType::SingleAsyTransfer;
            sSdoData.eResponseState := t_ReponseState::_SendData;
            
//**********************************************************************************************************************************************************
      else
        LogValue("@04FB (SdiasSDCIMaster::HandleSDOFifo) Invalid command: 0x{0}" , udValue:= sSDOFIFOHeader.NewInstCmd);
        
        // Remove Invalid Data from Fifo
        HWKVarSizeFIFO1.RemoveData();
        // Unlock SDO Channel
        sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);
        return;
      end_case;
      
    else
      // No data in FIFO
      // Unlock SDO Channel
      sigclib_atomic_setU32(pValue:=#sSdoData.DataLock, value:= SSDCIM_SDO_UNLOCK);
    end_if;
  
//  else
//    // SDO Channel busy, do nothing
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL SdiasSDCIMaster::HandleSDOCallback
  VAR
  	AsyStatetmp : t_SDCIRetCode;
    pDatatmp    : ^USINT;  
    bEndianSwapNeeded : BOOL;
    pParaInfo   : ^t_ConfigTablePara;
  END_VAR

  AsyStatetmp := sSdoData.AsyState;
  pDatatmp    := NIL;
  
  if (sSdoData.SdoReadData.LengthOfData) then
  
    if (sSdoData.SdoReadData.LengthOfData <= SIOL_MAX_SDO_DATA_SIZE) then
    
      // Get the infomation bEndianSwapNeeded
      bEndianSwapNeeded := FALSE;    
      if ( sSdoData.SdoReadData.PortSelection < SIOL_MAX_PORTS_SUPPORTED) then
      
        // Get parameter information
        pParaInfo := FindParaInTable( pActPortInfo := #aPortInfo[sSdoData.SdoReadData.PortSelection]
                                    , ParaID       := sSdoData.SdoReadData.ParaIndex
                                    , ParaSubID    := sSdoData.SdoReadData.ParaSubIndex);
        
        // Check if parameter needes endianswap
        bEndianSwapNeeded := CheckEndianSwapNeeded( pParaInfo     := pParaInfo
                                                  , PortSelection := sSdoData.SdoReadData.PortSelection);
      end_if;
      
      if bEndianSwapNeeded = TRUE then
        EndianSwap( pDst          := #sSdoData.SdoReadDataSwapped[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData]
                  , pSrc          := #sSdoData.SdoReadData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData]
                  , LengthOfData  := sSdoData.SdoReadData.LengthOfData);
        
        // Pass pointer to swapped data
        pDatatmp := #sSdoData.SdoReadDataSwapped[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData];
        
      else        
        
        // Pass pointer to data
        pDatatmp := #sSdoData.SdoReadData.aData[SIOL_MAX_SDO_DATA_SIZE-sSdoData.SdoReadData.LengthOfData];
      end_if;
      
    else
      AsyStatetmp := t_SDCIRetCode::SDCI_MicroCtrl_RspLengthTooBig;
    end_if;

  end_if;
  
  sSdoData.pCallBackFun$AsyCallBackSdiasSDCIMaster( pThis         := sSdoData.pCallBackThis
                                                  , AsyState      := AsyStatetmp
                                                  , LengthOfData  := sSdoData.SdoReadData.LengthOfData
                                                  , pData         := pDatatmp);
  
  // Don't care about return code. If reciever can't handle callback that's his problem.
  
END_FUNCTION

FUNCTION VIRTUAL SdiasSDCIMaster::CheckEndianSwapNeeded
	VAR_INPUT
		pParaInfo 	  : ^t_ConfigTablePara;  
    PortSelection : USINT;
	END_VAR
	VAR_OUTPUT
		bCheckEndianSwapNeeded 	: BOOL;
	END_VAR  
  
  bCheckEndianSwapNeeded := FALSE;  
  
  if ( (PortSelection < SIOL_MAX_PORTS_SUPPORTED) &
       (aPortInfo[PortSelection].SkipEndianSwapAsy = FALSE) ) then
  
    if pParaInfo then
      
      // Swap is only needed for _Float32, _Int16, _Int32, _Int64, _Uint16, _Uint32, _Uint64
      // Not needed for _Text and 1 Byte Parameters        
      case pParaInfo^.DataType of
        
        _Float32,
        _Int16,
        _Int32,
        _Int64,
        _Uint16,
        _Uint32,
        _Uint64:
          bCheckEndianSwapNeeded := TRUE;
        
      end_case;
      
    end_if;  
  end_if;
  
END_FUNCTION

FUNCTION SdiasSDCIMaster::EndianSwap
	VAR_INPUT
		pDst 	: ^USINT;
		pSrc 	: ^USINT;
		LengthOfData 	: USINT;
	END_VAR	
  VAR
  	pDataSrc : ^USINT;
    pDataDst : ^USINT;
    i : DINT;
  END_VAR
 
  // Method can't handle pDst = pSrc
  if pDst & pSrc & LengthOfData & pDst <> pSrc then
  
    pDataSrc := pSrc + LengthOfData - 1;
    pDataDst := pDst;
    
    for i := 1 to LengthOfData do
      
      pDataDst^ := pDataSrc^;
      
      pDataSrc -= 1;
      pDataDst += 1;
    
    end_for;
  
  end_if;

END_FUNCTION


FUNCTION SdiasSDCIMaster::HandleAutoConnect
	VAR_INPUT
		usPortNbr 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: SdiasSDCIMaster::t_SDCIRetCode;
	END_VAR
  VAR
  	udTimeDiff    : UDINT;
  	MyPara        : CmdStruct;
    MyResult      : results;
  END_VAR
  
  //initialize return code
  retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_Ready_Ok;
  
  //check for valid port numbers
  if usPortNbr >= SIOL_MAX_PORTS_SUPPORTED then
    return;
  end_if;
  
  //if port is not configured for SDCI Device dont start port scan
  if aPortInfo[usPortNbr].StartUpMode <> _SDCI & aPortInfo[usPortNbr].ActPortMode <> _SDCI then
    return;
  end_if;
  
  //check asy read timeout of other asy accesses
  if sSdoData.bSingleAsyTransferReady = TRUE & (ops.tAbsolute-sSdoData.udSingleAsyTransferReady >= SIOL_TIMEOUT_GETASYNCHRONOUS_DATA) then
    //reset flag
    sSdoData.bSingleAsyTransferReady := FALSE;
  end_if;
  
  //check last reconnect time to allow other asy communication (SDCIDevice_AsyncPara) and wait for other asy accesses to get their data
  if (ops.tAbsolute-sAutoConnectVars.udLastReconnectTry) < WaitTimeReconnect (*SIOL_MINIMUM_wAIT4RECONNECT_TIME*) 
  | (sSdoData.bSingleAsyTransferReady = TRUE) then
    retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_Busy;
    return;
  end_if;
  
  //get act port timediff as ms 
  udTimeDiff := (ops.tAbsolute - aPortInfo[usPortNbr].udStartConnect);
  //check if auto connect is enabled and interval time is reached for this port 
  if aPortInfo[usPortNbr].PhysicallyAvailable = FALSE
  & aPortInfo[usPortNbr].udAutoConnectTime 
  & aPortInfo[usPortNbr].udAutoConnectTime <= udTimeDiff then  
    // set reconnect for this port to check for connected devices
    MyPara.uiCmd   := CMD_SIOL_DEVICE_RECONNECT;
    // add the port in the last parameter
    MyPara.aPara[MAXCMDPARA-1] := usPortNbr;
    
    MyResult.uiLng := 0;
    
    ClassState.NewInst(#MyPara, #MyResult);
    
    if MyResult.uiLng >= sizeof(SdiasSDCIMaster::t_SDCIRetCode) then
      retcode := MyResult.aData$SdiasSDCIMaster::t_SDCIRetCode;
    else
      retcode := SdiasSDCIMaster::t_SDCIRetCode::SDCI_UnspecifiedError;
    end_if;
    
    //if ok then reconnect is started
    if retcode = SDCI_Ready_Ok then
      //save timediff of reconnecting
      aPortInfo[usPortNbr].udStartConnTimeDiff := ops.tAbsolute - aPortInfo[usPortNbr].udStartConnect;
      //set last reconnect time stamp for wait time
      aPortInfo[usPortNbr].udStartConnect := ops.tAbsolute;
      sAutoConnectVars.bReConnectStarted := TRUE;
    end_if;
  end_if;

END_FUNCTION

FUNCTION TAB SdiasSDCIMaster::BitMask
  
  0xFF$USINT, // special, all bits needed if rest of bits is 0
  0x01$USINT,
  0x03$USINT,
  0x07$USINT,
  0x0F$USINT,
  0x1F$USINT,
  0x3F$USINT,
  0x7F$USINT

END_FUNCTION
