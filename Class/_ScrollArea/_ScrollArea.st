//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_ScrollArea"
	Revision           = "0.15"
	GUID               = "{EF59612C-EA4A-11D6-8BC9-0048545E8899}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,360)"
	Comment            = "provides functionality to do unrestricted scroll list">
	<Channels>
		<Server Name="ActPos" GUID="{A65B69FA-2E4C-4E59-9092-9E74F4FC9378}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="ExtendedScrollBar" Required="true" Internal="false" DefValue="0" Comment="set client 1 and you&apos;ll get PgUp and PgDown buttons in vertical scrollbar"/>
		<Client Name="LineHighness" Required="false" Internal="false" Comment="client is used to set individual lineheight in pixel.&#13;&#10;if value is smaller or equal to 0 (&lt;=0), lineheight will be calculated automatically by using fontsize."/>
		<Client Name="LineWidth" Required="true" Internal="false" Comment="client is used to set linewidt in pixel.&#13;&#10;if displayed space is smaller than linewidth you&apos;ll get an horizontal scrollbar on bottom of scrolllist."/>
		<Client Name="VerticalLevel" Required="false" Internal="false" Comment="0...no vertical scrollbar visible&#13;&#10;1...vertical scrollbar placed on the right&#13;&#10;2...vertical scrollbar placed on the left"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.15" Date="2016-11-03" Author="kolott" Company="sigmatek" Description="sa35969: ability to move control in carousell"/>
		<Dokumentation Revision="0.14" Date="2015-04-17" Author="kolott" Company="sigmatek" Description="sa30874: bugfix: Wrong pixel on screen when calling ActPos.Write() and Scrolllist was not shown."/>
		<Dokumentation Revision="0.13" Date="2013-01-10" Author="kolott" Company="sigmatek" Description="dr1830: new client to set lineheight in pixel"/>
		<Dokumentation Revision="0.12" Date="2012-03-22" Author="kolott" Company="sigmatek" Description="sa21327: lineheight"/>
		<Dokumentation Revision="0.11" Date="2012-02-28" Author="kolott" Company="sigmatek" Description="betterment in LineBackGround method to ensure invers theme as background"/>
		<Dokumentation Revision="0.10" Date="2012-02-09" Author="kolott" Company="sigmatek" Description="betterment to ensure set of linenumber"/>
		<Dokumentation Revision="0.9" Date="2011-02-23" Author="kolott" Company="sigmatek" Description="bugfix Init vs. Init32"/>
		<Dokumentation Revision="0.8" Date="2010-12-21" Author="kolott" Company="sigmatek" Description="more than 65536 lines are possible. Use Line32 instead of Line"/>
		<Dokumentation Revision="0.8" Date="2010-12-20" Author="kolott" Company="sigmatek" Description="speed optimization"/>
	</RevDoku>
	<Network Name="_ScrollArea">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{17373B4C-4288-11D7-8BC9-0048545E8899}"
				Class      = "_MyIO"
				Position   = "(180,180)"
				Visualized = "true">
				<Channels>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="Graphic"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(652,210),(480,270),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(652,270),(480,330),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(180,270),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _MyIO

_ScrollArea : CLASS
: _MyIO
  //Servers:
	ActPos 	: SvrCh_DINT;
  //Clients:
	VerticalLevel 	: CltCh_DINT;
	LineWidth 	: CltCh_DINT;
	LineHighness 	: CltCh_DINT;
	ExtendedScrollBar 	: CltCh_DINT;
  //Variables:
		Scroll 	: _SCROLL;
		DrawBeam 	: BOOL;
		Focus 	: BOOL;
		LetsDraw 	: BOOL;
		FocusJustGiven 	: BOOL;
  //Functions:
	
	FUNCTION _ScrollArea
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method will be called once when the focus will be given to this object&#13;&#10;&#13;&#10;pio ....... pointer to _IO information&#13;&#10;&#13;&#10;return _IFAILED if you dont want to get the focus on the other hand _IDLE&#13;&#10;" Name="GetFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="GetFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return _IFAILED if you dont want to get the focus on the other hand _IDLE" Name="GetFocus.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once when the focus is taken from object&#13;&#10;&#13;&#10;pio ....... pointer to _IO information&#13;&#10;&#13;&#10;return always _IDLE because you can&apos;t prevent action&#13;&#10;" Name="KillFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL KillFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="KillFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return always _IDLE because you can&apos;t prevent action" Name="KillFocus.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to redraw the io&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;pr ........ pointer to result information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;inside of method you can decide if you want to see the flashing cursor or not.&#13;&#10;return state _IDIDIT if you don&apos;t want to see the flashing cursor.&#13;&#10;on the other hand return state _IDLE&#13;&#10;" Name="IF_DisplayCursor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_DisplayCursor
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method returns if the object is accessible with editor&#13;&#10;return FALSE if you don&apos;t want to get access to object&#13;&#10;on the other hand return TRUE&#13;&#10;" Name="Accessible"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Accessible
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL InitScroll
		VAR_INPUT
			pio 	: ^_IO;
			vno 	: UINT;
		END_VAR;
				//! <Function Comment="method is called every time when redraw of a single line is necessary.&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to structure _SCROLL" Name="Line.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to place where line should be drawn" Name="Line.pr"/>
			line 	: UINT;			//! <Variable Comment="16 bit linenumber " Name="Line.line"/>
			state 	: BOOL;			//! <Variable Comment="line is selected (true) or passive (false)" Name="Line.state"/>
		END_VAR;
	
	FUNCTION GLOBAL InitScroll32
		VAR_INPUT
			pio 	: ^_IO;
			vno 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL OutPage;
	
	FUNCTION __CDECL VIRTUAL GLOBAL Out
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL LineHeight
		VAR_INPUT
			preselect 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode (AX) 	: UINT;
		END_VAR;
				//! <Function Comment="method is called every time when redraw of a single line is necessary.&#13;&#10;" Name="Line32"/>
	FUNCTION VIRTUAL GLOBAL Line32
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to structure _SCROLL" Name="Line32.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to place where line should be drawn" Name="Line32.pr"/>
			line 	: DINT;			//! <Variable Comment="aktual linenumber starts with 0" Name="Line32.line"/>
			state 	: BOOL;			//! <Variable Comment="line is selected (true) or passive (false)" Name="Line32.state"/>
		END_VAR;
				//! <Function Comment="Function is used to draw background of single line. Second parameter is absolute position of line in pixel and last parameter will define color.&#13;&#10;" Name="LineBackGround"/>
	FUNCTION VIRTUAL GLOBAL LineBackGround
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to _SCROLL" Name="LineBackGround.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to room of line" Name="LineBackGround.pr"/>
			color 	: _COLOR;			//! <Variable Comment="backgroundcolor" Name="LineBackGround.color"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActPos::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _ScrollArea::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__SCROLLAREA
0$UINT, 15$UINT, (SIZEOF(::_ScrollArea))$UINT, 
1$UINT, 4$UINT, 0$UINT, 
TO_UDINT(3043040051), "_ScrollArea", //Class
TO_UDINT(2980745877), "_MyIO", 0$UINT, 3$UINT, //Baseclass
//Servers:
(::_ScrollArea.ActPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3351625522), "ActPos", 
//Clients:
(::_ScrollArea.VerticalLevel.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2058293551), "VerticalLevel", 
(::_ScrollArea.LineWidth.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(514906114), "LineWidth", 
(::_ScrollArea.LineHighness.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3365192829), "LineHighness", 
(::_ScrollArea.ExtendedScrollBar.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2879621541), "ExtendedScrollBar", 
END_FUNCTION


#define USER_CNT__ScrollArea 23

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__ScrollArea] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _ScrollArea::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _MyIO::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__ScrollArea;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #KillFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #IF_DisplayCursor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Accessible();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #InitScroll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #Out();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #LineHeight();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #Line32();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #LineBackGround();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ActPos::Write() );
	IF ActPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _ScrollArea();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma using _Lse
#pragma using Graphic


#pragma warning (disable: 73)

#define LEFT_RIGHT_SELECTION // scrollbalken kann links oder rechts dargestellt werden

FUNCTION GLOBAL __CDECL scrollarea_line
VAR_INPUT
  ps    : ^_SCROLL;  
  pt    : ^void;  
  pr    : ^_ROOM; 
  line  : UDINT; 
  state : BOOL; 
END_VAR

  pt$^_ScrollArea^.Line32(ps, pr, line$dint, state); 

END_FUNCTION


FUNCTION _ScrollArea::_ScrollArea
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR

  ret_code := C_OK;
  init_SCROLL(#Scroll);
  Scroll.position.no := 101;
  ActPos         := Scroll.position.pos;
  Focus          := FALSE; 
  DrawBeam       := FALSE; 
  LetsDraw       := FALSE; 
  FocusJustGiven := FALSE; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::Draw
VAR_INPUT
	pio		: ^_IO;
	pr		: ^_RESULT;
	pv		: ^_VARIABLE;
	input		: BOOL;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  if((LetsDraw = TRUE)|(IsDrawBackGround() = TRUE)) then 
    LetsDraw := FALSE; 
    Out(pio); 
  end_if;
  
  retcode := _IDIDIT; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::IF_Run
VAR_INPUT
	pio		: ^_IO;
	input		: BOOL;
END_VAR

  if(Focus = TRUE) then
    if(DrawBeam = TRUE) then
      ActBeam_SCROLL(#Scroll, TRUE);  
	    DrawBeam := FALSE; 
    end_if;

    Run_SCROLL(#Scroll, NIL);
  end_if; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::GetEvent
VAR_INPUT
	ped		: ^_EDITOR;
	pe		: ^_EVENT;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR
VAR
    doit : BOOL; 
	eat : BOOL;
END_VAR

  retcode := _IDLE; 

  if(Focus = TRUE) then
    eat := false; 
    if(pe^.ftype = _EVENT_KEYPRESS) then
      doit := FALSE; 
      case pe^.scancode of
        _UP   : if(Scroll.position.pos > 0) then
                  doit := TRUE; 
                end_if; 
        _DOWN : if(Scroll.position.pos < (Scroll.position.no - 1)) then
                  doit := TRUE; 
                end_if; 
        _RIGHT: if(Scroll.hlevel.active = TRUE) then
                  if(Scroll.hposition.pos < (Scroll.hposition.no - 1)) then
//                    Scroll.hposition.pos += (Scroll.out_room.xy2.x - Scroll.out_room.xy1.x) / 4; 
                    pe^.scancode := _PGRIGHT; 
                    doit := TRUE; 
                  end_if; 
                end_if; 
        _LEFT : if(Scroll.hlevel.active = TRUE) then
                  if(Scroll.hposition.pos > 0) then
//                    Scroll.hposition.pos -= (Scroll.out_room.xy2.x - Scroll.out_room.xy1.x) / 4; 
                    pe^.scancode := _PGLEFT; 
                    doit := TRUE; 
                  end_if; 
                end_if; 
        _PGLEFT, 
        _PGRIGHT, 
        _PGUP, 
        _PGDOWN : doit := TRUE; 
      end_case; 
    elsif(pe^.ftype = _EVENT_SHUTTLEDEC) then
      if(Scroll.position.pos > 0) then
        doit := TRUE; 
        eat  := TRUE;
      end_if; 
    elsif(pe^.ftype = _EVENT_SHUTTLEINC) then
      if(Scroll.position.pos < (Scroll.position.no - 1)) then
        doit := TRUE; 
        eat  := TRUE;
      end_if; 
    else
      doit := TRUE; 
      if((pe^.ftype = _EVENT_HIDMOVE)&(FocusJustGiven = TRUE)) then
        if((pe^.dot.x >= Scroll.out_room.xy1.x)&(pe^.dot.x <= Scroll.out_room.xy2.x)&
           (pe^.dot.y >= Scroll.out_room.xy1.y)&(pe^.dot.y <= Scroll.out_room.xy2.y)) then
          pe^.ftype := _EVENT_HIDPRESS; 
          eat       := TRUE; 
        end_if; 
      end_if;   
    end_if; 

    FocusJustGiven := FALSE; 

    if(doit = TRUE) then
      Run_SCROLL(#Scroll, pe);

      case(pe^.ftype) of
        _EVENT_KEYPRESS   : eat := TRUE; 
        _EVENT_HIDPRESS, 
//        _EVENT_HIDMOVE, // wegen sa35969 (scrolllist in carousell) auskommentiert
        _EVENT_HIDRELEASE : if((pe^.dot.x >= Scroll.out_room.xy1.x)&(pe^.dot.x <= Scroll.out_room.xy2.x)&
                               (pe^.dot.y >= Scroll.out_room.xy1.y)&(pe^.dot.y <= Scroll.out_room.xy2.y)) then
                              eat := TRUE; 
                            end_if;  

      end_case; 

      if(eat = TRUE) then
        init_EVENT(pe);     // eat event
        retcode := _IDIDIT;
      end_if; 
    end_if;
    
    ActPos := Scroll.position.pos;
  end_if; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::GetFocus
VAR_INPUT
	pio		: ^_IO;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  _MyIo::GetFocus(pio); 

  retcode := _IFAILED;

  if(Accessible(pio) = TRUE) then
    Focus          := TRUE; 
    DrawBeam       := TRUE;
    FocusJustGiven := TRUE;  
    retcode        := _IDIDIT;
    Scroll.Cursor := NIL;
    if(IF_DisplayCursor() = _IDLE) then
      Scroll.Cursor := Cursor;
    end_if;
  end_if; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::KillFocus
VAR_INPUT
	pio		: ^_IO;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  ActBeam_SCROLL(#Scroll, FALSE);  
  Focus := FALSE; 
  if(IF_DisplayCursor() = _IDLE) then
    Cursor_End(Cursor);
//    Scroll.Cursor := Cursor;
  end_if;
  Scroll.Cursor := NIL;
  _MyIo::KillFocus(pio);

  retcode := _IDLE; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::IF_Start
VAR_INPUT
	pio		: ^_IO;
	firsttime		: BOOL;
END_VAR

  if(firsttime = TRUE) then
    LetsDraw := TRUE; 
  end_if; 

  pio^.bRefreshAct := TRUE; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::Line
  VAR_INPUT
    ps		: ^_SCROLL;
    pr		: ^_ROOM;
    line	: UINT;
    state	: BOOL;
  END_VAR
  VAR
    txt     : ARRAY [0..300] of _ASCII; 
    color   : _COLOR; 
    att     : _ATTRIB; 
  END_VAR

  if(state = TRUE) then
    color := ps^.color_activ; 
  else
    color := ps^.color_inactiv; 
  end_if; 

  LineBackGround(ps, pr, GetBackColor(color));

  if(line < ps^.position.no) then

    StrCpy(#txt[0], sizeof(_ASCII), "baseline ", sizeof(_ASCII));
    DToA(#txt[9], line, 0x0800, sizeof(_ASCII));

    att := T_LEFTBOUND or T_UPBOUND or T_COPY or T_SOLID or T_PROP; 
    Graphic.OutTextXY(pr^.xy1.x+3, pr^.xy1.y, #txt[0], att, Graphic.MakeColor(INVISIBLE, color), sizeof(_ASCII));
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _ScrollArea::Line32
  VAR_INPUT
    ps		: ^_SCROLL;
    pr		: ^_ROOM;
    line	: DINT;
    state	: BOOL;
  END_VAR

  Line(ps, pr, to_uint(line), state);

END_FUNCTION


FUNCTION GLOBAL _ScrollArea::InitScroll32
	VAR_INPUT
		pio 	: ^_IO;
		vno 	: DINT;
	END_VAR
  VAR
    xx, yy  : UINT; 
    hno, defyy : DINT; 
    hzl : BOOL; 
    tcol : _COLOR; 
   #ifdef LEFT_RIGHT_SELECTION
    sb_iswo : dint; 
   #endif
  END_VAR 
  
  defyy := false;
  if((Scroll.line_height = DEFAULT_SCROLL_LINE_HEIGHT) | (Scroll.line_height < 1)) then
    font_size(pio^.font, #xx, #yy); 
    Scroll.line_height := LineHeight(yy);
    if(Scroll.line_height = yy) then
      defyy := true;
    end_if;
  end_if;
  
  Scroll.attrib_inactiv    := pio^.attrib; 
  Scroll.attrib_activ      := pio^.attrib; 
  Scroll.out_room          := pio^.space; 
  Scroll.scroll_room       := pio^.space;
  Scroll.font              := pio^.font; 
  Scroll.color_inactiv     := Graphic.MakeColor(GetPenColor(pio^.colback), GetPenColor(pio^.coltxt));
  Scroll.color_activ       := Graphic.MakeColor(GetEditColorBack(_EDITACTIVE), GetEditColorTxt(_EDITACTIVE));
  Scroll.frame_out         := pio^.colframe;
  Scroll.frame_scroll      := pio^.colframe;
  tcol := GetBackColor(Scroll.color_inactiv); 
  Scroll.level.color       := Graphic.MakeColor(tcol, tcol); 
  Scroll.level.frame_color := pio^.colframe;
  if(ExtendedScrollBar.Read() = 1) then
    Scroll.level.pguppgdown  := true;
  end_if;
  Scroll.hlevel.color      := Scroll.level.color; 
  Scroll.hlevel.frame_color := pio^.colframe;
  Scroll.frametype         := pio^.frametype;

  Scroll.scroll_room.xy1.x += 1; 
  Scroll.scroll_room.xy1.y += 1; 
  Scroll.scroll_room.xy2.x -= 1; 
  Scroll.scroll_room.xy2.y -= 1; 

  Scroll.position.no  := vno; 

  Scroll.level.active := FALSE;

 #ifdef LEFT_RIGHT_SELECTION
  sb_iswo := VerticalLevel.Read(); 
  if(sb_iswo = 1) then
    // scrollbalken rechts
    Scroll.scroll_room.xy2.x -= LEVELBUTTON_WIDTH; 
    Scroll.level.room.xy1.x  := Scroll.scroll_room.xy2.x+1; 
    Scroll.level.room.xy2.x  := Scroll.out_room.xy2.x;
    Scroll.level.room.xy1.y  := Scroll.out_room.xy1.y; 
    Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
    Scroll.level.active      := TRUE; 
  elsif(sb_iswo = 2) then
    //scrollbalken links
    Scroll.scroll_room.xy1.x += LEVELBUTTON_WIDTH; 
    Scroll.level.room.xy1.x  := Scroll.out_room.xy1.x + 1;  
    Scroll.level.room.xy2.x  := Scroll.out_room.xy1.x + LEVELBUTTON_WIDTH;
    Scroll.level.room.xy1.y  := Scroll.out_room.xy1.y; 
    Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
    Scroll.level.active      := TRUE; 
  end_if; 
 #else
  if(VerticalLevel.Read() = TRUE) then
    Scroll.scroll_room.xy2.x -= LEVELBUTTON_WIDTH; 
    Scroll.level.room.xy1.x  := Scroll.scroll_room.xy2.x+1; 
    Scroll.level.room.xy1.y  := Scroll.out_room.xy1.y; 
    Scroll.level.room.xy2.x  := Scroll.out_room.xy2.x;
    Scroll.level.room.xy2.y  := Scroll.out_room.xy2.y;
    Scroll.level.active      := TRUE; 
  end_if; 
 #endif

  Scroll.line_width  := to_uint(Scroll.scroll_room.xy2.x - Scroll.scroll_room.xy1.x + 1);

(*
  // alter code
  hzl := TRUE;
  hno := LineWidth.Read();
  if(hno < Scroll.line_width) then
    hzl := FALSE;
	hno := Scroll.line_width; 
  end_if; 	 
  Scroll.hposition.no := hno;
*)

  // neuer code
  hno := LineWidth.Read();
  if(hno < Scroll.line_width) then
    hzl := FALSE;
    Scroll.hposition.no := 0; 
  else
    hzl := TRUE; 
    Scroll.hposition.no := hno - Scroll.line_width; 
  end_if; 	 


  if(hzl = TRUE) then
    Scroll.level.room.xy2.y  -= (LEVELBUTTON_HEIGHT + 1); 
    Scroll.scroll_room.xy2.y -= (LEVELBUTTON_HEIGHT + 1);
    Scroll.hlevel.room.xy1.x := Scroll.out_room.xy1.x;  
    Scroll.hlevel.room.xy1.y := Scroll.scroll_room.xy2.y + 1;  
    Scroll.hlevel.room.xy2.x := Scroll.out_room.xy2.x;  
    Scroll.hlevel.room.xy2.y := Scroll.out_room.xy2.y;  
    if(Scroll.level.active = TRUE) then
     #ifdef LEFT_RIGHT_SELECTION
      if(sb_iswo = 1) then
        // scrollbalken ist rechts
        Scroll.hlevel.room.xy2.x -= LEVELBUTTON_WIDTH; 
      elsif(sb_iswo = 2) then
        // scrollbalken ist links
        Scroll.hlevel.room.xy1.x += LEVELBUTTON_WIDTH-1;
        Scroll.hlevel.room.xy2.x -= 1; 
      end_if; 
     #else
      Scroll.hlevel.room.xy2.x -= LEVELBUTTON_WIDTH; 
     #endif 
    end_if; 
    Scroll.hlevel.active     := TRUE;  
    Scroll.hposition.height  := 1; //to_uint((Scroll.scroll_room.xy2.x - Scroll.scroll_room.xy1.x) / 4);  
  elsif(Scroll.hlevel.active = TRUE) then
    Scroll.scroll_room.xy2.y := pio^.space.xy2.y - 1;
    Scroll.level.room.xy2.y := Scroll.out_room.xy2.y;
    Scroll.hlevel.active := FALSE;
  end_if; 

  // Scroll.position.height := to_uint((Scroll.scroll_room.xy2.y - Scroll.scroll_room.xy1.y) / yy);
  // änderung von rauand am 17.11.05 erbeten
  Scroll.position.height := to_uint((Scroll.scroll_room.xy2.y - Scroll.scroll_room.xy1.y + 1) / Scroll.line_height);
  
  if(Scroll.position.height < 1) then
    Scroll.position.height := 1;
  end_if; 

  if(Scroll.level.active = TRUE) then
    Scroll.hlevel.room.xy2.x += 1;
  end_if;

  if(defyy = true) then
    Scroll.line_height += to_uint((Scroll.scroll_room.xy2.y - Scroll.scroll_room.xy1.y + 1 - Scroll.position.height * Scroll.line_height) / Scroll.position.height); 
  end_if;

  Scroll.pt      := this;
  Scroll.pt_line := #scrollarea_line();             // --> to userdefined linedraw-interface

  if(Scroll.level.pguppgdown = true) then
    if(Scroll.level.room.xy2.y < Scroll.level.room.xy1.y + (4 * (LEVELBUTTON_HEIGHT+1))) then
      Scroll.level.pguppgdown := false;
    end_if;
  end_if;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::InitScroll
VAR_INPUT
	pio		: ^_IO;
	vno     : UINT; 
END_VAR

  if(vno = Scroll.position.no$uint) then
    // vorsicht, trickreich: wenn untere 16bit gleich sind kann anzahl > 16bit (32bit sein)
    InitScroll32(pio, Scroll.position.no);
  else
    InitScroll32(pio, vno);
  end_if;
  //InitScroll32(pio, vno);
  
END_FUNCTION


FUNCTION GLOBAL _ScrollArea::OutPage

  if(Focus = TRUE) then
    OutPageBeam_SCROLL(#Scroll, TO_UINT(Scroll.position.pos)); 
  else
    OutPage_SCROLL(#Scroll);
  end_if; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::Out
VAR_INPUT
  pio : ^_IO; 
END_VAR

  InitScroll(pio, Scroll.position.no$uint);
  //InitScroll32(pio, Scroll.position.no);
 
  Draw_SCROLL(#Scroll, FALSE);

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::Accessible
VAR_INPUT
	pio		: ^_IO;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := FALSE; 
  if(Scroll.position.no > 0) then
    retcode := TRUE; 
  end_if;  

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::IF_DisplayCursor
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  retcode := _IDLE;

END_FUNCTION 


FUNCTION __CDECL VIRTUAL GLOBAL _ScrollArea::LineHeight
VAR_INPUT
	preselect  : UINT;
END_VAR
VAR_OUTPUT
	retcode		: UINT;
END_VAR

  retcode := preselect;
  
  if(LineHighness.Read() > 0) then
    retcode := to_uint(LineHighness.Read());
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _ScrollArea::LineBackGround
VAR_INPUT
	ps		: ^_SCROLL;
	pr		: ^_ROOM;
	color	: _COLOR;
END_VAR
var
  attrib : _ATTRIB;
end_var

  if(ps^.nobck = true) then
    if(color <> ps^.color_inactiv) then
      return;
    end_if;
  end_if;

  color := Graphic.MakeColor(color, color);
  if(ps <> NIL) then
    if(ps^.frametype >= _THEMEFRAME) then
      attrib := T_FILL or T_COPY or T_SOLID;
      if(ps^.attrib_activ and T_INVERTTHEME) then
        attrib := T_FILL or T_COPY or T_SOLID or T_INVRS or T_INVERTTHEME;
      end_if;
      draw_THEME_partial(#ps^.out_room, pr, ps^.frametype, attrib, color); // speed optimization
      //DrawButton(#ps^.out_room, attrib, ps^.frametype, color, color);
      return;
    end_if;
  end_if;

  Graphic.Beam(pr^.xy1.x, pr^.xy1.y, pr^.xy2.x, pr^.xy2.y, T_COPY or T_SOLID, color);
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _ScrollArea::ActPos::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	pos, beg, end : dint;
  END_VAR

  result := ACCESS_DENIED;
  
  if((input >= 0) & (input < Scroll.position.no)) then
    pos := input;
    beg := Scroll.position.begin;
    if(Scroll.position.height > 1) then
      end := beg + Scroll.position.height;
      if((pos < beg) | (pos >= end)) then
        beg := pos - (Scroll.position.height / 2);
        
        end := Scroll.position.no - Scroll.position.height;
        if(beg > end) then
          beg := end;
        end_if;

        if(beg < 0) then
          beg := 0;
        end_if;
        
      end_if;
    else
      beg := pos;
    end_if;
    
    if((pos <> Scroll.position.pos) | (beg <> Scroll.position.begin)) then
      Scroll.position.begin    := beg;
      Scroll.position.pos      := pos;
      Scroll.position.oldbegin := beg;
      Scroll.position.oldpos   := pos;
      
      LetsDraw := true;  
      Refresh  += 1;
      if(Focus) then  
        DrawBeam := true;
      end_if;
    end_if;
    
    ActPos := pos;
    result := pos;
  end_if;

END_FUNCTION

(*
FUNCTION VIRTUAL GLOBAL _ScrollArea::ActPos::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	event : _EVENT;
    memo : dint;
  END_VAR

  memo := input;
  
  if(input >= Scroll.position.no) then
    input := Scroll.position.no - 1;
  end_if;
  
  if(input < 0) then
    input := 0;
  end_if;

  Scroll.position.pos := input;
    
  Scroll.position.begin := Scroll.position.pos - (Scroll.position.height / 2);
  if(Scroll.position.begin < 0) then
    Scroll.position.begin := 0;
  end_if;
    
  init_EVENT(#event);
  Run_SCROLL(#Scroll, #event);
  
	ActPos := Scroll.position.pos;

  if(ActPos = memo) then
 	  result := ActPos;
  else
    result := ACCESS_DENIED;
  end_if;
  
END_FUNCTION
*)