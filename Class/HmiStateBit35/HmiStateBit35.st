//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Source\Common\hmi_nuc.h"

(*!
<Class
	Name               = "HmiStateBit35"
	Revision           = "0.5"
	GUID               = "{FF95F69C-806C-47B3-95DC-D1AC8E019D26}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{3F44AB77-E0F3-4521-B939-4E86B5DF48D1}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="ChkBit" Required="true" Internal="false"/>
		<Client Name="ComPort" Required="true" Internal="false"/>
		<Client Name="StringLib" Required="true" Internal="false"/>
		<Client Name="VarList" Required="true" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\Common\hmi_nuc.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.5" Date="2018-08-31" Author="kolott" Company="sigmatek" Description="cTor added"/>
		<Dokumentation Revision="0.4" Date="2016-06-28" Author="kolott" Company="sigmatek" Description="Type of membervariable PHmi changen foom ^void to ^LseEasy."/>
		<Dokumentation Revision="0.3" Date="2016-03-07" Author="kolott" Company="sigmatek" Description="unused local variable deleted"/>
		<Dokumentation Revision="0.2" Date="2016-02-04" Author="kolott" Company="sigmatek" Description="new method GetMapCrc() added"/>
		<Dokumentation Revision="0.1" Date="2014-11-26" Author="kolott" Company="sigmatek" Description="EasyMap.xml: enable &apos;_&apos; in statebitname"/>
	</RevDoku>
</Class>
*)
HmiStateBit35 : CLASS
	TYPE
#pragma pack(push, 1)
	  StateBit : STRUCT
	    CBit : HMI_CHKBIT;
	    Value : DINT;
	    Access : UINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	ChkBit 	: CltChCmd_HmiChkBitList;
	ComPort 	: CltChCmd_HmiComPort;
	VarList 	: CltChCmd_HmiVarList;
	StringLib 	: CltChCmd_HmiStrLib;
  //Variables:
		UsedNo 	: UDINT;
		UsedChkBit : ARRAY [0..255] OF StateBit;

		RunIdx 	: UDINT;
		PHmi 	: ^LseEasy;
  //Functions:
	
	FUNCTION HmiStateBit35
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL Free;
	
	FUNCTION GLOBAL Start
		VAR_INPUT
			pthis 	: ^LseEasy;
		END_VAR;
	
	FUNCTION GLOBAL RefreshAll;
	
	FUNCTION GLOBAL RefreshRun;
	
	FUNCTION GLOBAL AddEntry
		VAR_INPUT
			pcb 	: ^HMI_CHKBIT;
			access 	: UINT;
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
	
	FUNCTION Seek
		VAR_INPUT
			pcb 	: ^HMI_CHKBIT;
			access 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION CallEntry
		VAR_INPUT
			idx 	: UDINT;
			update 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetVarInfo
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^HMI_VARINFO;
		END_VAR;
	
	FUNCTION GLOBAL GetMapInfoXML
		VAR_INPUT
			index 	: UDINT;
			ptext 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL GetMapCrc
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION DefaultInit
		VAR_INPUT
			pthis 	: ^LseEasy;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd HmiChkBitList
#pragma usingLtd HmiComPort
#pragma usingLtd HmiStrLib
#pragma usingLtd HmiVarList


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiStateBit35::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMISTATEBIT35
0$UINT, 5$UINT, (SIZEOF(::HmiStateBit35))$UINT, 
1$UINT, 4$UINT, 0$UINT, 
TO_UDINT(4141094888), "HmiStateBit35", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiStateBit35.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::HmiStateBit35.ChkBit.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(574303706), "ChkBit", TO_UDINT(3930770040), "HmiChkBitList", 0$UINT, 2$UINT, 
(::HmiStateBit35.ComPort.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3802332095), "ComPort", TO_UDINT(136722037), "HmiComPort", 0$UINT, 16$UINT, 
(::HmiStateBit35.VarList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(145198113), "VarList", TO_UDINT(3793961451), "HmiVarList", 0$UINT, 17$UINT, 
(::HmiStateBit35.StringLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3243119075), "StringLib", TO_UDINT(103556616), "HmiStrLib", 0$UINT, 2$UINT, 
END_FUNCTION


#define USER_CNT_HmiStateBit35 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiStateBit35] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiStateBit35::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_HmiStateBit35, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HmiStateBit35();

END_FUNCTION

#pragma usingLtd LseEasy

//{{LSL_IMPLEMENTATION

#includeC "..\LseEasy\Create.h"
#pragma using LseEasy

FUNCTION HmiStateBit35::HmiStateBit35
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;
  ClassSvr := 0;
  DefaultInit(NIL);

END_FUNCTION

FUNCTION HmiStateBit35::DefaultInit
	VAR_INPUT
		pthis 	: ^LseEasy;
	END_VAR

  PHmi   := pthis;
  UsedNo := 0;
  RunIdx := 0;

END_FUNCTION

FUNCTION GLOBAL HmiStateBit35::Free

  DefaultInit(PHmi);

END_FUNCTION

FUNCTION GLOBAL HmiStateBit35::Start
	VAR_INPUT
		pthis 	: ^LseEasy;
	END_VAR

  Free();
  ClassSvr := 0; 
  PHmi     := pthis;

END_FUNCTION

FUNCTION HmiStateBit35::CallEntry
  VAR_INPUT
  	idx : udint;
  	update : bool;
  END_VAR
  VAR
  	st : dint;
    ph : ^StateBit;
  END_VAR

  if(idx < UsedNo) then

    ph := #UsedChkBit[idx];
    st := 16#FF;
    
    if(ChkBit.Get(#ph^.CBit) <> nil) then
      if(ChkBit.Call(#ph^.CBit) = false) then
        st := st xor SBIT_VISIBLE;
      end_if;
    end_if;
    
    if(ph^.Access <> 0) then
      if(PHmi <> NIL) then
        if(PHmi^.HmiAccess(ph^.Access) = false) then
          st := st xor SBIT_ACCESS;
        end_if;
      end_if;
    end_if;
    
    if((ph^.Value <> st) | (update = true)) then
      if(ComPort.SendStateBit(idx$uint + 1, st$usint) = true) then
        ph^.Value := st;
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL HmiStateBit35::RefreshAll
  VAR
  	idx : udint;
  END_VAR

  idx := 0;
  while(idx < UsedNo) do
    CallEntry(idx, true);
    idx += 1;
  end_while;

END_FUNCTION

FUNCTION GLOBAL HmiStateBit35::RefreshRun

  if(UsedNo) then
    if(RunIdx >= UsedNo) then
      RunIdx := 0;
    end_if;
    
    CallEntry(RunIdx, false);
    
    RunIdx += 1;
  end_if;

END_FUNCTION

FUNCTION HmiStateBit35::Seek
	VAR_INPUT
		pcb 	: ^HMI_CHKBIT;
		access 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	idx : udint;
    ph : ^StateBit;
  END_VAR

  ph  := #UsedChkBit[0];
  idx := 0;
  while(idx < UsedNo) do
    if((ph^.CBit.no = pcb^.no) & (ph^.CBit.invert = pcb^.invert) & (ph^.Access = access)) then 
      retcode := idx;
      return;
    end_if;
    ph  += sizeof(StateBit);
    idx += 1;
  end_while;
  
  retcode := 16#FFFFFFFF;
  
END_FUNCTION

FUNCTION GLOBAL HmiStateBit35::GetVarInfo
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^HMI_VARINFO;
	END_VAR
  
  retcode := nil;
  if(pany <> nil) then
    if((pany^.ima = HMI_IMA_V_SERVERLIST) | (pany^.ima = HMI_IMA_V_SERVERTEXT00) | (pany^.ima = HMI_IMA_V_SERVERUNITTEXT)) then
      retcode := VarList.Get(pany^.value$udint);
    end_if;
  end_if;
    
END_FUNCTION

FUNCTION GLOBAL HmiStateBit35::AddEntry
	VAR_INPUT
		pcb 	: ^HMI_CHKBIT;
		access 	: UINT;
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR
  VAR
  	idx : udint;
    st : bool;
    cbit : HMI_CHKBIT;
    pvi : ^HMI_VARINFO;
  END_VAR

  retcode := 0;
  st      := false;
  
  if(ChkBit.Get(pcb) <> nil) then
    st := true;
  else
    pvi := GetVarInfo(pany);
    if(pvi <> nil) then
      if(ChkBit.Get(#pvi^.chkbit) <> nil) then
        st  := true;
        pcb := #pvi^.chkbit;
      end_if;
    end_if;
  
    if(st = false) then
      pcb := #cbit;
      init_HMI_CHKBIT(pcb);
    end_if;
  end_if;
    
  if(access <> 0) then
    st := true;
  else
    pvi := GetVarInfo(pany);
    if(pvi <> nil) then
      if(pvi^.access <> 0) then
        access := pvi^.access;
        st     := true;
      end_if;
    end_if;
  end_if;
  
  if(st = true) then
    idx := Seek(pcb, access);
    if(idx > UsedNo) then
      if(UsedNo >= 255) then
        return;
      end_if;
      
      UsedChkBit[UsedNo].CBit   := pcb^;
      UsedChkBit[UsedNo].Value  := -2244766;
      UsedChkBit[UsedNo].Access := access;
      retcode                   := UsedNo$usint;
      UsedNo                    += 1;
      ClassSvr                  := to_dint(UsedNo);
    else
      retcode := idx$usint;
    end_if;
    
    retcode += 1;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiStateBit35::GetMapInfoXML
	VAR_INPUT
		index 	: UDINT;
		ptext 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^CHAR;
	END_VAR
  VAR
    psb : ^StateBit;
    ph, plabel : ^char;
  END_VAR

  retcode := nil;
  ph      := ptext;
  if(index < UsedNo) then
    psb := #UsedChkBit[index];
    
    StringLib.StrCpy(ph, 1, "<statebit id=?", 1);
    ph += StringLib.StrLen(ph, 1);
    StringLib.DintToStr(ph, to_dint(index+1), 16#800, 1);
    StringLib.StrCat(ph, 1, "? sequence=?", 1);
    ph += StringLib.StrLen(ph, 1);
    
    plabel := ChkBit.GetLabel(#psb^.CBit);
    if(plabel <> nil) then
      if(psb^.CBit.invert) then
        ph^ := '!'; ph  += 1;
      end_if;
      StringLib.StrCpy(ph, 1, plabel, 1);
      ph += StringLib.StrLen(ph, 1);
    end_if;
    
    if(psb^.Access <> 0) then
      if(plabel <> nil) then
        StringLib.StrCat(ph, 1, " or ", 1);
        ph += StringLib.StrLen(ph, 1);
      end_if;
      
      StringLib.StrCpy(ph, 1, "(Access", 1);
      ph += StringLib.StrLen(ph, 1);
      StringLib.DintToStr(ph, psb^.Access, 16#800, 1);
      StringLib.StrCat(ph, 1, " shl 1)", 1);
    end_if;
    
    StringLib.StrCat(ph, 1, "?/>", 1);
    StringLib.StrXchg(ptext, '?', '"');
    
    retcode := ptext;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiStateBit35::GetMapCrc
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	index, len : udint;
    psb : ^StateBit;
    plabel : ^char;
  END_VAR

  retcode := 0;
  index   := 0;
  while(index < UsedNo) do
    psb   := #UsedChkBit[index];
    index += 1;
    
    retcode := (retcode rol 1) xor index;
    
    plabel := ChkBit.GetLabel(#psb^.CBit);
    if(plabel <> nil) then
      len := StringLib.StrLen(plabel, 1) + 1;
      retcode := make_crc32(retcode, plabel, len);
    end_if;
    
    if(psb^.CBit.invert) then
      retcode := (retcode rol 1) xor 1;
    end_if;
    
    if(psb^.Access <> 0) then
      retcode := (retcode rol 1) xor psb^.Access;
    end_if;
  end_while;

END_FUNCTION
