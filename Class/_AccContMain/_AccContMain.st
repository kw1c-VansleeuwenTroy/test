//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES


// Einstellungen der Benutzerdaten
//-----------------------------------------------------------------------------------------
#define   AccessControl_InitDriveLetter               "C:\Users.cfg"                          // Standard Laufwerksbuchstabe, sofern die Benutzerdaten nicht exportiert werden sollen
#define   AccessControl_InitDriveLetterV2             "C:\AccUserData.cfg"                    // Standard Laufwerksbuchstabe, sofern die Benutzerdaten nicht exportiert werden sollen, V2.26, dacpat, new define for longer serial numbers
#define   AccessControl_UserFile                      "Users.cfg"                             // Name der Datei für die Benutzerdaten
#define   AccessControl_UserFileV2                    "AccUserData.cfg"                       // V2.29, dacpat, new file for V2 user data
#define   AccessControl_DriveLetterLength             _strlen("C:\")                          // Länge des Strings für das aktuelle Laufwerk
#define   AccessControl_MaxUsernameLength             30                                      // Maximale Anzahl der Zeichen im Benutzernamen
#define   AccessControl_MaxPasswordLength             32                                      // Maximale Anzahl der Zeichen im Passwort
#define   AccessControl_MaxUserInfoLength             60                                      // Maximale Anzahl der Zeichen in der Information des Benutzers
#define   AccessControl_MaxUSBSNLength                20                                      // Maximale Anzahl der Zeichen in der USB-Seriennummer,
#define   AccessControl_MaxUSBSNLengthV2              127                                     // V2.29, dacpat, new define for extended serial numbers
#define   AccessControl_MaxUserFilePathLength         100                                     // Maximale Länge des Pfades der Datei für die Benutzerdaten
#define   AccessControl_NumUserBuffer                 20                                      // Anzahl der Benutzer, welche im Buffer platz haben


// Einstellungen für die Datei der Benutzerverwaltung
//-----------------------------------------------------------------------------------------
#define   AccessControl_Version1                       1                                      // Version der Benutzerverwaltung
#define   AccessControl_Version2                       2                                      // V2.29, dacpat, new user data version for extended serial numbers
#define   AccessControl_HeaderLength                  40                                      // Größe des Headers in der Datei mit den Benutzern


// Einstellungen für die Visualisierung
//-----------------------------------------------------------------------------------------
#define   AccessControl_MessageWindowNr               50053                                   // Nummer des Fensters, welches die MSGNr als Text darstellt
#define   AccessControl_RFIDMessageWindowNr           50055                                   // V2.30, dacpat, new window number for RFID messages
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_AccContMain"
	Revision           = "2.31"
	GUID               = "{6B241EE9-8750-42E7-81BF-9A727EC68B8A}"
	RealtimeTask       = "false"
	DefRealtime        = "1 ms"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(542,120)"
	Comment            = "Main class for user administration and login">
	<Channels>
		<Server Name="ActLevel" GUID="{C0D98F71-E967-4D92-9668-AB876FF6A96B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="level of active user"/>
		<Server Name="ActUser" GUID="{B99296E3-B1EB-4EC8-A4B9-A31CC0E2BC55}" Class="VirtualBaseInit" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="name of active user"/>
		<Server Name="CopyUserFile" GUID="{6C9A0803-5BCB-482D-9C7E-84A4D98E7430}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="&gt; 0 ... command export userdata&#13;&#10;&lt; 0 ... command import userdata&#13;&#10;= 0 ... idle"/>
		<Server Name="EInfo" GUID="{2223AEF5-BF74-4CBD-B5FF-5C9C382D40EA}" Class="VirtualBaseInit" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Edit: user info"/>
		<Server Name="ELevel" GUID="{084F13C3-DF80-4A3D-875B-4D4BB6B3C807}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Edit: userlevel"/>
		<Server Name="EPassword" GUID="{69CBC706-A257-4F7E-9829-7F66DD358684}" Class="VirtualBaseInit" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Edit: new password"/>
		<Server Name="EPassword2" GUID="{80982B07-59FA-4CCD-949E-EACA52960132}" Class="VirtualBaseInit" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Edit: new password repeated"/>
		<Server Name="EPasswordOld" GUID="{547F6489-9C9A-40F6-B0DC-F0F77A558F53}" Class="VirtualBaseInit" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Edit: old password"/>
		<Server Name="ETimeOut" GUID="{7CE15E69-10D2-4D9D-AE87-8C3A0EF30C62}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Edit: Timout for auto logoff"/>
		<Server Name="EUsbSN" GUID="{CC998564-8B86-4397-A8CD-906EAC525E35}" Class="VirtualBaseInit" Visualized="false" Initialize="true" WriteProtected="true" Retentive="false" Comment="UsbSerialNumber for management (use StringClass inside)"/>
		<Server Name="EUserName" GUID="{49EFE8EB-7C66-462D-9721-1A001FB3639B}" Class="VirtualBaseInit" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Edit: User name (string class)"/>
		<Server Name="LoadRamExV2" GUID="{BFDEF08D-F1E5-42C4-93D1-9D4BEA0F21CD}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="File" Comment="Server is used to load the RamEx data correctly after an old user file has been imported and the machine needs to be restarted."/>
		<Server Name="LoggedInWithUsb" GUID="{B40F27A3-15E4-4098-A792-C44F3404FB4D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="1 = user is logged in with USB stick"/>
		<Server Name="LPassword" GUID="{D733D475-2292-42E1-8B06-9337A659FFB5}" Class="VirtualBaseInit" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Login: password"/>
		<Server Name="LUserName" GUID="{81D81484-CCA8-4893-B2A5-00B3157542F6}" Class="VirtualBaseInit" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Login: username"/>
		<Server Name="MSGNr" GUID="{3D96A892-6ACA-4C4B-962F-EABFE1DC1C12}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="status of the user management (ENUMs, LSE textlist)"/>
		<Server Name="OpenMsgWindowSteps" GUID="{9F058F3E-9E96-4077-AFC5-FDCCEB29C2D9}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="in this Server the steps for opening a new &#13;&#10;Window are getting handled"/>
		<Server Name="SelectFunction" GUID="{F33B61CD-8421-4FDF-AA18-5FADE4137AD0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Server with write-methode witch calls another methodes&#13;&#10;    1:  AddUser()&#13;&#10;    2:  DeleteUser()&#13;&#10;    3:  ModifyUser()&#13;&#10;    4:  Login()&#13;&#10;    5:  Logout()&#13;&#10;    6:  ShowUserData()&#13;&#10;    7:  ChangePassword()&#13;&#10;    8:  AddUsbSN()&#13;&#10;    9:  AddUsbSNbyUser()&#13;&#10;    10: DelUsbSN()&#13;&#10;    11: clearSevers()&#13;&#10;    12: closeScreen()&#13;&#10;"/>
		<Server Name="Server0" Comment="1 = ready for visualization / 0 = hide login in visualization">
			<NewInst>
				<Function Name="DeactiveAccessLevel" Comment="This method is used to deactivate / activate the access level checking via NewInst command = 0">
					<InputParameter>
						<Parameter Name="bCheckAccessState" Comment="True = check access level deactivated&#13;&#10;False = check access level activated"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="ret_code"/>
					</OutputParameter>
				</Function>
			</NewInst>
		</Server>
		<Server Name="UserFile" GUID="{51793EDD-914C-4906-A9B1-3D19631C8E1E}" Class="String" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="path and name of file for userdata"/>
		<Server Name="UserIsLoggedIn" GUID="{F13DFF00-C2EA-471F-AFFE-21302A7FD5D5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="1 = user is logged in"/>
		<Client Name="AccessConfig" Required="true" Internal="false" Comment="Bit 0: 1 = ignore user-level for screen access"/>
		<Client Name="ActScreenNr" Required="true" Internal="false" Comment="screen-number of the active screen"/>
		<Client Name="ccEventQueue" Required="false" Internal="false" Comment="command channel to EventQueue object (optional)"/>
		<Client Name="ccSystemLogging" Required="false" Internal="false" Comment="command channel to SystemLogging (optional)"/>
		<Client Name="coDriveLetter" Required="false" Internal="false" Comment="object channel to DriveLetter object"/>
		<Client Name="coFileSys" Required="false" Internal="false" Comment="object channel to FileSys (don&apos;t connect!)"/>
		<Client Name="coGlobal" Required="true" Internal="false" Comment="object channel to ProjectGlobal object"/>
		<Client Name="Config" Required="false" Internal="false" Comment="Bit 0: 1 = Use ASCII KeyPad if ASCII-Only is activated (ONLY SET TO 1 IF FILEEXPLORER IS IMPLEMENTED!!)"/>
		<Client Name="coSystem" Required="false" Internal="false" Comment="object channel to System (don&apos;t connect!)"/>
		<Client Name="Deactivate" Required="false" Internal="false" Comment="Use for debugging. If 1 the access-contol is not enabled. Everyone can access pages even if a access-level is defined&#13;&#10;"/>
		<Client Name="ExtUserData" Required="true" Internal="true"/>
		<Client Name="RefreshList" Required="true" Internal="false" Comment="command &quot;refresh list&quot; - connect to AccessControlList for usermanagement"/>
		<Client Name="StrActUser" Required="true" Internal="true"/>
		<Client Name="StrEditInfo" Required="true" Internal="true"/>
		<Client Name="StrEditPassword" Required="true" Internal="true"/>
		<Client Name="StrEditPassword2" Required="true" Internal="true"/>
		<Client Name="StrEditPasswordOld" Required="true" Internal="true"/>
		<Client Name="StrEditUsbSN" Required="true" Internal="true"/>
		<Client Name="StrEditUserName" Required="true" Internal="true"/>
		<Client Name="StrLoginPassword" Required="true" Internal="true"/>
		<Client Name="StrLoginUserName" Required="true" Internal="true"/>
		<Client Name="StrUserFile" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_AccContMain\_AccContMain_de.pdf"/>
			<File Path=".\Class\_AccContMain\_AccContMain_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="2.31" Date="2022-03-07" Author="KaiAnd" Company="Sigmatek" Description="--&gt; Don&apos;t check the UsbSerialNumber when exporting/importing the user file to a USB device."/>
		<Dokumentation Revision="2.30" Date="2019-11-20" Author="dacpat" Company="Sigmatek" Description="- Added new functionality to log in via RFID card.&#13;&#10;- Added the new methods GetActUser(), SetRFIDMsgNr(), SetUserDataStrings() and getUserDataByUser().&#13;&#10;- Changed Server LoadRamExV2 from SRAM to File retentive."/>
		<Dokumentation Revision="2.29" Date="2019-09-04" Author="dacpat" Company="Sigmatek" Description="- Reworked the class to be able to use USB sticks with an extended serial numbers.&#13;&#10;  This includes an new user data structues and the conversion of old user files (&quot;Users.cfg&quot;) into the new format (file &quot;AccUserData.cfg&quot;).&#13;&#10;- Import and export of user files is now done in the bg task and not in the Write() method of the server CopyUserFile.&#13;&#10;- Header information of user files will be checked before the import is done. Prevents the import when information is incorrect."/>
		<Dokumentation Revision="2.28" Date="2019-07-15" Author="HerMor" Company="Sigmatek" Description="Client Config was added: Bit 0: 1 = Use ASCII KeyPad instead of UNICode KeyPad (Only set to 1 if FileExplorer is implemented)"/>
		<Dokumentation Revision="2.27" Date="2019-07-11" Author="HerMor" Company="Sigmatek" Description="TempAdmin does not reset to default after list is closed and opened"/>
		<Dokumentation Revision="2.26" Date="2019-07-11" Author="HerMor" Company="Sigmatek" Description="changed method Login() and Logout() to virtual"/>
		<Dokumentation Revision="2.25" Date="2018-05-28" Author="FurLuk" Company="Sigmatek" Description="change the way of opening a MessageWindow in order to avoid a Textbug"/>
		<Dokumentation Revision="2.24" Date="2017-12-26" Author="sprdie" Company="Sigmatek" Description="1: max password length changed from 8 to 32 (define: AccessControl_MaxPasswordLength)&#13;&#10;2: date &amp; time of last login and logout are now saved for each user"/>
		<Dokumentation Revision="2.23" Date="2017-09-19" Author="SchDom" Company="Sigmatek" Description="Implemented functionality to deactivate/activate the access level check with NewInst()"/>
		<Dokumentation Revision="2.22" Date="2016-11-11" Author="KaiAnd" Company="Sigmatek" Description="--&gt; client coDriveLetter: if it&apos;s not connected the message window will be opened and no client access will happen&#13;&#10;--&gt; if no USB stick is plugged, the message window will be opened and the export will not be started anymore"/>
		<Dokumentation Revision="2.21" Date="2016-10-28" Author="KaiAnd" Company="Sigmatek" Description="server0 will be set after INIT (1 = ready for visualization / 0 = hide login in visualization)"/>
		<Dokumentation Revision="2.20" Date="2016-10-10" Author="HubChr" Company="Sigmatek" Description="Added documentation pdfs, changed servers of embedded String objects to Data Channels"/>
		<Dokumentation Revision="2.19" Date="2016-10-06" Author="KaiAnd" Company="Sigmatek" Description="1: changed object channel for SystemLogging to a command channel; new help function LogMyText() for logging&#13;&#10;2: changed object channel to _EventQueue to a command channel; adding events now via this command channel&#13;&#10;3: changed define for message window in lasal screen"/>
		<Dokumentation Revision="2.18" Date="2016-09-29" Author="KaiAnd" Company="Sigmatek" Description="allow a new user with lower level AND the SAME level as the actual user"/>
		<Dokumentation Revision="2.17" Date="2016-07-13" Author="Roskri" Company="Sigmatek" Description="Changed define for message window in lasal screen"/>
		<Dokumentation Revision="2.16" Date="2016-05-19" Author="GreJoh" Company="Sigmatek" Description="Client coSystemLogging need not be connected."/>
		<Dokumentation Revision="2.15" Date="2016-02-04" Author="Roskri" Company="Sigmatek" Description="IF a login-USB was already connected during CPU-start it will now be recognized"/>
		<Dokumentation Revision="2.14" Date="2015-11-12" Author="hötant" Company="Sigmatek" Description="corrected method NewStick ( wrong handling of first user , USB login did not work )"/>
		<Dokumentation Revision="2.13" Date="2015-11-09" Author="hötant" Company="Sigmatek" Description="corrected a fault in method Login , memory allocation is not nessasary"/>
		<Dokumentation Revision="2.12" Date="2015-10-30" Author="BraLis" Company="Sigmatek" Description="-replaced the define &quot;AccessControl_IgnoreScreenAccess&quot; by the client AccessConfig; if set 0, the accesslevel will be checked&#13;&#10;-corrected the methods AddUser, DeleteUser, CreateAdmin, SearchUserbyUsbSN, AddUsbSN and DelUsbSN because of Access Exception"/>
		<Dokumentation Revision="2.11" Date="2015-10-29" Author="BraLis" Company="Sigmatek" Description="corrected the methods SearchUser, DeleteUser, getUserToEdit, Login, AddUser, CreateAdmin and IF_WindowRun because the buffer UsersBuffer was written wrong&#13;&#10;"/>
		<Dokumentation Revision="2.10" Date="2015-10-27" Author="BraLis&#13;&#10;" Company="Sigmatek" Description="-Error in IF_WindowRun: check the file length and set pActUser^.pNext := NIL&#13;&#10;-add method CreateStandardUser() which is called in the Init()&#13;&#10;-add the variable StandardUser which serves as a buffer for the standard users&#13;&#10;-modified SearchUser() that also the buffer StandardUser will be checked"/>
		<Dokumentation Revision="2.9&#13;&#10;&#13;&#10;" Date="2015-10-27" Author="KruAle&#13;&#10;" Company="Sigmatek" Description="new define &quot;AccessControl_IgnoreScreenAccess&quot;. If set, the class does not check after login/logout if the access-level is valid.&#13;&#10;"/>
		<Dokumentation Revision="2.8" Date="2015-09-29" Author="BraLis" Company="Sigmatek" Description="insert the method SystemLogging::LogEventText instead of TRACE-Messages"/>
		<Dokumentation Revision="2.7" Date="2015-09-22" Company="Sigmatek" Description="Creation."/>
	</RevDoku>
	<Network Name="_AccContMain">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{8005E018-7B4A-4188-9852-0A318F5B3C83}"
				Class      = "_Global"
				Position   = "(458,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
			<Object
				Name       = "ExtUserData"
				GUID       = "{83372E62-E6E2-4215-9D89-A0F321C1CCF9}"
				Class      = "RAMex"
				Position   = "(450,1800)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="m_udLength" Value="0"/>
					<Client Name="MultiTask"/>
					<Client Name="ThreadSafe" Value="0"/>
					<Client Name="UseFile" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrActUser"
				GUID       = "{1B803DCB-2376-45FB-B870-33B2941EB6E4}"
				Class      = "String"
				Position   = "(450,1500)"
				Visualized = "true">
				<Channels>
					<Server Name="Data" Value="&quot;C:\Users.cfg&quot;"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditInfo"
				GUID       = "{7AE4601E-7C0E-4B98-9FAE-154D0AC7622D}"
				Class      = "String"
				Position   = "(450,900)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditPassword"
				GUID       = "{6357ED1B-6D36-45F1-86E4-5BC76B2C562A}"
				Class      = "String"
				Position   = "(450,600)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditPassword2"
				GUID       = "{4AD4D94F-791D-499E-BC7A-D60EBDEE4ABA}"
				Class      = "String"
				Position   = "(450,750)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditPasswordOld"
				GUID       = "{6D0599E8-293F-4EB4-B2D3-4FA402CEFC05}"
				Class      = "String"
				Position   = "(450,450)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditUsbSN"
				GUID       = "{B42CFCF6-D3EB-4ED1-85B9-D31E0A6FF116}"
				Class      = "String"
				Position   = "(450,1050)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrEditUserName"
				GUID       = "{D89E4404-D5E5-4B0C-98BC-A886F3BF376D}"
				Class      = "String"
				Position   = "(450,300)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrLoginPassword"
				GUID       = "{B4830AE8-893B-488C-A2E6-89F745D42EC1}"
				Class      = "String"
				Position   = "(450,1350)"
				Visualized = "true">
				<Channels>
					<Server Name="Data" Value="0"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrLoginUserName"
				GUID       = "{54806AE7-2519-4475-9F81-BB64E7FBDBD8}"
				Class      = "String"
				Position   = "(450,1200)"
				Visualized = "true">
				<Channels>
					<Server Name="Data" Value="0"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrUserFile"
				GUID       = "{179FDEAC-8007-4279-BC94-5ACC0AF9E553}"
				Class      = "String"
				Position   = "(450,1650)"
				Visualized = "false">
				<Channels>
					<Server Name="Data" Value="&quot;C:\&quot;"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(938,210),(758,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(458,210),(38,210),"/>
			<Connection Source="this.StrEditUserName" Destination="StrEditUserName.Data"/>
			<Connection Source="this.EUserName" Destination="StrEditUserName.Data" Vertices="(938,330),(766,390),"/>
			<Connection Source="this.StrEditPassword" Destination="StrEditPassword.Data"/>
			<Connection Source="this.EPassword" Destination="StrEditPassword.Data" Vertices="(938,450),(766,690),"/>
			<Connection Source="this.StrUserFile" Destination="StrUserFile.Data"/>
			<Connection Source="this.EPasswordOld" Destination="StrEditPasswordOld.Data" Vertices="(938,390),(766,540),"/>
			<Connection Source="this.StrActUser" Destination="StrActUser.Data"/>
			<Connection Source="this.LPassword" Destination="StrLoginPassword.Data" Vertices="(938,870),(766,1440),"/>
			<Connection Source="this.StrLoginUserName" Destination="StrLoginUserName.Data"/>
			<Connection Source="this.StrLoginPassword" Destination="StrLoginPassword.Data"/>
			<Connection Source="this.LUserName" Destination="StrLoginUserName.Data" Vertices="(938,810),(766,1290),"/>
			<Connection Source="this.UserFile" Destination="StrUserFile.Data" Vertices="(938,1110),(766,1740),"/>
			<Connection Source="this.StrEditUsbSN" Destination="StrEditUsbSN.Data"/>
			<Connection Source="this.EUsbSN" Destination="StrEditUsbSN.Data" Vertices="(938,750),(766,1140),"/>
			<Connection Source="this.StrEditPassword2" Destination="StrEditPassword2.Data"/>
			<Connection Source="this.EPassword2" Destination="StrEditPassword2.Data" Vertices="(938,510),(766,840),"/>
			<Connection Source="this.StrEditInfo" Destination="StrEditInfo.Data"/>
			<Connection Source="this.EInfo" Destination="StrEditInfo.Data" Vertices="(938,690),(766,990),"/>
			<Connection Source="this.ActUser" Destination="StrActUser.Data" Vertices="(938,930),(766,1590),"/>
			<Connection Source="this.StrEditPasswordOld" Destination="StrEditPasswordOld.Data"/>
			<Connection Source="this.ExtUserData" Destination="ExtUserData.m_udLength"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Global

_AccContMain : CLASS
: _Global
	TYPE
	  CmdServer0 :  //! <Type Public="true" Name="CmdServer0"/>
	  (
	    DeactiveAccessLevel:=0
	  )$UINT;
	  t_a_USB_Serial : ARRAY [0..AccessControl_MaxUSBSNLength] OF CHAR;
	  t_a_USB_SerialV2 : ARRAY [0..AccessControl_MaxUSBSNLengthV2] OF CHAR;
	  t_e_MsgNumbers :
	  (
	    MSG_NO_ERR,
	    MSG_LOGIN_OK,
	    MSG_LOGOUT_OK,
	    MSG_ADDUSER_OK,
	    MSG_EDITUSER_OK,
	    MSG_DELUSER_OK,
	    MSG_PWCHANGE_OK,
	    MSG_EXPORT_USERS_OK,
	    MSG_IMPORT_USERS_OK,
	    MSG_USB_SERNUM,
	    ERR_USER_EXISTS,
	    ERR_USER_NOTEXIST,
	    ERR_NO_NAME,
	    ERR_NO_PASS,
	    ERR_WRONG_PASS,
	    ERR_WRONG_PWCHANGE,
	    ERR_USERS_FILE,
	    ERR_ADDUSER:=17,
	    ERR_MEMORY:=18,
	    ERR_EDITUSER,
	    ERR_DELUSER,
	    ERR_NO_DRIVE,
	    ERR_COPYUSERS,
	    ERR_USB_SERNUM,
	    ERR_NO_SCREEN_ACCESS,
	    ERR_WRONG_PWOLD,
	    ERR_DEL_USB_SERNUM,
	    ERR_AUTHORITY_EDITUSER,
	    ERR_AUTHORITY_LEVEL,
	    ERR_EDIT_OWNLEVEL,
	    ERR_AUTHLEVEL_LOW:=30,
	    ERR_RFIDDATA_NOMATCH,
	    ERR_WRITE_RFIDDATA,
	    MSG_RFID_LOGIN,
	    MSG_RFID_ADDUSER,
	    MSG_RFID_LOGOUT,
	    MSG_RFID_WRITEDATASUCCESS,
	    MSG_RFID_WRITEDATAREQUEST,
	    ERR_RFID_CARDNOTSUPPORTED
	  )$UDINT;
	  t_e_OpenMsgWindowSteps :  //! <Type Public="true" Name="t_e_OpenMsgWindowSteps"/>
	  (
	    CheckNewMessage,
	    WaitCycles,
	    OpenMessageWindow
	  )$UDINT;
	  t_e_RetCheckservers :
	  (
	    NAME_PASS_1,
	    NAME_1,
	    PASS_1,
	    NAME_PASS_ERR,
	    NAME_0,
	    PASS_0
	  )$UDINT;
	  t_e_UserDataStrings :  //! <Type Public="true" Name="t_e_UserDataStrings"/>
	  (
	    UserData_StrEditUserName,
	    UserData_StrEditPasswordOld,
	    UserData_StrEditPassword,
	    UserData_StrEditPassword2,
	    UserData_StrEditInfo,
	    UserData_StrLoginUserName,
	    UserData_StrLoginPassword
	  )$UDINT;
	  t_e_UserFile :
	  (
	    AccessControl_IDLE,
	    AccessControl_FILEOPENV2,
	    AccessControl_FILEOPEN,
	    AccessControl_WAIT4FILEOPEN,
	    AccessControl_FILELENGTH,
	    AccessControl_WAIT4FILELENGTH,
	    AccessControl_FILETELL,
	    AccessControl_WAIT4FILETELL,
	    AccessControl_READHEADER,
	    AccessControl_WAIT4READHEADER,
	    AccessControl_FILEREAD,
	    AccessControl_WAIT4FILEREAD,
	    AccessControl_FILEREFRESH,
	    AccessControl_WAIT4FILEREFRESH,
	    AccessControl_WRITEHEADER,
	    AccessControl_WAIT4WRITEHEADER,
	    AccessControl_FILLBUFFER,
	    AccessControl_FILEWRITE,
	    AccessControl_WAIT4FILEWRITE,
	    AccessControl_FILECLOSE,
	    AccessControl_WAIT4FILECLOSE,
	    AccessControl_FILEDELETE,
	    AccessControl_WAIT4FILEDELETE,
	    AccessControl_EXPORTUSERS,
	    AccessControl_WAIT4FILECOPY,
	    AccessControl_IMPORTUSERSV2,
	    AccessControl_IMPORTUSERSV1
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_User : STRUCT  //! <Type Public="true" Name="t_s_User"/>
	    aUsername : ARRAY [0..AccessControl_MaxUsernameLength] OF CHAR;
	    aUserPassword : ARRAY [0..AccessControl_MaxPasswordLength] OF CHAR;
	    usUserLevel : USINT;
	    udUserTimeout : UDINT;
	    aUserInfo : ARRAY [0..AccessControl_MaxUserInfoLength] OF CHAR;
	    USBSerial : t_a_USB_Serial;
	    LastLogin : _DATIM;
	    LastLogout : _DATIM;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_UserHeader : STRUCT
	    udVersion : UDINT;
	    udUserStructSize : UDINT;
	    udNumUser : UDINT;
	    aNotDefined : ARRAY [0..6] OF DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_UserV2 : STRUCT  //! <Type Public="true" Name="t_s_UserV2"/>
	    aUsername : ARRAY [0..AccessControl_MaxUsernameLength] OF CHAR;
	    aUserPassword : ARRAY [0..AccessControl_MaxPasswordLength] OF CHAR;
	    usUserLevel : USINT;
	    udUserTimeout : UDINT;
	    aUserInfo : ARRAY [0..AccessControl_MaxUserInfoLength] OF CHAR;
	    USBSerial : t_a_USB_SerialV2;
	    LastLogin : _DATIM;
	    LastLogout : _DATIM;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_VKAccessLists : STRUCT
	    AccessList : ^_AccContList;
	    pNext : ^t_s_VKAccessLists;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_VKUser : STRUCT
	    User : t_s_UserV2;
	    pNext : ^t_s_VKUser;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	SelectFunction 	: SvrCh_DINT;
	EUserName 	: SvrChCmd_UDINT;
	EPasswordOld 	: SvrChCmd_UDINT;
	EPassword 	: SvrChCmd_UDINT;
	EPassword2 	: SvrChCmd_UDINT;
	ELevel 	: SvrCh_DINT;
	ETimeOut 	: SvrCh_UDINT;
	EInfo 	: SvrChCmd_UDINT;
	EUsbSN 	: SvrChCmd_UDINT;
	LUserName 	: SvrChCmd_UDINT;
	LPassword 	: SvrChCmd_UDINT;
	ActUser 	: SvrChCmd_UDINT;
	ActLevel 	: SvrCh_DINT;
	MSGNr 	: SvrCh_DINT;
	UserFile 	: SvrChCmd_UDINT;
	CopyUserFile 	: SvrCh_DINT;
	UserIsLoggedIn 	: SvrCh_DINT;
	LoggedInWithUsb 	: SvrCh_DINT;
	OpenMsgWindowSteps 	: SvrCh_t_e_OpenMsgWindowSteps_PTofCls__AccContMain;
	LoadRamExV2 	: SvrCh_DINT;
  //Clients:
	Deactivate 	: CltCh_DINT;
	coDriveLetter 	: CltChCmd_String;
	coFileSys 	: CltChCmd__FileSys;
	coSystem 	: CltChCmd_System;
	StrActUser 	: CltChCmd_String;
	StrEditUserName 	: CltChCmd_String;
	StrEditPassword 	: CltChCmd_String;
	StrEditPassword2 	: CltChCmd_String;
	StrEditUsbSN 	: CltChCmd_String;
	StrLoginUserName 	: CltChCmd_String;
	StrLoginPassword 	: CltChCmd_String;
	StrEditInfo 	: CltChCmd_String;
	StrUserFile 	: CltChCmd_String;
	ccEventQueue 	: CltChCmd_DINT;
	ActScreenNr 	: CltCh_UDINT;
	coGlobal 	: CltChCmd_ProjectGlobal;
	RefreshList 	: CltCh_DINT;
	StrEditPasswordOld 	: CltChCmd_String;
	ccSystemLogging 	: CltChCmd_DINT;
	AccessConfig 	: CltCh_BDINT;
	ExtUserData 	: CltChCmd_RAMex;
	Config 	: CltCh_BDINT;
  //Variables:
		ActUserBuffer 	: t_s_UserV2;
		aUserFilePath : ARRAY [0..AccessControl_MaxUserFilePathLength] OF CHAR;

		dAsyncID 	: DINT;
		dAsyncState 	: DINT;
		dErrorCode 	: DINT;
		dFileHandle 	: DINT;
		dFileLength 	: DINT;
		dFileRead 	: DINT;
		dFileTell 	: DINT;
		dFileWrite 	: DINT;
		eUserFileState 	: t_e_UserFile;
		pAccessListsBuffer 	: ^t_s_VKAccessLists;
		pActUser 	: ^t_s_VKUser;
		pBefore 	: ^t_s_VKUser;
		udNumberOfUsers 	: UDINT;
		udTimeout 	: UDINT;			//! <Variable Comment="Zeit des Logins des aktuellen Benutzers.&#13;&#10;" Name="udTimeout"/>
		UsersBuffer 	: ^t_s_VKUser;
		bCloseScreen 	: BOOL;			//! <Variable Comment="Diese Variable gibt an, ob der Benutzer nach einem Logout noch die nötige Zugriffsberechtigung auf diesen Screen hat.&#13;&#10;False .. Zugriff erlaubt&#13;&#10;True  .. Screen wird gewechselt" Name="bCloseScreen"/>
		bLogoutOldUser 	: BOOL;			//! <Variable Comment="False .. default&#13;&#10;True  .. Aktuell eingeloggter Benutzer wird ausgeloggt, da sich ein neuer per USB-Stick anmeldet." Name="bLogoutOldUser"/>
		udAddedUserDataSize 	: UDINT;			//! <Variable Comment="Aktuelle Größe der zu schreibenden Benutzerdaten im Puffer." Name="udAddedUserDataSize"/>
		pUserBuffer 	: ^t_s_UserV2;			//! <Variable Comment="Puffer zum Schreiben der Benutzerdaten." Name="pUserBuffer"/>
		udUserBufferSize 	: UDINT;			//! <Variable Comment="Größe des Puffers zum Schreiben der Benutzerdaten." Name="udUserBufferSize"/>
		pWriteUserBuffer 	: ^t_s_UserV2;			//! <Variable Comment="Schreibe-Zeiger auf den Puffer zum Schreiben der Benutzerdaten." Name="pWriteUserBuffer"/>
		Header 	: t_s_UserHeader;
		StandardUser 	: ^t_s_VKUser;
		bdAccessConfig : BDINT
		[
		  1 IgnoreScreenAccess,
		];

		bNewStickAtStart 	: BOOL;			//! <Variable Comment="TRUE if a USB-stick was already&#13;&#10;inserted at CPU-start but Memory for&#13;&#10;UsersBuffer was not yet allocated.&#13;&#10;After allocation it will be false." Name="bNewStickAtStart"/>
		bUsersBufferAllocated 	: DINT;			//! <Variable Comment="TRUE when memory for USersBuffer&#13;&#10;have been allocated otherwise FALSE" Name="bUsersBufferAllocated"/>
		aPerSerNum 	: t_a_USB_SerialV2;			//! <Variable Comment="Array to save the USB-serial number&#13;&#10;for a USB that was connected to CPU&#13;&#10;during CPU-Start" Name="aPerSerNum"/>
		IsCon_ccSystemLogging 	: BOOL;
		IsCon_ccEventQueue 	: BOOL;
		IsCon_coDriveLetter 	: BOOL;
		bCheckAccesslevel 	: BOOL;
		doWindowOpen 	: BOOL;			//! <Variable Comment="gets set to TRUE if a new Window should be &#13;&#10;opened" Name="doWindowOpen"/>
		CycleCnt 	: DINT;			//! <Variable Comment="in this Variable the cycles waiting for a new&#13;&#10;opened Window are getting counted" Name="CycleCnt"/>
		bCheckTempAdmin 	: BOOL;
		IsV1 	: BOOL;
		ActUserV1 	: t_s_User;
		FileSaved 	: BOOL;
		FileSavePath : ARRAY [0..AccessControl_MaxUserFilePathLength] OF CHAR;

		CheckHeader 	: BOOL;
		HeaderInfoOk 	: BOOL;
		IsRFIDUser 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Constructor of the class, is used for initialisation of variables and server." Name="_AccContMain"/>
	FUNCTION _AccContMain
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="In dieser Methode wird das Datei-Handling verwaltet." Name="IF_WindowRun"/>
	FUNCTION VIRTUAL GLOBAL IF_WindowRun
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowEnd
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_ChkEnable
		VAR_INPUT
			key 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="method is called right before the kernel wants to open a toucheditor&#13;&#10;the parameter &apos;pe&apos; is a pointer to structure where the whole editorinformation is shown&#13;&#10;parameter preselect is the windownumber of the editor &#13;&#10;return &apos;preselect&apos; if you want the kernel to open the editor, on the other hand 16#FFFF&#13;&#10;" Name="IF_OpenTouchEditor"/>
	FUNCTION VIRTUAL GLOBAL IF_OpenTouchEditor
		VAR_INPUT
			pe 	: ^_EDITOR;
			preselect 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
				//! <Function Comment="Add a new user." Name="AddUser"/>
	FUNCTION GLOBAL AddUser;
				//! <Function Comment="Edit the selected user." Name="EditUser"/>
	FUNCTION GLOBAL EditUser;
				//! <Function Comment="Delete the selected user." Name="DeleteUser"/>
	FUNCTION GLOBAL DeleteUser;
				//! <Function Comment="Searches a user with the username." Name="SearchUser"/>
	FUNCTION SearchUser
		VAR_INPUT
			pBuffer 	: ^t_s_VKUser;			//! <Variable Comment="Pointer to the buffer in which the user should be searched." Name="SearchUser.pBuffer"/>
			pUserName 	: ^USINT;			//! <Variable Comment="Pointer to the username which should be searched." Name="SearchUser.pUserName"/>
			pUser 	: ^t_s_UserV2;			//! <Variable Comment="Pointer to the user data, in case that he was found." Name="SearchUser.pUser"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="-1..Error&#13;&#10;&gt;=0..Ok" Name="SearchUser.retcode"/>
		END_VAR;
				//! <Function Comment="Login of a user." Name="Login"/>
	FUNCTION VIRTUAL GLOBAL Login;
				//! <Function Comment="Triggers the actualization of the userfile." Name="refreshUserFile"/>
	FUNCTION refreshUserFile;
				//! <Function Comment="Logout of the user which is actual logged in." Name="Logout"/>
	FUNCTION VIRTUAL GLOBAL Logout;
				//! <Function Comment="Reset the server values." Name="clearServers"/>
	FUNCTION clearServers;
				//! <Function Comment="Provide the user data (for example: to edit a user in the visu)&#13;&#10;&#13;&#10;Benutzerdaten bereitstellen.&#13;&#10;(zB. zum Benutzer Bearbeiten in Visu)" Name="ShowUserData"/>
	FUNCTION GLOBAL ShowUserData;
				//! <Function Comment="Is used to change the password of a user." Name="ChangePassword"/>
	FUNCTION GLOBAL ChangePassword
		VAR_INPUT
			bAdmin 	: BOOL;			//! <Variable Comment="Shows if this method was called from a logged in user or from the user managment (Admin).&#13;&#10;&#13;&#10;Gibt an, ob diese Methode von einem eingeloggten Benutzer, oder von der Benutzerverwaltung (Administrator) aus aufgerufen wurde." Name="ChangePassword.bAdmin"/>
		END_VAR
		VAR_OUTPUT
			bRet 	: BOOL;			//! <Variable Comment="FALSE..Password is not changed&#13;&#10;TRUE..Password changed" Name="ChangePassword.bRet"/>
		END_VAR;
				//! <Function Comment="Links the serial number of a plugged USB-stick with the selected user." Name="AddUsbSN"/>
	FUNCTION GLOBAL AddUsbSN;
				//! <Function Comment="Links the serial number of a plugged USB-stick with the actual logged in user." Name="AddUsbSNbyUser"/>
	FUNCTION GLOBAL AddUsbSNbyUser;
				//! <Function Comment="Deletes the USB-link of the selected user." Name="DelUsbSN"/>
	FUNCTION GLOBAL DelUsbSN;
				//! <Function Comment="Writes a value on the server MSGNr depending on a ENUM. This value will be evaluated in the Visu, depending on a text list.&#13;&#10;&#13;&#10;Schreibt anhand eines ENUMs einen Wert auf den Server MSGNr, welcher in der Visu anhand einer Textliste ausgewertet wird." Name="SetMSGNr"/>
	FUNCTION VIRTUAL GLOBAL SetMSGNr
		VAR_INPUT
			dMSGNumber 	: DINT;
		END_VAR;
				//! <Function Comment="Searches a user depending on the number and sets the input parameter pUser to the data of the found user." Name="getUserDataByNr"/>
	FUNCTION GLOBAL getUserDataByNr
		VAR_INPUT
			udUserNr 	: UDINT;			//! <Variable Comment="Number of the user which should be searched." Name="getUserDataByNr.udUserNr"/>
			pUser 	: ^t_s_UserV2;			//! <Variable Comment="Pointer to the data of a found user." Name="getUserDataByNr.pUser"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0..Ok&#13;&#10;-1..Error" Name="getUserDataByNr.retcode"/>
		END_VAR;
				//! <Function Comment="Delivers the number of users." Name="getNumberOfUsers"/>
	FUNCTION GLOBAL getNumberOfUsers
		VAR_OUTPUT
			udUsers 	: UDINT;			//! <Variable Comment="Number of users." Name="getNumberOfUsers.udUsers"/>
		END_VAR;
				//! <Function Comment="Method to register access lists." Name="RegisterAccessList"/>
	FUNCTION GLOBAL RegisterAccessList
		VAR_INPUT
			pNewAccessList 	: ^_AccContList;			//! <Variable Comment="Thispointer of the access list." Name="RegisterAccessList.pNewAccessList"/>
		END_VAR;
				//! <Function Comment="Is called when a USB-stick is plugged in. If there is a link of the serial number and a user, the user will be logged in automatically." Name="NewStick"/>
	FUNCTION GLOBAL NewStick
		VAR_INPUT
			pSerNum 	: ^void;			//! <Variable Comment="Serial number of the USB-stick." Name="NewStick.pSerNum"/>
		END_VAR;
				//! <Function Comment="Is called when a plugged in USB-stick is going to unplug. Was a user logged in with this USB-stick, then he will be logged out." Name="StickRemoved"/>
	FUNCTION GLOBAL StickRemoved
		VAR_INPUT
			pSerNum 	: ^void;			//! <Variable Comment="Serial number of the USB-stick." Name="StickRemoved.pSerNum"/>
		END_VAR;
				//! <Function Comment="Looks if a user is linked with the serial number of a plugged in USB-stick." Name="SearchUserbyUsbSN"/>
	FUNCTION SearchUserbyUsbSN
		VAR_INPUT
			pUser 	: ^t_s_UserV2;			//! <Variable Comment="In case that a user was found, this pointer points to the user data." Name="SearchUserbyUsbSN.pUser"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="-1..Error&#13;&#10;&gt;=0..Ok" Name="SearchUserbyUsbSN.retcode"/>
		END_VAR;
				//! <Function Comment="Searches a user depending on the position in the list and returns a pointer to the userdata." Name="getUserToEdit"/>
	FUNCTION getUserToEdit
		VAR_INPUT
			udPos 	: UDINT;			//! <Variable Comment="Position of the user in the list." Name="getUserToEdit.udPos"/>
		END_VAR
		VAR_OUTPUT
			pUser 	: ^t_s_UserV2;			//! <Variable Comment="Pointer to the user data, in case that a user was found." Name="getUserToEdit.pUser"/>
		END_VAR;
				//! <Function Comment="Switch to the main screen." Name="closeScreen"/>
	FUNCTION closeScreen;
				//! <Function Comment="Creates a admin with the passed data." Name="CreateAdmin"/>
	FUNCTION GLOBAL CreateAdmin
		VAR_INPUT
			pUsername 	: ^CHAR;			//! <Variable Comment="Name of the admin." Name="CreateAdmin.pUsername"/>
			pPassword 	: ^CHAR;			//! <Variable Comment="Password of the admin." Name="CreateAdmin.pPassword"/>
			usLevel 	: USINT;			//! <Variable Comment="User level of the admin." Name="CreateAdmin.usLevel"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="FALSE..Admin not created.&#13;&#10;TRUE..Admin created." Name="CreateAdmin.bSuccessful"/>
		END_VAR;
				//! <Function Comment="help function to log a text via command channel to SystemLogging" Name="LogMyText"/>
	FUNCTION LogMyText
		VAR_INPUT
			pLogTxt 	: ^CHAR;			//! <Variable Comment="pointer to the text which should be logged" Name="LogMyText.pLogTxt"/>
		END_VAR;
	
	FUNCTION SaveUsersToRamEx;
	
	FUNCTION GetLogTimesFromRamEx;
	
	FUNCTION ConvertV1UserData
		VAR_INPUT
			pUserDataV1 	: ^t_s_User;
			pUserDataV2 	: ^t_s_UserV2;
		END_VAR;
	
	FUNCTION GLOBAL getTmpAdmin
		VAR_OUTPUT
			bTmpAdmin 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL setTmpAdmin
		VAR_INPUT
			bTmpAdmin 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SetRFIDMsgNr
		VAR_INPUT
			dMSGNumber 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetActUser
		VAR_INPUT
			pUser 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL SetUserDataStrings
		VAR_INPUT
			StringSelection 	: t_e_UserDataStrings;
			pString 	: ^CHAR;
			StringLength 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL getUserDataByUser
		VAR_INPUT
			pActUser 	: ^CHAR;
			pUser 	: ^t_s_UserV2;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="This method is used to deactivate / activate the access level checking via NewInst command = 0" Name="Server0.DeactiveAccessLevel"/>
	FUNCTION Server0::DeactiveAccessLevel
		VAR_INPUT
			bCheckAccessState 	: DINT;			//! <Variable Comment="True = check access level deactivated&#13;&#10;False = check access level activated" Name="DeactiveAccessLevel.bCheckAccessState"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: IprStates;
		END_VAR;
				//! <Function Name="Server0.NewInst" Hidden="true"/>
	FUNCTION VIRTUAL GLOBAL Server0::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SelectFunction::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CopyUserFile::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using RAMex
#pragma using String
#pragma usingLtd _FileSys
#pragma usingLtd ProjectGlobal
#pragma usingLtd System


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _AccContMain::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__ACCCONTMAIN
2$UINT, 31$UINT, (SIZEOF(::_AccContMain))$UINT, 
20$UINT, 22$UINT, 0$UINT, 
TO_UDINT(4110908185), "_AccContMain", //Class
TO_UDINT(3788417926), "_Global", 0$UINT, 15$UINT, //Baseclass
//Servers:
(::_AccContMain.SelectFunction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2341012260), "SelectFunction", 
(::_AccContMain.EUserName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(692262836), "EUserName", 
(::_AccContMain.EPasswordOld.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1388793247), "EPasswordOld", 
(::_AccContMain.EPassword.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(3839842070), "EPassword", 
(::_AccContMain.EPassword2.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(4008039435), "EPassword2", 
(::_AccContMain.ELevel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1170981826), "ELevel", 
(::_AccContMain.ETimeOut.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(657934102), "ETimeOut", 
(::_AccContMain.EInfo.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2322146267), "EInfo", 
(::_AccContMain.EUsbSN.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(3035685157), "EUsbSN", 
(::_AccContMain.LUserName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2246091247), "LUserName", 
(::_AccContMain.LPassword.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1216143693), "LPassword", 
(::_AccContMain.ActUser.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2702005403), "ActUser", 
(::_AccContMain.ActLevel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3379937697), "ActLevel", 
(::_AccContMain.MSGNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(565379775), "MSGNr", 
(::_AccContMain.UserFile.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(3973173805), "UserFile", 
(::_AccContMain.CopyUserFile.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2542678631), "CopyUserFile", 
(::_AccContMain.UserIsLoggedIn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(944245539), "UserIsLoggedIn", 
(::_AccContMain.LoggedInWithUsb.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2344123189), "LoggedInWithUsb", 
(::_AccContMain.OpenMsgWindowSteps.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(983097101), "OpenMsgWindowSteps", 
(::_AccContMain.LoadRamExV2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2250538048), "LoadRamExV2", 
//Clients:
(::_AccContMain.Deactivate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4121546348), "Deactivate", 
(::_AccContMain.coDriveLetter.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2932290194), "coDriveLetter", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.coFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(940542775), "coFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::_AccContMain.coSystem.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4161038425), "coSystem", TO_UDINT(968218125), "System", 0$UINT, 1$UINT, 
(::_AccContMain.StrActUser.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3044358681), "StrActUser", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.StrEditUserName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3343489247), "StrEditUserName", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.StrEditPassword.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(181786749), "StrEditPassword", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.StrEditPassword2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(879453780), "StrEditPassword2", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.StrEditUsbSN.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1615830285), "StrEditUsbSN", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.StrLoginUserName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2057897138), "StrLoginUserName", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.StrLoginPassword.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3073721360), "StrLoginPassword", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.StrEditInfo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2384849336), "StrEditInfo", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.StrUserFile.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4017309775), "StrUserFile", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.ccEventQueue.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2793728539), "ccEventQueue", 
(::_AccContMain.ActScreenNr.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1681679496), "ActScreenNr", 
(::_AccContMain.coGlobal.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3645698641), "coGlobal", 
(::_AccContMain.RefreshList.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(788426340), "RefreshList", 
(::_AccContMain.StrEditPasswordOld.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1250624554), "StrEditPasswordOld", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_AccContMain.ccSystemLogging.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1000190998), "ccSystemLogging", 
(::_AccContMain.AccessConfig.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(571864739), "AccessConfig", 
(::_AccContMain.ExtUserData.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3782875824), "ExtUserData", TO_UDINT(933570811), "RAMex", 1$UINT, 17$UINT, 
(::_AccContMain.Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(611510522), "Config", 
END_FUNCTION


#define USER_CNT__AccContMain 48

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__AccContMain] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _AccContMain::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Global::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Global::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Global::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__AccContMain;
	vmt.CmdTable.NewInstr		:= #Server0::NewInst();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IF_WindowRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #IF_WindowEnd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #IF_ChkEnable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #IF_OpenTouchEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #Login();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #Logout();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #SetMSGNr();

#pragma warning (default : 74)
	_Global::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Global::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SelectFunction.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SelectFunction::Write() );
	IF SelectFunction.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, EUserName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	EUserName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF EUserName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, EPasswordOld.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #EPasswordOld::M_WR_DIRECT();
	EPasswordOld.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF EPasswordOld.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, EPassword.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	EPassword.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF EPassword.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, EPassword2.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	EPassword2.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF EPassword2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ELevel.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ELevel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ETimeOut.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ETimeOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, EInfo.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	EInfo.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF EInfo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, EUsbSN.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	EUsbSN.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF EUsbSN.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, LUserName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #LUserName::M_WR_DIRECT();
	LUserName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF LUserName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, LPassword.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #LPassword::M_WR_DIRECT();
	LPassword.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF LPassword.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, ActUser.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #ActUser::M_WR_DIRECT();
	ActUser.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ActUser.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, UserFile.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #UserFile::M_WR_DIRECT();
	UserFile.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF UserFile.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CopyUserFile.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CopyUserFile::Write() );
	IF CopyUserFile.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LoadRamExV2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF LoadRamExV2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _AccContMain();

END_FUNCTION

#pragma usingLtd _AccContList

//{{LSL_IMPLEMENTATION
//{{LSL_HIDDEN_FUNCTION
FUNCTION VIRTUAL GLOBAL _AccContMain::Server0::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
	CASE pPara^.uiCmd$CmdServer0 OF
		DeactiveAccessLevel:
			ret_code := DeactiveAccessLevel(pPara^.aPara[0]);
			pResult^.uiLng := 0 + sizeof(pResult^.uiLng);
	ELSE

		ret_code := _Global::NewInst(pPara, pResult);
	END_CASE;


END_FUNCTION
//}}LSL_HIDDEN_FUNCTION

#pragma UsingLtd _AccContList


FUNCTION VIRTUAL GLOBAL _AccContMain::Init

  if (_Firstscan) then
    
    // Methode der Basis-Klasse
    _Global::Init();

    //-----------------------------------------------------------------------------------------
    //  check client-connnections and set flags
    //-----------------------------------------------------------------------------------------    
    if (IsClientConnected(#ccSystemLogging)) then
      IsCon_ccSystemLogging := TRUE;
    else 
      IsCon_ccSystemLogging := FALSE;
    end_if;
    if (IsClientConnected(#ccEventQueue)) then
      IsCon_ccEventQueue := TRUE;
    else 
      IsCon_ccEventQueue := FALSE;
    end_if;
    if (IsClientConnected(#coDriveLetter)) then
      IsCon_coDriveLetter := TRUE;
    else
      IsCon_coDriveLetter := FALSE;
    end_if;

    
    //-----------------------------------------------------------------------------------------
    // Speicher für Benutzer-Puffer
    //-----------------------------------------------------------------------------------------
    pUserBuffer$^void := coSystem.Malloc(size0 := sizeof(t_s_UserV2) * AccessControl_NumUserBuffer);  //V2.29, dacpat, updated to new struct
    if (pUserBuffer = NIL) then
      LogMyText("_AccContMain::Init(): Speicher allokieren für den Puffer zum Dateischreiben fehlgeschlagen" );
      return;
    else
      // Schreibezeiger und Länge des Puffers setzen
      pWriteUserBuffer  := pUserBuffer;
      udUserBufferSize  := sizeof(t_s_UserV2) * AccessControl_NumUserBuffer;  //V2.29, dacpat, updated to new struct
    end_if;
    
    // Zeiger auf Benutzer-Puffer setzen
    pActUser := UsersBuffer;
        
    //-----------------------------------------------------------------------------------------
    // Init fertig durchlaufen, mit Dateihandling beginnen
    //-----------------------------------------------------------------------------------------
    eUserFileState := AccessControl_FILEOPENV2;  //V2.26, dacpat, try to open the new version first
    
    bdAccessConfig := AccessConfig.Read();
    
    server0 := 1;   // 1 = ready for visualization   KaiAnd, V.2.21

    //-----------------------------------------------------------------------------------------

  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContMain::IF_WindowRun
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
		event 	: ^_EVENT;
	END_VAR
  VAR
    pHelp          : ^t_s_VKAccessLists;
    tmpUserTimeout : UDINT;
    tmpUser        : t_s_UserV2;  //V2.29, dacpat, updated to new struct
    tmpUserName    : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpCount       : UDINT;
  END_VAR
  
  // **********************************************************************************************
  // *** case-instruction for Opening a new Message-Window without textbugs    *** FurLuk,V2.25 ***
  // **********************************************************************************************
  case OpenMsgWindowSteps of
    
    CheckNewMessage:
      
      if (doWindowOpen) then
        doWindowOpen := FALSE;
        OpenMsgWindowSteps := WaitCycles;
      end_if;
      
    WaitCycles:
    
      CycleCnt += 1;
      if (CycleCnt > 35) then //must not be less then 25! (internal LasalScreen)
        OpenMsgWindowSteps := OpenMessageWindow;
        CycleCnt := 0;
      end_if;
      
    OpenMessageWindow:
      
      //V2.30, dacpat, added a new window for RFID messages
      if IsRFIDUser = TRUE then
      
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_RFIDMessageWindowNr, x2:=0);
        IsRFIDUser := FALSE;
      else
      
        InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      end_if;
      //InsertCmd(x0:=CMD_NEWWINDOW, x1:=AccessControl_MessageWindowNr, x2:=0);
      OpenMsgWindowSteps := CheckNewMessage;
      
  end_case;
  // **********************************************************************************************
  
  
  
  //****************************************************************************
  //****************************************************************************
  //****      Schrittschaltwerk für das Verwalten der Benutzerdaten         ****
  //****************************************************************************
  //****************************************************************************
  case eUserFileState of
    
    //****************************************************************************
    AccessControl_IDLE:
            // Benutzerdaten erfolgreich gelesen
            
      //if a USB-stick was connected during start
      if (bNewStickAtStart & bUsersBufferAllocated) then
        NewStick(#aPerSerNum);
        bNewStickAtStart := false;
      end_if;

    //****************************************************************************        
    AccessControl_FILEOPENV2:
      // Get the file path for the new user file
      //-----------------------------------------------------------------------------------------
      if CheckHeader = TRUE then  //V2.29, dacpat, new header check for imported user files
      
        // The import user file is on the USB stick
        aUserFilePath[0] := 0;
        coDriveLetter.GetDataAt(pData:=#aUserFilePath[0], udSize:=coDriveLetter.GetLength()+1, udAt:=0);
        
        StrNCpy(p0:=#aUserFilePath[AccessControl_DriveLetterLength],
                x1:=sizeof(aUserFilePath[0]),
                p2:=AccessControl_UserFileV2,
                x3:=sizeof(_ASCII),
                ml:=AccessControl_MaxUserFilePathLength);
      else
      
        // Try opening the standard file on C:\
        StrNCpy(p0 := #aUserFilePath[0], 
                x1 := sizeof(aUserFilePath[0]), 
                p2 := AccessControl_InitDriveLetterV2, 
                x3 := sizeof(_ASCII), 
                ml := AccessControl_MaxUserFilePathLength);
        
        StrUserFile.WriteDataOff(udLen:=_strlen(#aUserFilePath[0]), udOff:=0, pData:=#aUserFilePath[0]);
      end_if;
                  
      // Datei öffnen/erstellen, wenn vorhanden diese nicht überschreiben
      dAsyncID := coFileSys.FileOpen_A(Async := 1, FileName := #aUserFilePath[0], attributes := ATT_READ_ONLY);  //V2.29, dacpat, changed attribute to read only
      eUserFileState := AccessControl_WAIT4FILEOPEN;
            
    //****************************************************************************        
    AccessControl_FILEOPEN:
      // Get the file path for the old user file
      //-----------------------------------------------------------------------------------------
      if CheckHeader = TRUE then  //V2.29, dacpat, new header check for imported user files
      
        // The import user file is on the USB stick
        aUserFilePath[0] := 0;
        coDriveLetter.GetDataAt(pData:=#aUserFilePath[0], udSize:=coDriveLetter.GetLength()+1, udAt:=0);
        
        StrNCpy(p0:=#aUserFilePath[AccessControl_DriveLetterLength],
                x1:=sizeof(aUserFilePath[0]),
                p2:=AccessControl_UserFile,
                x3:=sizeof(_ASCII),
                ml:=AccessControl_MaxUserFilePathLength);
      else
      
        // Try opening the standard file on C:\
        StrNCpy(p0 := #aUserFilePath[0], 
                x1 := sizeof(aUserFilePath[0]), 
                p2 := AccessControl_InitDriveLetter, 
                x3 := sizeof(_ASCII), 
                ml := AccessControl_MaxUserFilePathLength);
        
        //StrUserFile.WriteDataOff(udLen:=_strlen(#aUserFilePath[0]), udOff:=0, pData:=#aUserFilePath[0]);
      end_if;
                  
      // Datei öffnen/erstellen, wenn vorhanden diese nicht überschreiben
      dAsyncID := coFileSys.FileOpen_A(Async := 1, FileName := #aUserFilePath[0], attributes := ATT_READ_ONLY);  //V2.29, dacpat, changed attribute to read only
      eUserFileState := AccessControl_WAIT4FILEOPEN;
            
    //****************************************************************************
    AccessControl_WAIT4FILEOPEN:
      // Datei schon fertig geöffnet?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);
      
      case dAsyncState of
        0:
          // Fertig und geöffnet
          if (dFileHandle >= 0) then
            
            eUserFileState := AccessControl_FILELENGTH;              
          else
            if IsV1 = FALSE then  //V2.29, dacpat, try opening the old version user file when there is no new version file
            
              IsV1 := TRUE;
              eUserFileState := AccessControl_FILEOPEN;
            else
            
              if CheckHeader = TRUE then
              
                CopyUserFile := 0;  // Reset server
                CheckHeader  := FALSE;
                SetMSGNr(dMSGNumber:=ERR_COPYUSERS);  // open window with error message
              end_if;

              IsV1 := FALSE;
              LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Öffnen der Datei" );
              eUserFileState := AccessControl_IDLE; 
            end_if;              
          end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          if CheckHeader = TRUE then
          
            CopyUserFile := 0;  // Reset server
            CheckHeader := FALSE;
            SetMSGNr(dMSGNumber:=ERR_COPYUSERS);  // open window with error message
          end_if;

          IsV1 := FALSE;
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Öffnen der Datei" );
          eUserFileState := AccessControl_IDLE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        if CheckHeader = TRUE then
        
          CopyUserFile := 0;  // Reset server
          CheckHeader := FALSE;
          SetMSGNr(dMSGNumber:=ERR_COPYUSERS);  // open window with error message
        end_if;

        IsV1 := FALSE;
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Öffnen der Datei" );
        eUserFileState := AccessControl_IDLE;                                
      end_case;
               
    //****************************************************************************
    AccessControl_FILELENGTH:
      // Länge der Datei lesen
      dAsyncID := coFileSys.FileLength_A(Async := 1, handle := dFileHandle);
      eUserFileState := AccessControl_WAIT4FILELENGTH;
            
    //****************************************************************************
    AccessControl_WAIT4FILELENGTH:
      // Länge der Datei schon fertig gelesen?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileLength);
      
      case dAsyncState of
        0:
          // Fertig und geöffnet
          if (dFileLength >= 0) then
            eUserFileState := AccessControl_FILETELL;  
          else
            LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen der Dateilänge" );
            eUserFileState := AccessControl_FILECLOSE;                
          end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen der Dateilänge" );
          eUserFileState := AccessControl_FILECLOSE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen der Dateilänge" );
        eUserFileState := AccessControl_FILECLOSE;                                
      end_case;
            
    //****************************************************************************
    AccessControl_FILETELL:
      // Position des Dateizeigers lesen
      dAsyncID := coFileSys.FileTell_A(Async := 1, handle := dFileHandle);
      eUserFileState := AccessControl_WAIT4FILETELL;
            
    //****************************************************************************
    AccessControl_WAIT4FILETELL:
      // Position des Dateizeigers schon gelesen?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileTell);
      
       case dAsyncState of
        0:
          // Fertig und geöffnet
          if (dFileTell = 0) then
            eUserFileState := AccessControl_READHEADER; 
          elsif (dFileTell >= 0) then
            eUserFileState := AccessControl_FILEREAD;  
          else
            LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Holen der Position des Dateizeigers" );
            eUserFileState := AccessControl_FILECLOSE;                
          end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Holen der Position des Dateizeigers" );
          eUserFileState := AccessControl_FILECLOSE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Holen der Position des Dateizeigers" );
        eUserFileState := AccessControl_FILECLOSE;                                
      end_case;
    
    //****************************************************************************
    AccessControl_READHEADER:
      // Wenn Daten vorhanden sind und der Dateizeiger gültig ist
      //-----------------------------------------------------------------------------------------
      if ((dFileLength > 0) & (dFileTell >= 0)) then
        
        // Dateizeiger gültig
        if (dFileTell < dFileLength) then
                                          
          // Header lesen
          dAsyncID := to_dint(coFileSys.FileRead_A(Async:=1, handle:=dFileHandle, buffer:=#Header, length:=AccessControl_HeaderLength));
          eUserFileState := AccessControl_WAIT4READHEADER;
        
        else
          eUserFileState := AccessControl_FILECLOSE;
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen des Headers" );            
        end_if;
        
      else
        eUserFileState := AccessControl_FILECLOSE;
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen des Headers" );            
      end_if;
            
    //****************************************************************************
    AccessControl_WAIT4READHEADER:
      // Daten schon fertig gelesen?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileRead);
      
      
      case dAsyncState of
        0:
        // Fertig und gelesen
        //-----------------------------------------------------------------------------------------
        if (dFileRead = AccessControl_HeaderLength) then
        
          // Header entschlüsseln und speichern
          DeEncode(#Header, sizeof(t_s_UserHeader), false);
          
          // Gleicher Versionsstand?
          if (((Header.udVersion = AccessControl_Version1) & (Header.udUserStructSize = sizeof(t_s_User))) 
           | ((Header.udVersion = AccessControl_Version2) & (Header.udUserStructSize = sizeof(t_s_UserV2)))  //V2.26, dacpat, version 1 or 2 can be loaded
           & (((Header.udNumUser * Header.udUserStructSize) + sizeof(t_s_UserHeader)) =  TO_UDINT(dFileLength))) then
          
            HeaderInfoOk := TRUE;  //V2.29, dacpat, information in the file header matches, copying the file from the USB stick is ok
            
            if CheckHeader = TRUE then
            
              //V2.29, dacpat, file version in header matches, close the file and copy/import it afterwards
              eUserFileState := AccessControl_FILECLOSE;
            else
              
              // Speicher für alle Benutzer reservieren
              tmpCount := 0;
              while (tmpCount < Header.udNumUser) do
                
                // Speicher für einen weiteren Benutzer reservieren
                //-----------------------------------------------------------------------------------------
                if (UsersBuffer = NIL) then
    
                  UsersBuffer$^void := coSystem.Malloc(sizeof(t_s_VKUser));
                  UsersBuffer^.pNext := NIL;
                  pActUser := UsersBuffer;
                  tmpCount += 1;
                  bUsersBufferAllocated := TRUE;
                else
                
                  pActUser^.pNext$^void := coSystem.Malloc(size0:=sizeof(t_s_VKUser)); 
                  if (pActUser^.pNext = NIL) then
                    SetMSGNr(dMSGNumber:=ERR_MEMORY);
                    LogMyText("_AccContMain::IF_WindowRun(): Fehler beim allokieren des Speichers" );
                    return;
                  else
                    tmpCount += 1;
                    pActUser := pActUser^.pNext;
                    pActUser^.pNext := NIL;
                  end_if;
                  
                end_if;
              
              end_while;
              
              // Zeiger wieder auf den reservierten Speicherplatz für den Ersten Benutzer setzen
              pActUser       := UsersBuffer;
              eUserFileState := AccessControl_FILETELL;
            end_if;
          
          else
            // Noch Kompatibel machen für andere Versionen!!!
            //  -> bei zu kleiner Struktur defaultwerte definieren, bei zu großer den Rest einfach nicht übernehmen!
            HeaderInfoOk := FALSE;  //V2.29, dacpat, Version is not ok, dont copy any user files
            LogMyText("_AccContMain::IF_WindowRun(): Falscher Versionsstand!" );
            eUserFileState := AccessControl_FILECLOSE;
          end_if;
          
        else
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen des Headers" );
          eUserFileState := AccessControl_FILECLOSE;
        end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen des Headers" );
          eUserFileState := AccessControl_FILECLOSE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen des Headers" );
        eUserFileState := AccessControl_FILECLOSE;                                
      end_case;
            
    //****************************************************************************
    AccessControl_FILEREAD:
      // Wenn Daten vorhanden sind und der Dateizeiger gültig ist
      //-----------------------------------------------------------------------------------------
      if ((dFileLength > 0) & (dFileTell >= 0))  then
        
        // Dateiende erreicht
        if (dFileTell >= dFileLength) then
          
          // Letzten Datensatz kennzeichnen
          eUserFileState  := AccessControl_FILECLOSE;
        
        // Weiteren Benutzer lesen
        else
          // Benutzerdaten des aktuellen Benutzers lesen
          if IsV1 = TRUE then
            //V2.29, dacpat, save version 1 user data into a variable for conversion
            dAsyncID := to_dint(coFileSys.FileRead_A(Async:=1, handle:=dFileHandle, buffer:=#ActUserV1, length:=sizeof(t_s_User)));
          else
          
            dAsyncID := to_dint(coFileSys.FileRead_A(Async:=1, handle:=dFileHandle, buffer:=#pActUser^.User, length:=sizeof(t_s_UserV2)));
          end_if;
          
          eUserFileState := AccessControl_WAIT4FILEREAD;
        end_if;
        
      else
        eUserFileState := AccessControl_FILECLOSE;
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen der Benutzerdaten" );            
      end_if;
            
    //****************************************************************************
    AccessControl_WAIT4FILEREAD:
      // Daten schon fertig gelesen?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileRead);
      
      case dAsyncState of
        0:
          // Fertig und gelesen
          //-----------------------------------------------------------------------------------------
          if ((dFileRead >= 0) & (pActUser <> NIL)) then
          
            if IsV1 = TRUE then  //V2.29, dacpat, when reading a version 1 user file we have to convert the data to the new format
            
              DeEncode(#ActUserV1, sizeof(t_s_User), false);
              ConvertV1UserData(pUserDataV1 := #ActUserV1, pUserDataV2 := #pActUser^.User);
            else
            
              // Benutzerdaten entschlüsseln
              DeEncode(#pActUser^.User, sizeof(t_s_UserV2), false);
            end_if;
            
            pActUser := pActUser^.pNext;
            
            // Keine oder falsche Benutzerdaten gelesen
            //-----------------------------------------------------------------------------------------
            if (dFileRead <> sizeof(t_s_User))
             & (dFileRead <> sizeof(t_s_UserV2)) then 
              
              SetMSGNr(dMSGNumber := ERR_USERS_FILE);
              LogMyText("_AccContMain::IF_WindowRun(): Keine bzw. falsche Benutzerdaten gelesen" );
              pActUser := UsersBuffer^.pNext;
              
              // Reservierten Speicher freigeben
              while (pActUser <> NIL) do
              
                pBefore         := pActUser;
                pActUser        := pActUser^.pNext;
                udNumberOfUsers := 0;
                coSystem.Free(ptr0:=pBefore);
              
              end_while;
              
              eUserFileState := AccessControl_FILECLOSE;
            
            // Richtigen Datensatz gelesen
            //-----------------------------------------------------------------------------------------
            else
            
              udNumberOfUsers += 1;                
              eUserFileState  := AccessControl_FILETELL;
            
            end_if;
              
            else
              LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen der Benutzerdaten" );
              eUserFileState := AccessControl_FILECLOSE;
            end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen der Benutzerdaten" );
          eUserFileState := AccessControl_FILECLOSE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Lesen der Benutzerdaten" );
        eUserFileState := AccessControl_FILECLOSE;                                
      end_case;
    
    //****************************************************************************
    AccessControl_FILEREFRESH:
      // Datei aktualisieren/ersetzen
      StrNCpy(p0 := #aUserFilePath[0],  //V2.29, dacpat, set the file path again in case a version 1 file was opened before
              x1 := sizeof(aUserFilePath[0]), 
              p2 := AccessControl_InitDriveLetterV2, 
              x3 := sizeof(_ASCII), 
              ml := AccessControl_MaxUserFilePathLength);
      StrUserFile.WriteDataOff(udLen:=_strlen(#aUserFilePath[0]), udOff:=0, pData:=#aUserFilePath[0]);
      
      dAsyncID := coFileSys.FileOpen_A(Async := 1, FileName := #aUserFilePath[0], attributes := ATT_CREATE_ALWAYS);
      eUserFileState := AccessControl_WAIT4FILEREFRESH;
            
    //****************************************************************************
    AccessControl_WAIT4FILEREFRESH:
      // Datei schon fertig geöffnet?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);
      
      case dAsyncState of
        0:
          // Fertig und wieder geöffnet
            if (dFileHandle >= 0) then
            
              pActUser            := UsersBuffer;
              pWriteUserBuffer    := pUserBuffer;
              udAddedUserDataSize := 0;
              eUserFileState := AccessControl_WRITEHEADER;
                    
            else
              LogMyText("_AccContMain::IF_WindowRun(): Datei für die Benutzerdaten konnte nicht erstellt werden" );
              eUserFileState := AccessControl_FILECLOSE;
            end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          LogMyText("_AccContMain::IF_WindowRun(): Datei für die Benutzerdaten konnte nicht erstellt werden" );
          eUserFileState := AccessControl_FILECLOSE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        LogMyText("_AccContMain::IF_WindowRun(): Datei für die Benutzerdaten konnte nicht erstellt werden" );
        eUserFileState := AccessControl_FILECLOSE;                                
      end_case;
        
    //****************************************************************************
    AccessControl_WRITEHEADER:
      // Header setzen und verschlüsseln
      Header.udVersion        := AccessControl_Version2;  //V2.29, dacpat, new version
      Header.udUserStructSize := sizeof(t_s_UserV2);  //V2.29, dacpat, updated to new struct
      Header.udNumUser        := udNumberOfUsers;
      DeEncode(#Header, sizeof(t_s_UserHeader), true);
      
      dAsyncID := coFileSys.FileWrite_A(Async:=1, handle:=dFileHandle, buffer:=#Header, length:=AccessControl_HeaderLength);
      eUserFileState := AccessControl_WAIT4WRITEHEADER;
    
    //****************************************************************************
    AccessControl_WAIT4WRITEHEADER:
      // Daten schon fertig geschrieben?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileWrite);
      
      case dAsyncState of
        0:
          // Header erfolgreich geschrieben
            if (dFileWrite = AccessControl_HeaderLength) then
              if (udNumberOfUsers > 0) then
                eUserFileState := AccessControl_FILLBUFFER;
              else
              
                if udNumberOfUsers = 0 then
                  //V2.29, dacpat, file writing is done when there are no users
                  FileSaved := TRUE;
                end_if;
                eUserFileState := AccessControl_FILECLOSE;
              end_if;
                    
            else
              LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
              eUserFileState := AccessControl_FILECLOSE;
            end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
          eUserFileState := AccessControl_FILECLOSE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
        eUserFileState := AccessControl_FILECLOSE;                                
      end_case;
            
    //****************************************************************************
    AccessControl_FILLBUFFER:
      // Alle Zeilen geschrieben, Buffer voll oder Zeit abgelaufen
      //-----------------------------------------------------------------------------------------
      while (udAddedUserDataSize < udUserBufferSize) do
        
        // erster User wurde nicht in das File eingetragen, da pNext NIL ist!!
        // Abfrage gilt nur, wenn erster User eingetragen wird
        if udAddedUserDataSize = 0 then
          if ((pActUser <> NIL) & (pWriteUserBuffer <> NIL)) then
            ActUserBuffer     := pActUser^.User;
            DeEncode(#ActUserBuffer, sizeof(t_s_UserV2), true);  //V2.29, dacpat, updated to new struct
            pWriteUserBuffer^ := ActUserBuffer;
            pWriteUserBuffer  += sizeof(t_s_UserV2);  //V2.29, dacpat, updated to new struct
          end_if;
        else
          // Zeiger auf Benutzer gültig?
          if ((pActUser^.pNext <> NIL) & (pWriteUserBuffer <> NIL)) then
            
            // Änderungen des Buffers in die Datei schreiben
            ActUserBuffer     := pActUser^.pNext^.User;
            DeEncode(#ActUserBuffer, sizeof(t_s_UserV2), true);  //V2.29, dacpat, updated to new struct
            pWriteUserBuffer^ := ActUserBuffer;
            pWriteUserBuffer  += sizeof(t_s_UserV2);  //V2.29, dacpat, updated to new struct
            pActUser          := pActUser^.pNext;
            
          else
            // Alle Benutzer in den Puffer geladen
            exit;
          end_if;
        end_if;

        // Größe der aktuellen Daten im Buffer erhöhen
        udAddedUserDataSize := pWriteUserBuffer$udint - pUserBuffer$udint;
        
      end_while;
      
      eUserFileState := AccessControl_FILEWRITE;
    
    //****************************************************************************
    AccessControl_FILEWRITE:
      // Zeiger auf Benutzer gültig?
      if ((pUserBuffer <> NIL) & (udAddedUserDataSize > 0)) then
        dAsyncID := coFileSys.FileWrite_A(Async:=1, handle:=dFileHandle, buffer:=pUserBuffer, length:=udAddedUserDataSize);
        eUserFileState := AccessControl_WAIT4FILEWRITE;
      else
        eUserFileState := AccessControl_FILECLOSE;
        LogMyText("_AccContMain::IF_WindowRun(): Zeiger auf Benutzerdaten ungültig" );
      end_if;
    
    //****************************************************************************
    AccessControl_WAIT4FILEWRITE:
      // Daten schon fertig geschrieben?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileWrite);
      
      case dAsyncState of
        0:
          // alle Benutzerdaten geschrieben
            if ((pActUser^.pNext = NIL) & (dFileWrite >= 0)) then
              
              // Aktualisiere registrierte Zugriffslisten
              pHelp := pAccessListsBuffer;              
              while (pHelp <> NIL) do
                pHelp^.AccessList^.UpdateList.Write(1);
                pHelp := pHelp^.pNext;
              end_while;
              
              if IsV1 = TRUE then
                //V2.29, dacpat, set flag for deleting the old version user file
                FileSaved := TRUE;
              end_if;
              
              eUserFileState := AccessControl_FILECLOSE;
              
            elsif dFileWrite >= 0 then
            
              // Buffer für neue Daten leeren und Schreibezeiger auf Anfang setzen
              pWriteUserBuffer    := pUserBuffer;
              udAddedUserDataSize := 0;
              
              eUserFileState := AccessControl_FILLBUFFER;
            else
            
              LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
              eUserFileState := AccessControl_FILECLOSE;
              
            end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
          eUserFileState := AccessControl_FILECLOSE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Schreiben der Benutzerdaten" );
        eUserFileState := AccessControl_FILECLOSE;                                
      end_case;
            
            
    //****************************************************************************
    AccessControl_FILECLOSE:            
      dAsyncID := coFileSys.FileClose_A(Async := 1, handle := dFileHandle);
      eUserFileState := AccessControl_WAIT4FILECLOSE;
            
            
    //****************************************************************************
    AccessControl_WAIT4FILECLOSE:
      // Datei schon geschlossen?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);
      
      case dAsyncState of
        0:
          // Fertig und geschlossen
          if (dFileHandle >= 0) then
            
              if CheckHeader = TRUE then  //V2.29, dacpat, closing the file after checking the header for an import
              
                if HeaderInfoOk = TRUE then
                
                  //V2.29, dacpat, information in header is ok, copy the respective file
                  if IsV1 = TRUE then
                  
                    eUserFileState := AccessControl_IMPORTUSERSV1;
                  else
                  
                    eUserFileState := AccessControl_IMPORTUSERSV2;
                  end_if;
                else
                
                  //V2.29, dacpat, information is incorrect, don't copy
                  IsV1 := FALSE;
                  CopyUserFile := 0;  // Reset server
                  SetMSGNr(dMSGNumber:=ERR_COPYUSERS);
                  eUserFileState := AccessControl_IDLE;
                end_if;
                
                CheckHeader := FALSE;
              else
              
                //V2.29, dacpat, loading an user file after the startup
                if IsV1 = TRUE then
                
                  if FileSaved = TRUE then
                  
                    IsV1      := FALSE;
                    FileSaved := FALSE;
                    eUserFileState := AccessControl_FILEDELETE;  //V2.29, dacpat, delete old user file after the conversion
                  else
                  
                    GetLogTimesFromRamEx();
                    refreshUserFile();  //V2.29, dacpat, write a new version 2 file after reading the version 1 file
                  end_if;
                else
                
                  if HeaderInfoOk = TRUE then
                    //V2.29, dacpat, new file was loaded, get the login and logout times
                    GetLogTimesFromRamEx();
                  end_if;
                  
                  eUserFileState := AccessControl_IDLE;
                end_if;
            end_if;
          else
            
            LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Schließen der Datei" );
            eUserFileState := AccessControl_IDLE;
            
          end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          IsV1        := FALSE;  //V2.29, dacpat, reset the flags in case of an error
          FileSaved   := FALSE;
          CheckHeader := FALSE;
          LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Schließen der Datei" );
          eUserFileState := AccessControl_IDLE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        IsV1        := FALSE;  //V2.29, dacpat, reset the flags in case of an error
        FileSaved   := FALSE;
        CheckHeader := FALSE;
        LogMyText("_AccContMain::IF_WindowRun(): Fehler beim Schließen der Datei" );
        eUserFileState := AccessControl_IDLE;                                
      end_case;
    
    //****************************************************************************
    AccessControl_FILEDELETE:
    
      //V2.29, dacpat, delete the old user file after it is converted to the new version
      //or try do delete the new user file in case an old user file was imported
      if IsV1 = FALSE then
      
        // Delete the old user file
        dAsyncID := coFileSys.FileDelete_A(Async := 1, filename := AccessControl_InitDriveLetter);
        eUserFileState := AccessControl_WAIT4FILEDELETE;
      else
      
        // Delete the new user file after importing an old user file so that the old file can be loaded after the restart
        dAsyncID := coFileSys.FileDelete_A(Async := 1, filename := AccessControl_InitDriveLetterV2);
        eUserFileState := AccessControl_WAIT4FILEDELETE;
      end_if;
    
    //****************************************************************************
    AccessControl_WAIT4FILEDELETE:
    
      // Is file already deleted?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);
      
      case dAsyncState of
        0:
            // Done
            if (dFileHandle >= 0) | (dFileHandle = -9) then  // It's ok when the file doesnt exist
            
              if IsV1 = TRUE then
              
                CopyUserFile := 0;  // Reset server
                IsV1 := FALSE;
                SetMSGNr(dMSGNumber:=MSG_IMPORT_USERS_OK);
                LoadRamExV2.Write(input := TRUE);  // Set retentive Server to load RamEx data after the restart correctly
              end_if;
            else
            
              if IsV1 = TRUE then
              
                CopyUserFile := 0;  // Reset server
                IsV1 := FALSE;
                SetMSGNr(dMSGNumber:=ERR_COPYUSERS);
              end_if;
              LogMyText("_AccContMain::IF_WindowRun(): Error while deleting the old user file" );
            end_if;
            
            eUserFileState := AccessControl_IDLE;
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          if IsV1 = TRUE then
          
            CopyUserFile := 0;  // Reset server
            IsV1 := FALSE;
            SetMSGNr(dMSGNumber:=ERR_COPYUSERS);
          end_if;
          LogMyText("_AccContMain::IF_WindowRun(): Error while deleting the an user file" );
          eUserFileState := AccessControl_IDLE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        if IsV1 = TRUE then
        
          CopyUserFile := 0;  // Reset server
          IsV1 := FALSE;
          SetMSGNr(dMSGNumber:=ERR_COPYUSERS);
        end_if;
        LogMyText("_AccContMain::IF_WindowRun(): Error while deleting the an user file" );
        eUserFileState := AccessControl_IDLE;                                
      end_case;
    
    //****************************************************************************
    AccessControl_EXPORTUSERS:
    
      // V2.29, dacpat, export the new user file
      FileSavePath[0] := 0;
      coDriveLetter.GetDataAt(pData:=#FileSavePath[0], udSize:=coDriveLetter.GetLength()+1, udAt:=0);
      StrNCpy(p0:=#FileSavePath[AccessControl_DriveLetterLength],
              x1:=sizeof(FileSavePath[0]),
              p2:=AccessControl_UserFileV2,  //V2.29, dacpat, export with new file name
              x3:=sizeof(_ASCII),
              ml:=AccessControl_MaxUserFilePathLength);
        
      // Copy the user file to the USB stick
      dAsyncID := coFileSys.FileCopy_A(Async := 1, pSource := AccessControl_InitDriveLetterV2, pDest := #FileSavePath[0], udOption := 0);
      
      eUserFileState := AccessControl_WAIT4FILECOPY;
    
    //****************************************************************************
    AccessControl_WAIT4FILECOPY:
    
      // Is file already copied?
      dAsyncState := coFileSys.GetAsyncState(ID := to_udint(dAsyncID), Erg := #dFileHandle);
      
      case dAsyncState of
        0:
            // Done
            if (dFileHandle = 0) then
            
              if (CopyUserFile > 0) then
              
                // Export successful
                CopyUserFile := 0;  // Reset server
                SetMSGNr(dMSGNumber:=MSG_EXPORT_USERS_OK);
                eUserFileState := AccessControl_IDLE;
              
              elsif (CopyUserFile < 0) then
                
                if IsV1 = TRUE then
                
                  // Delete the new user file
                  eUserFileState := AccessControl_FILEDELETE;
                else
                
                  // Import sucessful
                  CopyUserFile := 0;  // Reset server
                  SetMSGNr(dMSGNumber:=MSG_IMPORT_USERS_OK);
                  eUserFileState := AccessControl_IDLE;
                end_if;
              end_if;
            
            else
            
              if (IsV1 = FALSE) & (CopyUserFile < 0) then
              
                //V2.29, dacpat, failed to import the version 2 file, try to copy the verion 1 file
                IsV1 := TRUE;
                eUserFileState := AccessControl_IMPORTUSERSV1;
              else
              
                //V2.29, dacpat, no user file available on the USB stick
                CopyUserFile := 0;  // Reset server
                IsV1 := FALSE;
                SetMSGNr(dMSGNumber:=ERR_COPYUSERS);
                LogMyText("_AccContMain::IF_WindowRun(): Error while copying the user file" );
                eUserFileState := AccessControl_IDLE;
              end_if;
            end_if;  
        
        RT_INVALID_ID,
        RT_ERG_DELETED:
          CopyUserFile := 0;  // Reset server
          IsV1 := FALSE;
          SetMSGNr(dMSGNumber:=ERR_COPYUSERS);
          LogMyText("_AccContMain::IF_WindowRun(): Error while copying the user file" );
          eUserFileState := AccessControl_IDLE;                  
          
        RT_NOT_STARTED,
        RT_IN_PROGRESS:
        
      else
        CopyUserFile := 0;  // Reset server
        IsV1 := FALSE;
        SetMSGNr(dMSGNumber:=ERR_COPYUSERS);
        LogMyText("_AccContMain::IF_WindowRun(): Error while copying the user file" );
        eUserFileState := AccessControl_IDLE;                                
      end_case;
    
    //****************************************************************************
    AccessControl_IMPORTUSERSV2:
    
      //V2.29, dacpat, build file path for the new user file
      FileSavePath[0] := 0;
      coDriveLetter.GetDataAt(pData:=#FileSavePath[0], udSize:=coDriveLetter.GetLength()+1, udAt:=0);
      StrNCpy(p0:=#FileSavePath[AccessControl_DriveLetterLength],
              x1:=sizeof(FileSavePath[0]),
              p2:=AccessControl_UserFileV2,
              x3:=sizeof(_ASCII),
              ml:=AccessControl_MaxUserFilePathLength);
      
      //Try to copy version 2 file first
      dAsyncID := coFileSys.FileCopy_A(Async := 1, pSource := #FileSavePath[0], pDest := AccessControl_InitDriveLetterV2, udOption := 0);
      
      eUserFileState := AccessControl_WAIT4FILECOPY;
    
    //****************************************************************************
    AccessControl_IMPORTUSERSV1:
    
      //V2.26, dacpat, build file path for the old user file
      FileSavePath[0] := 0;
      coDriveLetter.GetDataAt(pData:=#FileSavePath[0], udSize:=coDriveLetter.GetLength()+1, udAt:=0);
      StrNCpy(p0:=#FileSavePath[AccessControl_DriveLetterLength],
              x1:=sizeof(FileSavePath[0]),
              p2:=AccessControl_UserFile,
              x3:=sizeof(_ASCII),
              ml:=AccessControl_MaxUserFilePathLength);
      
      // try to copy the version 1 file
      dAsyncID := coFileSys.FileCopy_A(Async := 1, pSource := #FileSavePath[0], pDest := AccessControl_InitDriveLetter, udOption := 0);
      
      eUserFileState := AccessControl_WAIT4FILECOPY;
  end_case;
  
  
  // Abmeldezeit des eingeloggten Benutzers kontrollieren
  //-----------------------------------------------------------------------------------------
  if (UserIsLoggedIn & (LoggedInWithUsb = 0)) then
    
    tmpUserName[0] := 0;
    StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    if (SearchUser(pBuffer := UsersBuffer, pUserName:=#tmpUserName[0], pUser:=#tmpUser) <> -1) then
      
      // Abmeldezeit eingegeben?
      tmpUserTimeout := (tmpUser.udUserTimeout min);
      if (tmpUserTimeout <> 0) then
        
        // Abmeldezeit bei einem Event zurücksetzen
        //-----------------------------------------------------------------------------------------
        if ((event^.ftype = _EVENT_HIDPRESS) | (event^.ftype = _EVENT_KEYPRESS)) then
          udTimeout := ops.tAbsolute;
        end_if;
        
        // Zeit abgelaufen?
        //-----------------------------------------------------------------------------------------
        if ((ops.tAbsolute - udTimeout) > tmpUserTimeout) then
          Logout();
          udTimeout      := 0;
          tmpUserName[0] := 0;
        end_if;
      end_if;
    end_if;
  end_if;
  

END_FUNCTION


FUNCTION _AccContMain::refreshUserFile
  
  // Datei mit den Benutzerdaten aktualisieren (Schrittschaltwerk neu anstoßen)
  eUserFileState := AccessControl_FILEREFRESH;
  
END_FUNCTION


FUNCTION GLOBAL _AccContMain::AddUser
  VAR
    pActualVKUser : ^t_s_VKUser;
    tmpUserName   : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpPassword   : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpPWControl  : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpUserInfo   : ARRAY[0..AccessControl_MaxUserInfoLength] of CHAR;
  END_VAR
  
  tmpUserName[0]  := 0;
  tmpPassword[0]  := 0;
  tmpPWControl[0] := 0;
  tmpUserInfo[0]  := 0;
   
  StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
  StrEditPassword.GetDataAt(pData:=#tmpPassword[0], udSize:=StrEditPassword.GetLength()+1, udAt:=0);
  StrEditPassword2.GetDataAt(pData:=#tmpPWControl[0], udSize:=StrEditPassword2.GetLength()+1, udAt:=0);
  StrEditInfo.GetDataAt(pData:=#tmpUserInfo[0], udSize:=StrEditInfo.GetLength()+1, udAt:=0);
  
  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if (StrEditUserName.GetLength()) then
    
    // Benutzer existiert noch nicht
    //-----------------------------------------------------------------------------------------
    if (SearchUser(pBuffer := UsersBuffer, pUserName := #tmpUserName[0], pUser := NIL) = -1) then
      
      // Berechtigt um diese Zugriffsberechtigung zu vergeben
      if (ELevel <= ActLevel) | (IsRFIDUser = TRUE) then  //V2.30, dacpat, its allowed to add a RFID user despite no having the correct user level  // KaiAnd, V.2.18
      
        if (UsersBuffer = NIL) then
        
          if (StrCmp(p0:=#tmpPassword[0], x1:=sizeof(tmpPassword[0]), p2:=#tmpPWControl[0], x3:=sizeof(tmpPWControl[0])) = 0) then
            
            UsersBuffer$^void := coSystem.Malloc(sizeof(t_s_VKUser));
            UsersBuffer^.pNext := NIL;
            pActualVKUser := UsersBuffer;
            
            // Benutzerdaten in die Struktur speichern
            //-----------------------------------------------------------------------------------------
            StrNCpy(p0 := #pActualVKUser^.User.aUsername[0], 
                      x1 := sizeof(pActualVKUser^.User.aUsername[0]), 
                      p2 := #tmpUserName[0], 
                      x3 := sizeof(tmpUserName[0]), 
                      ml := AccessControl_MaxUsernameLength);
              StrNCpy(p0 := #pActualVKUser^.User.aUserPassword[0], 
                      x1 := sizeof(pActualVKUser^.User.aUserPassword[0]), 
                      p2 := #tmpPassword[0], 
                      x3 := sizeof(tmpPassword[0]), 
                      ml := AccessControl_MaxPasswordLength);
              StrNCpy(p0 := #pActualVKUser^.User.aUserInfo[0], 
                      x1 := sizeof(pActualVKUser^.User.aUserInfo[0]), 
                      p2 := #tmpUserInfo[0], 
                      x3 := sizeof(tmpUserInfo[0]), 
                      ml := AccessControl_MaxUserInfoLength);
              pActualVKUser^.User.usUserLevel   := TO_USINT(ELevel);
              pActualVKUser^.User.udUserTimeout := ETimeOut;
              pActualVKUser^.User.USBSerial[0]  := 0;
              
              // sprdie v2.14 - initialize date & time  of login/logout with 0 >>>
              _memset(#pActualVKUser^.User.LastLogin, 0, sizeof(_DATIM));
              _memset(#pActualVKUser^.User.LastLogout, 0, sizeof(_DATIM));
              // sprdie v2.14 <<<
              
              pActualVKUser^.pNext := NIL;
              
              udNumberOfUsers += 1;
              refreshUserFile();
            
            else
              SetMSGNr(dMSGNumber:=ERR_ADDUSER);
            end_if;
          
        else
        
          pActualVKUser := UsersBuffer;
        
          // Letzten Benutzer holen
          while (pActualVKUser^.pNext <> NIL)  do
            pActualVKUser := pActualVKUser^.pNext;
          end_while;
          
          // Passwörter auf Gleichheit überprüfen
          //-----------------------------------------------------------------------------------------
          if ((pActualVKUser <> NIL) & (StrCmp(p0:=#tmpPassword[0], x1:=sizeof(tmpPassword[0]), p2:=#tmpPWControl[0], x3:=sizeof(tmpPWControl[0])) = 0)) then     
         
            // Speicher für den neuen Benutzer allokieren
            pActualVKUser^.pNext$^void := coSystem.Malloc(sizeof(t_s_VKUser));
            if (pActualVKUser^.pNext = NIL) then
              SetMSGNr(dMSGNumber:=ERR_MEMORY);
              LogMyText("_AccContMain::AddUser(): Fehler beim allokieren des Speichers" );
              return;
            end_if;
          
            pActualVKUser := pActualVKUser^.pNext;
            
            // Benutzerdaten in die Struktur speichern
            //-----------------------------------------------------------------------------------------
            StrNCpy(p0 := #pActualVKUser^.User.aUsername[0], 
                    x1 := sizeof(pActualVKUser^.User.aUsername[0]), 
                    p2 := #tmpUserName[0], 
                    x3 := sizeof(tmpUserName[0]), 
                    ml := AccessControl_MaxUsernameLength);
            StrNCpy(p0 := #pActualVKUser^.User.aUserPassword[0], 
                    x1 := sizeof(pActualVKUser^.User.aUserPassword[0]), 
                    p2 := #tmpPassword[0], 
                    x3 := sizeof(tmpPassword[0]), 
                    ml := AccessControl_MaxPasswordLength);
            StrNCpy(p0 := #pActualVKUser^.User.aUserInfo[0], 
                    x1 := sizeof(pActualVKUser^.User.aUserInfo[0]), 
                    p2 := #tmpUserInfo[0], 
                    x3 := sizeof(tmpUserInfo[0]), 
                    ml := AccessControl_MaxUserInfoLength);
            pActualVKUser^.User.usUserLevel   := TO_USINT(ELevel);
            pActualVKUser^.User.udUserTimeout := ETimeOut;
            pActualVKUser^.User.USBSerial[0]  := 0;
            
            // sprdie v2.14 - initialize date & time  of login/logout with 0 >>>
            _memset(#pActualVKUser^.User.LastLogin, 0, sizeof(_DATIM));
            _memset(#pActualVKUser^.User.LastLogout, 0, sizeof(_DATIM));
            // sprdie v2.14 <<<
            
            pActualVKUser^.pNext := NIL;
            
            udNumberOfUsers += 1;
            refreshUserFile();
          
          else
            SetMSGNr(dMSGNumber:=ERR_ADDUSER);
          end_if;
        
      end_if;

      else
        SetMSGNr(dMSGNumber:=ERR_AUTHORITY_LEVEL);
      end_if;
      
    else
      SetMSGNr(dMSGNumber:=ERR_USER_EXISTS);
    end_if;
    
  else
    SetMSGNr(dMSGNumber:=ERR_NO_NAME); 
  end_if;
  
  IsRFIDUser := FALSE;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::EditUser
  VAR
    tmpPos         : DINT;
    pActUser       : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
    tmpUserName    : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpActUserName : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpUserInfo    : ARRAY[0..AccessControl_MaxUserInfoLength] of CHAR;
    tmpPWold       : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpOwnUser     : UINT;
    ret : DINT;
  END_VAR
  
  tmpPos         := 0;
  tmpUserName[0] := 0;
  tmpUserInfo[0] := 0;
  tmpPWold[0]    := 0;
  
  // Benutzername und Passwort holen
  StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
  StrEditInfo.GetDataAt(pData:=#tmpUserInfo[0], udSize:=StrEditInfo.GetLength()+1, udAt:=0);
  StrEditPasswordOld.GetDataAt(pData:=#tmpPWold[0], udSize:=StrEditPasswordOld.GetLength()+1, udAt:=0);
  if (UserIsLoggedIn) then
    StrActUser.GetDataAt(pData:=#tmpActUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
  end_if;
  tmpOwnUser := (StrCmp(p0:=#tmpUserName[0], x1:=sizeof(tmpUserName[0]), p2:=#tmpActUserName[0], x3:=sizeof(tmpActUserName[0])));
  
  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if (StrEditUserName.GetLength()) then
  
    tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:= #tmpUserName[0], pUser:=NIL);
    // Benutzer existiert
    if (tmpPos >= 0) then
    
      // Benutzer nur zum Bearbeiten holen
      //-----------------------------------------------------------------------------------------
      pActUser := getUserToEdit(udPos:=to_udint(tmpPos));
      // Berechtigt um diesen Benutzer zu bearbeiten bzw. den eigenen Benutzer bearbeiten
      if ((pActUser <> NIL) & ((pActUser^.usUserLevel <= ActLevel) | (tmpOwnUser = 0))) then      // KaiAnd, V.2.18
        
        // Berechtigt um diese Zugriffsberechtigung zu vergeben
        if ((ELevel <= ActLevel) | (tmpOwnUser = 0)) then       // KaiAnd, V.2.18
          
          // Passwort überprüfen
          ret := StrCmp(p0:=#tmpPWold[0], x1:=sizeof(tmpPWold[0]), p2:=#pActUser^.aUserPassword[0], x3:=sizeof(pActUser^.aUserPassword[0]));
          if (StrCmp(p0:=#tmpPWold[0], x1:=sizeof(tmpPWold[0]), p2:=#pActUser^.aUserPassword[0], x3:=sizeof(pActUser^.aUserPassword[0])) = 0) then
            
            // Neue Benutzerdaten übernehmen
//            if (ChangePassword(bAdmin:=true) = true) then
            ChangePassword(bAdmin:=TRUE);   // KaiAnd, ohne Abfrage des RET-Values
              
              StrNCpy(p0 := #pActUser^.aUsername[0], 
                      x1 := sizeof(pActUser^.aUsername[0]), 
                      p2 := #tmpUserName[0], 
                      x3 := sizeof(tmpUserName[0]), 
                      ml := AccessControl_MaxUsernameLength);
              StrNCpy(p0 := #pActUser^.aUserInfo[0], 
                      x1 := sizeof(pActUser^.aUserInfo[0]), 
                      p2 := #tmpUserInfo[0], 
                      x3 := sizeof(tmpUserInfo[0]), 
                      ml := AccessControl_MaxUserInfoLength);
              pActUser^.udUserTimeout := ETimeOut;
                
              // Der Benutzer darf sein eigenes Level nicht bearbeiten
              if ((tmpOwnUser = 0) & (pActUser^.usUserLevel <> TO_USINT(ELevel))) then
              
                SetMSGNr(dMSGNumber:=ERR_EDIT_OWNLEVEL);
              else
                pActUser^.usUserLevel := TO_USINT(ELevel);
                SetMSGNr(dMSGNumber:=MSG_EDITUSER_OK);
              end_if;
                
              refreshUserFile();
            
//           end_if;
            
          else
            SetMSGNr(dMSGNumber:=ERR_WRONG_PWOLD);
          end_if;
        
        else
          SetMSGNr(dMSGNumber:=ERR_AUTHORITY_LEVEL);
        end_if;
        
      else
        SetMSGNr(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
      end_if;
      
    else
      SetMSGNr(dMSGNumber:=ERR_USER_NOTEXIST);
    end_if;
    
  else
      SetMSGNr(dMSGNumber:=ERR_NO_NAME);
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::DeleteUser
  VAR
    tmpPos          : DINT;
    tmpCount        : DINT;
    pBefore         : ^t_s_VKUser;
    pActualVKUser   : ^t_s_VKUser;
    pActUser        : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
    tmpActUserName  : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpDelUserName  : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
  END_VAR
  
  tmpPos   := 0;
  tmpCount := 0;
  
  // Aktuellen und zu löschenden Benutzernamen holen
  StrActUser.GetDataAt(pData:=#tmpActUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
  StrEditUserName.GetDataAt(pData:=#tmpDelUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
    
  // Kontrollieren, damit der aktuell angemeldete Benutzer nicht gelöscht wird
  //-----------------------------------------------------------------------------------------
  if (StrCmp(p0:=#tmpActUserName[0], x1:=sizeof(tmpActUserName[0]), p2:=#tmpDelUserName[0], x3:=sizeof(tmpDelUserName[0]))) then

    // Benutzername angegeben
    if (StrEditUserName.GetLength()) then
      
      // Position des Benutzers holen
      //-----------------------------------------------------------------------------------------
      tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:=StrEditUserName.DataBuffer.GetDataPtr(), pUser:=NIL);
      if (tmpPos >= 0) then
        
        pActUser := getUserToEdit(udPos:=to_udint(tmpPos));
        // Berechtigt um diesen Benutzer zu löschen?
        if ((pActUser <> NIL) & (pActUser^.usUserLevel <= ActLevel)) then // KaiAnd, V.2.18

          pActualVKUser := UsersBuffer;
          
          if (tmpPos = 0) then
            // Letzten Benutzer speichern
            pBefore       := pActualVKUser;
          else
            while (tmpCount <> tmpPos) do
              tmpCount += 1;
              // Letzten Benutzer speichern
              pBefore       := pActualVKUser;
              // nächsten Benutzer holen
              pActualVKUser := pActualVKUser^.pNext;
            end_while;
          end_if;

          // Letztes Element
          if (pActualVKUser^.pNext = NIL) then
          
            // Speicher freigeben
            coSystem.Free(ptr0:=pActualVKUser);
            pBefore^.pNext := NIL;
            RefreshList.Write(input:=1);
            
          else
            
            // Speicher freigeben
            coSystem.Free(ptr0:=pActualVKUser);
            
            if (tmpPos = 0) then
              pBefore := pActualVKUser^.pNext; 
              UsersBuffer := pBefore;
            else
              pBefore^.pNext := pActualVKUser^.pNext; 
            end_if;

          end_if;;
        
          udNumberOfUsers -= 1;
          pActualVKUser   := NIL;
          if (udNumberOfUsers = 0) then
            UsersBuffer := NIL;
          end_if;
          refreshUserFile();
        
        else
          SetMSGNr(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
        end_if;
        
      else
        SetMSGNr(dMSGNumber:=ERR_USER_NOTEXIST);
      end_if;
      
    else
      SetMSGNr(dMSGNumber:=ERR_NO_NAME);
    end_if;
    
  else
    SetMSGNr(dMSGNumber:=ERR_DELUSER);
  end_if;
  
END_FUNCTION
  

FUNCTION GLOBAL _AccContMain::ShowUserData
  VAR
    tmpPos    : DINT;
    tmpUser   : t_s_UserV2;  //V2.29, dacpat, updated to new struct
  END_VAR
  
  tmpPos := -1;

  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if (StrEditUserName.GetLength()) then
  
      // Position des Benutzers holen
      //-----------------------------------------------------------------------------------------
      tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:=StrEditUserName.DataBuffer.GetDataPtr(), pUser:=#tmpUser);
      if (tmpPos >= 0) then
      
        // Benutzerdaten kopieren
        StrEditUserName.WriteDataOff(udLen:=_strlen(#tmpUser.aUsername[0]), udOff:=0, pData:=#tmpUser.aUsername[0]);
        StrEditPasswordOld.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPassword.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPassword2.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditInfo.WriteDataOff(udLen:=_strlen(#tmpUser.aUserInfo[0]), udOff:=0, pData:=#tmpUser.aUserInfo[0]);
        ELevel   := tmpUser.usUserLevel;
        ETimeOut := tmpUser.udUserTimeout;
        
      else
        
        // Leere Daten kopieren
        StrEditUserName.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPasswordOld.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPassword.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditPassword2.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        StrEditInfo.WriteDataOff(udLen:=1, udOff:=0, pData:="");
        ELevel   := 0;
        ETimeOut := 0;
        
        SetMSGNr(dMSGNumber:=ERR_USER_NOTEXIST);
        
      end_if;
    
  else
  
    SetMSGNr(dMSGNumber:=ERR_NO_NAME);
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::ChangePassword
	VAR_INPUT
		bAdmin 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bRet 	: BOOL;
	END_VAR
  VAR
  	tmpUserName   : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpPassword   : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpPWControl  : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpUser       : t_s_UserV2;  //V2.29, dacpat, updated to new struct
    pActUser      : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
    tmpPos        : DINT;
    tmpPW1Length  : UDINT;
    tmpPW2Length  : UDINT;
  END_VAR
  
  bRet            := false;
  tmpUserName[0]  := 0;
  tmpPassword[0]  := 0;
  tmpPWControl[0] := 0;
  pActUser        := NIL;
  tmpPos          := 0;
  
  // Benutzer eingeloggt oder Benutzerverwaltung
  //-----------------------------------------------------------------------------------------
  if ((UserIsLoggedIn = true) | (bAdmin = true)) then
    
    // Benutzername und Passwörter holen
    if (bAdmin = true) then
      StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
    else
      StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    end_if;
    tmpPW1Length := StrEditPassword.GetLength()+1;
    tmpPW2Length := StrEditPassword2.GetLength()+1;
    StrEditPassword.GetDataAt(pData:=#tmpPassword[0], udSize:=tmpPW1Length, udAt:=0);
    StrEditPassword2.GetDataAt(pData:=#tmpPWControl[0], udSize:=tmpPW2Length, udAt:=0);
    
    // Soll das PW geändert werden?
    //-----------------------------------------------------------------------------------------
    if ((tmpPW1Length > 1) & (tmpPW2Length > 1)) then
    
      // Geändertes Passwort richtig eingegeben?
      //-----------------------------------------------------------------------------------------
      if (StrCmp(p0:=#tmpPassword[0], x1:=sizeof(tmpPassword[0]), p2:=#tmpPWControl[0], x3:=sizeof(tmpPWControl[0])) = 0) then
        
        // Position des Benutzers holen
        tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:= #tmpUserName[0], pUser:=#tmpUser);
        if (tmpPos >= 0) then
                  
          // Benutzerdaten anhand der Position holen und neues Passwort setzen
          //-----------------------------------------------------------------------------------------
          pActUser := getUserToEdit(udPos:=to_udint(tmpPos));
          if (pActUser <> NIL) then
          
            StrNCpy(p0 := #pActUser^.aUserPassword[0], 
                    x1 := sizeof(pActUser^.aUserPassword[0]), 
                    p2 := #tmpPassword[0], 
                    x3 := sizeof(tmpPassword[0]), 
                    ml := AccessControl_MaxPasswordLength);
            if (bAdmin = false) then
              refreshUserFile();
            end_if;
            SetMSGNr(dMSGNumber:=MSG_PWCHANGE_OK);
            bRet := true;
            
          end_if;
          
        else
        
          SetMSGNr(dMSGNumber:=ERR_USER_NOTEXIST);
        
        end_if;
        
      else
      
        SetMSGNr(dMSGNumber:=ERR_WRONG_PWCHANGE);
      
      end_if;
    
    else
      
      // Passwort nicht geändert
      bRet := FALSE;
      
    end_if;
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContMain::SelectFunction::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
 
	SelectFunction := input;

  //*****************************************************************************
  //** Jeweilige Funktion ausgewählt                                           **
  //*****************************************************************************
  case SelectFunction of
    
    // Legt einen neuen Benutzer an
    1:  AddUser();
        clearServers();
    
    // Löscht den ausgewählten Benutzer
    2:  DeleteUser();
        clearServers();
    
    // Bearbeitet den ausgewählten Benutzer
    3:  EditUser();
        clearServers();
    
    // Login
    4:  Login();
        clearServers();
    
    // Logout
    5:  Logout();
        clearServers();
    
    // Schreibt die Benutzerdaten des ausgewählten Benutzers auf die Server zum Bearbeiten
    6:  ShowUserData();
    
    // Ändert das Passwort des ausgewählten Benutzers
    7:  ChangePassword(bAdmin:=false);
        clearServers();
    
    // Verknüpft die Seriennummer des aktuellen Speichermediums mit dem eingeloggten Benutzer
    8:  AddUsbSN();
        clearServers();
    
    // Verknüpft die Seriennummer des aktuellen Speichermediums mit dem eingeloggten Benutzer
    9:  AddUsbSNbyUser();
        clearServers();
    
    // Löscht die Verknüpfung der Seriennummer mit dem aktuellen Speichermedium
    10: DelUsbSN();
        clearServers();
       
    // Löscht alle Benutzerdaten auf den Servern
    11: clearServers();
        
    
    // Springt auf den vorherigen Bildschirm
    12: closeScreen();
    
    // V2.30, dacpat, RFID Login
    13:  IsRFIDUser := TRUE;
         Login();
         clearServers();
    
    // V2.30, dacpat, RFID Add User
    14:  IsRFIDUser := TRUE;
         AddUser();
         clearServers();
    
  end_case;

 	result := SelectFunction;
  SelectFunction := 0;

END_FUNCTION


FUNCTION _AccContMain::SearchUser
	VAR_INPUT
		pBuffer 	: ^t_s_VKUser;
		pUserName 	: ^USINT;
		pUser   : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpPos        : DINT;
    pActualVKUser : ^t_s_VKUser;
  END_VAR
  
  retcode := -1;
  
  if (pBuffer = NIL) then
    return;
  end_if;;  
  
  tmpPos  := 0;
  
  pActualVKUser := pBuffer; 
  
  // Benutzer anhand des Benutzernamens suchen
  //-----------------------------------------------------------------------------------------
  while (pActualVKUser <> NIL) do
  
    tmpPos += 1;
    if (StrCmp(p0:=#pActualVKUser^.User.aUsername[0], x1:=sizeof(pActualVKUser^.User.aUsername[0]), p2:=pUserName, x3:=sizeof(_ASCII)) = 0) then
      
      // Benutzerdaten zurückgeben
      if (pUser <> NIL) then
        pUser^ := pActualVKUser^.User;
      end_if;

      retcode := tmpPos-1;
      exit;
      
    else
    
      pActualVKUser := pActualVKUser^.pNext;
      retcode       := -1;
    
    end_if;
    
  end_while;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContMain::Login
  VAR
    tmpUser       : t_s_UserV2;  //V2.29, dacpat, updated to new struct
    tmpUserName   : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpPassword   : ARRAY[0..AccessControl_MaxPasswordLength] of CHAR;
    tmpScreenInfo : ^_PRJ_ENTRY;    
    NiGive	      : CmdStruct;
    NiGet         : Results;
    tmpPos        : DINT;
    pEditUser     : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
  END_VAR
  
  tmpUserName[0] := 0;
  tmpPassword[0] := 0;

  // Benutzername und Passwort holen
  StrLoginUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrLoginUserName.GetLength()+1, udAt:=0);
  StrLoginPassword.GetDataAt(pData:=#tmpPassword[0], udSize:=StrLoginPassword.GetLength()+1, udAt:=0);
  
  // Benutzername angegeben?
  //-----------------------------------------------------------------------------------------
  if (StrLoginUserName.GetLength()) then
  (*
    // Administrator holen
    if UsersBuffer = NIL then
        
      //UsersBuffer$^void := coSystem.Malloc(sizeof(t_s_VKUser));
      //UsersBuffer^.pNext := NIL;
      //tmpUser := UsersBuffer^.User;
      
    else
    
      tmpUser := UsersBuffer^.User;
    
    end_if;
    *)
    
    _memset(dest:=#tmpUser, usByte:=0, cntr:=sizeof(t_s_UserV2));  //V2.29, dacpat, updated to new struct
    
    // Wenn der Benutzer existiert oder sich der Administrator einloggt
    //-----------------------------------------------------------------------------------------
    // sprdie v2.24 - save pos of user if normal user logged in
    tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:=#tmpUserName[0], pUser:=#tmpUser);
    if ( (tmpPos >= 0) | 
         (SearchUser(pBuffer := StandardUser, pUserName:=#tmpUserName[0], pUser:=#tmpUser) >= 0) ) then
     
      // Passwort überprüfen
      if (StrCmp(p0:=#tmpUser.aUserPassword[0], x1:=sizeof(tmpUser.aUserPassword[0]), p2:=#tmpPassword[0], x3:=sizeof(tmpPassword[0])) = 0) then
        
        // Wenn ein anderer Benutzer eingeloggt ist, diesen ausloggen
        if (UserIsLoggedIn = true) then
          bLogoutOldUser := true;
          Logout();
          bLogoutOldUser := false;
        end_if;
       
        // Neuen Benutzer einloggen
        StrActUser.WriteDataOff(udLen:=_strlen(#tmpUser.aUsername[0]), udOff:=0, pData:=#tmpUser.aUsername[0]);
        ActLevel       := tmpUser.usUserLevel;
        UserIsLoggedIn := true;
        
        // Login als Event speichern
        if (IsCon_ccEventQueue = True) then
          NiGive.uiCmd    := 7;               // Command AddUserLoginLogout()
          NiGive.aPara[0] := (#tmpUser.aUsername[0])$DINT;
          NiGive.aPara[1] := ActLevel;
          NiGive.aPara[2] := TO_DINT(TRUE);
          ccEventQueue.NewInst(#NiGive, #NiGet);
        end_if;
        
        // sprdie v2.24 - save login date & time of user
        if tmpPos >= 0 then
          pEditUser := getUserToEdit(tmpPos$UDINT);
          get_DATIM(#pEditUser^.LastLogin);
        end_if;
        
        // Zeit beim Login speichern (für Abmeldezeit)
        udTimeout := ops.tAbsolute;
        
        // Soll Benutzer-Level überprüft werden?
        if (bdAccessConfig.IgnoreScreenAccess = 0) then
          
          // Neuer Benutzer berechtigt auf diesem Screen zu sein?
          tmpScreenInfo := Prj_GetEntryByNo(x0:=to_uint(ActScreenNr.Read()), x1:=_PE_PICTURE);
          if ((tmpScreenInfo <> NIL) & (tmpScreenInfo^.access > ActLevel)) then
            bCloseScreen := true;
            closeScreen();
            SetMSGNr(dMSGNumber:=ERR_NO_SCREEN_ACCESS);
            IsRFIDUser := FALSE;
            return;
          end_if;
          
        end_if;
    
        // Seite refreshen
        IsRFIDUser := FALSE;
        InsertCmd(x0:=CMD_NEWPICTURE, x1:=to_dint(ActScreenNr.Read()), x2:=0);
      
      else
      
        IsRFIDUser := FALSE;
        SetMSGNr(dMSGNumber:=ERR_WRONG_PASS);
        
      end_if;
    
    else
    
      //V2.30, dacpat, a new RFID can be added to the user list when the user doesnt exist
      if IsRFIDUser = TRUE then
      
        // Allow the RFID user to be added to the user list.
        SetMSGNr(dMSGNumber := MSG_RFID_ADDUSER);
      else
      
        // Normal user handling
        SetMSGNr(dMSGNumber:=ERR_USER_NOTEXIST);
      end_if;
      //SetMSGNr(dMSGNumber:=ERR_USER_NOTEXIST);
    
    end_if;
    
  else
    
    IsRFIDUser := FALSE;
    SetMSGNr(dMSGNumber:=ERR_NO_NAME);
    
  end_if;

  SaveUsersToRamEx();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContMain::Logout
  VAR
    tmpUserName   : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpScreenInfo : ^_PRJ_ENTRY;
    NiGive        : CmdStruct;
    NiGet         : Results;
    tmpPos        : DINT;
    pEditUser     : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
    tmpUser       : t_s_UserV2;  //V2.29, dacpat, updated to new struct
  END_VAR
  
  // Logout als Event speichern
  //-----------------------------------------------------------------------------------------
  tmpUserName[0] := 0;  
  StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
  if (IsCon_ccEventQueue = True) then
    NiGive.uiCmd    := 7;               // Command AddUserLoginLogout()
    NiGive.aPara[0] := (#tmpUserName[0])$DINT;
    NiGive.aPara[1] := ActLevel;
    NiGive.aPara[2] := TO_DINT(FALSE);
    ccEventQueue.NewInst(#NiGive, #NiGet);
  end_if;
  
  // sprdie v2.24 - save date & time of logout
  tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:=#tmpUserName[0], pUser:=#tmpUser);
  if tmpPos >= 0 then
    pEditUser := getUserToEdit(tmpPos$UDINT);
    get_DATIM(#pEditUser^.LastLogout);
  end_if;

  // Aktuelle Benutzerdaten zurücksetzen
  //-----------------------------------------------------------------------------------------
  StrActUser.WriteDataOff(udLen:=1, udOff:=0, pData:="");
  ActLevel        := 0;
  UserIsLoggedIn  := false;
  LoggedInWithUsb := false;
  
  // Soll Benutzer-Level überprüft werden?
  if (bdAccessConfig.IgnoreScreenAccess = 0) then
    
    // Benutzer berechtigt auf diesem Bildschirm zu sein?
    tmpScreenInfo := Prj_GetEntryByNo(x0:=to_uint(ActScreenNr.Read()), x1:=_PE_PICTURE);
    if ((bLogoutOldUser = false) & (tmpScreenInfo <> NIL) & (tmpScreenInfo^.access > ActLevel)) then
      bCloseScreen := true;
      closeScreen();
      SetMSGNr(dMSGNumber:=ERR_NO_SCREEN_ACCESS);
    end_if;
    
  end_if;
  RefreshList.Write(input:=1);  
  SaveUsersToRamEx();  
  
END_FUNCTION


FUNCTION _AccContMain::clearServers

  // Alle Server zurücksetzen/löschen
  //-----------------------------------------------------------------------------------------
  StrEditPasswordOld.Clear();
  StrEditPassword.Clear();
  StrEditPassword2.Clear();
  StrEditUserName.Clear();
  StrEditInfo.Clear();
  StrLoginPassword.Clear();
  StrLoginUserName.Clear();
  ELevel   := 0;
  ETimeOut := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContMain::SetMSGNr
	VAR_INPUT
		dMSGNumber 	: DINT;
	END_VAR
  
  // Info für Pop-Up Fenster in der Visualisierung 
  MSGNr := dMSGNumber;
  doWindowOpen := TRUE;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::getUserDataByNr
	VAR_INPUT
		udUserNr 	: UDINT;
		pUser 	: ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpPos        : UDINT;
    pActualVKUser : ^t_s_VKUser;
  END_VAR
  
  tmpPos  := 0;
  pActualVKUser := UsersBuffer; 
  
  // Übergabeparameter ok?
  //-----------------------------------------------------------------------------------------
  if ((pUser <> NIL) & (udUserNr >= 0)) then
  
    // Benutzer anhand der Nummer suchen
    //-----------------------------------------------------------------------------------------
    while ((tmpPos <> udUserNr) & (pActualVKUser <> NIL) & (pActualVKUser^.pNext <> NIL)) do

      tmpPos        += 1;
      pActualVKUser := pActualVKUser^.pNext;
      
    end_while;
    
    // Gefundene Benutzerdaten gültig?
    //-----------------------------------------------------------------------------------------
    if (pActualVKUser <> NIL) then
      pUser^  := pActualVKUser^.User;
      retcode := 0;
    else
      retcode := -1;
    end_if;
    
  else
  
    retcode := -1;
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::getNumberOfUsers
	VAR_OUTPUT
		udUsers 	: UDINT;
	END_VAR
  
  udUsers := udNumberOfUsers;

END_FUNCTION


FUNCTION _AccContMain::getUserToEdit
	VAR_INPUT
		udPos 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pUser 	: ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
	END_VAR
  VAR
  	pActualVKUser : ^t_s_VKUser;
    tmpCount      : UDINT;
  END_VAR
  
  pActualVKUser := UsersBuffer;
  tmpCount := 0;
  pUser    := NIL;
  
  // Suche Benutzer anhand der Position
  //-----------------------------------------------------------------------------------------
  while ((pActualVKUser <> NIL) & (tmpCount <> udPos)) do
    tmpCount += 1;
    pActualVKUser := pActualVKUser^.pNext;
  end_while;
  
  // Benutzerdaten zurückgeben (nicht den Administrator -> pos = 0) 
  //-----------------------------------------------------------------------------------------
  if (tmpCount >= 0) then
    pUser := #pActualVKUser^.User;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::RegisterAccessList
	VAR_INPUT
		pNewAccessList 	: ^_AccContList;
	END_VAR
  VAR
  	pHelp  : ^t_s_VKAccessLists;
  END_VAR
  
  // Registrierte Zugriffsliste für Aktualisierung
  //-----------------------------------------------------------------------------------------
  if (pNewAccessList <> NIL) then
    
    // Speicher leer
    if (pAccessListsBuffer = NIL) then
    
      pAccessListsBuffer$^void := coSystem.Malloc(size0:=sizeof(t_s_VKAccessLists));
      if (pAccessListsBuffer = NIL) then
        SetMSGNr(dMSGNumber:=ERR_MEMORY);
        LogMyText("_AccContMain::RegisterAccessList(): Fehler beim allokieren des Speichers" );
        return;
      end_if;
      pAccessListsBuffer^.AccessList := pNewAccessList;
      pAccessListsBuffer^.pNext      := NIL;
    
    else
      
      // Das Ende der Liste finden
      pHelp := pAccessListsBuffer;
      while (pHelp^.pNext <> NIL) do
        pHelp := pHelp^.pNext;
      end_while;
      
      // Speicher für die Zugriffsliste allokieren
      pHelp^.pNext$^void := coSystem.Malloc(size0:=sizeof(t_s_VKAccessLists));
      if (pHelp^.pNext = NIL) then
        SetMSGNr(dMSGNumber:=ERR_MEMORY);
        LogMyText("_AccContMain::RegisterAccessList(): Fehler beim allokieren des Speichers" );
        return;
      end_if;
      pHelp^.pNext^.AccessList := pNewAccessList;
      pHelp^.pNext^.pNext      := NIL;
      
    end_if;
  end_if;

END_FUNCTION


FUNCTION _AccContMain::_AccContMain
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
  // Server
  LoggedInWithUsb     := false;
  UserIsLoggedIn      := false;
  ELevel              := 0;
  ETimeOut            := 0;
  // Variablen
  pAccessListsBuffer  := NIL;
  UsersBuffer  := NIL;
  StandardUser := NIL;
  udNumberOfUsers     := 0;
  dErrorCode          := MSG_NO_ERR;
  
	ret_code            := C_OK;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::NewStick
	VAR_INPUT
		pSerNum 	: ^void;
	END_VAR
  VAR
  	User : t_s_UserV2;  //V2.29, dacpat, updated to new struct
  END_VAR

  StrEditUsbSN.WriteDataOff(udLen:=_strlen(pSerNum$^CHAR), udOff:=0, pData:=pSerNum$^CHAR);
  
  // Seriennummer des USB-Sticks mit vorhandenen Benutzerdaten vergleichen
  //-----------------------------------------------------------------------------------------
  if (SearchUserbyUsbSN(#User) >= 0) then
  
    StrLoginUserName.WriteDataOff(udLen:=_strlen(#User.aUsername[0]), udOff:=0, pData:=#User.aUsername[0]);
    StrLoginPassword.WriteDataOff(udLen:=_strlen(#User.aUserPassword[0]), udOff:=0, pData:=#User.aUserPassword[0]);
    Login();
    clearServers();
    LoggedInWithUsb := true;
  
  elsif (!!bUsersBufferAllocated) then
    bNewStickAtStart := TRUE;
    aPerSerNum := pSerNum$^t_a_USB_SerialV2^;  //V2.29, dacpat, updated to new struct
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::StickRemoved
	VAR_INPUT
		pSerNum 	: ^void;
	END_VAR
  VAR
  	tmpUser     : t_s_UserV2;  //V2.29, dacpat, updated to new struct
    tmpUserName : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
  END_VAR
  
  tmpUserName[0] := 0;  
  
  // Nur wenn ein Benutzer mit dem USB-Stick eingeloggt ist
  //-----------------------------------------------------------------------------------------
  if (LoggedInWithUsb = true) then
  
    StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    
    // Benutzerdaten holen
    if (SearchUser(pBuffer := UsersBuffer, pUserName:=#tmpUserName[0], pUser:=#tmpUser) >= 0) then
      
      // Wenn die Seriennummer identisch ist
      if (StrCmp(p0:=#tmpUser.USBSerial[0], x1:=sizeof(tmpUser.USBSerial[0]), p2:=pSerNum$^CHAR, x3:=sizeof(_ASCII)) = 0) then
      
        Logout();
        clearServers();
        LoggedInWithUsb := false;

      end_if;
  
    end_if;
  
  end_if;
  
  StrEditUsbSN.Clear(); 

END_FUNCTION


FUNCTION _AccContMain::SearchUserbyUsbSN
	VAR_INPUT
		pUser 	: ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpPos        : DINT;
    pActualVKUser : ^t_s_VKUser;
    tmpEditUsbSN  : Array[0..AccessControl_MaxUSBSNLengthV2] of CHAR;  //V2.29, dacpat, extended serial number length
  END_VAR
  
  retcode         := -1;
  tmpPos          := 0;
  tmpEditUsbSN[0] := 0;
  pActualVKUser   := UsersBuffer;
  
  if (pActualVKUser = NIL) then
    return;
  end_if; 
  
  if (StrEditUsbSN.GetLength() + 1) <= sizeof(tmpEditUsbSN) then  //V2.29, dacpat, check if the data fits into the array or not
  
    StrEditUsbSN.GetDataAt(pData:=#tmpEditUsbSN[0], udSize:=(StrEditUsbSN.GetLength() + 1), udAt:=0);
  else
  
    return;
  end_if;
  
  // Nach der Seriennummer suchen
  //-----------------------------------------------------------------------------------------
  while pActualVKUser <> NIL do
    
    tmpPos += 1;
    // Gleiche Seriennummer gefunden
    if (StrCmp(p0:=#pActualVKUser^.User.USBSerial[0], x1:=sizeof(pActualVKUser^.User.USBSerial[0]), p2:=#tmpEditUsbSN[0], x3:=sizeof(tmpEditUsbSN[0])) = 0) then
      
      // Benutzerdaten holen
      if (pUser <> NIL) then
        pUser^ := pActualVKUser^.User;
      end_if;
      
      retcode := tmpPos-1;
      exit;
      
    else
    
      pActualVKUser := pActualVKUser^.pNext;
      retcode := -1;
    
    end_if;
    
  end_while;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::AddUsbSNbyUser
  VAR
    tmpUserName : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
  END_VAR
  
  tmpUserName[0] := 0;
  
  // Eingeloggten Benutzer mit der Seriennummer des USB-Sticks verknüpfen
  //-----------------------------------------------------------------------------------------
  if (UserIsLoggedIn = true) then
  
    StrActUser.GetDataAt(pData:=#tmpUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    StrEditUserName.WriteDataOff(udLen:=_strlen(#tmpUserName[0]), udOff:=0, pData:=#tmpUserName[0]);
    AddUsbSN();
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::AddUsbSN
  VAR
    tmpPos      : DINT;
    pActUser    : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
    pOldUserSN      : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
    tmpUserName     : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpActUserName  : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpNewPos       : DINT;
    tmpOwnUser      : UINT;
  END_VAR
  
  if UserIsLoggedIn then
    StrActUser.GetDataAt(pData:=#tmpActUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
  end_if;
  
  tmpPos          := 0;
  pActUser        := NIL;
  tmpUserName[0]  := 0;
  tmpNewPos       := 0;
  
  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if (StrEditUserName.GetLength()) then
  
    // Benutzername und dessen Position holen
    StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
    tmpNewPos := SearchUser(pBuffer := UsersBuffer, pUserName:= #tmpUserName[0], pUser:=NIL);
    
    // Benutzer gefunden
    //-----------------------------------------------------------------------------------------
    if (tmpNewPos >= 0) then
    
      // Wenn ein USB-Stick mit einem Benutzer verknüpft werden soll, muss der Benutzer manuell eingeloggt sein
      if ((LoggedInWithUsb = false) & (StrEditUsbSN.GetLength() > 0)) then
        
        //Benutzerdaten anhand der Position holen
        pActUser := getUserToEdit(udPos:=to_udint(tmpNewPos));
        tmpOwnUser := (StrCmp(p0:=#pActUser^.aUsername[0], x1:=sizeof(pActUser^.aUsername[0]), p2:=#tmpActUserName[0], x3:=sizeof(tmpActUserName[0])));
        if (pActUser <> NIL) & ((pActUser^.usUserLevel < ActLevel) | (tmpOwnUser = 0)) then
        
          // Wenn dieser USB-Stick schon mit einem anderen Benutzer verknüpft ist, lösche diese Verbindung
          tmpPos := SearchUserbyUsbSN(pUser:=NIL);
          if (tmpPos >= 0) then
            // Benutzerdaten anhand der Position holen
            pOldUserSN := getUserToEdit(udPos:=to_udint(tmpPos));
            if (StrCmp(p0:=#pActUser^.USBSerial[0], x1:=sizeof(pActUser^.USBSerial[0]), p2:=#pOldUserSN^.USBSerial[0], x3:=sizeof(pOldUserSN^.USBSerial[0])) <> 0) then
             
              if (pOldUserSN <> NIL) & ((pOldUserSN^.usUserLevel < ActLevel) | (StrCmp(p0:=#pOldUserSN^.aUsername[0], x1:=sizeof(pOldUserSN^.aUsername[0]), p2:=#tmpActUserName[0], x3:=sizeof(tmpActUserName[0])) = 0)) then
                pOldUserSN^.USBSerial[0] := 0;
              else
                SetMSGNr(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
                return;
              end_if;
             
            else
              SetMSGNr(dMSGNumber:=ERR_USB_SERNUM);
            end_if;
           
          end_if;
          
          // Seriennummer des USB-Sticks speichern
          StrEditUsbSN.GetDataAt(pData:=#pActUser^.USBSerial[0], udSize:=StrEditUsbSN.GetLength()+1, udAt:=0);
          refreshUserFile();
        
        else
        
          SetMSGNr(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
      
        end_if;
      else
        
        SetMSGNr(dMSGNumber:=ERR_USB_SERNUM);
      
      end_if;
      
    else
    
      SetMSGNr(dMSGNumber:=ERR_USER_NOTEXIST);
    
    end_if;
    
  else
      
    SetMSGNr(dMSGNumber:=ERR_NO_NAME);
    
  end_if;
      
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContMain::IF_WindowEnd
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
	END_VAR
  
  // Alle Server beim Schließen eines Fensters zurücksetzen
  //-----------------------------------------------------------------------------------------
  if (whoami^.ima <> IMA_TOUCHEDITOR) then
  
    clearServers();
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::DelUsbSN
  VAR
    tmpPos         : DINT;
    tmpOwnUser     : UINT;
    pActUser       : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
    tmpUserName    : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
    tmpActUserName : ARRAY[0..AccessControl_MaxUsernameLength] of CHAR;
  END_VAR
  
  tmpPos            := 0;
  pActUser          := NIL;
  tmpUserName[0]    := 0;
  tmpActUserName[0] := 0;
  
  // Benutzername angegeben
  //-----------------------------------------------------------------------------------------
  if (StrEditUserName.GetLength()) then
  
    StrEditUserName.GetDataAt(pData:=#tmpUserName[0], udSize:=StrEditUserName.GetLength()+1, udAt:=0);
    StrActUser.GetDataAt(pData:=#tmpActUserName[0], udSize:=StrActUser.GetLength()+1, udAt:=0);
    
    // Position des Benutzers holen
    tmpPos := SearchUser(pBuffer := UsersBuffer, pUserName:=#tmpUserName[0], pUser:=NIL);
    if (tmpPos >= 0) then
      
      // Benutzerdaten anhand der Position holen
      pActUser := getUserToEdit(to_udint(tmpPos));
      tmpOwnUser := (StrCmp(p0:=#tmpUserName[0], x1:=sizeof(tmpUserName[0]), p2:=#tmpActUserName[0], x3:=sizeof(tmpActUserName[0])));
      if ( (pActUser <> NIL) & ((tmpOwnUser) | ((tmpOwnUser = 0) & (LoggedInWithUsb = 0))) &
         (StrLen(txt:=#pActUser^.USBSerial[0], size:=sizeof(pActUser^.USBSerial[0])) <> 0) ) then
        
        // Berechtigt um diesen Benutzer zu bearbeiten bzw. den eigenen Benutzer bearbeiten 
        if ((pActUser^.usUserLevel < ActLevel) | (tmpOwnUser = 0)) then
          pActUser^.USBSerial[0] := 0;
          refreshUserFile();     
        else
          SetMSGNr(dMSGNumber:=ERR_AUTHORITY_EDITUSER);
        end_if;     

      else
        
        SetMSGNr(dMSGNumber:=ERR_DEL_USB_SERNUM);
      
      end_if;
      
    else
      
      SetMSGNr(dMSGNumber:=ERR_USER_NOTEXIST);
        
    end_if;
    
  else
      
    SetMSGNr(dMSGNumber:=ERR_NO_NAME);
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContMain::CopyUserFile::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	CopyUserFile := input;
  
  // Exportieren/Importieren der Benutzerdatei auf einen USB-Speicher 
  //-----------------------------------------------------------------------------------------
  if (CopyUserFile <> 0) then
    
    // USB-Speichermedium auch angeschlossen?
    //-----------------------------------------------------------------------------------------
    if (IsCon_coDriveLetter = TRUE) then          // KaiAnd, V.2.22

      //if ( (coDriveLetter.GetLength() > 0) & 
      //     (StrEditUsbSN.GetLength() > 0) ) then  // KaiAnd, V.2.22
        
      if (coDriveLetter.GetLength() > 0) then  // V2.31: without check of UsbSerialNumber

        //V2.29, dacpat, reworked write method, file copying etc. is now done in bg task
        if (eUserFileState = AccessControl_IDLE) then
        
          if (CopyUserFile > 0) then
            // V2.29, dacpat, export with new file name
            eUserFileState := AccessControl_EXPORTUSERS;
          else
            // V2.29, dacpat, check version in file header before importing the file
            CheckHeader    := TRUE;
            eUserFileState := AccessControl_FILEOPENV2;
          end_if;
        end_if;
      
      else  // coDriveLetter with empty string
        CopyUserFile := 0;
        SetMSGNr(dMSGNumber:=ERR_NO_DRIVE);
      end_if;
    
    else  // coDriveLetter client not connected
      CopyUserFile := 0;
      SetMSGNr(dMSGNumber:=ERR_NO_DRIVE);
    end_if;
    
  end_if;
  
  result := CopyUserFile;

END_FUNCTION


FUNCTION _AccContMain::closeScreen
    
  // Benutzer befindet sich auf einem Screen, ohne korrekte Zugangsberechtigung
  if ((bCloseScreen = true) & (bdAccessConfig.IgnoreScreenAccess = 0)) then  
    
    // Kehre zum Start-Bildschirm zurück
    InsertCmd(x0:=CMD_NEWPICTURE, x1:=coGlobal.GetStartPicture(), x2:=0);
    bCloseScreen := false;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _AccContMain::CreateAdmin
	VAR_INPUT
		pUsername 	: ^CHAR;
		pPassword 	: ^CHAR;
		usLevel 	: USINT;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  
  //Rückgabewert initialisieren
  bSuccessful := FALSE;
  
  if (StandardUser = NIL) then
        
    StandardUser$^void := coSystem.Malloc(sizeof(t_s_VKUser));
    StandardUser^.pNext := NIL;
    
  end_if;  
  
  //Benutzerdaten gültig?
  if ((pUsername <> NIL) & (pPassword <> NIL) & (usLevel <> NIL)) then
  
    StrNCpy(p0 := #StandardUser^.User.aUsername[0], 
            x1 := sizeof(StandardUser^.User.aUsername[0]), 
            p2 := pUsername,                          
            x3 := sizeof(_ASCII),
            ml := AccessControl_MaxUsernameLength);
    StrNCpy(p0 := #StandardUser^.User.aUserPassword[0], 
            x1 := sizeof(StandardUser^.User.aUserPassword[0]), 
            p2 := pPassword,                                  
            x3 := sizeof(_ASCII), 
            ml := AccessControl_MaxPasswordLength);
    StandardUser^.User.usUserLevel   := usLevel;       
    StandardUser^.User.udUserTimeout := 0;
      
    bSuccessful := true;
    
    // HerMor V.2.27: Set Flag true
    setTmpAdmin(true);
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AccContMain::IF_ChkEnable
	VAR_INPUT
		key 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := false;
  
  // Zugangsebenen deaktiviert (frei zugänglich)
  //-----------------------------------------------------------------------------------------
  if (Deactivate = true) then
  
    retcode := true;
  
  // Zugangsebenen über NewInst() deaktiviert (frei zugänglich)
  //-----------------------------------------------------------------------------------------
  elsif (bCheckAccesslevel = TRUE) then
  
    retcode := true;
  
  // Zugangscode prüfen
  //-----------------------------------------------------------------------------------------
  elsif (ActLevel >= key) then
  
    retcode := true;
 
  end_if;

END_FUNCTION


FUNCTION _AccContMain::LogMyText
  VAR_INPUT
		pLogTxt 	: ^CHAR;
	END_VAR

  VAR
    NiGive	  : CmdStruct;
    NiGet     : Results;
  END_VAR

  if ((IsCon_ccSystemLogging = True) & (pLogTxt <> NIL)) then

    NiGive.uiCmd    := 0;               // Command
    NiGive.aPara[0] := (pLogTxt)$DINT;  // pointer to text

    ccSystemLogging.NewInst(#NiGive, #NiGet);

  end_if;

END_FUNCTION


FUNCTION _AccContMain::DeactiveAccessLevel
	VAR_INPUT
		bCheckAccessState 	: DINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  
  // SchDom V 2.23: Deacivate check accesslevel
  if (bCheckAccessState = TRUE) then
    bCheckAccesslevel := TRUE;
  else
    bCheckAccesslevel := FALSE;
  end_if;
  
	ret_code := READY;
  
END_FUNCTION


FUNCTION _AccContMain::SaveUsersToRamEx
  VAR
    i     : UINT;
    pRead : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
  END_VAR
  
  ExtUserData.SetSize(udSize:=sizeof(t_s_UserV2)*udNumberOfUsers);  //V2.29, dacpat, updated to new struct
  
  // loop through users and save to SRAM
  i := 0;
  repeat
  
    pRead := getUserToEdit(udPos:=i);
    
    if pRead <> NIL then
      ExtUserData.SetDataAt(pData:=pRead$^USINT, udSize:=sizeof(t_s_UserV2), udAt:=i*sizeof(t_s_UserV2));  //V2.29, dacpat, updated to new struct
    end_if;
    
    i += 1;
    
  until (pRead = NIL) end_repeat;
  

END_FUNCTION


FUNCTION _AccContMain::GetLogTimesFromRamEx
  VAR
    pReadV1      : ^t_s_User;
    pReadV2      : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
    pWrite       : ^t_s_UserV2;  //V2.29, dacpat, updated to new struct
    dWriteIndex  : DINT;
    noUsers      : UINT;
    i            : UINT;
  END_VAR

  if IsV1 = TRUE & LoadRamExV2 = FALSE then  //V2.29, dacpat, check if version 1 should be used
  
    pReadV1$^USINT := ExtUserData.GetDataPtr(); // for reading purposes only!!!
    noUsers := to_uint(ExtUserData.m_udLength / sizeof(t_s_User));
    
    if (pReadV1 <> NIL) & (noUsers > 0) then
      for i:=0 to (noUsers-1) do 
      
        dWriteIndex := SearchUser(pBuffer:=UsersBuffer, pUserName:=#pReadV1^.aUsername[0], pUser:=NIL);
        
        if dWriteIndex >= 0 then
          pWrite := getUserToEdit(to_udint(dWriteIndex));
          if pWrite <> NIL then        
            pWrite^.LastLogin  := pReadV1^.LastLogin;
            pWrite^.LastLogout := pReadV1^.LastLogout;
          end_if;
        end_if;
          
        pReadV1 += sizeof(t_s_User);     
      end_for;
    
      // Save the users to RamEx in the new format after reading the old format
      SaveUsersToRamEx();
    end_if;
  else
  
    pReadV2$^USINT := ExtUserData.GetDataPtr(); // for reading purposes only!!!
    noUsers := to_uint(ExtUserData.m_udLength / sizeof(t_s_UserV2));
    
    if (pReadV2 <> NIL) & (noUsers > 0) then
      for i:=0 to (noUsers-1) do 
      
        dWriteIndex := SearchUser(pBuffer:=UsersBuffer, pUserName:=#pReadV2^.aUsername[0], pUser:=NIL);
        
        if dWriteIndex >= 0 then
          pWrite := getUserToEdit(to_udint(dWriteIndex));
          if pWrite <> NIL then        
            pWrite^.LastLogin  := pReadV2^.LastLogin;
            pWrite^.LastLogout := pReadV2^.LastLogout;
          end_if;
        end_if;
          
        pReadV2 += sizeof(t_s_UserV2);      
      end_for;
      
      LoadRamExV2.Write(input := FALSE);
    end_if;
  end_if;

END_FUNCTION


// HerMor V2.27: 
FUNCTION GLOBAL _AccContMain::getTmpAdmin
	VAR_OUTPUT
		bTmpAdmin 	: BOOL;
	END_VAR
  
  bTmpAdmin := bCheckTempAdmin;

END_FUNCTION


// HerMor V2.27:
FUNCTION GLOBAL _AccContMain::setTmpAdmin
	VAR_INPUT
		bTmpAdmin 	: BOOL;
	END_VAR
  
  bCheckTempAdmin := bTmpAdmin;

END_FUNCTION


// HerMor V.2.28:
FUNCTION VIRTUAL GLOBAL _AccContMain::IF_OpenTouchEditor
	VAR_INPUT
		pe 	: ^_EDITOR;
		preselect 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  
  VAR
  	CheckASCII : BDINT;
  END_VAR
  
  CheckASCII := Config.Read();
 
  //Überprüfen, ob Config-Bit0 gesetzt ist (NUR SETZTEN WENN FILEEXPLORER IMPLEMENTIERT IST!!)
  if (CheckASCII AND 2#1) then
    // Tastatur wird geändert wenn nur ASCII Zeichen erlaubt sind 
    if (VarList_GetOnlyAscii(x0 := #pe^.variable.info) = TRUE) then 
      // Eingabe nur ASCII 
      if (preselect = _WIN_EDITOR_ANUMERIC) then 
        // ASCII Tastatur aufrufen 
        preselect := _WIN_EDITOR_ANUMFILEX; 
      end_if; 
    end_if; 
  end_if;

  retcode := preselect; 

END_FUNCTION


FUNCTION _AccContMain::ConvertV1UserData
	VAR_INPUT
		pUserDataV1 	: ^t_s_User;
		pUserDataV2 	: ^t_s_UserV2;
	END_VAR
  
  //V2.29, dacpat, convert the old user data into the new format
  
  // User name
  //-----------------------------------------------------------------------------------------
  StrNCpy(p0 := #pUserDataV2^.aUsername[0], 
          x1 := sizeof(pUserDataV2^.aUsername[0]), 
          p2 := #pUserDataV1^.aUsername[0],                          
          x3 := sizeof(_ASCII),
          ml := AccessControl_MaxUsernameLength);
  
  // User password
  //-----------------------------------------------------------------------------------------
  StrNCpy(p0 := #pUserDataV2^.aUserPassword[0], 
          x1 := sizeof(pUserDataV2^.aUserPassword[0]), 
          p2 := #pUserDataV1^.aUserPassword[0],                          
          x3 := sizeof(_ASCII),
          ml := AccessControl_MaxPasswordLength);
  
  // User level
  //-----------------------------------------------------------------------------------------
  pUserDataV2^.usUserLevel := pUserDataV1^.usUserLevel;
  
  // User timeout
  //-----------------------------------------------------------------------------------------
  pUserDataV2^.udUserTimeout := pUserDataV1^.udUserTimeout;
  
  // User info
  //-----------------------------------------------------------------------------------------
  StrNCpy(p0 := #pUserDataV2^.aUserInfo[0], 
          x1 := sizeof(pUserDataV2^.aUserInfo[0]), 
          p2 := #pUserDataV1^.aUserInfo[0],                          
          x3 := sizeof(_ASCII),
          ml := AccessControl_MaxUserInfoLength);
  
  // User serial number
  //-----------------------------------------------------------------------------------------
  StrNCpy(p0 := #pUserDataV2^.USBSerial[0], 
          x1 := sizeof(pUserDataV2^.USBSerial[0]), 
          p2 := #pUserDataV1^.USBSerial[0],                          
          x3 := sizeof(_ASCII),
          ml := AccessControl_MaxUSBSNLength);
  
  // User last login
  //-----------------------------------------------------------------------------------------
  pUserDataV2^.LastLogin := pUserDataV1^.LastLogin;
  
  // User last logout
  //-----------------------------------------------------------------------------------------
  pUserDataV2^.LastLogout := pUserDataV1^.LastLogout;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::SetRFIDMsgNr
	VAR_INPUT
		dMSGNumber 	: DINT;
	END_VAR
  
  //V2.30, dacpat, new method to open the new window for special RFID messages
  
  IsRFIDUser := TRUE;  // Set flag to open different message window
  SetMSGNr(dMSGNumber := dMSGNumber);

END_FUNCTION


FUNCTION GLOBAL _AccContMain::GetActUser
  VAR_INPUT
		pUser 	: ^CHAR;
	END_VAR
  VAR
  	tmpUser : ARRAY [0..AccessControl_MaxUsernameLength] of CHAR;
    tmpSize : UDINT;
  END_VAR
  
  //V2.30, dacpat, new method to get usernam of the currently logged in  user
  
  tmpSize := StrActUser.GetLength();
  
  if tmpSize > AccessControl_MaxUsernameLength then
  
    tmpSize := AccessControl_MaxUsernameLength;
  end_if;
  
  StrActUser.GetDataAt(pData  := #tmpUser[0],
                       udSize := tmpSize,
                       udAt   := 0);
  
  tmpUser[tmpSize] := 0;
  
  // Copy the ActUser to the given pointer
  StrNCpy(p0 := pUser, 
          x1 := sizeof(_ASCII), 
          p2 := #tmpUser[0],                          
          x3 := sizeof(_ASCII),
          ml := AccessControl_MaxUsernameLength);

END_FUNCTION


FUNCTION GLOBAL _AccContMain::SetUserDataStrings
	VAR_INPUT
		StringSelection 	: t_e_UserDataStrings;
		pString 	: ^CHAR;
		StringLength 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: UDINT;
	END_VAR
  VAR
  	tmpSize : UDINT;
  END_VAR
  
  //V2.30, dacpat, new method to be able to set the different embedde strings from another class
  
  Retcode := 0;
  
  if pString <> NIL then
  
    case StringSelection of
    
      // StrEditUserName
      //-----------------------------------------------------------------------------------------
      UserData_StrEditUserName:
        // Check the string size
        if StringLength > AccessControl_MaxUsernameLength then
        
          tmpSize := AccessControl_MaxUsernameLength;
        else
        
          tmpSize := StringLength;
        end_if;
        
        StrEditUserName.WriteDataOff(udLen := tmpSize,
                                     udOff := 0,
                                     pData := pString);
      
      // StrEditPasswordOld
      //-----------------------------------------------------------------------------------------
      UserData_StrEditPasswordOld:
        // Check the string size
        if StringLength > AccessControl_MaxPasswordLength then
        
          tmpSize := AccessControl_MaxPasswordLength;
        else
        
          tmpSize := StringLength;
        end_if;
        
        StrEditPasswordOld.WriteDataOff(udLen := tmpSize,
                                        udOff := 0,
                                        pData := pString);
      
      // StrEditPassword
      //-----------------------------------------------------------------------------------------
      UserData_StrEditPassword:
        // Check the string size
        if StringLength > AccessControl_MaxPasswordLength then
        
          tmpSize := AccessControl_MaxPasswordLength;
        else
        
          tmpSize := StringLength;
        end_if;
        
        StrEditPassword.WriteDataOff(udLen := tmpSize,
                                     udOff := 0,
                                     pData := pString);
      
      // StrEditPassword2
      //-----------------------------------------------------------------------------------------
      UserData_StrEditPassword2:
        // Check the string size
        if StringLength > AccessControl_MaxPasswordLength then
        
          tmpSize := AccessControl_MaxPasswordLength;
        else
        
          tmpSize := StringLength;
        end_if;
        
        StrEditPassword2.WriteDataOff(udLen := tmpSize,
                                      udOff := 0,
                                      pData := pString);
      
      // StrEditInfo
      //-----------------------------------------------------------------------------------------
      UserData_StrEditInfo:
        // Check the string size
        if StringLength > AccessControl_MaxUserInfoLength then
        
          tmpSize := AccessControl_MaxUserInfoLength;
        else
        
          tmpSize := StringLength;
        end_if;
        
        StrEditInfo.WriteDataOff(udLen := tmpSize,
                                 udOff := 0,
                                 pData := pString);
      
      // StrLoginUserName
      //-----------------------------------------------------------------------------------------
      UserData_StrLoginUserName:
        // Check the string size
        if StringLength > AccessControl_MaxUsernameLength then
        
          tmpSize := AccessControl_MaxUsernameLength;
        else
        
          tmpSize := StringLength;
        end_if;
        
        StrLoginUserName.WriteDataOff(udLen := tmpSize,
                                      udOff := 0,
                                      pData := pString);
      
      // StrLoginPassword
      //-----------------------------------------------------------------------------------------
      UserData_StrLoginPassword:
        // Check the string size
        if StringLength > AccessControl_MaxPasswordLength then
        
          tmpSize := AccessControl_MaxPasswordLength;
        else
        
          tmpSize := StringLength;
        end_if;
        
        StrLoginPassword.WriteDataOff(udLen := tmpSize,
                                      udOff := 0,
                                      pData := pString);
      
      else
      
        Retcode := DEFSCOPE;
        LogMyText("_AccContMain::SetUserDataStrings(): Invalid string selection");
    end_case;
  else
  
    Retcode := DEFSCOPE;
    LogMyText("_AccContMain::SetUserDataStrings(): Invalid string pointer");
  end_if;

END_FUNCTION


FUNCTION GLOBAL _AccContMain::getUserDataByUser
	VAR_INPUT
		pActUser 	: ^CHAR;
		pUser 	: ^t_s_UserV2;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpPos : DINT;
  END_VAR
  
  //V2.30, dacpat, new method to get the user informations by using the username
  
  retcode := FALSE;
  
  if pActUser <> NIL & pUser <> NIL then
  
    tmpPos := SearchUser(pBuffer   := UsersBuffer,
                         pUserName := pActUser,
                         pUser     := pUser);
    
    if tmpPos >= 0 then
    
      // User was found
      retcode := TRUE;
    else
    
      // User is not in the buffer
      LogMyText("_AccContMain::getUserDataByUser(): User was not found in the buffer");
    end_if;                   
  else
  
    LogMyText("_AccContMain::getUserDataByUser(): Invalid pointer");
  end_if;

END_FUNCTION
