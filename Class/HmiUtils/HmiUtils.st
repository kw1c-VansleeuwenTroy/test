//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Source\Common\hmi_nuc.h"

(*!
<Class
	Name               = "HmiUtils"
	Revision           = "0.2"
	GUID               = "{A4A65825-AE84-4556-82CD-4E7A89C49A46}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{2DA162DA-C4DE-43A9-89F0-DCEFD693C03B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\Common\hmi_nuc.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.2" Date="2016-05-20" Author="kolott" Company="sigmatek" Description="sa26785: compilerversion 60, property preceding zero implemented"/>
		<Dokumentation Revision="0.1" Date="2014-08-06" Author="kolott" Company="sigmatek" Description="functions init_SCHEME() and free_SCHEME() added"/>
	</RevDoku>
</Class>
*)
HmiUtils : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiUtils::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMIUTILS
0$UINT, 2$UINT, (SIZEOF(::HmiUtils))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(4154992490), "HmiUtils", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiUtils.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
END_FUNCTION


#define USER_CNT_HmiUtils 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiUtils] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiUtils::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION GLOBAL init_HMI_CHKBIT VAR_INPUT ptr : ^HMI_CHKBIT; END_VAR
  ptr^.no     := HMI_DEFCHKBIT;
  ptr^.invert := 0;
END_FUNCTION

FUNCTION GLOBAL free_HMI_CHKBIT VAR_INPUT ptr : ^HMI_CHKBIT; END_VAR
  init_HMI_CHKBIT(ptr);
END_FUNCTION

FUNCTION GLOBAL init_HMI_ANYTHING VAR_INPUT ptr : ^HMI_ANYTHING; END_VAR
  ptr^.ima   := HMI_IMA_GARNIX; 
  ptr^.value := HMI_DEFVALUE; 
END_FUNCTION

FUNCTION GLOBAL free_HMI_ANYTHING VAR_INPUT ptr : ^HMI_ANYTHING; END_VAR
  init_HMI_ANYTHING(ptr); 
END_FUNCTION

FUNCTION GLOBAL init_HMI_VARINFO VAR_INPUT ptr : ^HMI_VARINFO; END_VAR
  ptr^.station    := 0; 
  ptr^.reftime    := 0; 
  ptr^.access     := HMI_DEFACCESS; 
  ptr^.vartype    := HMI_FREE; 
  ptr^.subtype    := 0; 
  init_HMI_ANYTHING(#ptr^.limit_hi); 
  init_HMI_ANYTHING(#ptr^.limit_lo); 
  init_HMI_ANYTHING(#ptr^.text1); 
  init_HMI_ANYTHING(#ptr^.unitschema);
  ptr^.scope      := HMI_DEFSCOPE;
  init_HMI_CHKBIT(#ptr^.chkbit);
  ptr^.parabit16  := 0;
  ptr^.flags      := 0;
  ptr^.lasalid    := 0;            // lasalid 
  ptr^.index35    := HMI_DEFSCOPE; // offset auf daten in reflist
  ptr^.escm_index35 := HMI_DEFSCOPE; // offset auf daten in reflist
  ptr^.oldval     := -2147483648;  // init wert
//  ptr^.enumidx    := 0xFFFF;
END_FUNCTION

FUNCTION GLOBAL free_HMI_VARINFO VAR_INPUT ptr : ^HMI_VARINFO; END_VAR
  init_HMI_VARINFO(ptr); 
END_FUNCTION

FUNCTION GLOBAL init_HMI_ROOM VAR_INPUT ptr : ^HMI_ROOM; END_VAR
  ptr^.xy1.x := 0; 
  ptr^.xy1.y := 0; 
  ptr^.xy2.x := 0; 
  ptr^.xy2.y := 0; 
END_FUNCTION

FUNCTION GLOBAL free_HMI_ROOM VAR_INPUT ptr : ^HMI_ROOM; END_VAR
  init_HMI_ROOM(ptr);
END_FUNCTION

FUNCTION GLOBAL init_HMI_XUNIT VAR_INPUT ptr : ^HMI_XUNIT; END_VAR
  init_HMI_ANYTHING(#ptr^.digits);
  ptr^.digits.ima     := HMI_IMA_DINT_CONSTANT;
  ptr^.digits.value   := 9;
  init_HMI_ANYTHING(#ptr^.posdezpt);
  ptr^.posdezpt.ima   := HMI_IMA_DINT_CONSTANT;
  ptr^.posdezpt.value := 0; 
  ptr^.formula        := 0; 
  init_HMI_ANYTHING(#ptr^.text); 
  ptr^.leading0      := HMI_DEFAULT;
END_FUNCTION

FUNCTION GLOBAL free_HMI_XUNIT VAR_INPUT ptr : ^HMI_XUNIT; END_VAR
  free_HMI_ANYTHING(#ptr^.digits);
  free_HMI_ANYTHING(#ptr^.posdezpt);
  free_HMI_ANYTHING(#ptr^.text);
  init_HMI_XUNIT(ptr);
END_FUNCTION

FUNCTION GLOBAL init_HMI_PRJINFO VAR_INPUT ptr : ^HMI_PRJINFO; END_VAR
  init_HMI_ANYTHING(#ptr^.ima); 
  ptr^.access := HMI_DEFACCESS; 
  init_HMI_CHKBIT(#ptr^.chkbit); 
  ptr^.name[0] := 0; 
END_FUNCTION

FUNCTION GLOBAL free_HMI_PRJINFO VAR_INPUT ptr : ^HMI_PRJINFO; END_VAR
  free_HMI_ANYTHING(#ptr^.ima); 
  free_HMI_CHKBIT(#ptr^.chkbit); 
  init_HMI_PRJINFO(ptr);
END_FUNCTION

FUNCTION GLOBAL init_HMI_SCHEMELINE VAR_INPUT ptr : ^HMI_SCHEMELINE; END_VAR
  init_HMI_ANYTHING(#ptr^.any);
  ptr^.operator := SCHEMEOP_EQUAL;
  ptr^.op2      := -1;
END_FUNCTION

FUNCTION GLOBAL free_HMI_SCHEMELINE VAR_INPUT ptr : ^HMI_SCHEMELINE; END_VAR
  free_HMI_ANYTHING(#ptr^.any);
  init_HMI_SCHEMELINE(ptr);
END_FUNCTION

FUNCTION GLOBAL init_HMI_SCHEME VAR_INPUT ptr : ^HMI_SCHEME; END_VAR
  ptr^.no       := 0;
  ptr^.ptr      := NIL;
  ptr^.serverno := HMI_DEFSCOPE;
  ptr^.index35  := HMI_DEFSCOPE;
END_FUNCTION

FUNCTION GLOBAL free_HMI_SCHEME VAR_INPUT ptr : ^HMI_SCHEME; END_VAR
  init_HMI_SCHEME(ptr);
END_FUNCTION

FUNCTION GLOBAL init_HMI_FCTLINE VAR_INPUT ptr : ^HMI_FCTLINE; END_VAR
  ptr^.qbef := HMI_QNOP;
  init_HMI_ANYTHING(#ptr^.op1);
  init_HMI_ANYTHING(#ptr^.op2);
END_FUNCTION

FUNCTION GLOBAL free_HMI_FCTLINE VAR_INPUT ptr : ^HMI_FCTLINE; END_VAR
  free_HMI_ANYTHING(#ptr^.op1);
  free_HMI_ANYTHING(#ptr^.op2);
  init_HMI_FCTLINE(ptr);
END_FUNCTION

FUNCTION GLOBAL init_HMI_CTRL_CIRCLE VAR_INPUT ptr : ^HMI_CTRL_CIRCLE; END_VAR
  init_HMI_ROOM(#ptr^.room);
	init_HMI_CHKBIT(#ptr^.chkbit);
	ptr^.color  := 0;;
	ptr^.attrib := 0;
	ptr^.angle := 0;
	ptr^.arc   := 3600;
END_FUNCTION

FUNCTION GLOBAL free_HMI_CTRL_CIRCLE VAR_INPUT ptr : ^HMI_CTRL_CIRCLE; END_VAR
  free_HMI_ROOM(#ptr^.room);
	free_HMI_CHKBIT(#ptr^.chkbit);
  init_HMI_CTRL_CIRCLE(ptr);
END_FUNCTION

FUNCTION GLOBAL init_HMI_CTRL_IMAGE VAR_INPUT ptr : ^HMI_CTRL_IMAGE; END_VAR
  init_HMI_ROOM(#ptr^.room);
  init_HMI_CHKBIT(#ptr^.chkbit);
  init_HMI_ANYTHING(#ptr^.any);
  ptr^.colorback := 0;  
  ptr^.attrib    := 0;
END_FUNCTION

FUNCTION GLOBAL free_HMI_CTRL_IMAGE VAR_INPUT ptr : ^HMI_CTRL_IMAGE; END_VAR
  free_HMI_ROOM(#ptr^.room); 
  free_HMI_CHKBIT(#ptr^.chkbit); 
  init_HMI_CTRL_IMAGE(ptr); 
END_FUNCTION

FUNCTION GLOBAL init_HMI_GFUNCT VAR_INPUT ptr : ^HMI_GFUNCT; END_VAR
  init_HMI_ANYTHING(#ptr^.pos_edge);  
  init_HMI_ANYTHING(#ptr^.neg_edge);  
  ptr^.triggertype := 0;  
END_FUNCTION

FUNCTION GLOBAL free_HMI_GFUNCT VAR_INPUT ptr : ^HMI_GFUNCT; END_VAR
  free_HMI_ANYTHING(#ptr^.pos_edge);  
  free_HMI_ANYTHING(#ptr^.neg_edge);  
  init_HMI_GFUNCT(ptr);
END_FUNCTION

FUNCTION GLOBAL init_HMI_CTRL_IO VAR_INPUT pio : ^HMI_CTRL_IO; END_VAR
  init_HMI_ROOM(#pio^.room); 
  init_HMI_CHKBIT(#pio^.chkbit); 
  pio^.attrib       := 0;
  pio^.font         := HMI_DEFFONT;
  pio^.color_back   := 0;
  pio^.color_text   := 1;
  init_HMI_ANYTHING(#pio^.server);
  init_HMI_ANYTHING(#pio^.anything1);
  init_HMI_ANYTHING(#pio^.anything2);
  init_HMI_ANYTHING(#pio^.anything3);
  init_HMI_ANYTHING(#pio^.anything4);
  pio^.iotype       := HMI_IOT_DEFAULT;
  pio^.writeprotect := true;
  pio^.access       := HMI_DEFACCESS; 
  pio^.enterplus    := 0;
  pio^.frame        := HMI_DEFFRAME;
  
  pio^.hotkey       := 0;
  init_HMI_GFUNCT(#pio^.gfunct);
  pio^.setval       := 1;
  pio^.resetval     := 0;
  pio^.act_momntry  := false;
  pio^.no_myio      := 0xFFFFFFFF;
  pio^.imagealign   := 0;
  pio^.selector     := 0;
    
//  pio^.flags        := 0;
  pio^.h_next       := 0;
  pio^.v_next       := 0;
  
END_FUNCTION

FUNCTION GLOBAL free_HMI_CTRL_IO VAR_INPUT pio : ^HMI_CTRL_IO; END_VAR
  init_HMI_CTRL_IO(pio);
END_FUNCTION

FUNCTION GLOBAL init_HMI_CTRL_RECTANGLE VAR_INPUT ptr : ^HMI_CTRL_RECTANGLE; END_VAR
  init_HMI_ROOM(#ptr^.room); 
  init_HMI_CHKBIT(#ptr^.chkbit); 
  ptr^.color  := 0;  
  ptr^.attrib := 0;
  ptr^.frame        := HMI_DEFFRAME;
END_FUNCTION

FUNCTION GLOBAL free_HMI_CTRL_RECTANGLE VAR_INPUT ptr : ^HMI_CTRL_RECTANGLE; END_VAR
  free_HMI_ROOM(#ptr^.room);
  free_HMI_CHKBIT(#ptr^.chkbit);
  init_HMI_CTRL_RECTANGLE(ptr); 
END_FUNCTION

FUNCTION GLOBAL init_HMI_CTRL_TEXT VAR_INPUT ptr : ^HMI_CTRL_TEXT; END_VAR
  init_HMI_ROOM(#ptr^.room);
  init_HMI_CHKBIT(#ptr^.chkbit);
  ptr^.colorback := 0;  
  ptr^.colortext := 0;  
  ptr^.attrib    := 0;
  ptr^.frame     := HMI_DEFFRAME;
END_FUNCTION

FUNCTION GLOBAL free_HMI_CTRL_TEXT VAR_INPUT ptr : ^HMI_CTRL_TEXT; END_VAR
  free_HMI_ROOM(#ptr^.room); 
  free_HMI_CHKBIT(#ptr^.chkbit); 
  free_HMI_ANYTHING(#ptr^.anything); 
  init_HMI_CTRL_TEXT(ptr); 
END_FUNCTION
