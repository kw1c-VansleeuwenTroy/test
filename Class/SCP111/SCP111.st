//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define SCP111_DEVICE_ID 1049
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "SCP111"
	Revision           = "1.41"
	GUID               = "{0895B3E0-011E-422A-B14C-ABA587DF4D86}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\scp.ico"
	SharedCommandTable = "true"
	Objectsize         = "(670,120)"
	Comment            = "Class for an SCP111 Safety-Modul">
	<Channels>
		<Server Name="ApplCRC" GUID="{D5178D2C-980B-4282-8BC9-28A86B95A2C5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the CRC of the safety logic (see CRC Dialog in the SafetyDesigner)"/>
		<Server Name="CanOut" GUID="{9434C100-2191-448D-B314-3A2535A4BBA1}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ClassState">
		</Server>
		<Server Name="DesignerPrjConfigCRC" GUID="{0DD55283-7D24-4B8A-9805-0FEF95946956}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the CRC of the whole SafetyDesigner project configuration (see CRC Dialog in the SafetyDesigner)"/>
		<Server Name="DesignerPrjName" GUID="{69E13CC5-FE82-48D1-973A-FD2671712AA7}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows the name of the actual safety designer project"/>
		<Server Name="DesignerPrjRev" GUID="{50F3C08D-F1EE-4447-91A9-758A83D53F3C}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows the revision of the actual safety designer project"/>
		<Server Name="ErrorState" GUID="{97F68A06-7C65-48EA-8747-7C685BBBBAF1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: no error&#13;&#10;1: error&#13;&#10;2: communication timeout on input data from other safety modules"/>
		<Server Name="FastUnsafeInputs" GUID="{F7E36086-DB61-4453-BD44-693DD3AB5FD4}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="write the 32 fast unsafe inputs to this server (bit coded)"/>
		<Server Name="FastUnsafeOutputs" GUID="{9ADD5AEE-A374-43D2-ADAB-8CAB457DE785}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="this server shows the actual state of the 32 fast unsafe outputs (bit coded)"/>
		<Server Name="FCN_Command" GUID="{325FD72B-AEAC-439E-BE73-FC17DB6B8E0C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="The server shows the currently pending command in the SCP firmware in relation with the FlexConNode functionality&#13;&#10;&#13;&#10;Write 1 to this server to establish a connection with the FlexConHost (FCN_StateMachine has to be 1 = IDLE State)&#13;&#10;"/>
		<Server Name="FCN_HostSafetyNumber" GUID="{2D80BE68-8BF9-4870-B4D3-741A9EE41316}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="If there is a connection to a FlexConHost, this server shows the SafetyNumber of the Host"/>
		<Server Name="FCN_StateMachine" GUID="{656029C6-63CC-41E0-A316-C2E1D06B4266}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the current state of the FlexConNode state machine in the SCP firmware&#13;&#10;&#13;&#10;0..FlexConNode not found in safety project&#13;&#10;1..IDLE&#13;&#10;2..LOGIN&#13;&#10;3..CONNECTED to FlexConHost&#13;&#10;4..LOGOUT&#13;&#10;5..ERROR"/>
		<Server Name="FirmwareVersion" GUID="{99D3F343-CFCA-4C79-A783-5B921AE2119D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Firmware version&#13;&#10;&#13;&#10;Format:&#13;&#10;16#XXXXYYYY&#13;&#10;&#13;&#10;XXXX = Major Revision&#13;&#10;YYYY = Minor Revision"/>
		<Server Name="GetDiagConnect" GUID="{2A126113-C4E6-4AA4-8BA5-80B07BAA9458}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="HGWOut" GUID="{642F158A-ADA9-4D4D-B7E2-E3FE2680D747}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="HwCRC" GUID="{626D2522-8ED3-4F0D-865F-34190ACD588D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the CRC of the hardware configuration (see CRC Dialog in the SafetyDesigner)"/>
		<Server Name="QuitComError" GUID="{8F2D6E32-DB61-4B9A-A52C-6566EFE9F015}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Write to this server to quit communication errors (indicated if Server ErrorState = 2)&#13;&#10;This server can also quit general errors (Server ErrorState = 1) if the safety.dlm is used.&#13;&#10;&#13;&#10;To detect the used quit method, read the server directly after writing. In both cases the error quitting is done asynchronously (= not immediately).&#13;&#10;&#13;&#10;Server shows actual quit-state&#13;&#10;  2..busy with quitting general errors (safety dll version 6 or higher required)&#13;&#10;  1..busy with quitting communication error&#13;&#10;  0..ready&#13;&#10; -1..error at creating a new safety state&#13;&#10; -2..failed to disable user prompt for quit error&#13;&#10; -3..failed to select module via safety number&#13;&#10; -4..error at establishing connection to module (safety designer must not be online at the same time!)&#13;&#10; -5..failed to send the quit error command to the module&#13;&#10; -6..failed to delete the created safety state"/>
		<Server Name="RunState" GUID="{505E7FD0-1D16-49C8-9046-FDC7C879ECAA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: not running&#13;&#10;1: running in operational or temporary operational mode"/>
		<Server Name="SafetyNumber" GUID="{6C2DC144-9119-4CA0-8B66-11868AB52785}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the unique safety number of this module"/>
		<Server Name="SafetyRetryCounter" GUID="{53AF9255-7390-41E2-BA2F-967B9CAACF8A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the amount of all retries on the safety bus."/>
		<Server Name="SafetyState" GUID="{1C61AEC1-1DB4-494A-BB65-88BAD86607BA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows state of safety module&#13;&#10;&#13;&#10;_ModuleNotFound:&#13;&#10; - Module has not been found at the given position&#13;&#10;&#13;&#10;_WaitForSynchronicity:&#13;&#10; - Waiting to get synchrony with interacting modules&#13;&#10;&#13;&#10;_SafetyClassOK:&#13;&#10; - Module has been found and no errors reported&#13;&#10;&#13;&#10;_MemAllocFailed: &#13;&#10; - Failed to allocate or reallocate some memory for the module&#13;&#10;&#13;&#10;_ReadFWVerFailed:&#13;&#10; - Failed to read firmware version of module&#13;&#10;&#13;&#10;_ReinitConfig:&#13;&#10; - Only for CPU: Config of CPU has changed and update is in progress&#13;&#10;&#13;&#10;_ModFromCfgNotFound (Only for CPU):&#13;&#10; - Module in configuration, which is not physically available and HW-Class is placed&#13;&#10; - Module in configuration, which is not physically available and no HW-Class is placed&#13;&#10; - Module in configuration, which is not a CDIAS module (according to it&apos;s HW-Path)&#13;&#10;&#13;&#10;_UnsafeVarNotFound (Only for CPU):&#13;&#10; - Couldn&apos;t find an unsafe variable in the project. Compare spelling in Designer and in project.&#13;&#10;&#13;&#10;_UnknownCfgError (Only for CPU):&#13;&#10; - Error in reading config or creating routing tables occured.&#13;&#10;&#13;&#10;_AsyncComError: &#13;&#10; - Too many consecutive asynchronous commands failed! Please contact Sigmatek Support! &#13;&#10; &#13;&#10;_DOsIncreasedRestartApp: &#13;&#10; - Number or size of module accesses increased with new safety project! &#13;&#10; - =&gt; Can&apos;t continue, because the new data is not covered by the actual accesses! Restart Application! &#13;&#10; &#13;&#10;_LostPowerSupply: &#13;&#10; - The power supply of the safe CPU has been lost. &#13;&#10; &#13;&#10;_WrongSafetyHW: &#13;&#10; - The Safety objects in the project do not match the physical modules. &#13;&#10; - For every physical module a safety object must be placed in the project!"/>
		<Server Name="SdiasSafetyOut" GUID="{87F1233D-548C-411B-BB97-ABC3F4C7A72E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ServiceMode" GUID="{64B9AD40-F811-4EA4-A753-CD7DFD5C2230}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: operational mode&#13;&#10;1: service mode or temporary operational mode&#13;&#10;2: check configuration phase"/>
		<Server Name="ValidationButtonState" GUID="{A0B1F955-6FEF-4898-A807-C9A614B77BF4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the validation button&#13;&#10;0: Validation button not used at the moment&#13;&#10;1: Select a command by pressing the button&#13;&#10;2: Command is executed&#13;&#10;3: Error in module"/>
		<Client Name="SdiasSafetyManagerFSoE1" Required="true" Internal="true"/>
		<Client Name="ServerUpdateTime" Required="false" Internal="false" Comment="Time in ms, how long the Servers (unsafe variables in Safety Designer) should take to update.&#13;&#10;This Client is automatically updated, if the given time is too short to handle with the current amount of servers."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.41" Date="23.05.2022" Author="LanSte" Company="Sigmatek" Description="Corrected hardware description file for Eplan support."/>
		<Dokumentation Revision="1.40" Date="28.09.2021" Author="ZoePat" Company="Sigmatek" Description="Changes in baseclass to support SCP211."/>
		<Dokumentation Revision="1.39" Date="20.04.2021" Author="RamAnd" Company="Sigmatek" Description="Added 2 new servers ApplCRC and HwCRC to show the CRCs of the safety application logic as well as the hardware configuration."/>
		<Dokumentation Revision="1.38" Date="01.02.2021" Author="EisMic" Company="Sigmatek" Description="Corrected an error that caused the class to be stuck in _Wait4Synchronicity state when using unsafe variables."/>
		<Dokumentation Revision="1.37" Date="30.09.2020&#13;&#10;05.10.2020" Author="RamAnd&#13;&#10;&#13;&#10;EisMic" Company="Sigmatek" Description="Sending the BusReady message to the safety module could have been blocked by a new InputPDO being added in the process. This would have led to the class being stuck in the _WaitForSynchronicity state. Adding InputPDOs is now prevented while the BusReady signal is being sent out.&#13;&#10;Added support to get the visual error code offset for the class SafetyDiagnosisInfo.&#13;&#10;Diagnosis info data is now fetched even if the the manager initialisation is not finished."/>
		<Dokumentation Revision="1.36" Date="03.06.2020" Author="RamAnd" Company="Sigmatek" Description="The Initialisation is now skipped if the DeviceID at the current SDIAS Place is wrong. Otherwise it would lead to timeouts in the SSDO-transfer which would unnecessarily block the safety task."/>
		<Dokumentation Revision="1.35" Date="25.03.2020" Author="RamAnd" Company="Sigmatek" Description="If the module is connected during runtime, there could be a problem when creating the internal safety configuration which would lead to PDOs of this module not working."/>
		<Dokumentation Revision="1.34" Date="27.02.2020" Author="HaeTho" Company="Sigmatek" Description="Servers FCN_Command, FCN_StateMachine and FCN_HostSafetyNumber of class SdiasSafetyManagerFSoE are now connected to the according servers of SCP111"/>
		<Dokumentation Revision="1.33" Date="16.01.2020" Author="LanSte" Company="Sigmatek" Description="Suppressed redundant warning in combination with _BUS_IF_GET_DEACTIVATED_STATE."/>
		<Dokumentation Revision="1.32" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.31" Date="24.07.2019" Author="RamAnd" Company="Sigmatek" Description="Corrected comparison before reusing PDO Input buffer.&#13;&#10;Corrected the background task being unnecessarily blocked after power cycling the safe CPU while the SDIAS bus power supply still remains on."/>
		<Dokumentation Revision="1.30" Date="18.07.2019" Author="RamAnd" Company="Sigmatek" Description="Corrected that SDO forwarding would not work properly in some cases."/>
		<Dokumentation Revision="1.29" Date="25.06.2019" Author="RamAnd" Company="Sigmatek" Description="Added support for FlexCon functionality."/>
		<Dokumentation Revision="1.28" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.27" Date="11.12.2018" Author="EisMic" Company="Sigmatek" Description="Machinenumber from HGW1033 is now used as a 4 Byte value instead of a 1 byte value."/>
		<Dokumentation Revision="1.26" Date="23.11.2018" Author="PieSte" Company="Sigmatek" Description="The PLC cycle time is written periodically into the module so that this time is used in the safety log file."/>
		<Dokumentation Revision="1.25" Date="18.10.2018" Author="LanSte" Company="Sigmatek" Description="Ignore QuitComError if not in ErrorState.&#13;&#10;Added support for custom FSoE Connections."/>
		<Dokumentation Revision="1.24" Date="23.10.2018" Author="EisMic" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.23" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.22" Date="05.07.2018" Author="PieSte&#13;&#10;EisMic" Company="Sigmatek" Description="Added support for HGW1033."/>
		<Dokumentation Revision="1.21" Date="24.04.2018" Author="RamAnd" Company="Sigmatek" Description="Fetch hardware versions of safe IO modules if this feature is supported by the firmware."/>
		<Dokumentation Revision="1.20" Date="10.04.2018" Author="PieSte" Company="Sigmatek" Description="Fixed an error in the UpDateNotStd() method. If a digital input or output module was optional and hardware was not available, the IOStates pointer was not increased. "/>
		<Dokumentation Revision="1.19" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.18" Date="29.11.2017" Author="FurDom" Company="Sigmatek" Description="Added support to read out the error information on the channels"/>
		<Dokumentation Revision="1.17" Date="22.08.2017" Author="RamAnd" Company="Sigmatek" Description="Fixed an error which prevented two SCP111s on the same PLC from exchanging interfaceframes in both directions."/>
		<Dokumentation Revision="1.16" Date="11.04.2017" Author="RamAnd" Company="Sigmatek" Description="Extended diagnosis information (added firmware version, safety designer project name and revision).&#13;&#10;Added HW Version."/>
		<Dokumentation Revision="1.15" Date="12.06.2017" Author="RamAnd" Company="Sigmatek" Description="When another module disconnects before the connection is marked as synchrony, the counter for modules to synchronize is now decremented so the next connect can get synchrony properly."/>
		<Dokumentation Revision="1.14" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.13" Date="01.03.2017" Author="EisMic" Company="Sigmatek" Description="The configuration of the module (SCP011 or SCP111) is now also read out if the module is connected during runtime."/>
		<Dokumentation Revision="1.12" Date="14.02.2017" Author="EisMic" Company="Sigmatek" Description="Added support for ADD_DYN_SLAVE command."/>
		<Dokumentation Revision="1.11" Date="10.02.2016" Author="RamAnd" Company="Sigmatek" Description="Support for FSoE via IP added."/>
		<Dokumentation Revision="1.10" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.9" Date="04.07.2016" Author="RamAnd" Company="Sigmatek" Description="It&apos;s now allowed to have an object of an IO module or HBG if it&apos;s not set to required and it&apos;s neither projected in the safety designer nor physically available."/>
		<Dokumentation Revision="1.8" Date="08.03.2016" Author="EisMic" Company="Sigmatek" Description="Added support for SafetyDiagnosisInfo hardwareclass."/>
		<Dokumentation Revision="1.7" Date="21.01.2016" Author="EisMic" Company="Sigmatek" Description="Outputs are now written in RtPostScan instead of RtPreScan to improve the reaction speed.&#13;&#10;LED-stati are now set to the right state if the SCP is used without any I/O modules."/>
		<Dokumentation Revision="1.6" Date="31.08.2015" Author="RamAnd" Company="Sigmatek" Description="If no configuration is available at the CPU, the optional settings are now ignored since they are not available in this state. This could have lead to SDIAS errors if safety modules were set to required."/>
		<Dokumentation Revision="1.5" Date="31.07.2015" Author="RamAnd" Company="Sigmatek" Description="Added server DesignerPrjConfigCRC to show the CRC of the SafetyDesigner project.&#13;&#10;Added support for optional Safe-IOs (configured in SafetyDesigner)."/>
		<Dokumentation Revision="1.4" Date="22.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.3" Date="08.06.2015" Author="PieSte" Company="Sigmatek" Description="Changes at Lhd-file for &quot;TypeId&quot; were not taken over."/>
		<Dokumentation Revision="1.2" Date="21.05.2015" Author="PieSte" Company="Sigmatek" Description="Corrected spelling attribute &quot;TypeId&quot; at lhd-file."/>
		<Dokumentation Revision="1.1" Date="16.04.2015" Author="EisMic" Company="Sigmatek" Description="Added support for graphical hardware editor."/>
		<Dokumentation Revision="1.0" Date="15.04.2015" Author="RamAnd" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="SCP111">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{3C5E18AB-BEC6-4D9D-BC37-F959E2C7DAE6}"
				Class      = "BusInterfaceSdias"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="CallCommand"/>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
				</Channels>
			</Object>
			<Object
				Name           = "SdiasSafetyManagerFSoE1"
				GUID           = "{EF603F3E-5340-40A9-AAB0-BB16ED46D520}"
				Class          = "SdiasSafetyManagerFSoE"
				Position       = "(990,570)"
				Visualized     = "true"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="ApplCRC"/>
					<Server Name="CanOut"/>
					<Server Name="ClassSvr"/>
					<Server Name="DesignerPrjConfigCRC"/>
					<Server Name="DesignerPrjName"/>
					<Server Name="DesignerPrjRev"/>
					<Server Name="ErrorState"/>
					<Server Name="FastUnsafeInputs"/>
					<Server Name="FastUnsafeOutputs"/>
					<Server Name="FCN_Command"/>
					<Server Name="FCN_HostSafetyNumber"/>
					<Server Name="FCN_StateMachine"/>
					<Server Name="FirmwareVersion"/>
					<Server Name="GetDiagConnect"/>
					<Server Name="HGWOut"/>
					<Server Name="HwCRC"/>
					<Server Name="QuitComError"/>
					<Server Name="RunState"/>
					<Server Name="SafetyNumber"/>
					<Server Name="SafetyRetryCounter"/>
					<Server Name="SafetyState"/>
					<Server Name="SdiasSafetyOut"/>
					<Server Name="ServiceMode"/>
					<Server Name="ValidationButtonState"/>
					<Server Name="VoltageOK"/>
					<Client Name="DeviceID" Value="SCP111_DEVICE_ID"/>
					<Client Name="ServerUpdateTime" Value="50"/>
					<Client Name="ToBusInterface"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(1848,210),(736,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(1848,270),(736,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(1848,390),(736,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(1848,450),(736,510),"/>
			<Connection Source="this.SdiasSafetyOut" Destination="SdiasSafetyManagerFSoE1.SdiasSafetyOut" Vertices="(1848,1410),(1676,1800),"/>
			<Connection Source="SdiasSafetyManagerFSoE1.ServerUpdateTime" Destination="this.ServerUpdateTime" Vertices="(990,720),(38,510),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(1848,330),(736,330),"/>
			<Connection Source="this.SafetyState" Destination="SdiasSafetyManagerFSoE1.SafetyState" Vertices="(1848,510),(1676,720),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.QuitComError" Destination="SdiasSafetyManagerFSoE1.QuitComError" Vertices="(1848,750),(1676,1020),"/>
			<Connection Source="this.FirmwareVersion" Destination="SdiasSafetyManagerFSoE1.FirmwareVersion" Vertices="(1848,810),(1676,1080),"/>
			<Connection Source="this.SafetyNumber" Destination="SdiasSafetyManagerFSoE1.SafetyNumber" Vertices="(1848,870),(1676,1140),"/>
			<Connection Source="this.DesignerPrjName" Destination="SdiasSafetyManagerFSoE1.DesignerPrjName" Vertices="(1848,1110),(1676,1500),"/>
			<Connection Source="this.DesignerPrjRev" Destination="SdiasSafetyManagerFSoE1.DesignerPrjRev" Vertices="(1848,1170),(1676,1560),"/>
			<Connection Source="this.CanOut" Destination="SdiasSafetyManagerFSoE1.CanOut" Vertices="(1848,1470),(1676,1860),"/>
			<Connection Source="this.SafetyRetryCounter" Destination="SdiasSafetyManagerFSoE1.SafetyRetryCounter" Vertices="(1848,1530),(1676,1200),"/>
			<Connection Source="this.SdiasSafetyManagerFSoE1" Destination="SdiasSafetyManagerFSoE1.ClassSvr"/>
			<Connection Source="SdiasSafetyManagerFSoE1.ToBusInterface" Destination="_base.CallCommand" Vertices="(990,660),(736,630),"/>
			<Connection Source="this.DesignerPrjConfigCRC" Destination="SdiasSafetyManagerFSoE1.DesignerPrjConfigCRC" Vertices="(1848,930),(1676,1260),"/>
			<Connection Source="this.GetDiagConnect" Destination="SdiasSafetyManagerFSoE1.GetDiagConnect" Vertices="(1848,1590),(1676,1440),"/>
			<Connection Source="this.HGWOut" Destination="SdiasSafetyManagerFSoE1.HGWOut" Vertices="(1848,1650),(1676,1920),"/>
			<Connection Source="this.FCN_Command" Destination="SdiasSafetyManagerFSoE1.FCN_Command" Vertices="(1848,1710),(1676,1980),"/>
			<Connection Source="this.FCN_StateMachine" Destination="SdiasSafetyManagerFSoE1.FCN_StateMachine" Vertices="(1848,1770),(1676,2040),"/>
			<Connection Source="this.FCN_HostSafetyNumber" Destination="SdiasSafetyManagerFSoE1.FCN_HostSafetyNumber" Vertices="(1848,1830),(1676,2100),"/>
			<Connection Source="this.ApplCRC" Destination="SdiasSafetyManagerFSoE1.ApplCRC" Vertices="(1848,990),(1676,1320),"/>
			<Connection Source="this.HwCRC" Destination="SdiasSafetyManagerFSoE1.HwCRC" Vertices="(1848,1050),(1676,1380),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using BusInterfaceSdias

SCP111 : CLASS
: BusInterfaceSdias
  //Servers:
	SafetyState 	: SvrCh_SafetyConfigStateType;
	RunState 	: SvrCh_DINT;
	ServiceMode 	: SvrCh_DINT;
	ErrorState 	: SvrCh_DINT;
	QuitComError 	: SvrCh_DINT;
	FirmwareVersion 	: SvrCh_HDINT;
	SafetyNumber 	: SvrCh_HDINT;
	DesignerPrjConfigCRC 	: SvrCh_HDINT;
	ApplCRC 	: SvrCh_HDINT;
	HwCRC 	: SvrCh_HDINT;
	DesignerPrjName 	: SvrChCmd_UDINT;
	DesignerPrjRev 	: SvrChCmd_UDINT;
	ValidationButtonState 	: SvrCh_DINT;
	FastUnsafeInputs 	: SvrCh_BDINT;
	FastUnsafeOutputs 	: SvrCh_BDINT;
	SdiasSafetyOut 	: SvrChCmd_DINT;
	CanOut 	: SvrChCmd_DINT;
	SafetyRetryCounter 	: SvrCh_DINT;
	GetDiagConnect 	: SvrChCmd_DINT;
	HGWOut 	: SvrChCmd_DINT;
	FCN_Command 	: SvrCh_UDINT;
	FCN_StateMachine 	: SvrCh_UDINT;
	FCN_HostSafetyNumber 	: SvrCh_HDINT;
  //Clients:
	ServerUpdateTime 	: CltCh_UDINT;
	SdiasSafetyManagerFSoE1 	: CltChCmd_SdiasSafetyManagerFSoE;
  //Variables:
  //Functions:
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
				//! <Function Comment="Make a request to fetch the diagnosis data" Name="FetchDiagState"/>
	FUNCTION VIRTUAL GLOBAL FetchDiagState;
				//! <Function Comment="Check if the diagnosis data have arrived (if so, retcode = TRUE)." Name="GetDiagState"/>
	FUNCTION VIRTUAL GLOBAL GetDiagState
		VAR_INPUT
			pDiagState 	: ^SafetyDiagState;
		END_VAR
		VAR_OUTPUT
			StateReady 	: BOOL;			//! <Variable Comment="FALSE...State is not ready (value of &quot;input parameter&quot; not changed)&#13;&#10;TRUE....State is ready (input parameter)" Name="GetDiagState.StateReady"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FetchDiagInfo
		VAR_INPUT
			ucChoice 	: USINT;			//! <Variable Comment="   0..µC1&#13;&#10;&lt;&gt; 0..µC2" Name="FetchDiagInfo.ucChoice"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDiagInfo
		VAR_INPUT
			pDiagInfo 	: ^SafetyDiagInfo;
		END_VAR
		VAR_OUTPUT
			StateReady 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SafetyState::Read
		VAR_OUTPUT
			output (EAX) 	: SafetyConfigStateType;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitComError::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitComError::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FirmwareVersion::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SafetyNumber::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DesignerPrjConfigCRC::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ApplCRC::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HwCRC::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FastUnsafeInputs::Write
		VAR_INPUT
			input (EAX) 	: BDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: BDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FastUnsafeOutputs::Write
		VAR_INPUT
			input (EAX) 	: BDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: BDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SafetyRetryCounter::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDiagConnect::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HGWOut::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FCN_Command::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FCN_Command::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FCN_StateMachine::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FCN_HostSafetyNumber::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using SdiasSafetyManagerFSoE


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SCP111::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SCP111
1$UINT, 41$UINT, (SIZEOF(::SCP111))$UINT, 
23$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1571585774), "SCP111", //Class
TO_UDINT(2368828999), "BusInterfaceSdias", 1$UINT, 26$UINT, //Baseclass
//Servers:
(::SCP111.SafetyState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1504224158), "SafetyState", 
(::SCP111.RunState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2759549320), "RunState", 
(::SCP111.ServiceMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1978843086), "ServiceMode", 
(::SCP111.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::SCP111.QuitComError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1389350282), "QuitComError", 
(::SCP111.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::SCP111.SafetyNumber.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2430374202), "SafetyNumber", 
(::SCP111.DesignerPrjConfigCRC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(349909197), "DesignerPrjConfigCRC", 
(::SCP111.ApplCRC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2412485999), "ApplCRC", 
(::SCP111.HwCRC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3992965099), "HwCRC", 
(::SCP111.DesignerPrjName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2397083450), "DesignerPrjName", 
(::SCP111.DesignerPrjRev.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2854741250), "DesignerPrjRev", 
(::SCP111.ValidationButtonState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2335086012), "ValidationButtonState", 
(::SCP111.FastUnsafeInputs.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1891345754), "FastUnsafeInputs", 
(::SCP111.FastUnsafeOutputs.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(766673388), "FastUnsafeOutputs", 
(::SCP111.SdiasSafetyOut.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1660330439), "SdiasSafetyOut", 
(::SCP111.CanOut.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4133122455), "CanOut", 
(::SCP111.SafetyRetryCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1159647258), "SafetyRetryCounter", 
(::SCP111.GetDiagConnect.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1383671281), "GetDiagConnect", 
(::SCP111.HGWOut.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1053584609), "HGWOut", 
(::SCP111.FCN_Command.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2520919212), "FCN_Command", 
(::SCP111.FCN_StateMachine.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3844074925), "FCN_StateMachine", 
(::SCP111.FCN_HostSafetyNumber.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3307951323), "FCN_HostSafetyNumber", 
//Clients:
(::SCP111.ServerUpdateTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(247674937), "ServerUpdateTime", 
(::SCP111.SdiasSafetyManagerFSoE1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3365623752), "SdiasSafetyManagerFSoE1", TO_UDINT(1131165733), "SdiasSafetyManagerFSoE", 1$UINT, 33$UINT, 
END_FUNCTION


#define USER_CNT_SCP111 30

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SCP111] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SCP111::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= BusInterfaceSdias::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SCP111;
	vmt.CmdTable.NewInstr		:= #ClassState::NewInst();
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #FetchDiagState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #GetDiagState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #FetchDiagInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #GetDiagInfo();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SafetyState.pMeth			:= StoreMethod( #SafetyState::Read(), #M_NO_F() );
	IF SafetyState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QuitComError.pMeth			:= StoreMethod( #QuitComError::Read(), #QuitComError::Write() );
	IF QuitComError.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FirmwareVersion.pMeth			:= StoreMethod( #FirmwareVersion::Read(), #M_NO_F() );
	IF FirmwareVersion.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SafetyNumber.pMeth			:= StoreMethod( #SafetyNumber::Read(), #M_NO_F() );
	IF SafetyNumber.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DesignerPrjConfigCRC.pMeth			:= StoreMethod( #DesignerPrjConfigCRC::Read(), #M_NO_F() );
	IF DesignerPrjConfigCRC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ApplCRC.pMeth			:= StoreMethod( #ApplCRC::Read(), #M_NO_F() );
	IF ApplCRC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HwCRC.pMeth			:= StoreMethod( #HwCRC::Read(), #M_NO_F() );
	IF HwCRC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, DesignerPrjName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	DesignerPrjName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DesignerPrjName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, DesignerPrjRev.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	DesignerPrjRev.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DesignerPrjRev.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FastUnsafeInputs.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FastUnsafeInputs::Write() );
	IF FastUnsafeInputs.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FastUnsafeOutputs.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FastUnsafeOutputs::Write() );
	IF FastUnsafeOutputs.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SdiasSafetyOut.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	SdiasSafetyOut.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasSafetyOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CanOut.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	CanOut.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CanOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SafetyRetryCounter.pMeth			:= StoreMethod( #SafetyRetryCounter::Read(), #M_NO_F() );
	IF SafetyRetryCounter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, GetDiagConnect.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #GetDiagConnect::Read();
	GetDiagConnect.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF GetDiagConnect.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, HGWOut.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #HGWOut::Read();
	HGWOut.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF HGWOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FCN_Command.pMeth			:= StoreMethod( #FCN_Command::Read(), #FCN_Command::Write() );
	IF FCN_Command.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FCN_StateMachine.pMeth			:= StoreMethod( #FCN_StateMachine::Read(), #M_NO_F() );
	IF FCN_StateMachine.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FCN_HostSafetyNumber.pMeth			:= StoreMethod( #FCN_HostSafetyNumber::Read(), #M_NO_F() );
	IF FCN_HostSafetyNumber.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL SCP111::SafetyState::Read
  VAR_OUTPUT
    output (EAX) 	: SafetyConfigStateType;
  END_VAR

  SafetyState := SdiasSafetyManagerFSoE1.SafetyState.Read();
  output := SafetyState;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::QuitComError::Read
  VAR_OUTPUT
    output (EAX) 	: DINT;
  END_VAR

  QuitComError := SdiasSafetyManagerFSoE1.QuitComError.Read();
  output := QuitComError;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::QuitComError::Write
  VAR_INPUT
    input (EAX) 	: DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: DINT;
  END_VAR

  QuitComError := input;
  result := SdiasSafetyManagerFSoE1.QuitComError.Write(QuitComError);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::FirmwareVersion::Read
  VAR_OUTPUT
    output (EAX) 	: HDINT;
  END_VAR

  FirmwareVersion := SdiasSafetyManagerFSoE1.FirmwareVersion.Read();
  output := FirmwareVersion;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::SafetyNumber::Read
  VAR_OUTPUT
    output (EAX) 	: HDINT;
  END_VAR

  SafetyNumber := SdiasSafetyManagerFSoE1.SafetyNumber.Read();
  output := SafetyNumber;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::FastUnsafeInputs::Write
  VAR_INPUT
    input (EAX) 	: BDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: BDINT;
  END_VAR

  FastUnsafeInputs := input;
  result := SdiasSafetyManagerFSoE1.FastUnsafeInputs.Write(FastUnsafeInputs);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::ClassState::NewInst
  VAR_INPUT
    pPara 	: ^CmdStruct;
    pResult 	: ^results;
  END_VAR
  VAR_OUTPUT
    ret_code 	: iprStates;
  END_VAR
  VAR
    pRtRefreshData : ^t_RtRefresh;
  END_VAR

  ret_code := READY;
  
  CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
    SDIAS_SET_RT_DATA:
      pRtRefreshData        := pPara^.aPara[0]$^t_RtRefresh;
      RunState              := pRtRefreshData^.LEDRunState;
      ServiceMode           := pRtRefreshData^.LEDServiceMode;
      ErrorState            := pRtRefreshData^.LEDErrorState;
      ValidationButtonState := pRtRefreshData^.LEDValidationButtonState;
      FastUnsafeOutputs     := pRtRefreshData^.FastUnsafeOutputs;
      
//**********************************************************************************************************************************************************
    SDIAS_SET_SAFETY_STATE:
      SafetyState := pPara^.aPara[0]$SafetyConfigStateType;
      
//**********************************************************************************************************************************************************
    SDIAS_SET_ASY_STATE:
      QuitComError := pPara^.aPara[0]$^t_AsyRefresh^.QuitComError;
  
//**********************************************************************************************************************************************************

  ELSE
    ret_code := BusInterfaceSdias::ClassState::NewInst(pPara, pResult);
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::FastUnsafeOutputs::Write
  VAR_INPUT
    input (EAX) 	: BDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: BDINT;
  END_VAR

  result := SdiasSafetyManagerFSoE1.FastUnsafeOutputs.Write(input);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::SafetyRetryCounter::Read
  VAR_OUTPUT
    output (EAX) 	: DINT;
  END_VAR

  SafetyRetryCounter := SdiasSafetyManagerFSoE1.SafetyRetryCounter.Read();
  output := SafetyRetryCounter;

END_FUNCTION


FUNCTION VIRTUAL SCP111::GetDeviceID
  VAR_OUTPUT
    output 	: UDINT;
  END_VAR
  
  output := SCP111_DEVICE_ID;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL SCP111::FetchDiagState

  SdiasSafetyManagerFSoE1.FetchDiagState();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::GetDiagState
  VAR_INPUT
    pDiagState 	: ^SafetyDiagState;
  END_VAR
  VAR_OUTPUT
    StateReady 	: BOOL;
  END_VAR
  
  StateReady := SdiasSafetyManagerFSoE1.GetDiagState(pDiagState);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::FetchDiagInfo
  VAR_INPUT
    ucChoice 	: USINT;
  END_VAR

  SdiasSafetyManagerFSoE1.FetchDiagInfo(ucChoice);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::GetDiagInfo
  VAR_INPUT
    pDiagInfo 	: ^SafetyDiagInfo;
  END_VAR
  VAR_OUTPUT
    StateReady 	: BOOL;
  END_VAR
  
  StateReady := SdiasSafetyManagerFSoE1.GetDiagInfo(pDiagInfo);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::DesignerPrjConfigCRC::Read
  VAR_OUTPUT
    output (EAX) 	: HDINT;
  END_VAR

  DesignerPrjConfigCRC := SdiasSafetyManagerFSoE1.DesignerPrjConfigCRC.Read();
  output := DesignerPrjConfigCRC;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::GetDiagConnect::Read
  VAR_OUTPUT
    output (EAX) 	: DINT;
  END_VAR

  GetDiagConnect := SdiasSafetyManagerFSoE1.GetDiagConnect.Read();
  output := GetDiagConnect;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::HGWOut::Read
  VAR_OUTPUT
    output (EAX) 	: DINT;
  END_VAR

  HGWOut := SdiasSafetyManagerFSoE1.HGWOut.Read();
  output := HGWOut;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::FCN_Command::Read
  VAR_OUTPUT
    output (EAX) 	: UDINT;
  END_VAR

  FCN_Command := SdiasSafetyManagerFSoE1.FCN_Command.Read();
  output := FCN_Command;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::FCN_Command::Write
  VAR_INPUT
    input (EAX) 	: UDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: UDINT;
  END_VAR

  FCN_Command := input;
  result := (SdiasSafetyManagerFSoE1.FCN_Command.Write(FCN_Command))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::FCN_StateMachine::Read
  VAR_OUTPUT
    output (EAX) 	: UDINT;
  END_VAR

  FCN_StateMachine := SdiasSafetyManagerFSoE1.FCN_StateMachine.Read();
  output := FCN_StateMachine;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::FCN_HostSafetyNumber::Read
  VAR_OUTPUT
    output (EAX) 	: HDINT;
  END_VAR

  FCN_HostSafetyNumber := SdiasSafetyManagerFSoE1.FCN_HostSafetyNumber.Read();
  output := FCN_HostSafetyNumber;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::ApplCRC::Read
	VAR_OUTPUT
		output (EAX) 	: HDINT;
	END_VAR

	ApplCRC := SdiasSafetyManagerFSoE1.ApplCRC.Read();
	output := ApplCRC;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP111::HwCRC::Read
	VAR_OUTPUT
		output (EAX) 	: HDINT;
	END_VAR

	HwCRC := SdiasSafetyManagerFSoE1.HwCRC.Read();
	output := HwCRC;

END_FUNCTION
