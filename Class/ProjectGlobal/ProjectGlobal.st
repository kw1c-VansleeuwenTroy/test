//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES


// Eigenschaften der Bildschirm-Informationen
//----------------------------------------------------------------------------------
#define Global_NumScreenInfos                            100                                 // Anzahl der reservierten Einträge für die Bildschirminformation

#define Global_MenueScreenNr                             10                                  // Bildschirm-Nummer des Menüs (Startseite)

#define Global_MenueMin                                  5                                   // Bildschirm-Nummer Alarme(*Ez0999*)

#define Global_MenueMax                                  4410                                // Bildschirm-Nummer Login Screens(*Ez0999*)

#define PRJGLOBAL_MAX_STATION                            255                                 // Highest possible LSE Station-Number

#define PRJGLOBAL_STATION_INTERN                         0                                   // Identifier for internal LSE-Station

#define PRJGLOBAL_STATION_EXTERN                         1                                   // Identifier for TCPIP1 LSE-Station


#define     CMD_GETIPOverStation      1000
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "ProjectGlobal"
	Revision           = "1.19"
	GUID               = "{32CE6A2A-4575-47CD-8859-2C4DBEC739BB}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,600)"
	Comment            = "Class to handle global Project Issues (Display of Station Numbers, Window Numbers and so on).">
	<Channels>
		<Server Name="ActIma" GUID="{0D9D98DB-0C25-4949-AB9B-798A21434FFB}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ActScreen" GUID="{1342D1AE-314F-4B0F-B51F-58F3FCDB408E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="number of the active screen"/>
		<Server Name="ActWindow" GUID="{72DAFE04-32FA-4626-B614-883E53F3DA1F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="number of the active window"/>
		<Server Name="ExtStationNumber" GUID="{1DD9F31D-E79E-4F89-80BB-C0797FA27AA2}" Visualized="false" Initialize="true" DefValue="-1" WriteProtected="true" Retentive="false" Comment="LSE-Station Number of Oscilloscope-PLC. If initvalue=-1, value is determined automatically.&#13;&#10;&#13;&#10;Automatic mode:&#13;&#10;Data of IPC.INI is browsed and station numbers are extracted. If more than one external station is defined, ProjectGlobal will use the station with the highest value. &#13;&#10;IMPORTANT: In automatic mode, Station number is not valid before call of IF_ProjectReady!&#13;&#10;Automatic mode does not support substations (see t_ipc.h, #define UC_MULTICPU)"/>
		<Server Name="HostLanguage" GUID="{27895FD7-FF6B-412C-833B-C7902F683A66}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="File" Comment="System-wide Host Language (1) - will be set after Init and every time you write to the server. &#13;&#10;&#13;&#10;0 ... Disable functionality&#13;&#10;x ... Windows ID of the language or index in the LSE language list (0-based)&#13;&#10;&#13;&#10;Examples for Windows ID: &#13;&#10;1033 = English (United States)&#13;&#10;2057 = English (Britain)&#13;&#10;1031 = German (Standard Germany)&#13;&#10;3079 = German (Austria)&#13;&#10;1043 = Dutch (Standard)&#13;&#10;Attention: the Language must be present in the LSE-Project!&#13;&#10;"/>
		<Server Name="HostLanguage2" GUID="{63C8393E-1C11-47EF-8CF4-7BD277C69E6A}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="File" Comment="System-wide Host Language 2 - will be set after Init and every time you write to the server. &#13;&#10;&#13;&#10;0 ... Disable functionality&#13;&#10;x ... Windows ID of the language or index in the LSE language list (0-based)&#13;&#10;&#13;&#10;Examples for Windows ID: &#13;&#10;1033 = English (United States)&#13;&#10;2057 = English (Britain)&#13;&#10;1031 = German (Standard Germany)&#13;&#10;3079 = German (Austria)&#13;&#10;1043 = Dutch (Standard)&#13;&#10;Attention: the Language must be present in the LSE-Project!&#13;&#10;"/>
		<Server Name="HostLanguage3" GUID="{D5CDEF9D-84D6-4B18-BB9E-5935A035CB3F}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="File" Comment="System-wide Host Language 3 - will be set after Init and every time you write to the server. &#13;&#10;&#13;&#10;0 ... Disable functionality&#13;&#10;x ... Windows ID of the language or index in the LSE language list (0-based)&#13;&#10;&#13;&#10;Examples for Windows ID: &#13;&#10;1033 = English (United States)&#13;&#10;2057 = English (Britain)&#13;&#10;1031 = German (Standard Germany)&#13;&#10;3079 = German (Austria)&#13;&#10;1043 = Dutch (Standard)&#13;&#10;Attention: the Language must be present in the LSE-Project!&#13;&#10;"/>
		<Server Name="IP4Communication" GUID="{228006C1-E72C-430A-A718-0EACC137345C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Command Channel to get the ip address over station number"/>
		<Server Name="OwnStationNumber" GUID="{7C040E9B-DDE1-4897-96BF-15819E44BFCF}" Visualized="false" Initialize="true" DefValue="-1" WriteProtected="true" Retentive="false" Comment="LSE-Station Number of HMI. If initvalue=-1, value is determined automatically.&#13;&#10;&#13;&#10;Automatic mode:&#13;&#10;Data of IPC.INI is browsed and station numbers are extracted. If more than one internal station is defined, ProjectGlobal will use the station with the highest value. &#13;&#10;IMPORTANT: In automatic mode, Station number is not valid before call of IF_ProjectReady!&#13;&#10;Automatic mode does not support substations (see t_ipc.h, #define UC_MULTICPU)"/>
		<Server Name="ProjectIsReady" GUID="{0CADDCFD-E1A7-4FAB-A36F-42E1B468B18F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="output: 1= project is ready (LSE ready)"/>
		<Client Name="ccEventQueue" Required="false" Internal="false" Comment="command channel to the EventQueue of the EventJournal"/>
		<Client Name="ccSystemLogging" Required="false" Internal="false" Comment="command channel to SystemLogging (optional)"/>
		<Client Name="coGraphic" Required="false" Internal="false" Comment="object channel to Graphic (don&apos;t connect!)"/>
		<Client Name="OffDate" Required="true" Internal="true"/>
		<Client Name="OffTime" Required="true" Internal="true"/>
		<Client Name="PreLoadScreens" Required="false" Internal="false" Comment="Connect to a table with screen number for preloading."/>
		<Client Name="ProjectReady" Required="true" Internal="false" Comment="true = Visu started successful "/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="object channel to SigCLib (don&apos;t connect)"/>
		<Client Name="SysDate" Required="true" Internal="false" Comment="system date"/>
		<Client Name="SysTime" Required="true" Internal="false" Comment="system time"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\ProjectGlobal\ProjectGlobal_de.pdf"/>
			<File Path=".\Class\ProjectGlobal\ProjectGlobal_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.19" Date="2021-03-05" Author="dacpat" Company="Sigmatek" Description="- Cleanup the offscreen after preloading the screens.&#13;&#10;- Added log messages.&#13;&#10;- Set methods SwitchOn() und SwitchOff() to virtual."/>
		<Dokumentation Revision="1.18" Date="2020-04-17" Author="RauAnd" Company="Sigmatek" Description="A new functionality for preloading screens was integrated into ProjectGlobal. This functionality initializes the screens before the screens are opened."/>
		<Dokumentation Revision="1.17" Date="2019-06-19" Author="KruAle" Company="Sigmatek" Description="Eventlogging for checkbits and enumerations implemented."/>
		<Dokumentation Revision="1.16" Date="2018-02-28" Author="KaiAnd" Company="Sigmatek" Description="--&gt; set the Host Language 2 and 3 (via new class servers)&#13;&#10;!!! needs _LSE 0.114 or higher !!!"/>
		<Dokumentation Revision="1.15" Date="2017-10-18" Author="SprDie" Company="Sigmatek" Description="Server ActIma added to show if Window or Screen is active "/>
		<Dokumentation Revision="1.14" Date="2017-03-30" Author="KaiAnd" Company="Sigmatek" Description="--&gt; set the Host Language (via new class server)&#13;&#10;--&gt; overwrite method ::IF_WritePost() for logging &quot;normal&quot; value changes (without keypad) to the eventjournal"/>
		<Dokumentation Revision="1.13" Date="2016-12-07" Author="KaiAnd" Company="Sigmatek" Description="new server ProjectIsReady - can be used from other classes instead of clients &quot;LSE ready&quot; or &quot;ProjectReady&quot;"/>
		<Dokumentation Revision="1.12" Date="2016-10-10" Author="HubChr" Company="Sigmatek" Description="Added documentation pdfs."/>
		<Dokumentation Revision="1.11" Date="2016-10-06" Author="KaiAnd" Company="Sigmatek" Description="1: set the message box properties in ::IF_ProjectReady()&#13;&#10;2: changed object channel for SystemLogging to a command channel; new help function LogMyText() for logging&#13;&#10;3: changed object channel to _EventQueue to a command channel; adding events now via this command channel"/>
		<Dokumentation Revision="1.10" Date="2016-09-16" Author="HubChr" Company="Sigmatek" Description="Station numbers of internal and external station are now gathered from ipc.ini and displayed"/>
		<Dokumentation Revision="1.9" Date="2016-07-12" Author="HasHan" Company="Sigmatek" Description="add ActWindow server"/>
		<Dokumentation Revision="1.8" Date="2016-05-19" Author="GreJoh" Company="Sigmatek" Description="Client coSystemLogging must not be connected."/>
		<Dokumentation Revision="1.7" Date="2016-02-22" Author="Roskri" Company="Sigmatek" Description="Removed uneccesary Methods, servers and clients for switching between screens."/>
		<Dokumentation Revision="1.6" Date="2015-09-29" Author="BraLis" Company="Sigmatek" Description="insert the method SystemLogging::LogEventText instead of TRACE-Messages"/>
		<Dokumentation Revision="1.5" Date="2015-09-22" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
	<Network Name="ProjectGlobal">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{FDF7FBF3-7B29-4010-BA5F-F7F4F7C2B928}"
				Class      = "_Global"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
			<Object
				Name       = "OffDate"
				GUID       = "{98FA88F6-930B-4CC6-8AE9-F02D5DB59415}"
				Class      = "Ram"
				Position   = "(390,480)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "OffTime"
				GUID       = "{174EEAFB-6D7C-4C2C-84EA-F68038040918}"
				Class      = "Ram"
				Position   = "(390,660)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(862,210),(518,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="this.OffDate" Destination="OffDate.Data"/>
			<Connection Source="this.OffTime" Destination="OffTime.Data"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Global

ProjectGlobal : CLASS
: _Global
	TYPE
#pragma pack(push, 1)
	  t_s_ScreenInfo : STRUCT
	    uiScreenNr : UINT;
	    usLevel : USINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ActScreen 	: SvrCh_UDINT;
	ActWindow 	: SvrCh_UDINT;
	ActIma 	: SvrCh__IMA;
	ProjectIsReady 	: SvrCh_DINT;
	IP4Communication 	: SvrChCmd_DINT;
	OwnStationNumber 	: SvrCh_DINT;
	ExtStationNumber 	: SvrCh_DINT;
	HostLanguage 	: SvrCh_UDINT;
	HostLanguage2 	: SvrCh_UDINT;
	HostLanguage3 	: SvrCh_UDINT;
  //Clients:
	SigCLib 	: CltChCmd_SigCLib;
	coGraphic 	: CltChCmd_Graphic;
	ProjectReady 	: CltCh_DINT;
	SysDate 	: CltCh_HDINT;
	SysTime 	: CltCh_HDINT;
	OffDate 	: CltChCmd_Ram;
	OffTime 	: CltChCmd_Ram;
	ccEventQueue 	: CltChCmd_DINT;
	ccSystemLogging 	: CltChCmd_DINT;
	PreLoadScreens 	: CltCh_DINT;
  //Variables:
		bFirstInit 	: BOOL;
		uiStartPicture 	: UINT;
		bProjectReady 	: BOOL;
		dOldValue 	: DINT;
		dNewValue 	: DINT;
		udVarNo 	: UDINT;
		bLogValue 	: BOOL;
		pComPort 	: ^_COMPORT;
		pIP_Adress : ARRAY [0..16] OF CHAR;

		IPAdressValid 	: SINT;
		ProjectReadyVar 	: BOOL;
		udTimeStamp 	: UDINT;
		IsCon_ccSystemLogging 	: BOOL;
		IsCon_ccEventQueue 	: DINT;
		OffScreen 	: _NEWSCREEN;
		ScreenRoom 	: _ROOM;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowStart
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			firsttime 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowRun
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="methode will be called after lse-project is successfully loaded and &#13;&#10;possibly given communication to extern plc is stable" Name="IF_ProjectReady"/>
	FUNCTION VIRTUAL GLOBAL IF_ProjectReady
		VAR_INPUT
			state 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_InputIsSaved
		VAR_INPUT
			pi 	: ^_INPUT;
			pr 	: ^_RESULT;
		END_VAR;
				//! <Function Comment="this method is called before a value is written into the system&#13;&#10;set return parameter with FALSE if you want to prohibit&#13;&#10;otherwise value will be written into system&#13;&#10;" Name="IF_Write"/>
	FUNCTION VIRTUAL GLOBAL IF_Write
		VAR_INPUT
			pres 	: ^_RESULT;
			pvar 	: ^_VARIABLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="this method is called right after a value is successfully written into system" Name="IF_WritePost"/>
	FUNCTION VIRTUAL GLOBAL IF_WritePost
		VAR_INPUT
			pres 	: ^_RESULT;
			pvar 	: ^_VARIABLE;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IF_IpcIni
		VAR_INPUT
			pini 	: ^_IPCINI;
		END_VAR;
				//! <Function Comment="Delivers the screen number of the start screen as return value." Name="GetStartPicture"/>
	FUNCTION GLOBAL GetStartPicture
		VAR_OUTPUT
			uiStartPictureNr 	: UINT;			//! <Variable Comment="Number of the start screen" Name="GetStartPicture.uiStartPictureNr"/>
		END_VAR;
				//! <Function Comment="Get the IP-adress by the station number." Name="GetIpAdressOfStation"/>
	FUNCTION GLOBAL GetIpAdressOfStation
		VAR_INPUT
			pIpAdress 	: ^CHAR;			//! <Variable Comment="Pointer to a text with the IP-adress of the station" Name="GetIpAdressOfStation.pIpAdress"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: SINT;			//! <Variable Comment="0.. Project loading hasn&apos;t finished&#13;&#10;-1.. No IP-adress set&#13;&#10;1.. Ok" Name="GetIpAdressOfStation.retcode"/>
		END_VAR;
				//! <Function Comment="Add an event for turning on the PLC to the event journal." Name="SwitchOn"/>
	FUNCTION VIRTUAL SwitchOn
		VAR_INPUT
			hdTime 	: HDINT;			//! <Variable Comment="event time" Name="SwitchOn.hdTime"/>
			hdDate 	: HDINT;			//! <Variable Comment="event date" Name="SwitchOn.hdDate"/>
		END_VAR;
				//! <Function Comment="Add an event for turning off the plc to the event journal." Name="SwitchOff"/>
	FUNCTION VIRTUAL SwitchOff
		VAR_INPUT
			hdTime 	: HDINT;			//! <Variable Comment="event time" Name="SwitchOff.hdTime"/>
			hdDate 	: HDINT;			//! <Variable Comment="event date" Name="SwitchOff.hdDate"/>
		END_VAR;
				//! <Function Comment="help function to log a text via command channel to SystemLogging" Name="LogMyText"/>
	FUNCTION LogMyText
		VAR_INPUT
			pLogTxt 	: ^CHAR;			//! <Variable Comment="pointer to the text which should be logged" Name="LogMyText.pLogTxt"/>
		END_VAR;
	
	FUNCTION _PreLoadScreens;
	
	FUNCTION VIRTUAL GLOBAL IP4Communication::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HostLanguage::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HostLanguage2::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HostLanguage3::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Ram
#pragma usingLtd Graphic
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ProjectGlobal::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_PROJECTGLOBAL
1$UINT, 19$UINT, (SIZEOF(::ProjectGlobal))$UINT, 
10$UINT, 10$UINT, 0$UINT, 
TO_UDINT(1462004836), "ProjectGlobal", //Class
TO_UDINT(3788417926), "_Global", 0$UINT, 15$UINT, //Baseclass
//Servers:
(::ProjectGlobal.ActScreen.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3239971925), "ActScreen", 
(::ProjectGlobal.ActWindow.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2511770808), "ActWindow", 
(::ProjectGlobal.ActIma.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(364721159), "ActIma", 
(::ProjectGlobal.ProjectIsReady.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3858541921), "ProjectIsReady", 
(::ProjectGlobal.IP4Communication.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4090129760), "IP4Communication", 
(::ProjectGlobal.OwnStationNumber.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3196279637), "OwnStationNumber", 
(::ProjectGlobal.ExtStationNumber.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2856174611), "ExtStationNumber", 
(::ProjectGlobal.HostLanguage.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(39712233), "HostLanguage", 
(::ProjectGlobal.HostLanguage2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3271670052), "HostLanguage2", 
(::ProjectGlobal.HostLanguage3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3020327346), "HostLanguage3", 
//Clients:
(::ProjectGlobal.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 37$UINT, 
(::ProjectGlobal.coGraphic.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(792223587), "coGraphic", TO_UDINT(1140816688), "Graphic", 0$UINT, 1$UINT, 
(::ProjectGlobal.ProjectReady.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3641930940), "ProjectReady", 
(::ProjectGlobal.SysDate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1714210210), "SysDate", 
(::ProjectGlobal.SysTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2737203869), "SysTime", 
(::ProjectGlobal.OffDate.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2631048100), "OffDate", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::ProjectGlobal.OffTime.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1507341467), "OffTime", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::ProjectGlobal.ccEventQueue.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2793728539), "ccEventQueue", 
(::ProjectGlobal.ccSystemLogging.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1000190998), "ccSystemLogging", 
(::ProjectGlobal.PreLoadScreens.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2136632948), "PreLoadScreens", 
END_FUNCTION


#define USER_CNT_ProjectGlobal 47

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ProjectGlobal] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ProjectGlobal::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Global::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Global::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Global::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_ProjectGlobal;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #IF_WindowStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IF_WindowRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #IF_ProjectReady();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #IF_InputIsSaved();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #IF_Write();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #IF_WritePost();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #IF_IpcIni();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #SwitchOn();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #SwitchOff();

#pragma warning (default : 74)
	_Global::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Global::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, IP4Communication.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.NewInstr		:= #IP4Communication::NewInst();
	IP4Communication.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF IP4Communication.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HostLanguage.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HostLanguage::Write() );
	IF HostLanguage.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HostLanguage2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HostLanguage2::Write() );
	IF HostLanguage2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HostLanguage3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HostLanguage3::Write() );
	IF HostLanguage3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::Init
  
  // Methode der Basis-Klasse
  _Global::Init();
  
  if (_FirstScan) then
    
    //-----------------------------------------------------------------------------------------
    //  check client-connnections and set flags                                                
    //-----------------------------------------------------------------------------------------
    if (IsClientConnected(#ccSystemLogging)) then
      IsCon_ccSystemLogging := TRUE;
    end_if;
    
    if (IsClientConnected(#ccEventQueue)) then
      IsCon_ccEventQueue := TRUE;
    end_if;
    
      
      
  end_if;

  ProjectIsReady := 0;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_ProjectReady
	VAR_INPUT
		state 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmpDate : HDINT;
    tmpTime : HDINT;
  END_VAR
  
  //#3306 PreloadScreens Functionality
  if IsClientConnected(#PreLoadScreens) then
    _PreLoadScreens();
  end_if; 

  // aktuelle Zeit lesen
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();
  
  // System wurde gerade gestartet
  //-------------------------------------------------------
  
  // Datum + Zeit vom Ausschalten lesen
  tmpDate := (OffDate.Data.Read())$HDINT;
  tmpTime := (OffTime.Data.Read())$HDINT;
    
  // Event für Ausschalten vom System
  SwitchOff(hdTime  := tmpTime, hdDate  := tmpDate);
    
  // Event für Einschalten vom System
  SwitchOn( hdTime  := SysTime, hdDate  := SysDate);
 
  ProjectReadyVar := TRUE;

  ProjectReady.Write(input:=1);
  
  // V.1.13, KaiAnd: Server "ProjectIsReady" (can be used from other classes instead of" LSE ready")
  ProjectIsReady := 1;

  // Visualisierung ist erfolgreich hochgefahren
  bProjectReady := true;
  
  IPAdressValid := GetIpAdressOfStation(#pIP_Adress[0]);
 
  //---------------------------------------------------------------------------------------------------------
  // set the messagebox properties  V.1.11, KaiAnd
  //---------------------------------------------------------------------------------------------------------
  MessageBoxSetFontScheme("Headline");

  MessageBoxSetFrame(box:=FRAME_WINDOW_NEWAGE, button:=FRAME_NEWAGE_DARK);

  MessageBoxSetColorBox(back  := coGraphic.MakeColor(MakeColorFromIndex(247), MakeColorFromIndex(242)),
                        text  := coGraphic.MakeColor(MakeColorFromIndex(246), MakeColorFromIndex(246)),
                        frame := coGraphic.MakeColor(MakeColorFromIndex(242), MakeColorFromIndex(242)) );

  MessageBoxSetColorButton(back  := coGraphic.MakeColor(MakeColorFromIndex(242), MakeColorFromIndex(242)),
                           text  := coGraphic.MakeColor(MakeColorFromIndex(241), MakeColorFromIndex(241)),
                           frame := coGraphic.MakeColor(MakeColorFromIndex(242), MakeColorFromIndex(242)) );

  //---------------------------------------------------------------------------------------------------------
  // set the Host Language  V.1.14, V.1.16, KaiAnd
  //---------------------------------------------------------------------------------------------------------
  Prj_HostLanguageSet(HostLanguage);
  Prj_HostLanguageSetEx(2, HostLanguage2);
  Prj_HostLanguageSetEx(3, HostLanguage3);

  //---------------------------------------------------------------------------------------------------------


  // Rückgabewert setzen
  retcode := state;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_WindowStart
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
		firsttime 	: BOOL;
	END_VAR

  // Methode der Basis-Klasse
  _Global::IF_WindowStart(whoami, pic, firsttime);
  
  //--------------------------------------------------------------------------------------------------
  if (bFirstInit = false) then
    bFirstInit := true;
    uiStartPicture := to_uint(whoami^.no);
  end_if;
  
  
  //*****************************************************************************
  //** UNTERSCHEIDUNG DER KOMMANDOS                                            **
  //*****************************************************************************
  case whoami^.ima of
    
    // Screen
    //--------------------------------------------------------------------------------------------------
    IMA_PICTURE:
    
      // aktuelles Bildnummer darstellen
      ActScreen := whoami^.no;
      ActIma := IMA_PICTURE; // v1.15 - show Screen is active
      
    // Window
    //--------------------------------------------------------------------------------------------------
    IMA_WINDOW:
    
      // aktuelle Windownummer darstellen
      ActWindow := whoami^.no;
      ActIma := IMA_WINDOW; // v1.15 - show if Window is active
      
  end_case;
  
END_FUNCTION

FUNCTION GLOBAL ProjectGlobal::GetStartPicture
	VAR_OUTPUT
		uiStartPictureNr 	: UINT;
	END_VAR

  
  // Nr des Start-Bildschirms
  uiStartPictureNr := uiStartPicture;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_Write
	VAR_INPUT
		pres 	: ^_RESULT;
		pvar 	: ^_VARIABLE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	tmpResult     : _RESULT;
    tmpParameter  : UDINT;
  END_VAR

  // Rückgabewert setzen
  // => Wert darf immer geändert werden
  retcode := true;
  
  bLogValue := false;
  
  // Prüfen ob Projekt bereit hochgefahren ist
  if (bProjectReady) then
      
    // Einstellungen vom Parameter lesen
    tmpParameter := pvar^.info.statistic.parameter;
    
    // Prüfen, ob Logbuch für Parameter ausgewählt wurde
    if (tmpParameter AND 2#10) then
    
      // Variablennummer speichern
      udVarNo := pvar^.no;
      
      // In Logbuch eintragen
      bLogValue := true;
      
      //*****************************************************************************
      //** UNTERSCHEIDUNG DER TYPEN                                                **
      //*****************************************************************************
      case pvar^.info.vartype of
        
        // Datum
        //*****************************************************************************
        FDATE:
        
          // Speichern des aktuellen Wertes
          dOldValue := pres^.value;
          
          // Speichern des neuen Wertes
          DATE_to_lasal(p0:=#dNewValue, p1:=#pres^.datim.fdate);
                        
        // Zeit
        //*****************************************************************************
        FTIME:
        
          // Speichern des aktuellen Wertes
          dOldValue := pres^.value;
          
          // Speichern des neuen Wertes
          TIME_to_lasal(p0:=#dNewValue, p1:=#pres^.datim.ftime);
        
        // String
        //*****************************************************************************
        FSTRING:
        
          LogMyText("ProjectGlobal::IF_Write(): Änderung von Strings kann noch nicht mitgeloggt werden" );
          
        // der Rest
        //*****************************************************************************
        else
        
          // Speichern des aktuellen Wertes
          if (get_dat(p0:=#tmpResult, x1:=udVarNo) = true) then
            dOldValue := tmpResult.value;
          else
            dOldValue := 0;
            LogMyText("ProjectGlobal::IF_Write(): Bestimmen des Wertes vor der Änderung fehlgeschlagen" );
          end_if;

          // Speichern des neuen Wertes
          dNewValue := pres^.value;
          
      end_case;
    
    end_if;
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_WritePost
	VAR_INPUT
		pres 	: ^_RESULT;
		pvar 	: ^_VARIABLE;
	END_VAR

  VAR
    NiGive	: CmdStruct;
    NiGet   : Results;
  END_VAR

  // Prüfen ob Projekt bereit hochgefahren ist
  if (bProjectReady) then
    
    // Soll die Wertänderung ins Logbuch geschrieben werden?
    if (bLogValue = true) then
    
      // Prüfen ob die Variablennummer noch gleich ist
      if (pvar^.no = udVarNo) then
      
        // Info an _EventJournal weitergeben
        case (pvar^.info.vartype) of
        
          // hier nur Binär Werte behandeln
          BINARY:
            
            // Auf Änderung prüfen
            if (dOldValue <> pres^.value) then
            
              // neues Event hinzufügen
              if (IsCon_ccEventQueue = True) then
                NiGive.uiCmd    := 5;               // Command AddValueChange()
                NiGive.aPara[0] := udVarNo$DINT;
                NiGive.aPara[1] := dOldValue;
                NiGive.aPara[2] := pres^.value;
                ccEventQueue.NewInst(#NiGive, #NiGet);
              end_if;
              bLogValue := False;   // clear Flag "In Logbuch eintragen"

            end_if;
          
          // alles andere wie bisher in ::IF_InputIsSaved() behandeln
          else

        end_case;

      else
        LogMyText("ProjectGlobal::IF_WritePost(): Variablennummer hat sich geändert, zwischenzeitlich hat eine andere Änderung stattgefunden" );
      end_if;
    
    end_if;    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_InputIsSaved
	VAR_INPUT
		pi 	: ^_INPUT;
		pr 	: ^_RESULT;
	END_VAR
  VAR
    NiGive	: CmdStruct;
    NiGet   : Results;
  END_VAR

  // Prüfen ob Projekt bereit hochgefahren ist
  if (bProjectReady) then
    
    // Soll die Wertänderung ins Logbuch geschrieben werden?
    if (bLogValue = true) then
    
      // Prüfen ob die Variablennummer noch gleich ist
      if ( (pi^.io.variable.info[0].state = VAR_VAL) &
           (pi^.io.variable.info[0].value = udVarNo$DINT) ) then
      
        // Info an _EventJournal weitergeben
        case pi^.io.typ of
        
          // Datum
          //*****************************************************************************
          AS_DATE:
          
            // Auf Änderung prüfen
            if (dOldValue <> dNewValue) then
              
              if (IsCon_ccEventQueue = True) then
                NiGive.uiCmd    := 2;               // Command AddDateChange()
                NiGive.aPara[0] := udVarNo$DINT;
                NiGive.aPara[1] := dOldValue;
                NiGive.aPara[2] := dNewValue;
                ccEventQueue.NewInst(#NiGive, #NiGet);
              end_if;
            
            end_if;


          // Zeit
          //*****************************************************************************
          AS_TIME:
            
            // Auf Änderung prüfen
            if dOldValue <> dNewValue then
            
              // neues Event hinzufügen
              if (IsCon_ccEventQueue = True) then
                NiGive.uiCmd    := 3;               // Command AddTimeChange()
                NiGive.aPara[0] := udVarNo$DINT;
                NiGive.aPara[1] := dOldValue;
                NiGive.aPara[2] := dNewValue;
                ccEventQueue.NewInst(#NiGive, #NiGet);
              end_if;
              
            end_if;


          // String
          //*****************************************************************************
          AS_ASCII:
          
          
          // Menü
          //*****************************************************************************
          AS_MENU:
            
            // Auf Änderung prüfen
            if dOldValue <> dNewValue then
            
              // neues Event hinzufügen
              if (IsCon_ccEventQueue = True) then
                NiGive.uiCmd    := 4;               // Command AddMenuChange()
                NiGive.aPara[0] := udVarNo$DINT;
                NiGive.aPara[1] := pi^.io.info.tbo.no$DINT;
                NiGive.aPara[2] := dOldValue;
                NiGive.aPara[3] := dNewValue;
                ccEventQueue.NewInst(#NiGive, #NiGet);
              end_if;

            end_if;
            
            
          // KruAle v1.17: der Rest
          //*****************************************************************************
          AS_NUMERIC, AS_CHKBOX, AS_ENUMERATION:
            
            // Auf Änderung prüfen
            if dOldValue <> dNewValue then
            
              // neues Event hinzufügen
              if (IsCon_ccEventQueue = True) then
                NiGive.uiCmd    := 5;               // Command AddValueChange()
                NiGive.aPara[0] := udVarNo$DINT;
                NiGive.aPara[1] := dOldValue;
                NiGive.aPara[2] := dNewValue;
                ccEventQueue.NewInst(#NiGive, #NiGet);
              end_if;

            end_if;
          
          else
            LogMyText("ProjectGlobal::IF_InputIsSaved(): Event für diese Änderung wird nicht unterstützt" );
        end_case;

      else
        LogMyText("ProjectGlobal::IF_InputIsSaved(): Variablennummer hat sich geändert, zwischenzeitlich hat eine andere Änderung stattgefunden" );
      end_if;
    
    end_if;    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IP4Communication::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	len     : UDINT;
    NewInstUser   : BOOL;
  END_VAR

  NewInstUser := FALSE;  ret_code := READY;

  case pPara^.uiCmd of

    // --------------------------
    // Usercommand to get the IP adress
    CMD_GETIPOVERSTATION:
    
       if (IPAdressValid = 1) then
         len := SigCLib.StrLen(str:=#pIP_Adress[0]);
         pResult^.uiLng := len$UINT;
         SigCLib.MemCpy(#pResult^.aData[0], #pIP_Adress[0], len + 1); 
          ret_code := READY;

       elsif (IPAdressValid = -1) then
        ret_code := ERROR;
       else
        ret_code := BUSY;
       end_if;
       
       NewInstUser := TRUE;

  end_case;
  
  // If no user cmd is done, do the base newInst
  if (NewInstUser = FALSE) then
    ret_code := _Global::Server0.NewInst(pPara, pResult);
  end_if;


END_FUNCTION


FUNCTION GLOBAL ProjectGlobal::GetIpAdressOfStation
	VAR_INPUT
		pIpAdress 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: SINT;
	END_VAR
  VAR
    udIPAdress  :UDINT;
    tmpIP_ASCII  : ARRAY[0..16] of _ASCII;
  END_VAR
  
  retcode := 0;
  
  if (ProjectReadyVar = TRUE) then
    udIPAdress := 0;
    
    // get LSE Station
    pComPort := Get_COMPORT(ExtStationNumber$UINT);  
      
    if (pComPort <> NIL) then
      udIPAdress := pComPort^.comdef.ipadress;
    
      // konvertieren der IP in string format
      DToA(p0:=#tmpIP_ASCII[0], x1:=(udIPAdress AND 0xFF)$DINT, x2:=0x800, x3:=sizeof(_ASCII));
      SigCLib.StrCpy(dst0:=pIpAdress, src0:=#tmpIP_ASCII[0]);
      SigCLib.StrCat(ps1:=pIpAdress, ps2:=".");
      // zweite stelle der IP adresse konvertieren    
      DToA(p0:=#tmpIP_ASCII[0], x1:=((udIPAdress shr 8) AND 0xFF)$DINT, x2:=0x800, x3:=sizeof(_ASCII));
      SigCLib.StrCat(ps1:=pIpAdress, ps2:=#tmpIP_ASCII[0]);
      SigCLib.StrCat(ps1:=pIpAdress, ps2:=".");
      // dritte stelle der IP adresse konvertieren    
      DToA(p0:=#tmpIP_ASCII[0], x1:=((udIPAdress shr 16) AND 0xFF)$DINT, x2:=0x800, x3:=sizeof(_ASCII));
      SigCLib.StrCat(ps1:=pIpAdress, ps2:=#tmpIP_ASCII[0]);
      SigCLib.StrCat(ps1:=pIpAdress, ps2:=".");
      // vierte stelle der IP adresse konvertieren    
      DToA(p0:=#tmpIP_ASCII[0], x1:=((udIPAdress shr 24) AND 0xFF)$DINT, x2:=0x800, x3:=sizeof(_ASCII));
      SigCLib.StrCat(ps1:=pIpAdress, ps2:=#tmpIP_ASCII[0]);
      
      retcode := 1;
    
    else
    // no ip adress set
      retcode := -1;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL ProjectGlobal::SwitchOn
	VAR_INPUT
		hdTime 	: HDINT;
		hdDate 	: HDINT;
	END_VAR
  VAR
    NiGive : CmdStruct;
    NiGet  : Results;
  END_VAR
  
  if (IsCon_ccEventQueue = True) then
    NiGive.uiCmd    := 0;               // Command AddSystemOnOff()
    NiGive.aPara[0] := hdDate$DINT;
    NiGive.aPara[1] := hdTime$DINT;
    NiGive.aPara[2] := TO_DINT(TRUE);
    ccEventQueue.NewInst(#NiGive, #NiGet);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL ProjectGlobal::SwitchOff
	VAR_INPUT
		hdTime 	: HDINT;
		hdDate 	: HDINT;
	END_VAR
  VAR
    NiGive : CmdStruct;
    NiGet  : Results;
  END_VAR
  
  if (IsCon_ccEventQueue = True) then
    NiGive.uiCmd    := 0;               // Command AddSystemOnOff()
    NiGive.aPara[0] := hdDate$DINT;
    NiGive.aPara[1] := hdTime$DINT;
    NiGive.aPara[2] := TO_DINT(FALSE);
    ccEventQueue.NewInst(#NiGive, #NiGet);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_WindowRun
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
		event 	: ^_EVENT;
	END_VAR
  
    if (ops.tAbsolute - udTimeStamp) > 5 SECS then
      
      udTimeStamp := ops.tAbsolute;
      // aktuelle Zeit lesen
      SysDate := SysDate.Read();
      SysTime := SysTime.Read();
      
      // aktuelle Zeit speichern
      OffDate.Data.Write(SysDate$DINT);
      OffTime.Data.Write(SysTime$DINT);
      
    end_if;
    

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::IF_IpcIni
	VAR_INPUT
		pini 	: ^_IPCINI;
	END_VAR
  VAR
    i     :   INT;
  END_VAR

(***********************************************************************)
(***** HubChr v1.10 - automatical determination of StationNumbers.******)
(***** Initvalue always beats; in case of more than one station of *****)
(***** a kind (int/ext), station with the highest number is used. ******)
(***********************************************************************)

#ifndef UC_MULTICPU  // the following code does not work for substations

  if (OwnStationNumber = -1) | (ExtStationNumber = -1) then  // if both stations are defined by initvalue, no search is necessary

    case pini^.ComSet.no of
      
      1:  //  we only have one station (single-cpu project) - in this case we use the same station number for both
      
        for i := PRJGLOBAL_MAX_STATION to 0 by -1 do
        
          if pini^.ComSet.mapper[i].aktmap = PRJGLOBAL_STATION_INTERN then
            OwnStationNumber := i;
            ExtStationNumber := i;
            exit;
          end_if;
          
        end_for;



      else  // we have more than one station - in this case we use the highest of both external and internal
      
        for i := PRJGLOBAL_MAX_STATION to 0 by -1 do  // browse from top to bottom because highest number shall be used
          
          if pini^.ComSet.mapper[i].aktmap = PRJGLOBAL_STATION_INTERN then  // we have found an internal station
            
            if OwnStationNumber = -1 then // if user already defined an internal station number by initvalue, we don't change it!
              OwnStationNumber := i;    // set server
              if ExtStationNumber <> -1 then // if we already have an external station number, no need for further search!
                exit;
              end_if;
            end_if;
            
          end_if;
          
          if pini^.ComSet.mapper[i].aktmap = PRJGLOBAL_STATION_EXTERN then  // we have found an external station
          
            if ExtStationNumber = -1 then // if user already defined an external station number by initvalue, we don't change it!
              ExtStationNumber := i;    // set server
              if OwnStationNumber <> -1 then  // if we already have an internal station number, no need for further search!
                exit;
              end_if;
            end_if;
            
          end_if;
          
        end_for;


    end_case;

  end_if;

#endif


END_FUNCTION


FUNCTION ProjectGlobal::LogMyText
	VAR_INPUT
		pLogTxt 	: ^CHAR;
	END_VAR

  VAR
    NiGive	  : CmdStruct;
    NiGet     : Results;
  END_VAR

  if ((IsCon_ccSystemLogging = True) & (pLogTxt <> NIL)) then

    NiGive.uiCmd    := 0;               // Command
    NiGive.aPara[0] := (pLogTxt)$DINT;  // pointer to text

    ccSystemLogging.NewInst(#NiGive, #NiGet);

  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::HostLanguage::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	HostLanguage := input;
	result := HostLanguage;

  Prj_HostLanguageSet(HostLanguage);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::HostLanguage2::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	HostLanguage2 := input;
	result := HostLanguage2;

  Prj_HostLanguageSetEx(2, HostLanguage2);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProjectGlobal::HostLanguage3::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	HostLanguage3 := input;
	result := HostLanguage3;

  Prj_HostLanguageSetEx(3, HostLanguage3);

END_FUNCTION


FUNCTION ProjectGlobal::_PreLoadScreens
  VAR
    tmpOldScreen    : _NEWSCREEN;
    tmpScanBar      : UINT;
    tmpScreenNr     : UINT;
    tmpNoScreens    : UDINT;
    tmpCount        : DINT;
    pTableOffset    : ^UDINT;
    pFirstScreens   : ^UDINT;
  END_VAR
  
  // Anzahl der Screens holen  
  pFirstScreens := (PreLoadScreens.Read())$^UDINT;
  
  if pFirstScreens <> NIL then
  
    tmpNoScreens := (pFirstScreens^) / sizeof(UDINT);
    pTableOffset := (pFirstScreens + sizeof(UDINT));
   
    // unsichtbaren Bildschirm erstellen - Screenshoot
    coGraphic.GetScreenSize(room:=#ScreenRoom);
    init_NEWSCREEN(#OffScreen);
    if coGraphic.CreateOffScreen(pScreen := #OffScreen, 
                                 width   := to_uint(ScreenRoom.xy2.x), 
                                 height  := to_uint(ScreenRoom.xy2.y)) = 1 then
      // Progressbar erzeugen
      tmpScanBar := ScanBar_Add(p0:="Init Screens:", x0:=to_dint(tmpNoScreens));
      
      tmpCount := 0;
      while (tmpNoScreens) do
        
        // aktuellen Bildschirm speichern
        coGraphic.GetScreen(#tmpOldScreen);
        
        // aktiviere unsichtbaren Bildschirm
        coGraphic.SetScreen(pScreen := #OffScreen);
        
        // Nächsten Screen holen
        tmpScreenNr  := to_uint(pTableOffset^);
        pTableOffset += sizeof(UDINT);
        
        // Öffne den angegebenen Bildschirm
        //-----------------------------------------------------------------------------------------
        if DrawPicWin(x0 := IMA_PICTURE, 
                      x1 := tmpScreenNr, 
                      x2 := 20) = false then
        
          LogMyText("ProjectGlobal::_PreLoadScreens(): Failed to draw a screen");
        end_if;
        
        // Nächster Screen
        tmpNoScreens -= 1;
        tmpCount     += 1;
        
        // alten Bildschirm aktivieren
        coGraphic.SetScreen(pScreen := #tmpOldScreen);
        
        // Progressbar refreshen
        ScanBar_Run(x0:=tmpScanBar, x1:=tmpCount);
      end_while;
      
      // V1.19, dacpat, cleanup the offscreen after preloading
      coGraphic.DestroyOffScreen(#OffScreen);  // kill the OffScreen 
      
      // Progressbar schließen
      ScanBar_End(x0:=tmpScanBar);
    else
    
      LogMyText("ProjectGlobal::_PreLoadScreens(): Failed to create offscreen for drawing the screens");
    end_if;
  end_if;

END_FUNCTION
