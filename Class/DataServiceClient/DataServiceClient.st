//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\DataServiceClient\CDsClient.h"

(*!
<Class
	Name               = "DataServiceClient"
	Revision           = "0.2"
	GUID               = "{C504696D-660B-408B-AE42-9F9728026380}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\DataServiceClient\DataServiceClient.ico"
	SharedCommandTable = "true"
	Objectsize         = "(480,240)"
	Comment            = "Class is used to establish communication to object of class DataServiceAPIex at extern plc. A watchdog will inform user about stability of connection.&#13;&#10;After a well done connection is broken DataServiceClient will try to reconnect to plc until user will call method Close()">
	<Channels>
		<Server Name="CpuState" GUID="{A0591742-A406-452F-881A-2DE38137B330}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="State oc connected plc, -1 on disconnect&#13;&#10; OFFLINE           -1&#13;&#10; RUN_RAM            0&#13;&#10; RUN_ROM            1&#13;&#10; STOP_BRKPT        15&#13;&#10; SINGLESTEP        18"/>
		<Server Name="RxData" GUID="{9C34767D-AFA5-440C-8C52-1BBC4975A49A}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Number or received datapackages"/>
		<Server Name="TxData" GUID="{9C662888-84EE-4F21-80D4-D1FEE1E9EF7D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Number of sent datapackages"/>
		<Client Name="ClientId" Required="true" Internal="false" DefValue="666"/>
		<Client Name="SigCLib" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\DataServiceClient\CDsClient.cpp"/>
			<File Path=".\Class\DataServiceClient\CDsUtils.cpp"/>
			<File Path=".\Class\DataServiceClient\CDsClient.h" Include="true"/>
			<File Path=".\Class\DataServiceClient\CDsIntern.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner/>
		<Dokumentation Revision="0.2" Date="2021-06-14" Author="kolott" Company="sigmatek" Description="8D-2702: Avoid UserCallback after call of function DataLink_Close(). new method OnTaskBeginEnd()"/>
		<Dokumentation Revision="0.1" Date="2020-03-31" Author="kolott" Company="sigmatek" Description="new method CreateDataBufferEx() added&#13;&#10;FragmentManager added to handle fragmented incomming datatpackages"/>
		<Dokumentation Revision="0.0" Date="2019-12-20" Author="kolott" Company="sigmatek" Description="release"/>
	</RevDoku>
</Class>
*)
DataServiceClient : CLASS
  //Servers:
	CpuState 	: SvrChCmd_DINT;
	RxData 	: SvrCh_UDINT;
	TxData 	: SvrCh_DINT;
  //Clients:
	SigCLib 	: CltChCmd_SigCLib;
	ClientId 	: CltCh_UDINT;
  //Variables:
		Hdl 	: ^void;
		PcbUserRx 	: ^void;
		PcbUserTx 	: ^void;
		PcbUserState 	: ^void;
		PcbUserCookie 	: ^void;
		PcbUserTskBE 	: ^void;
  //Functions:
	
	FUNCTION DataServiceClient
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Method is called each time when receiving data from plc." Name="OnReceiveEx"/>
	FUNCTION VIRTUAL GLOBAL OnReceiveEx
		VAR_INPUT
			port 	: ^void;			//! <Variable Comment="handle" Name="OnReceiveEx.port"/>
			pdata 	: ^DsComData;			//! <Variable Comment="address of data" Name="OnReceiveEx.pdata"/>
		END_VAR;
				//! <Function Comment="Establish asynchron connection via DataLink to secified plc.&#13;&#10;Note: You have to wait afterwards till &apos;CpuState&apos; changes to different value than -1 till connection is stable.&#13;&#10;After a well done connection is broken DataServiceClient will try to reconnect to plc until user will call method Close()." Name="Open"/>
	FUNCTION GLOBAL Open
		VAR_INPUT
			ipv4 	: ^CHAR;			//! <Variable Comment="IP-Address of plc to connect + optional tcp-port (default 2402)&#13;&#10;e.g.: &quot;192.168.150.13:2402&quot;" Name="Open.ipv4"/>
			timeout_to_host 	: UDINT;			//! <Variable Comment="Timeout in ms to connect" Name="Open.timeout_to_host"/>
			usertext 	: ^CHAR := nil;			//! <Variable Comment="arbitrary ascii-0-terminated text with a maximum length of 31 characters or &apos;NIL&apos;." Name="Open.usertext"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="&apos;true&apos; or &apos;false&apos;" Name="Open.retcode"/>
		END_VAR;
				//! <Function Comment="Establish synchron connection via DataLink to secified plc.&#13;&#10;Note: Do not call this method in any &apos;high priority task&apos;. Method will wait for connection to external plc. Check server &apos;CpuState&apos; for state of connection.&#13;&#10;After a well done connection is broken DataServiceClient will try to reconnect to plc until user will call method Close()" Name="OpenSyn"/>
	FUNCTION GLOBAL OpenSyn
		VAR_INPUT
			ipv4 	: ^CHAR;			//! <Variable Comment="IP-Address of plc to connect + optional tcp-port (default 2402)&#13;&#10;e.g.: &quot;192.168.150.13:2402&quot;" Name="OpenSyn.ipv4"/>
			timeout_to_host 	: UDINT;			//! <Variable Comment="Timeout in ms to connect" Name="OpenSyn.timeout_to_host"/>
			usertext 	: ^CHAR := nil;			//! <Variable Comment="arbitrary ascii-0-terminated text with a maximum length of 31 characters or &apos;NIL&apos;." Name="OpenSyn.usertext"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true or false" Name="OpenSyn.retcode"/>
		END_VAR;
				//! <Function Comment="Close ready done connection to external plc" Name="Close"/>
	FUNCTION GLOBAL Close;
				//! <Function Comment="Send userspecific data to connected plc." Name="Send"/>
	FUNCTION GLOBAL Send
		VAR_INPUT
			pcd 	: ^DsComData;			//! <Variable Comment="data to send" Name="Send.pcd"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true or false" Name="Send.retcode"/>
		END_VAR;
				//! <Function Comment="Send data to plc and wait for answer.&#13;&#10;Note: Method will wait maximum &apos;timeout&apos; milliseconds for answer" Name="SendSyn"/>
	FUNCTION GLOBAL SendSyn
		VAR_INPUT
			pcd_dst 	: ^DsComData;			//! <Variable Comment="Address where response should be filed" Name="SendSyn.pcd_dst"/>
			pcd_src 	: ^DsComData;			//! <Variable Comment="data to send" Name="SendSyn.pcd_src"/>
			timeout 	: UDINT;			//! <Variable Comment="Timeout in ms till response (answer)" Name="SendSyn.timeout"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true or false" Name="SendSyn.retcode"/>
		END_VAR;
				//! <Function Comment="Call method NewInst at plc with userspecific data.&#13;&#10;Responsedata are foramtted as followed&#13;&#10;  [ ..... DSComDataHdr&#13;&#10;  [4] ... userid&#13;&#10;  [4] ... result (iprstate)&#13;&#10;  [2] ... datalength in bytes (results.uilen) always datalength + 2 !&#13;&#10;  [ ..... data" Name="NewInstCall"/>
	FUNCTION GLOBAL NewInstCall
		VAR_INPUT
			userid 	: UDINT;			//! <Variable Comment="individual id which can be found in response data" Name="NewInstCall.userid"/>
			lasalid 	: UDINT;			//! <Variable Comment="Lasalid of NewInst to be adressed" Name="NewInstCall.lasalid"/>
			cmd 	: UINT;			//! <Variable Comment="NewInst command to perform" Name="NewInstCall.cmd"/>
			pdata 	: ^void;			//! <Variable Comment="Address of data sent to NewInst" Name="NewInstCall.pdata"/>
			datalen 	: UDINT;			//! <Variable Comment="Bytelength of userdata to send" Name="NewInstCall.datalen"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true or false on error" Name="NewInstCall.retcode"/>
		END_VAR;
				//! <Function Comment="Call method NewInst at plc with userspecific data. Note: Method will wait for response.&#13;&#10;Responsedata are foramtted as followed&#13;&#10;  [ ..... DSComDataHdr&#13;&#10;  [4] ... userid&#13;&#10;  [4] ... result (iprstate)&#13;&#10;  [2] ... datalength in bytes (results.uilen) always datalength + 2 !&#13;&#10;  [ ..... data" Name="NewInstCallSyn"/>
	FUNCTION GLOBAL NewInstCallSyn
		VAR_INPUT
			pcd_dst 	: ^DsComData;			//! <Variable Comment="Address where response should be filed" Name="NewInstCallSyn.pcd_dst"/>
			userid 	: UDINT;			//! <Variable Comment="individual id which can be found in response data" Name="NewInstCallSyn.userid"/>
			lasalid 	: UDINT;			//! <Variable Comment="Lasalid of NewInst to be adressed" Name="NewInstCallSyn.lasalid"/>
			cmd 	: UINT;			//! <Variable Comment="NewInst command to perform" Name="NewInstCallSyn.cmd"/>
			pdata 	: ^void;			//! <Variable Comment="Address of data sent to NewInst" Name="NewInstCallSyn.pdata"/>
			datalen 	: UDINT;			//! <Variable Comment="Bytelength of userdata to send" Name="NewInstCallSyn.datalen"/>
			timeout 	: UDINT;			//! <Variable Comment="Timeout in ms till response (answer)" Name="NewInstCallSyn.timeout"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true or false on error" Name="NewInstCallSyn.retcode"/>
		END_VAR;
				//! <Function Comment="Method is used to test communication. Userdata of arbitrary amount will be send to and retceived from plc." Name="SendCmdLoop"/>
	FUNCTION GLOBAL SendCmdLoop
		VAR_INPUT
			pdata 	: ^void;			//! <Variable Comment="Address of userdata to send an receive" Name="SendCmdLoop.pdata"/>
			datasize 	: UDINT;			//! <Variable Comment="Bytesize of userdata" Name="SendCmdLoop.datasize"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true or false on error" Name="SendCmdLoop.retcode"/>
		END_VAR;
				//! <Function Comment="Method will be called each time when data has to be sent to plc" Name="OnTransmitEx"/>
	FUNCTION VIRTUAL GLOBAL OnTransmitEx
		VAR_INPUT
			port 	: ^void;			//! <Variable Comment="handle" Name="OnTransmitEx.port"/>
			pdata 	: ^DsComData;			//! <Variable Comment="address of data" Name="OnTransmitEx.pdata"/>
		END_VAR;
				//! <Function Comment="Method will be called each time when plc-state will change" Name="CpuStateRx"/>
	FUNCTION VIRTUAL GLOBAL CpuStateRx
		VAR_INPUT
			port 	: ^void;			//! <Variable Comment="handle" Name="CpuStateRx.port"/>
			cpu_state 	: DINT;			//! <Variable Comment="plc state or -1 if offline" Name="CpuStateRx.cpu_state"/>
		END_VAR;
				//! <Function Comment="Method is used to test communication. Userdata of arbitrary amount will be send to and received from plc.&#13;&#10;Note: Method will wait for receiving data." Name="SendCmdLoopSyn"/>
	FUNCTION GLOBAL SendCmdLoopSyn
		VAR_INPUT
			pcd_dst 	: ^DsComData;			//! <Variable Comment="Address of destination where returned data should be filed" Name="SendCmdLoopSyn.pcd_dst"/>
			pdata 	: ^void;			//! <Variable Comment="Address of userdata to send an receive" Name="SendCmdLoopSyn.pdata"/>
			datasize 	: UDINT;			//! <Variable Comment="Bytesize of userdata" Name="SendCmdLoopSyn.datasize"/>
			timeout 	: UDINT;			//! <Variable Comment="Timeout in ms till response (answer)" Name="SendCmdLoopSyn.timeout"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true or false on error" Name="SendCmdLoopSyn.retcode"/>
		END_VAR;
				//! <Function Comment="Method is used to create databuffer of arbitrary bytesize including initialized needed header to communicate with loader.&#13;&#10;if used bytesize will fit into given &apos;statbuff&apos; this static buffer will be of use. On the other hand memory will be allocated inside. &#13;&#10;Therefore always use method DsComDataDestroy() to delete created databuffer afterwards." Name="DsComDataCreateEx"/>
	FUNCTION GLOBAL DsComDataCreateEx
		VAR_INPUT
			scratchbuff 	: ^void;			//! <Variable Comment="static buffer to use or &apos;nil&apos;" Name="DsComDataCreateEx.scratchbuff"/>
			scratchbuffsize 	: UDINT;			//! <Variable Comment="Bytesize of given static buffer or 0." Name="DsComDataCreateEx.scratchbuffsize"/>
			datasize 	: UDINT;			//! <Variable Comment="Bytesize of userdata to capture." Name="DsComDataCreateEx.datasize"/>
			id_minor 	: UINT;			//! <Variable Comment="Minor Id to identify message in plc." Name="DsComDataCreateEx.id_minor"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^DsComData;			//! <Variable Comment="true or false" Name="DsComDataCreateEx.retcode"/>
		END_VAR;
				//! <Function Comment="Method is used to create databuffer of arbitrary bytesize including initialized needed header.&#13;&#10;if used bytesize will fit into given &apos;statbuff&apos; this static buffer will be of use. On the other hand memory will be allocated inside. &#13;&#10;Therefore always use method DsComDataDestroy() to delete created databuffer afterwards." Name="DsComDataCreate"/>
	FUNCTION GLOBAL DsComDataCreate
		VAR_INPUT
			scratchbuff 	: ^void;			//! <Variable Comment="static buffer to use or &apos;nil&apos;" Name="DsComDataCreate.scratchbuff"/>
			scratchbuffsize 	: UDINT;			//! <Variable Comment="Bytesize of given static buffer or 0." Name="DsComDataCreate.scratchbuffsize"/>
			datasize 	: UDINT;			//! <Variable Comment="Bytesize of userdata to capture." Name="DsComDataCreate.datasize"/>
			id_major 	: UINT;			//! <Variable Comment="Major Id to identify message in plc. &#13;&#10;Use define ComId_Major_DS to communicate with internal part of DataLink." Name="DsComDataCreate.id_major"/>
			id_minor 	: UINT;			//! <Variable Comment="Minor Id to identify message in plc." Name="DsComDataCreate.id_minor"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^DsComData;			//! <Variable Comment="true or false" Name="DsComDataCreate.retcode"/>
		END_VAR;
				//! <Function Comment="Use method to free databuffer created with method DataBufferCreate() of DataBufferCreateEx()" Name="DsComDataDestroy"/>
	FUNCTION GLOBAL DsComDataDestroy
		VAR_INPUT
			scratchbuff 	: ^void;			//! <Variable Comment="same static buffer used at create" Name="DsComDataDestroy.scratchbuff"/>
			buffer 	: ^DsComData;			//! <Variable Comment="pointer returned at create" Name="DsComDataDestroy.buffer"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^DsComData;			//! <Variable Comment="alway nil" Name="DsComDataDestroy.retcode"/>
		END_VAR;
				//! <Function Comment="Method is used to give Callback when data received (rx), when data transmit (tx) and plc state changed (state). Nil is allowed when corresponding callback is not needed.&#13;&#10;Rx-callback has to be of prototype FUNCTION GLOBAL FCbRx VAR_INPUT port:^void; pcd:^DsComData; pcookie:^void; END_VAR;&#13;&#10;Tx-callback has to be of prototype FUNCTION GLOBAL FCbTx VAR_INPUT port:^void; pcd:^DsComData; pcookie:^void; END_VAR;&#13;&#10;CpuState-callback has to be of prototype FUNCTION GLOBAL FCbState VAR_INPUT port:^void; cpu_state:dint; pcookie:^void; END_VAR;&#13;&#10;TaskBeginEnd-callback has to be of prototype FUNCTION GLOBAL FunctThreadBE VAR_INPUT port:^void; state:udint; pcookie:^void; END_VAR;&#13;&#10;Note: Type of parameter &apos;pcookie&apos; can be of any userspecific pointertype.&#13;&#10;" Name="SetCallback"/>
	FUNCTION GLOBAL SetCallback
		VAR_INPUT
			pcb_rx 	: ^void;			//! <Variable Comment="Pointer to rx-callbackfunction of prototype FUNCTION GLOBAL FCbRx VAR_INPUT port:^void; pcd:^DsComData; pcookie:^void; END_VAR;" Name="SetCallback.pcb_rx"/>
			pcb_tx 	: ^void;			//! <Variable Comment="Pointer to tx-callbackfunction of prototype FUNCTION GLOBAL FCbTx VAR_INPUT port:^void; pcd:^DsComData; pcookie:^void; END_VAR;" Name="SetCallback.pcb_tx"/>
			pcb_state 	: ^void;			//! <Variable Comment="Callback to plc-state callback of prototype FUNCTION GLOBAL FCbState VAR_INPUT port:^void; cpu_state:dint; pcookie:^void; END_VAR;" Name="SetCallback.pcb_state"/>
			pcookie 	: ^void;			//! <Variable Comment="cookie, eg. this pointer of calling object" Name="SetCallback.pcookie"/>
			pcb_task_begin_end 	: ^void := nil;
		END_VAR;
				//! <Function Comment="Method will give state of connection" Name="IsOnline"/>
	FUNCTION GLOBAL IsOnline
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true ... connection well done&#13;&#10;false ... connectionerror" Name="IsOnline.retcode"/>
		END_VAR;
				//! <Function Comment="Get DscCrc of connected plc." Name="GetDscCrc"/>
	FUNCTION GLOBAL GetDscCrc
		VAR_OUTPUT
			retcode 	: UDINT;			//! <Variable Comment="Descriptor Crc of enclosed plc" Name="GetDscCrc.retcode"/>
		END_VAR;
				//! <Function Comment="Get value of client &apos;ClientId&apos;" Name="GetClientId"/>
	FUNCTION GLOBAL GetClientId
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
				//! <Function Comment="Get LasalId of given label. &#13;&#10;Note: Functon just will send command to enclosed plc without retrieving response.&#13;&#10;Response will be formatted like&#13;&#10;  [ ..... DSComDataHdr (majorid = ComId_Major_DS, minorid =ComCmd_GetLasalId_Result)&#13;&#10;  [4] ... number of enclosed records (1)&#13;&#10;  * [4] ... given varid&#13;&#10;  * [4] ... LasalId&#13;&#10;  * [1] ... mode (server, client, global variable)" Name="GetLasalId"/>
	FUNCTION GLOBAL GetLasalId
		VAR_INPUT
			label 	: ^CHAR;			//! <Variable Comment="Label of server (ascii-0-terminated string)" Name="GetLasalId.label"/>
			varid 	: UDINT;			//! <Variable Comment="userspecific ID to identify asynchron rx-message (answer)" Name="GetLasalId.varid"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="true or false" Name="GetLasalId.retcode"/>
		END_VAR;
				//! <Function Comment="Get LasalId of given label and wait for response.&#13;&#10;Function will return valid LasalId or 0 in case of error." Name="GetLasalIdSyn"/>
	FUNCTION GLOBAL GetLasalIdSyn
		VAR_INPUT
			label 	: ^CHAR;			//! <Variable Comment="Label of server (ascii-0-terminated string)" Name="GetLasalIdSyn.label"/>
			timeout 	: UDINT;			//! <Variable Comment="Timeout in ms till response (answer)" Name="GetLasalIdSyn.timeout"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;			//! <Variable Comment="Lasalid or 0 on error" Name="GetLasalIdSyn.retcode"/>
		END_VAR;
				//! <Function Comment="Get Usertext given by method Open() or OpenSyn()" Name="GetUserText"/>
	FUNCTION GLOBAL GetUserText
		VAR_OUTPUT
			retcode 	: ^CHAR;			//! <Variable Comment="Valid pointer to usertext (ascii-0-string) or &apos;NIL&apos; in case of error." Name="GetUserText.retcode"/>
		END_VAR;
				//! <Function Comment="Methode will be called once when task is yet started and once when task is right before end." Name="OnTaskBeginEnd"/>
	FUNCTION VIRTUAL GLOBAL OnTaskBeginEnd
		VAR_INPUT
			port 	: ^void;
			state 	: BOOL;			//! <Variable Comment="true = notify that task has just started&#13;&#10;false = notify that task will end yet" Name="OnTaskBeginEnd.state"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DataServiceClient::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DATASERVICECLIENT
0$UINT, 2$UINT, (SIZEOF(::DataServiceClient))$UINT, 
3$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1926365810), "DataServiceClient", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DataServiceClient.CpuState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(792956354), "CpuState", 
(::DataServiceClient.RxData.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1120226718), "RxData", 
(::DataServiceClient.TxData.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2493296259), "TxData", 
//Clients:
(::DataServiceClient.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 37$UINT, 
(::DataServiceClient.ClientId.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3115012432), "ClientId", 
END_FUNCTION


#define USER_CNT_DataServiceClient 4

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DataServiceClient] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DataServiceClient::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DataServiceClient, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #OnReceiveEx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #OnTransmitEx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #CpuStateRx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #OnTaskBeginEnd();

#pragma warning (default : 74)
	CpuState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CpuState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= DataServiceClient();

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION GLOBAL FCbRxTx	VAR_INPUT port:^void; pcd:^DsComData; pcookie:^void; END_VAR;
FUNCTION GLOBAL FCbState VAR_INPUT port:^void; cpu_state:dint; pcookie:^void; END_VAR;
FUNCTION GLOBAL FCbThreadBeginEnd VAR_INPUT port:^void; state:bool; pcookie:^void; END_VAR;


function __cdecl global fnc_CpuStateRx var_input pds0:^void; pthis:^DataServiceClient; cpu_state:DINT; end_var

  pthis^.CpuStateRx(pds0, cpu_state);

end_function

function __cdecl global fnc_DataRx var_input pds0:^void; pthis:^DataServiceClient; pdata:^DsComData; end_var

  if(pdata^.id_minor <> ComCmd_AliveTrigger) | (pdata^.id_major <> ComId_Major_DS) then
    pthis^.OnReceiveEx(pds0, pdata);
  end_if;
  
end_function

function __cdecl global fnc_DataTx var_input pds0:^void; pthis:^DataServiceClient; pdata:^DsComData; end_var

  if(pdata^.id_minor <> ComCmd_AliveTrigger) | (pdata^.id_major <> ComId_Major_DS) then
    pthis^.OnTransmitEx(pds0, pdata);
  end_if;
  
end_function

function __cdecl global fnc_ThreadBeginEnd var_input pds0:^void; pthis:^DataServiceClient; state:usint; end_var

  pthis^.OnTaskBeginEnd(pds0, (state <> 0));
  
end_function

FUNCTION DataServiceClient::DataServiceClient
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  CpuState      := DSC_CPUSTATE_OFFLINE;
	ret_code      := C_OK;
  PcbUserRx     := nil;
  PcbUserTx     := nil;
  PcbUserState  := nil;
  PcbUserCookie := nil;
  PcbUserTskBE  := nil;
  Hdl           := nil; 
//  Hdl      := DataLink_Open("10.10.116.19", 11, 15000, ClientId, #fnc_DataRx(), #fnc_DataTx(), #fnc_CpuStateRx(), this, nil);
//  Hdl      := DataLink_Open("192.168.150.70", 11, 15000, ClientId, #fnc_DataRx(), #fnc_DataTx(), #fnc_CpuStateRx(), this, nil);

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::SetCallback
	VAR_INPUT
		pcb_rx 	: ^void;
		pcb_tx 	: ^void;
		pcb_state 	: ^void;
		pcookie 	: ^void;
		pcb_task_begin_end 	: ^void;(* := nil *)
	END_VAR
  
  PcbUserRx     := pcb_rx;
  PcbUserTx     := pcb_tx;
  PcbUserState  := pcb_state;
  PcbUserCookie := pcookie;
  PcbUserTskBE  := pcb_task_begin_end;

END_FUNCTION

#pragma warning (disable : 73)
FUNCTION VIRTUAL GLOBAL DataServiceClient::CpuStateRx
	VAR_INPUT
		port 	: ^void;
		cpu_state 	: DINT;
	END_VAR
  VAR
  	pcbh : ^void;
  END_VAR

  CpuState := cpu_state;

  if(PcbUserState <> nil) then
    pcbh := PcbUserState;
    if(pcbh <> nil) then
      pcbh$FCbState(port, cpu_state, PcbUserCookie);
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DataServiceClient::OnReceiveEx
	VAR_INPUT
		port 	: ^void;
		pdata 	: ^DsComData;
	END_VAR
  VAR
  	pcbh : ^void;
  END_VAR

  RxData += 1;
  
  if(PcbUserRx <> nil) then
    pcbh := PcbUserRx;
    if(pcbh <> nil) then
      pcbh$FCbRxTx(port, pdata, PcbUserCookie);
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DataServiceClient::OnTransmitEx
	VAR_INPUT
		port 	: ^void;
		pdata 	: ^DsComData;
	END_VAR
  VAR
  	pcbh : ^void;
  END_VAR

  TxData += 1;

  if(PcbUserTx <> nil) then
    pcbh := PcbUserTx;
    if(pcbh <> nil) then
      pcbh$FCbRxTx(port, pdata, PcbUserCookie);
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL DataServiceClient::OnTaskBeginEnd
	VAR_INPUT
		port 	: ^void;
		state 	: BOOL;
	END_VAR
  VAR
  	pcbh : ^void;
  END_VAR

  if(PcbUserTskBE <> nil) then
    pcbh := PcbUserTskBE;
    if(pcbh <> nil) then
      pcbh$FCbThreadBeginEnd(port, state, PcbUserCookie);
    end_if;
  end_if;

END_FUNCTION
#pragma warning (default : 73)

FUNCTION GLOBAL DataServiceClient::Open
	VAR_INPUT
		ipv4 	: ^CHAR;
		timeout_to_host 	: UDINT;
		usertext 	: ^CHAR;(* := nil *)
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;

  if(Hdl = nil) then
    Hdl     := DataLink_OpenEx(ipv4, 12, timeout_to_host, GetClientId(), #fnc_DataRx(), #fnc_DataTx(), #fnc_CpuStateRx(), #fnc_ThreadBeginEnd(), this, usertext);
    retcode := (Hdl <> nil);
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL DataServiceClient::OpenSyn
	VAR_INPUT
		ipv4 	: ^CHAR;
		timeout_to_host 	: UDINT;
		usertext 	: ^CHAR;(* := nil *)
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;

  if(Hdl = nil) then
    Hdl     := DataLink_OpenSynEx(ipv4, 12, timeout_to_host, GetClientId(), #fnc_DataRx(), #fnc_DataTx(), #fnc_CpuStateRx(), #fnc_ThreadBeginEnd(), this, usertext);
    retcode := (Hdl <> nil);
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL DataServiceClient::Close

  if(Hdl <> nil) then
    Hdl := DataLink_Close(Hdl); // handle wird auf nil gesetzt
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL DataServiceClient::IsOnline
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := DataLink_IsOnline(Hdl) <> 0;
  
END_FUNCTION

FUNCTION GLOBAL DataServiceClient::Send
	VAR_INPUT
		pcd 	: ^DsComData;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := DataLink_Send(Hdl, pcd) <> 0;

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::SendSyn
	VAR_INPUT
		pcd_dst 	: ^DsComData;
		pcd_src 	: ^DsComData;
		timeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := DataLink_SendSyn(pcd_dst, Hdl, pcd_src, timeout) <> 0;

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::GetDscCrc
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := DataLink_GetDscCrc(Hdl);
  
END_FUNCTION

FUNCTION GLOBAL DataServiceClient::NewInstCall
	VAR_INPUT
		userid 	: UDINT;
		lasalid 	: UDINT;
		cmd 	: UINT;
		pdata 	: ^void;
		datalen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := DataLink_NewInstCall(Hdl, userid, lasalid, cmd, pdata, datalen) <> 0;

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::NewInstCallSyn
	VAR_INPUT
		pcd_dst 	: ^DsComData;
		userid 	: UDINT;
		lasalid 	: UDINT;
		cmd 	: UINT;
		pdata 	: ^void;
		datalen 	: UDINT;
		timeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := DataLink_NewInstCallSyn(pcd_dst, Hdl, userid, lasalid, cmd, pdata, datalen, timeout) <> 0;

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::SendCmdLoop
	VAR_INPUT
		pdata 	: ^void;
		datasize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := DataLink_SendCmdLoop(Hdl, pdata, datasize) <> 0;

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::SendCmdLoopSyn
	VAR_INPUT
		pcd_dst 	: ^DsComData;
		pdata 	: ^void;
		datasize 	: UDINT;
		timeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := DataLink_SendCmdLoopSyn(pcd_dst, Hdl, pdata, datasize, timeout) <> 0;

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::DsComDataCreateEx
	VAR_INPUT
		scratchbuff 	: ^void;
		scratchbuffsize 	: UDINT;
		datasize 	: UDINT;
		id_minor 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^DsComData;
	END_VAR

  retcode := DsComData_CreateEx(scratchbuff, scratchbuffsize, datasize, ComId_Major_DS, id_minor);

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::DsComDataCreate
	VAR_INPUT
		scratchbuff 	: ^void;
		scratchbuffsize 	: UDINT;
		datasize 	: UDINT;
		id_major 	: UINT;
		id_minor 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^DsComData;
	END_VAR

  retcode := DsComData_CreateEx(scratchbuff, scratchbuffsize, datasize, id_major, id_minor);

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::DsComDataDestroy
	VAR_INPUT
		scratchbuff 	: ^void;
		buffer 	: ^DsComData;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^DsComData;
	END_VAR

  retcode$^void := DsComData_Destroy(scratchbuff, buffer);

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::GetClientId
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  if(ClientId = 0) then
    ClientId := 1 + sigclib_random(100000);
  end_if;

  retcode := ClientId;

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::GetLasalId
	VAR_INPUT
		label 	: ^CHAR;
		varid 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := DataLink_GetLasalId(Hdl, label, varid) <> 0;

END_FUNCTION

FUNCTION GLOBAL DataServiceClient::GetLasalIdSyn
  VAR_INPUT 
    label : ^CHAR; 
		timeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
    retcode : UDINT; 
	END_VAR

  retcode := DataLink_GetLasalIdSyn(Hdl, label, timeout);
  
END_FUNCTION

FUNCTION GLOBAL DataServiceClient::GetUserText
	VAR_OUTPUT
    retcode : ^char; 
	END_VAR

  retcode := DataLink_GetUserText(Hdl);

END_FUNCTION

