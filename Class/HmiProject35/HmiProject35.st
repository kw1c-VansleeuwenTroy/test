//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "HmiProject35"
	Revision           = "0.7"
	GUID               = "{92761A8E-A99B-41B3-8C17-2DC1DC767053}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{84D4B76A-CC82-4CB1-B379-CF1BC740EFF2}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="TotalByteSize" GUID="{2390F602-B8E5-46A2-957A-F9C6DD70780D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="number of bytes has to be sent to hmi"/>
		<Server Name="TotalFileNo" GUID="{C9C38F33-66BD-48F8-BD91-AF14F7A5F87B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="number of files hase to be sent to hmi"/>
		<Client Name="StdLib" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.7" Date="2020-06-18" Author="kolott" Company="sigmatek" Description="Enable functionality of T9-Keypad configuration"/>
		<Dokumentation Revision="0.6" Date="2018-08-31" Author="kolott" Company="sigmatek" Description="Ctor added"/>
		<Dokumentation Revision="0.5" Date="2018-08-27" Author="kolott" Company="sigmatek" Description="Methode AddEntry() will return &apos;true&apos; when parameter pdata = NIL"/>
		<Dokumentation Revision="0.4" Date="2016-09-09" Author="kolott" Company="sigmatek" Description="method AlignU32() added to compute aligned size of project in HMI"/>
		<Dokumentation Revision="0.3" Date="2014-10-14" Author="kolott" Company="sigmatek" Description="comment added"/>
		<Dokumentation Revision="0.2" Date="2014-02-13" Author="kolott" Company="sigmatek" Description="ensure that crc is not 0 or -1"/>
		<Dokumentation Revision="0.1" Date="2014-01-17" Author="kolott" Company="sigmatek" Description="release"/>
	</RevDoku>
</Class>
*)
HmiProject35 : CLASS
	TYPE
#pragma pack(push, 1)
	  PtrSt : STRUCT
	    ptr : ^void;
	    free : BOOL;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	TotalByteSize 	: SvrCh_UDINT;
	TotalFileNo 	: SvrCh_UDINT;
  //Clients:
	StdLib 	: CltChCmd__StdLib;
  //Variables:
		Ptr 	: ^void;
		Pointer : ARRAY [0..511] OF PtrSt;

		FileNameScr 	: UINT;
		FileNameFnt 	: UINT;
		FileNameImg 	: UINT;
		xData : ARRAY [0..4000] OF USINT;

  //Functions:
	
	FUNCTION HmiProject35
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL Free;
	
	FUNCTION GLOBAL Start;
	
	FUNCTION GLOBAL AddEntry
		VAR_INPUT
			listid 	: UDINT;
			number 	: UDINT;
			pdata 	: ^void;
			do_copy 	: BOOL;
			free 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION Copy_BIGBOX
		VAR_INPUT
			ptr 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL End
		VAR_INPUT
			startscreen 	: UDINT;
			timex_backlight 	: UDINT;
			timex_sendtemp 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL GetBox
		VAR_INPUT
			index 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^void;
		END_VAR;
	
	FUNCTION AlignU32
		VAR_INPUT
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION DefaultInit;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiProject35::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMIPROJECT35
0$UINT, 7$UINT, (SIZEOF(::HmiProject35))$UINT, 
3$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2613567777), "HmiProject35", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiProject35.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::HmiProject35.TotalByteSize.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1071768353), "TotalByteSize", 
(::HmiProject35.TotalFileNo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(647744270), "TotalFileNo", 
//Clients:
(::HmiProject35.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_HmiProject35 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiProject35] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiProject35::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_HmiProject35, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HmiProject35();

END_FUNCTION

//{{LSL_IMPLEMENTATION

#includeC "..\LseEasy\Create.h"

#define MAXPRJENTRYNUMBER35  ((sizeof(xData) - sizeof(_BOX_PROJECTLIST)) / sizeof(_BOX_PROJECTLIST_ENTRY)) // 512

FUNCTION HmiProject35::HmiProject35
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code      := C_OK;
  ClassSvr      := 0;
  TotalByteSize := 0;
  TotalFileNo   := 0;
  DefaultInit();

END_FUNCTION

FUNCTION HmiProject35::DefaultInit
  
  FileNameScr := 0;
  FileNameImg := 0;
  FileNameFnt := 0;
  Ptr         := NIL;
  _memset(#Pointer[0], 0, sizeof(Pointer));
  
END_FUNCTION

FUNCTION GLOBAL HmiProject35::Free
  var
    no : udint;
  end_var

  no := sizeof(Pointer) / sizeof(PtrSt);
  while(no) do
    no -= 1;
    if(Pointer[no].free = true) then
      StdLib.Free(Pointer[no].ptr);
    end_if;
  end_while;

  DefaultInit();
  
END_FUNCTION

FUNCTION GLOBAL HmiProject35::Start
  
  Free();
  ClassSvr      := 0;
  TotalByteSize := 0;
  TotalFileNo   := 0;
  
END_FUNCTION

FUNCTION HmiProject35::Copy_BIGBOX
  var_input
    ptr : ^void;
  end_var
  var_output
    retcode : ^void;
  end_var
  VAR
    psrc : ^_BIGBOX_HEADER;
  END_VAR

  psrc    := ptr$^_BIGBOX_HEADER;
  retcode := StdLib.MallocV1(psrc^.size, 0);
    
  if(retcode <> NIL) then
    _memcpy(retcode, ptr, psrc^.size);
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiProject35::AddEntry
	VAR_INPUT
		listid 	: UDINT;
		number 	: UDINT;
		pdata 	: ^void;
		do_copy 	: BOOL;
		free 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    psrc : ^_BIGBOX_HEADER;
    pprj : ^_BOX_PROJECTLIST;
    pdst : ^_BOX_PROJECTLIST_ENTRY;
  end_var

  if(Ptr = NIL) then
    Ptr := #xData[0];
    _memset(Ptr, 0, sizeof(xData));
    pprj$^void := Ptr;
    pprj^.start_screen    := 0;
    pprj^.timex_backlight := 0;
    pprj^.timex_sendtemp  := 0;
    pprj^.compilerversion := 0; // todo: compilerversion setzen
    pprj^.prjcrc          := 0;
    pprj^.no              := 0;
    pprj^.boxhdr.size     := 0;
    pprj^.boxhdr.crc32    := 0;
  end_if;

  retcode := false;

  if(pdata = NIL) then
    retcode := true;
  elsif(Ptr <> NIL) then
  
    pprj$^void := Ptr;
    if(pprj^.no < MAXPRJENTRYNUMBER35) then
      if(do_copy = true) then
        pdata := Copy_BIGBOX(pdata);
        free  := true;
      end_if;
  
      if(pdata <> NIL) then
        Pointer[pprj^.no].free := free;
        Pointer[pprj^.no].ptr  := pdata;
      
        psrc := pdata$^_BIGBOX_HEADER;
        pdst := #pprj^.data[0]; // decieve boundexceed
        pdst += (pprj^.no) * sizeof(_BOX_PROJECTLIST_ENTRY);
        
        case listid of
          BIGBOX_VARLIST      : pdst^.filename := 16#1000;
          BIGBOX_TEXTLIST     : pdst^.filename := 16#2000;
          BIGBOX_BOOTIMAGE    : pdst^.filename := 16#3000;
          BIGBOX_FUNCTIONLIST : pdst^.filename := 16#7000;
          BIGBOX_SHEMELIST    : pdst^.filename := 16#8000;
          BIGBOX_SETUPLIST    : pdst^.filename := 16#9000;
          BIGBOX_KEYBRD_T9    : pdst^.filename := 16#A000;
          BIGBOX_IMAGE        : pdst^.filename := 16#4000 or FileNameImg;
                                FileNameImg    += 1;
          BIGBOX_SCREEN       : pdst^.filename := 16#5000 or FileNameScr;
                                FileNameScr    += 1;
          BIGBOX_FONT         : pdst^.filename := 16#6000 or FileNameFnt;
                                FileNameFnt    += 1;
          else                  return;
        end_case;
        
        retcode  := true;
      
        pdst^.listid := to_uint(listid);
        pdst^.number := to_uint(number);
        
        pprj^.no     += 1;
        ClassSvr     := pprj^.no;
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION HmiProject35::AlignU32
	VAR_INPUT
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  if(size and 16#00000003) then
    size := size and 16#FFFFFFFC;
    size += 4;
  end_if;
  
  retcode := size;

END_FUNCTION

FUNCTION GLOBAL HmiProject35::End
	VAR_INPUT
		startscreen 	: UDINT;
		timex_backlight 	: UDINT;
		timex_sendtemp 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^void;
	END_VAR
  var
    pprj : ^_BOX_PROJECTLIST;
    no : udint;
    pbox : ^_BIGBOX_HEADER;
  end_var

  TotalByteSize := 0;
  TotalFileNo   := 0;

  if((timex_sendtemp > 0) & (timex_sendtemp < 1000)) then
    timex_sendtemp := 1000;
  end_if;

  if(Ptr <> NIL) then
    pprj$^void := Ptr;
    pprj^.boxhdr.size := 0;
    
    // startscreen eintragen
    pprj^.start_screen  := to_uint(startscreen);

    // backlighttimeout
    pprj^.timex_backlight := to_uint(timex_backlight / 1000);
    
    // sendtemperature interval
    pprj^.timex_sendtemp  := to_uint(timex_sendtemp);

    // berechnung project crc
    // vorsicht: nicht ändern muss gleich wie im hmi sein
    pprj^.prjcrc := 0;
    no           := pprj^.no;
    while(no) do
      no -= 1;
      pbox$^void := GetBox(no);
      if(pbox <> NIL) then
        pprj^.prjcrc := (pprj^.prjcrc rol 1) xor pbox^.crc32;
        TotalByteSize  += AlignU32(pbox^.size);
      end_if;
    end_while;

    if((pprj^.prjcrc = 0) | (pprj^.prjcrc = 16#FFFFFFFF)) then
      pprj^.prjcrc := 16#240270; // crc must not be 0 or -1
    end_if;

    end_BIGBOX_HEADER(#pprj^.boxhdr, sizeof(_BOX_PROJECTLIST) - sizeof(pprj^.data) + (pprj^.no * sizeof(_BOX_PROJECTLIST_ENTRY)));
    
    TotalByteSize += AlignU32(pprj^.boxhdr.size);
    TotalFileNo   := pprj^.no + 1;
  end_if;
  
  retcode := Ptr;

END_FUNCTION

FUNCTION GLOBAL HmiProject35::GetBox
	VAR_INPUT
		index : UDINT;
	END_VAR    
	VAR_OUTPUT
		retcode 	: ^void;
	END_VAR    
  var
    pprj : ^_BOX_PROJECTLIST;
  end_var

  retcode := NIL;
  
  if(Ptr <> NIL) then
    pprj$^void := Ptr;

    if(index < pprj^.no) then
      retcode := Pointer[index].ptr;
    end_if;
  end_if;

END_FUNCTION
