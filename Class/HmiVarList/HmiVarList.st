//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "HmiVarList"
	Revision           = "0.17"
	GUID               = "{9F1C9F8E-3E8F-438E-B340-699A15BD6D63}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Client Name="ComPort" Required="true" Internal="false"/>
		<Client Name="HmiUnitShemeList" Required="true" Internal="true"/>
		<Client Name="HmiVarList35" Required="true" Internal="false"/>
		<Client Name="Label" Required="true" Internal="true"/>
		<Client Name="StringLib" Required="true" Internal="false"/>
		<Client Name="TextList" Required="true" Internal="false"/>
		<Client Name="UnitInfo" Required="true" Internal="true"/>
		<Client Name="VarInfo" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.17" Date="2018-12-27" Author="kolott" Company="sigmatek" Description="Method RenameRootObject() added"/>
		<Dokumentation Revision="0.16" Date="2018-08-28" Author="kolott" Company="sigmatek" Description="Enable view of REAL-Values on HMI&#13;&#10;Variable Limits at Variables will work with HMI-Firmware &gt;= 1.23"/>
		<Dokumentation Revision="0.15" Date="2017-07-06" Author="kolott" Company="sigmatek" Description="methode GetVarnoByHmiVarno() done global"/>
		<Dokumentation Revision="0.14" Date="2016-05-20" Author="kolott" Company="sigmatek" Description="sa26785: compilerversion 60, property preceding zero implemented"/>
		<Dokumentation Revision="0.13" Date="2016-04-23" Author="kolott" Company="sigmatek" Description="sa34276: new methode Recalculate() added to ensure recalculation from binary to physical values"/>
		<Dokumentation Revision="0.12" Date="2016-02-17" Author="kolott" Company="sigmatek" Description="betterment in method GetValue()"/>
		<Dokumentation Revision="0.11" Date="2016-02-04" Author="kolott" Company="sigmatek" Description="new method GetMapCrc() added"/>
		<Dokumentation Revision="0.10" Date="2015-06-03" Author="kolott" Company="sigmatek" Description="new method GetVarNoByName() and GetVarNoByLasalId() to evaluate &apos;varno&apos; of given server"/>
		<Dokumentation Revision="0.9" Date="2014-11-26" Author="kolott" Company="sigmatek" Description="new method HmiVariableExtention() used to ensure userextended modifications done in firmware of hmi&#13;&#10;EasyMap.xml: enable &apos;_&apos; in varname"/>
		<Dokumentation Revision="0.8" Date="2014-11-24" Author="kolott" Company="sigmatek" Description="ability to set string at stringserver "/>
		<Dokumentation Revision="0.7" Date="2014-10-14" Author="kolott" Company="sigmatek" Description="Server &quot;ListVal0&quot; is added to ensure scrollist on HMI"/>
		<Dokumentation Revision="0.6" Date="2014-08-06" Author="kolott" Company="sigmatek" Description="Server of type ENUM will work as well"/>
		<Dokumentation Revision="0.5" Date="2014-06-02" Author="kolott" Company="sigmatek" Description="bugfix: unicode text on display has always started with character &apos;?&apos;"/>
		<Dokumentation Revision="0.4" Date="2014-03-07" Author="kolott" Company="sigmatek" Description="easymap info in xml-format"/>
		<Dokumentation Revision="0.3" Date="2014-02-21" Author="kolott" Company="sigmatek" Description="HmiSwVersion and HmiHwVersion added"/>
		<Dokumentation Revision="0.2" Date="2014-01-20" Author="kolott" Company="sigmatek" Description="optimization in method RefreshRun()"/>
	</RevDoku>
	<Network Name="HmiVarList">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{58D1A081-E883-47F1-81E9-6B29F8BA2FA1}"
				Class      = "HmiBaseList"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "HmiUnitShemeList"
				GUID       = "{DDFD2CD4-ACB1-4E7C-8C48-53A068F80E7C}"
				Class      = "HmiShemeList"
				Position   = "(780,780)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "Label"
				GUID       = "{0806C304-7D57-43C7-9377-DE0FED88D684}"
				Class      = "HmiAsciiBuffer"
				Position   = "(210,540)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
					<Client Name="StringLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "UnitInfo"
				GUID       = "{C9BB1E6B-E36A-4AA4-A5AB-D5D76B1BC515}"
				Class      = "HmiUnitList"
				Position   = "(210,780)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
			<Object
				Name       = "VarInfo"
				GUID       = "{E3E5982E-B392-4881-A1B8-1C9B73FAE293}"
				Class      = "HmiVarInfoList"
				Position   = "(210,360)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="File"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1252,210),(518,210),"/>
			<Connection Source="_base.File" Destination="this.File" Vertices="(218,210),(38,210),"/>
			<Connection Source="this.Label" Destination="Label.ClassSvr"/>
			<Connection Source="VarInfo.File" Destination="this.File" Vertices="(210,450),(38,210),"/>
			<Connection Source="Label.File" Destination="this.File" Vertices="(210,630),(38,210),"/>
			<Connection Source="this.VarInfo" Destination="VarInfo.ClassSvr"/>
			<Connection Source="Label.StringLib" Destination="this.StringLib" Vertices="(210,690),(38,270),"/>
			<Connection Source="this.UnitInfo" Destination="UnitInfo.ClassSvr"/>
			<Connection Source="UnitInfo.File" Destination="this.File" Vertices="(210,870),(38,210),"/>
			<Connection Source="this.HmiUnitShemeList" Destination="HmiUnitShemeList.ClassSvr"/>
			<Connection Source="HmiUnitShemeList.File" Destination="this.File" Vertices="(780,870),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using HmiBaseList

HmiVarList : CLASS
: HmiBaseList
	TYPE
	  PLseEasy : ^LseEasy;
	  PStringInternal : ^StringInternal;
	END_TYPE
  //Servers:
  //Clients:
	StringLib 	: CltChCmd_HmiStrLib;
	UnitInfo 	: CltChCmd_HmiUnitList;
	Label 	: CltChCmd_HmiAsciiBuffer;
	VarInfo 	: CltChCmd_HmiVarInfoList;
	TextList 	: CltChCmd_HmiTextList;
	HmiVarList35 	: CltChCmd_HmiVarList35;
	ComPort 	: CltChCmd_HmiComPort;
	HmiUnitShemeList 	: CltChCmd_HmiShemeList;
  //Variables:
		TxtDummyUni : ARRAY [0..255] OF UINT;

		TxtDummyAscii : ARRAY [0..255] OF CHAR;

		RunIndex 	: UDINT;
		TempStr : ARRAY [0..255] OF USINT;

		TempUniStr : ARRAY [0..255] OF UINT;

		HmiVarNoToVarNo : ARRAY [0..2048] OF UDINT;

		HmiVarNoMaxIndex 	: UDINT;
		BacklightDimLid 	: UDINT;
		HmiVarNoInUse 	: BOOL;
		HmiSwVersionLid 	: UDINT;
		HmiHwVersionLid 	: UDINT;
		TmpScheme 	: HMI_SCHEME;
		TmpSchemeLines : ARRAY [0..255] OF HMI_SCHEMELINE;

		SuperLseEasy 	: PLseEasy;
  //Functions:
	
	FUNCTION HmiVarList
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL Load
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL Free;
	
	FUNCTION GetServerNameSub
		VAR_INPUT
			txt 	: ^CHAR;
			varno 	: UDINT;
			pcut 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^HMI_VARINFO;
		END_VAR;
	
	FUNCTION GLOBAL GetServerName
		VAR_INPUT
			txt 	: ^CHAR;
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetLasalId
		VAR_INPUT
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetAdd35
		VAR_INPUT
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION Add35
		VAR_INPUT
			varno 	: UDINT;
			pvi 	: ^HMI_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GetUnitTextAdd35
		VAR_INPUT
			varno 	: UDINT;
			pvi 	: ^HMI_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GetDescribingTextAdd35
		VAR_INPUT
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetValue
		VAR_INPUT
			pvalue 	: ^DINT;
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetDescribingText
		VAR_INPUT
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetUnitText
		VAR_INPUT
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetValueAnything
		VAR_INPUT
			pval 	: ^DINT;
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetUnit
		VAR_INPUT
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^HMI_XUNIT;
		END_VAR;
	
	FUNCTION GLOBAL LoadUnitScheme
		VAR_INPUT
			dpne 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL RefreshRun;
	
	FUNCTION GLOBAL RefreshAll;
	
	FUNCTION UpdateVariable
		VAR_INPUT
			varno 	: UDINT;
			pvi 	: ^HMI_VARINFO;
			value 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ReadString
		VAR_INPUT
			lid 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^UINT;
		END_VAR;
	
	FUNCTION GLOBAL UpdateValue
		VAR_INPUT
			hmivarno 	: UINT;
			value 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetVarnoByHmiVarno
		VAR_INPUT
			hmivarno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION SetVarnoByHmiVarno
		VAR_INPUT
			varno 	: UDINT;
			hmivarno 	: UDINT;
		END_VAR;
	
	FUNCTION KillPostToken
		VAR_INPUT
			pname 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL UpdateString
		VAR_INPUT
			hmivarno 	: UINT;
			pstr 	: ^void;
			chrsize 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL Get
		VAR_INPUT
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^HMI_VARINFO;
		END_VAR;
	
	FUNCTION GLOBAL OverloadLight
		VAR_INPUT
			ovrlodno 	: DINT;
		END_VAR;
	
	FUNCTION Start;
	
	FUNCTION GLOBAL SetLid
		VAR_INPUT
			lidBacklight 	: UDINT;
			lidSwVer 	: UDINT;
			lidHwVer 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetMapInfoXML
		VAR_INPUT
			index 	: UDINT;
			ptext 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL CreateShemeFromEnum
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^HMI_SCHEME;
		END_VAR;
	
	FUNCTION EnumSchemeAdd
		VAR_INPUT
			dst 	: ^HMI_SCHEME;
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetServerNameToken
		VAR_INPUT
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^UINT;
		END_VAR;
	
	FUNCTION WriteString
		VAR_INPUT
			lid 	: UDINT;
			ptxt 	: ^void;
			chrsize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION HmiVariableExtention
		VAR_INPUT
			varname 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetSuper
		VAR_INPUT
			psuper 	: PLseEasy;
		END_VAR;
	
	FUNCTION GetVarNoSub
		VAR_INPUT
			name 	: ^CHAR;
			scope 	: UDINT;
			station 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetVarNoByName
		VAR_INPUT
			name 	: ^CHAR;
			station 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetVarNoByLasalID
		VAR_INPUT
			lasalid 	: UDINT;
			station 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetMapCrc
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION Recalculate
		VAR_INPUT
			pvalue 	: ^DINT;
			varno 	: UDINT;
			to_hmi 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetDigits
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
			vornullen 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
	
	FUNCTION ConvertRealToDint
		VAR_INPUT
			rvalue 	: REAL;
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION ConvertDintToReal
		VAR_INPUT
			value 	: DINT;
			varno 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: REAL;
		END_VAR;
	
	FUNCTION DoLimit
		VAR_INPUT
			pany 	: ^HMI_ANYTHING;
			def_limit 	: DINT;
			pid 	: ^UDINT;
			id_bit 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VariableLimitsInUse
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
				//! <Function Comment="Method can be used to chance name of individual Object&#13;&#10;oldname ... existing name of Object&#13;&#10;newname ... new name of Object&#13;&#10;function will return true on success, on the other hand false" Name="RenameRootObject"/>
	FUNCTION GLOBAL RenameRootObject
		VAR_INPUT
			oldname 	: ^CHAR;
			newname 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using HmiAsciiBuffer
#pragma using HmiShemeList
#pragma using HmiUnitList
#pragma using HmiVarInfoList
#pragma usingLtd HmiComPort
#pragma usingLtd HmiStrLib
#pragma usingLtd HmiTextList
#pragma usingLtd HmiVarList35


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiVarList::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMIVARLIST
0$UINT, 17$UINT, (SIZEOF(::HmiVarList))$UINT, 
0$UINT, 8$UINT, 0$UINT, 
TO_UDINT(3793961451), "HmiVarList", //Class
TO_UDINT(3735923847), "HmiBaseList", 0$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::HmiVarList.StringLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(3243119075), "StringLib", TO_UDINT(103556616), "HmiStrLib", 0$UINT, 2$UINT, 
(::HmiVarList.UnitInfo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1431051711), "UnitInfo", TO_UDINT(2706799507), "HmiUnitList", 0$UINT, 2$UINT, 
(::HmiVarList.Label.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4193489496), "Label", TO_UDINT(3253426089), "HmiAsciiBuffer", 0$UINT, 1$UINT, 
(::HmiVarList.VarInfo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2280015214), "VarInfo", TO_UDINT(1002095878), "HmiVarInfoList", 0$UINT, 1$UINT, 
(::HmiVarList.TextList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3693760938), "TextList", TO_UDINT(2809265865), "HmiTextList", 0$UINT, 4$UINT, 
(::HmiVarList.HmiVarList35.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1599081198), "HmiVarList35", TO_UDINT(1599081198), "HmiVarList35", 0$UINT, 5$UINT, 
(::HmiVarList.ComPort.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3802332095), "ComPort", TO_UDINT(136722037), "HmiComPort", 0$UINT, 16$UINT, 
(::HmiVarList.HmiUnitShemeList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1872312570), "HmiUnitShemeList", TO_UDINT(3851519469), "HmiShemeList", 0$UINT, 3$UINT, 
END_FUNCTION


#define USER_CNT_HmiVarList 2

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiVarList] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiVarList::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= HmiBaseList::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= HmiBaseList::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, HmiBaseList::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_HmiVarList;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Load();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #Free();

#pragma warning (default : 74)
	HmiBaseList::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF HmiBaseList::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HmiVarList();

END_FUNCTION

#pragma usingLtd LseEasy
#pragma usingLtd StringInternal

//{{LSL_IMPLEMENTATION

#includeC "..\LseEasy\Create.h"

#pragma usingLtd StringInternal
#pragma usingLtd LseEasy

FUNCTION HmiVarList::HmiVarList
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code     := C_OK;
  SuperLseEasy := nil;

END_FUNCTION

FUNCTION HmiVarList::Start

  HmiVarNoInUse    := false;
  HmiVarNoMaxIndex := 0;
  RunIndex         := 0;
  _memset(#HmiVarNoToVarNo[0], 16#FF, sizeof(HmiVarNoToVarNo));

END_FUNCTION

FUNCTION VIRTUAL HmiVarList::Free

  VarInfo.Free();
  Label.Free();
  UnitInfo.Free();
  Start();

END_FUNCTION

FUNCTION VIRTUAL HmiVarList::Load
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  Start();
  VarInfo.Load();
  Label.Load();
  UnitInfo.Load();

  retcode := File.FChkFile();
  
  if(retcode = false) then
    Free();
  end_if;

  Label.MakeGuidePost();
  ClassSvr := to_dint(Label.GetNo());

END_FUNCTION

FUNCTION HmiVarList::GetServerNameSub
	VAR_INPUT
		txt 	: ^char;
		varno 	: UDINT;
		pcut 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^HMI_VARINFO;
	END_VAR
  var
    pvi : ^HMI_VARINFO;
    name : ^char;
    cut : uint;
  end_var

  // ist pcut^ <> 0 dann wird der string nach dem ersten '.' nicht weiter vervollständigt
  
  retcode := NIL;
  pvi     := VarInfo.Get(varno);
  cut     := pcut^;
  
  if(pvi <> NIL) then
    if(pvi^.scope <> HMI_DEFSCOPE) then
      if(GetServerNameSub(txt, pvi^.scope, pcut) <> NIL) then
        if(cut = pcut^) then
          if(pvi^.vartype = HMI_OBJECT) then
            StringLib.StrCat(txt, sizeof(LASCII), "\", sizeof(LASCII));
          else
            if(cut) then
              pcut^ += 1; // stringzusammenstellung abbrechen
              cut   += 1;
            end_if;
            StringLib.StrCat(txt, sizeof(LASCII), ".", sizeof(LASCII));
          end_if;
        end_if;
      end_if;
    end_if;
    
    name := Label.GetText(varno);
    if(name <> NIL) then
      if(cut = pcut^) then
        StringLib.StrCat(txt, sizeof(LASCII), name, sizeof(LASCII));
      end_if;
      retcode := pvi;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetServerName
	VAR_INPUT
		txt 	: ^char;
		varno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    cut : uint;
  end_var

  retcode := false; 
  if(txt <> NIL) then
    txt^ := 0;
    cut  := 0;
    if(GetServerNameSub(txt, varno, #cut) <> NIL) then
      retcode := true; 
    end_if; 
  end_if; 
  
END_FUNCTION

FUNCTION HmiVarList::KillPostToken
	VAR_INPUT
		pname 	: ^char;
	END_VAR
  VAR
  	cnt : udint;
  END_VAR

  cnt := 0;
  while(pname^) do
    if(pname^ = '.') then
      cnt += 1;
      if(cnt = 2) then
        pname^ := 0;
        return;
      end_if;
    end_if;
    pname += 1;
  end_while;

END_FUNCTION

FUNCTION HmiVarList::HmiVariableExtention
	VAR_INPUT
		varname 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := 16#FFFFFFFF;

  if(SuperLseEasy <> nil) then
    retcode := SuperLseEasy^.HmiVariableExtention(varname);
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetLasalId
	VAR_INPUT
		varno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	pvi : ^HMI_VARINFO;
    name : array[0..255] of char;
    p0 : ^VirtualBase;
    extvarno : udint;
  END_VAR


  retcode := 0;
  pvi     := VarInfo.Get(varno);
  if(pvi <> NIL) then
    if(pvi^.lasalid <> 0) then
      // vorsicht: lasalid 1 bedeudet dass Server nicht vorhanden ist
      if(pvi^.lasalid > 1) then
        retcode := pvi^.lasalid;
      end_if;
      return;
    end_if;
    
    if((pvi^.vartype <> HMI_CONSTANT) & (pvi^.vartype <> HMI_MERKER) & (pvi^.vartype <> HMI_ENUMITEM)) then
      if(GetServerName(#name[0], varno) = true) then
      
        extvarno := HmiVariableExtention(#name[0]); // lookup userextention
        if(extvarno < 16#FFFF) then
          pvi^.lasalid := 1;
          pvi^.index35 := extvarno;
        else
          if(pvi^.vartype = HMI_BIT) then
            KillPostToken(#name[0]);
          end_if;
      
          _LookUpEmbed_C(#name[0], #pvi^.lasalid$^void, #p0);
          if(pvi^.lasalid <> 0) then
            retcode := pvi^.lasalid;
          else
            pvi^.lasalid := 1;
          end_if;
        end_if;
        
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION HmiVarList::ConvertRealToDint
	VAR_INPUT
		rvalue 	: REAL;
		varno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    any : HMI_ANYTHING;
    dig : udint;
  END_VAR

  any.ima   := HMI_IMA_V_SERVERLIST;
  any.value := to_dint(varno);
  dig       := GetDigits(#any, false);
  while(dig > 0) do
    rvalue := rvalue * 10;
    dig -= 1;
  end_while;
  retcode   := to_dint(rvalue);

END_FUNCTION

FUNCTION HmiVarList::ConvertDintToReal
	VAR_INPUT
		value 	: DINT;
		varno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: REAL;
	END_VAR
  VAR
    any : HMI_ANYTHING;
    dig : udint;
  END_VAR

  any.ima   := HMI_IMA_V_SERVERLIST;
  any.value := to_dint(varno);
  dig       := GetDigits(#any, false);
  retcode   := value;
  while(dig > 0) do
    retcode := retcode / 10;
    dig -= 1;
  end_while;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetValue
	VAR_INPUT
		pvalue 	: ^DINT;
		varno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    pvi : ^HMI_VARINFO;
  	lid : udint;
    pstrInt : ^StringInternal;
  END_VAR

  retcode := false;
  
  pvi := VarInfo.Get(varno);

  if(pvi <> NIL) then
    if((pvi^.vartype = HMI_CONSTANT) | (pvi^.vartype = HMI_ENUMITEM)) then
      pvalue^ := pvi^.limit_hi.value;
      retcode := true;
    elsif(pvi^.vartype = HMI_MERKER) then
      pvalue^ := 0;
      retcode := true;
    elsif((pvi^.vartype = HMI_BINARY) | (pvi^.vartype = HMI_DATE) | (pvi^.vartype = HMI_TIME) | (pvi^.vartype = HMI_BIT) | (pvi^.vartype = HMI_ENUM)) then
      lid := GetLasalId(varno);
      if(lid <> 0) then
        retcode := true;
        pvalue^ := RD(lid$^void); // call read-methode
      
        if(pvi^.vartype = HMI_BIT) then
          pvalue^ := to_dint(((pvalue$^udint^) shr (pvi^.subtype and 16#FF)) and 1);
        end_if;
        
        if((pvi^.vartype = HMI_BINARY) & (pvi^.subtype = 12)) then
          // es ist ein Real-Value --> in DINT umrechnen
          pvalue^ := ConvertRealToDint(pvalue$^REAL^, varno);
        end_if;
        
        Recalculate(pvalue, varno, true); // in hmi-wert umrechnen
        
      end_if;
    elsif(pvi^.vartype = HMI_STRING) then
      lid := GetLasalId(varno);
      if(lid <> 0) then
        pStrInt$udint := lid;
        pvalue^ := to_dint(pStrInt^.GetCrc());
        retcode := true;
      end_if;
    end_if;
 end_if;
 
END_FUNCTION

FUNCTION HmiVarList::GetUnitTextAdd35
  VAR_INPUT
    varno : UDINT;
  	pvi : ^HMI_VARINFO;
  END_VAR
  VAR_OUTPUT
    retcode : UDINT;
	END_VAR
  VAR
  	ptxt : ^uint;
  END_VAR

  retcode := HMI_DEFSCOPE;
  ptxt := GetUnitText(varno);
  if(ptxt <> NIL) then
    retcode := TextList.Add35(ptxt);
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetUnitText
  VAR_INPUT
    varno : UDINT;
  END_VAR
  VAR_OUTPUT
    retcode : ^UINT;
	END_VAR
  VAR
  	pui : ^HMI_XUNIT;
  END_VAR
 
  retcode := NIL;
  
  pui     := GetUnit(varno);
  if(pui <> NIL) then
    retcode := TextList.GetText(#pui^.text);
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetDescribingText
  VAR_INPUT
    varno : UDINT;
  END_VAR
  VAR_OUTPUT
    retcode : ^UINT;
	END_VAR
  VAR
  	pvi : ^HMI_VARINFO;
  END_VAR

  retcode := NIL;
  
  pvi := VarInfo.Get(varno);
  if(pvi <> NIL) then
    retcode := TextList.GetText(#pvi^.text1);
    if(retcode = NIL) then
      if(GetServerName(#TxtDummyAscii[0], varno) = true) then
        StringLib.StrCpy(#TxtDummyUni[0], 2, #TxtDummyAscii[0], 1);
        retcode := #TxtDummyUni[0];
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetServerNameToken
  VAR_INPUT
    varno : UDINT;
  END_VAR
  VAR_OUTPUT
    retcode : ^UINT;
	END_VAR
  VAR
    ptxt : ^char;
  END_VAR

  retcode := NIL;
  ptxt    := Label.GetText(varno);
  if(ptxt <> nil) then
    StringLib.StrCpy(#TxtDummyUni[0], 2, ptxt, 1);
    retcode := #TxtDummyUni[0];
  end_if;
  
END_FUNCTION

FUNCTION HmiVarList::GetDescribingTextAdd35
  VAR_INPUT
    varno : UDINT;
  END_VAR
  VAR_OUTPUT
    retcode : UDINT;
	END_VAR
  VAR
  	ptxt : ^UINT;
  END_VAR
  
  retcode := HMI_DEFSCOPE;
  ptxt    := GetDescribingText(varno);
  if(ptxt <> NIL) then
    retcode := TextList.Add35(ptxt);
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetValueAnything
	VAR_INPUT
		pval 	: ^DINT;
		pany 	: ^HMI_ANYTHING;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;
  
  if(pany^.ima = HMI_IMA_DINT_CONSTANT) then
    pval^   := pany^.value;
    retcode := true;
  elsif(pany^.ima = HMI_IMA_UDINT_CONSTANT) then
    pval^   := pany^.value;
    retcode := true;
  elsif(pany^.ima = HMI_IMA_V_SERVERLIST) then
    retcode := GetValue(pval, to_udint(pany^.value));
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetVarnoByHmiVarno
	VAR_INPUT
		hmivarno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
 
  retcode := 0xFFFFFFFF;
  if(hmivarno <= HmiVarNoMaxIndex) then //(sizeof(HmiVarNoToVarNo) / sizeof(HmiVarNoToVarNo[0]))) then
    retcode := HmiVarNoToVarNo[hmivarno];
  end_if;
  
END_FUNCTION

FUNCTION HmiVarList::SetVarnoByHmiVarno
  VAR_INPUT
    varno : UDINT;
    hmivarno : UDINT;
  END_VAR
 
  if(hmivarno < (sizeof(HmiVarNoToVarNo) / sizeof(HmiVarNoToVarNo[0]))) then
    HmiVarNoInUse := true;
    HmiVarNoToVarNo[hmivarno] := varno;
    if(hmivarno > HmiVarNoMaxIndex) then
      HmiVarNoMaxIndex := hmivarno;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION HmiVarList::VariableLimitsInUse
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := false;
  
  if(SuperLseEasy <> NIL) then
    if(SuperLseEasy^.VariableLimitsInUse() = true) then
      if(SuperLseEasy^.HmiSwVersion.Read() >= 123) then // ab HMI-Firmwarversion 1.23 sind variable Grenzwerte möglich
        retcode := true;
      else
        SuperLseEasy^.OutMessage("WARNING: Need HMI-FirmwareUpdate to ensure functionality of variable Limit");
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION HmiVarList::DoLimit
  VAR_INPUT
    pany : ^HMI_ANYTHING;
    def_limit : dint;
    pid : ^udint;
    id_bit : udint;
  END_VAR
  VAR_OUTPUT
    retcode : DINT;
	END_VAR
  VAR
  	vno : udint;
  END_VAR

  vno := HMI_DEFSCOPE;  
  if(pany^.ima = HMI_IMA_V_SERVERLIST) then
    if(VariableLimitsInUse() = true) then
      vno := GetAdd35(pany^.value$udint);
    end_if;
  end_if;
  
  if(vno = HMI_DEFSCOPE) then
    if(GetValueAnything(#retcode, pany) = false) then
      retcode := def_limit; // konstanter defaultwert
    end_if;
  else
    retcode := to_dint(vno); // variablennummer
    pid^ := (pid^) or id_bit; // limit ist variabel
  end_if;

END_FUNCTION

FUNCTION HmiVarList::Add35
  VAR_INPUT
    varno : UDINT;
    pvi : ^HMI_VARINFO;
  END_VAR
  VAR_OUTPUT
    retcode : UDINT;
	END_VAR
  VAR
  	txt1, txt2 : udint;
    og, ug : dint;
  END_VAR

  txt1 := GetDescribingTextAdd35(varno) and 16#3FFF; // 2msb's are reserved to ensure variable limits
  
  if(pvi^.vartype =  HMI_STRING) then
    txt2 := VARTYPE_STRING;
    og   := pvi^.subtype;
    ug   := pvi^.subtype;
  else
    txt2 := GetUnitTextAdd35(varno, pvi);
    og   := DoLimit(#pvi^.limit_hi,  2147483647, #txt1, 16#8000); // evaluate hi-limit
    ug   := DoLimit(#pvi^.limit_lo, -2147483648, #txt1, 16#4000); // evaluate lo-limit
  end_if;
  
  retcode := HMIVarList35.AddEntry(og, ug, txt1$uint, txt2$uint);
  
  SetVarnoByHmiVarno(varno, retcode);

END_FUNCTION

FUNCTION GLOBAL HmiVarList::Get
	VAR_INPUT
		varno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^HMI_VARINFO;
	END_VAR

  retcode := VarInfo.Get(varno);

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetAdd35
	VAR_INPUT
		varno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	pvi : ^HMI_VARINFO;
  END_VAR

  retcode := HMI_DEFSCOPE;

  pvi := VarInfo.Get(varno);
  if(pvi <> NIL) then
    if(pvi^.lasalid = 0) then
      GetLasalId(varno);
    end_if;
    
    if(pvi^.lasalid = BacklightDimLid) then
      pvi^.index35 := VARNO_BACKLIGHT_DIM;
    elsif(pvi^.lasalid = HmiSwVersionLid) then
      pvi^.index35 := VARNO_SWVERSION;
    elsif(pvi^.lasalid = HmiHwVersionLid) then
      pvi^.index35 := VARNO_HWVERSION;
    elsif(pvi^.index35 = HMI_DEFSCOPE) then
      pvi^.index35 := Add35(varno, pvi);
    end_if;
    
    retcode := pvi^.index35;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetUnit
	VAR_INPUT
		varno 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^HMI_XUNIT;
	END_VAR
  VAR
  	pvi : ^HMI_VARINFO;
    index, svrno : udint;
    value : dint;
    pany : ^HMI_ANYTHING;
  END_VAR

  retcode := nil;
  pvi     := VarInfo.Get(varno);
  
  if(pvi <> nil) then
    pany := #pvi^.unitschema;
    
    if(pany^.ima = HMI_IMA_V_UNITSCHEMA) then
      index := to_udint(pany^.value);
      svrno := HmiUnitShemeList.GetServerNumber(index);
      if(GetValue(#value, svrno) = true) then
        pany := HmiUnitShemeList.GetResult(index, value); // unitschema auswerten
      end_if;
    end_if;  

    if(pany <> nil) then
      if(pany^.ima = HMI_IMA_V_UNIT) then
        index   := to_udint(pany^.value);
        retcode := UnitInfo.Get(index);
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::LoadUnitScheme
	VAR_INPUT
		dpne 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := HmiUnitShemeList.LoadFile(dpne);

END_FUNCTION

FUNCTION HmiVarList::WriteString
  VAR_INPUT
    lid : udint;
    ptxt : ^void;
    chrsize : udint;
  END_VAR
  VAR_OUTPUT
    retcode : bool;
  END_VAR
  VAR
    pstrInt : ^StringInternal;
    len : udint;
  END_VAR

  if(lid <> 0) then
    pStrInt$udint := lid;
    len := StringLib.StrLen(ptxt, to_uint(chrsize)) + 1;
    if(chrsize = 1) then
      pStrInt^.WriteDataOff(len, 0, ptxt$^usint);
    else
      pStrInt^.WriteDataOffUni(len*2, 0, ptxt$^uint, 2);
    end_if;
  end_if;

  retcode := false;

END_FUNCTION

FUNCTION HmiVarList::ReadString
  VAR_INPUT
    lid : udint;  
  END_VAR
  VAR_OUTPUT
    retcode : ^uint;
  END_VAR
  VAR
  	len : udint;
    pstrInt : ^StringInternal;
    unicode : bool;
  END_VAR
  
  retcode := NIL;
  
  if(lid <> 0) then
    pStrInt$udint := lid;
    len           := pStrInt^.GetLength();
    if(len > (sizeof(TempStr) - 2)) then
      len := sizeof(TempStr) - 2;
    end_if;
    
    if(len > 0) then
      pStrInt^.GetDataAt(#TempStr[0], len, 0);
      TempStr[len]$uint := 0; // unicode abschluss sicherstellen
    
      unicode := false;
      if(len > 1) then
        if(TempStr[0]$uint = 16#0200) then
          unicode := true;
        end_if;
      end_if;
      
      if(unicode = true) then
        retcode$^usint := #TempStr[2];
      else
        StringLib.StrCpy(#TempUniStr[0], 2, #TempStr[0], 1);  
        retcode := #TempUniStr[0];
      end_if;  
    else
      TempUniStr[0] := 0;
      retcode       := #TempUniStr[0];
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION HmiVarList::UpdateVariable
	VAR_INPUT
		varno 	: UDINT;
		pvi 	: ^HMI_VARINFO;
		value 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    pstr : ^uint;
    strlen : udint;
  END_VAR

  retcode := false;
  
  if(pvi^.vartype = HMI_STRING) then
    pstr := ReadString(GetLasalId(varno));
    if(pstr <> NIL) then
    
      strlen := StringLib.StrLen(pstr, 2); // uni-strlen
      if(strlen > 63) then // hmi kann nicht mehr als 63 zeichen
        if(SuperLseEasy <> NIL) then
          SuperLseEasy^.OutMessage("WARNING: Max.length of stringupdate exceeded ..."); // sa39546
        end_if;
        _memcpy(#TxtDummyUni[0], pstr, 63*2);
        pstr := #TxtDummyUni[0];
        TxtDummyUni[63] := 0;
        strlen := 63;
      end_if;
      
      retcode := ComPort.UpdateString(pvi^.index35, pstr, (strlen + 1) * 2);
    end_if;
  else
    retcode := ComPort.UpdateData(pvi^.index35, value);
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL HmiVarList::RefreshAll
  VAR 
    pvi : ^HMI_VARINFO;
    value : dint;
    idx, varno : udint;
  END_VAR

//  idx := 0;
//  pvi := VarInfo.Get(idx);
//  while(pvi) do
//    if(pvi^.index35 < VARNO_SPEZIAL) then
//      if(GetValue(#value, idx) = true) then 
//        if(UpdateVariable(idx, pvi, value) = true) then
//          pvi^.oldval := value;
//        end_if;
//      end_if;
//    end_if;
//    
//    idx += 1;
//    pvi := VarInfo.Get(idx);
//  end_while;
//  
//  RunIndex := 0;

  if(HmiVarNoInUse = true) then
    for idx:=0 to HmiVarNoMaxIndex do
      varno := GetVarnoByHmiVarno(idx);
      pvi   := VarInfo.Get(varno);
      if(pvi <> nil) then
        if(pvi^.index35 <> HMI_DEFSCOPE) then
          if(GetValue(#value, varno) = true) then 
            UpdateVariable(varno, pvi, value);
          end_if;
        end_if;
      end_if;
    end_for;
  end_if;
  
  RunIndex := 0;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::RefreshRun
  VAR
    pvi : ^HMI_VARINFO;
    varno, nox : udint;
    value : dint;
  END_VAR

  if(HmiVarNoInUse = true) then
    nox := 5;
    while(nox) do
      nox -= 1;
    
      if(RunIndex > HmiVarNoMaxIndex) then
        RunIndex := 0;
      end_if;
    
      varno := GetVarnoByHmiVarno(RunIndex);
      pvi   := VarInfo.Get(varno);
      if(pvi <> nil) then
        if(pvi^.index35 <> HMI_DEFSCOPE) then
          if(GetValue(#value, varno) = true) then 
            if(value <> pvi^.oldval) then
              if(UpdateVariable(varno, pvi, value) = true) then
                pvi^.oldval := value;
              end_if;
            end_if;
          end_if;
        end_if;
      end_if;
    
      RunIndex += 1;
    end_while;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::UpdateString
	VAR_INPUT
		hmivarno 	: UINT;
		pstr 	: ^void;
    chrsize : udint;
	END_VAR
  VAR
    pvi : ^HMI_VARINFO;
    lid, varno : udint;
  END_VAR

  varno := GetVarnoByHmiVarno(hmivarno);

  pvi := VarInfo.Get(varno);
  if(pvi <> nil) then
    lid := GetLasalId(varno);
    if(lid <> 0) then
      if(pvi^.vartype = HMI_STRING) then
        WriteString(lid, pstr, chrsize);
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::UpdateValue
	VAR_INPUT
		hmivarno 	: UINT;
		value 	: DINT;
	END_VAR
  VAR
    pvi : ^HMI_VARINFO;
    lid, bitdat : udint;
    varno : udint;
  END_VAR

  varno := GetVarnoByHmiVarno(hmivarno);

  pvi := VarInfo.Get(varno);
  if(pvi <> nil) then
    lid := GetLasalId(varno);
    if(lid <> 0) then
    
      Recalculate(#value, varno, false); // in sps-wert umrechnen
    
      if((pvi^.vartype = HMI_BINARY) | (pvi^.vartype = HMI_DATE) | (pvi^.vartype = HMI_TIME) | (pvi^.vartype = HMI_ENUM)) then
      
        if((pvi^.vartype = HMI_BINARY) & (pvi^.subtype = 12)) then
          // es ist ein Real-Value --> in DINT auf REAL umrechnen
          value$REAL := ConvertDintToReal(value, varno);
        end_if;
      
        if(WR(lid$^void, value) = ACCESS_DENIED) then
          pvi^.oldval := 123 + RD(lid$^void); // force refresh
        else
          pvi^.oldval := value; // wert updaten, somit wird kein anschliessender refresh ausgeführt
        end_if;
      elsif(pvi^.vartype = HMI_BIT) then
        bitdat := 1 shl (pvi^.subtype and 16#FF);
        if(value <> 0) then
          bitdat := bitdat or 0x80000000;
          value  := 1; 
        end_if;
        WR(lid$^void, bitdat$dint);
        pvi^.oldval := value; // call read-methode
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetMapInfoXML
	VAR_INPUT
		index 	: UDINT;
		ptext 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^CHAR;
	END_VAR
  VAR
  	varno : udint;
    pvi : ^HMI_VARINFO;
    ph : ^char;
  END_VAR

  retcode := nil;
  ph      := ptext;
  varno   := GetVarnoByHmiVarno(index);
  pvi     := VarInfo.Get(varno);
  if(pvi <> nil) then
    if(pvi^.index35 <> HMI_DEFSCOPE) then
      StringLib.StrCpy(ph, 1, "<variable id=?", 1);
      ph += StringLib.StrLen(ph, 1);
      StringLib.DintToStr(ph, to_dint(pvi^.index35), 16#800, 1);
      StringLib.StrCat(ph, 1, "? name=?", 1);
      ph  += StringLib.StrLen(ph, 1);
      if(GetServerName(ph, varno) = true) then
        StringLib.StrCat(ph, 1, "?/>", 1);
        StringLib.StrXchg(ptext, '?', '"');
        retcode := ptext;
      end_if;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::OverloadLight
	VAR_INPUT
		ovrlodno 	: DINT;
	END_VAR

  if(ovrlodno >= 0) then
    Label.OverloadLight(ovrlodno);
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::SetLid
	VAR_INPUT
		lidBacklight 	: UDINT;
		lidSwVer 	: UDINT;
		lidHwVer 	: UDINT;
	END_VAR

  BacklightDimLid := lidBacklight;
  HmiSwVersionLid := lidSwVer;
  HmiHwVersionLid := lidHwVer;

END_FUNCTION

FUNCTION HmiVarList::EnumSchemeAdd
	VAR_INPUT
		dst 	: ^HMI_SCHEME;
    varno : udint;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	psl : ^HMI_SCHEMELINE;
		pvi : ^HMI_VARINFO;
  END_VAR

  retcode := false;

  if(dst^.no < 255) then
  
    pvi := VarInfo.Get(varno);
    if(pvi <> nil) then
      psl := dst^.ptr + (dst^.no * sizeof(HMI_SCHEMELINE));
      init_HMI_SCHEMELINE(psl);
    
      case pvi^.text1.ima of 
        HMI_IMA_V_TEXTLIST00 , 
        HMI_IMA_V_TEXTLIST01 , 
        HMI_IMA_V_TEXTLIST02 , 
        HMI_IMA_V_TEXTLIST03 , 
        HMI_IMA_V_TEXTLIST04 , 
        HMI_IMA_V_TEXTLIST05 , 
        HMI_IMA_V_TEXTLIST06 , 
        HMI_IMA_V_TEXTLIST07 , 
        HMI_IMA_V_TEXTLIST08 , 
        HMI_IMA_V_TEXTLIST09 : 
          psl^.any := pvi^.text1;
        else 
          psl^.any.ima   := HMI_IMA_V_SERVERNAMETOKEN;
          psl^.any.value := to_dint(varno);
      end_case;
    
      psl^.operator := SCHEMEOP_EQUAL;
      psl^.op2      := pvi^.limit_hi.value;
    
      dst^.no += 1;
      retcode := true;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::CreateShemeFromEnum
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
	END_VAR
  VAR_OUTPUT
    retcode : ^HMI_SCHEME;
  END_VAR
  VAR
    varno : UDINT;
  	pvi, tmp : ^HMI_VARINFO;
    i : udint;
  END_VAR

  retcode := nil;

  init_HMI_SCHEME(#TmpScheme);
  TmpScheme.ptr := #TmpSchemeLines[0];

  if(pany^.ima = HMI_IMA_V_SERVERLIST) then
    varno := pany^.value$udint;
    pvi   := VarInfo.Get(varno);
    if(pvi <> NIL) then
      if(pvi^.vartype = HMI_ENUM) then
        i := 0;
        repeat
          tmp := VarInfo.Get(i);
          if(tmp <> nil) then
            if(tmp^.scope = varno) then
              if(tmp^.vartype = HMI_ENUMITEM) then
                if(EnumSchemeAdd(#TmpScheme, i) = false) then
                  tmp := nil;
                end_if;
              end_if;
            end_if;
          end_if;
          
          i   += 1;
        until(tmp = nil) end_repeat;
        
      end_if;
    end_if;
  end_if;

  retcode := #TmpScheme;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::SetSuper
	VAR_INPUT
		psuper 	: PLseEasy;
	END_VAR

  SuperLseEasy := psuper;

END_FUNCTION

FUNCTION HmiVarList::GetVarNoSub
	VAR_INPUT
		name 	: ^CHAR;
		scope 	: UDINT;
		station 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  var
    pvi : ^HMI_VARINFO;
    ptx : ^char;
  end_var

  retcode := 0; 
  pvi     := VarInfo.Get(retcode);
  while(pvi <> nil) do
    if(pvi^.station = station$usint) then
      if(pvi^.scope = scope) then
        ptx := Label.GetText(retcode);
        if(ptx <> nil) then
          if(StringLib.StrCmp(name, sizeof(char), ptx, sizeof(char)) = 0) then
            return;
          end_if;
        end_if;
      end_if;
    end_if;
    retcode += 1;
    pvi := VarInfo.Get(retcode);
  end_while;

  retcode := HMI_DEFSCOPE;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetVarNoByName
	VAR_INPUT
		name 	: ^CHAR;
		station 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  var
    label : array[0..128] of char;
    ptx : ^char;
    chr : char;
  end_var

  retcode := HMI_DEFSCOPE;
  
  if(name <> NIL) then
    ptx := #label[0];
    while(1) do
      chr  := name^;
      ptx^ := chr;
      name += sizeof(char);
      ptx  += sizeof(char);
    
      case(chr) of
         0  ,
        '.' ,
        '\' : ptx -= sizeof(char);
              ptx^:= 0;
              ptx := #label[0];
              retcode := GetVarNoSub(ptx, retcode, station);
              if((retcode = HMI_DEFSCOPE)|(chr = 0)) then
                return;
              end_if;
              ptx^ := 0;
      end_case;
    end_while;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetVarNoByLasalID
	VAR_INPUT
		lasalid 	: UDINT;
		station 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  var
    pvi : ^HMI_VARINFO;
  end_var

  retcode := 0; 
  pvi     := VarInfo.Get(retcode);
  while(pvi <> nil) do
    if(pvi^.lasalid = lasalid) then
      if(pvi^.station = station$usint) then
        return;  
      end_if;
    end_if;
    retcode += 1;
    pvi := VarInfo.Get(retcode);
  end_while;

  retcode := HMI_DEFSCOPE;

END_FUNCTION

FUNCTION GLOBAL HmiVarList::GetMapCrc
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	varno, index, len : udint;
    pvi : ^HMI_VARINFO;
    txt : array[0..255] of char;
    end : bool;
  END_VAR

  retcode := 0;
  
  index := 0;
  repeat 
    end   := true;
    varno := GetVarnoByHmiVarno(index);
    pvi   := VarInfo.Get(varno);
    if(pvi <> nil) then
      if(pvi^.index35 <> HMI_DEFSCOPE) then
        end := false;
        if(GetServerName(#txt[0], varno) = true) then
          len := StringLib.StrLen(#txt[0], 1) + 1;
          retcode += make_crc32(retcode, #txt[0], len);
        end_if;
        retcode := (retcode rol 1) xor pvi^.index35;
      end_if;
    end_if;
    index += 1;
  until(end = true) end_repeat;

END_FUNCTION

FUNCTION HmiVarList::Recalculate
	VAR_INPUT
		pvalue 	: ^DINT;
		varno 	: UDINT;
		to_hmi 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	puni : ^HMI_XUNIT;
    dezpt : dint;
  END_VAR

  retcode := false;
  if(SuperLseEasy <> nil) then
    puni := GetUnit(varno);
  
    if(puni <> nil) then
      if(puni^.formula > 0) then
        retcode := true;
        dezpt   := 0;
       
        if(GetValueAnything(#dezpt, #puni^.posdezpt) = true) then
          pvalue^ := SuperLseEasy^.Recalculate(pvalue^, puni^.formula, dezpt, to_hmi);
        end_if;
      end_if;
    end_if;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL HmiVarList::GetDigits
	VAR_INPUT
		pany 	: ^HMI_ANYTHING;
		vornullen 	: bool;
	END_VAR
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR
  VAR
  	puni : ^HMI_XUNIT;
    pvi : ^HMI_VARINFO;
    value : dint;
    digits : usint;
    tmpvnul : HMI_DTF;
  END_VAR
  
  retcode := 0;
  digits  := 10;
  tmpvnul := HMI_DEFAULT;   
  
  if(pany^.ima = HMI_IMA_V_SERVERLIST) then
    puni := GetUnit(to_udint(pany^.value));
    if(puni <> nil) then
      if(GetValueAnything(#value, #puni^.posdezpt) = true) then
        retcode := (value$usint) and 7;
      end_if;
      
      if(GetValueAnything(#value, #puni^.digits) = true) then
        digits := value$usint;
      end_if;
      
      tmpvnul := puni^.leading0;
    end_if;
    
    if(vornullen = true) then
      pvi := Get(to_udint(pany^.value));
      if(pvi <> nil) then
      
        if(tmpvnul = HMI_DEFAULT) then
          tmpvnul := HMI_FALSE;
          if(pvi^.flags.leading0) then
            tmpvnul := HMI_TRUE;
          end_if;
        end_if;
        
        if(tmpvnul = HMI_TRUE) then
          if(retcode < digits) then
            digits  := (digits - retcode) and 16#0F;
            retcode := retcode or (digits shl 3);
          end_if;
        end_if;
      end_if;
    end_if;
  end_if;

END_FUNCTION


FUNCTION GLOBAL HmiVarList::RenameRootObject
	VAR_INPUT
		oldname 	: ^CHAR;
		newname 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pvi : ^HMI_VARINFO;
    varno : udint;
    pobjname : ^char;
  END_VAR

  retcode := false;
  varno   := 0;
  
  repeat
    pvi := VarInfo.Get(varno);
    if(pvi <> NIL) then
      if(pvi^.vartype = HMI_OBJECT) & (pvi^.scope = HMI_DEFSCOPE) then
        pobjname := Label.GetText(varno);
        if(pobjname <> NIL) then
//          if(StringLib.StrCmp(pobjname, sizeof(char), oldname, sizeof(char)) = 0) then
          if(_stricmp(pobjname, oldname) = 0) then // caseinsensitive
            if(Label.RenText(varno, newname) = true) then
              retcode := true;
            end_if;
          end_if;
        end_if;
      end_if;
    end_if;
    varno += 1;
  until (pvi = NIL) end_repeat;

END_FUNCTION
