//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Ram"
	Revision           = "1.3"
	GUID               = "{67843DDE-277A-11D4-83FF-00902787C17B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Ram\Ram.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "static RAM, retentive data">
	<Channels>
		<Server Name="Data" GUID="{67843DDF-277A-11D4-83FF-00902787C17B}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\Ram\Ram.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner/>
		<Dokumentation Revision="1.3" Date="2013-09-04" Author="kolott" Company="sigmatek" Description="usage of semaphor implemented (LockOn(), LockOff())"/>
		<Dokumentation Revision="1.2" Date="2013-04-08" Author="kolott" Company="sigmatek" Description="ARM-Ready"/>
	</RevDoku>
</Class>
*)
Ram : CLASS
  //Servers:
	Data 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		pRamAddr 	: ^RamCell;			//! <Variable Comment="pointer to static RAM" Name="pRamAddr"/>
		Version 	: DINT;
  //Functions:
	
	FUNCTION Ram
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="---------------------- &#13;&#10;---- OLD VERSION ----&#13;&#10;----------------------&#13;&#10; not supported since 02.2002&#13;&#10;" Name="ChkRAM"/>
	FUNCTION GLOBAL ChkRAM;
				//! <Function Comment="---------------------- &#13;&#10;---- OLD VERSION ----&#13;&#10;----------------------&#13;&#10; not supported since 02.2002&#13;&#10;" Name="MakeNewRAMentry"/>
	FUNCTION GLOBAL MakeNewRAMentry
		VAR_INPUT
			udCRC 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pRAM 	: ^RamCell;
		END_VAR;
				//! <Function Comment="&#13;&#10;    EDI -&gt; cell&#13;&#10;    &lt;-AX = data&#13;&#10;" Name="QuickChk"/>
	FUNCTION AWL QuickChk
		VAR_INPUT
			pin (EDI) 	: ^RamCell;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="---------------------- &#13;&#10;---- OLD VERSION ----&#13;&#10;----------------------&#13;&#10; not supported since 02.2002&#13;&#10;" Name="SearchRAM"/>
	FUNCTION SearchRAM
		VAR_INPUT
			udCRC32 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^RamCell;
		END_VAR;
				//! <Function Comment="---------------------- &#13;&#10;---- OLD VERSION ----&#13;&#10;----------------------&#13;&#10; not supported since 02.2002&#13;&#10;" Name="CompressRAM"/>
	FUNCTION CompressRAM
		VAR_OUTPUT
			udMoved 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Schreibfunktion der Klasse S-RAM bei Version grösser 2&#13;&#10;" Name="WriteNew"/>
	FUNCTION AWL VIRTUAL GLOBAL WriteNew
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL LockOn;
	
	FUNCTION GLOBAL LockOff;
				//! <Function Comment="------------------------------------------------&#13;&#10; der Klasse Ram fuer alte Version des S_RAM&#13;&#10;------------------------------------------------&#13;&#10;" Name="Data.Write"/>
	FUNCTION AWL VIRTUAL GLOBAL Data::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Ram::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_RAM
1$UINT, 3$UINT, (SIZEOF(::Ram))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1903583397), "Ram", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Ram.Data.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2607161047), "Data", 
//Clients:
END_FUNCTION


#define USER_CNT_Ram 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Ram] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Ram::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Ram, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #WriteNew();

#pragma warning (default : 74)
	Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= Ram();

END_FUNCTION

//{{LSL_IMPLEMENTATION
(******************************************************************************
*
*	Class RAM
*	Created: Sigmatek
*	Changes:
*		0.1 => 1.1	/	25.03.2005	/	Mark:	//#SR000
*			make compatible to lasal 2 with #define Lasal2_OBJ in "Memory.h"
*
******************************************************************************)

#include <Rtos_privheader.h>
#include <RTOS_Mem.h>
#include <Rtos_header.h>
#include <LSL_ST_LSLFILE.H> // RTKernel V3.18
#include <lsl_st_mt.h>

VAR_PRIVATE
  ram_muxifc : ^LSL_MT_TYPE;
  ram_muxhdl : ^void;
END_VAR

#define LASAL2_OBJ			//activate for Lasal2 Library

VAR_EXTERNAL
	aRamHdr			: RAMhdr;
END_VAR

//--------------------------------------------------------------
// im neuen ram die verbindung zum s-ram suchen  (Im Loader)
//--------------------------------------------------------------  
// Wird von allen S-Ram klassen verwendet um das objekt mit den
// Daten zu verbinden

FUNCTION GLOBAL AWL Find_sRam
VAR_INPUT
	CRC32		: UDINT;
END_VAR
VAR_OUTPUT
	pRamAdr		: ^XramCell;
END_VAR;
// neue funktion für den C-IPC
FUNCTION GLOBAL AWL Find_sRamFile
VAR_INPUT
	CRC32		:  UDINT;
	ppRamAdr	: ^UDINT;
	ppFileAdr	: ^XFileCell;
	uiType		: UDINT;				// 0=RamZelle 1=RamExZelle 	
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR;
// liefert S-RAM Version
FUNCTION GLOBAL AWL GetVersion_sRam
VAR_OUTPUT
	Version		: UDINT;
END_VAR;


//
//  ==========================================================
//   ID:= 06145
//   Rev:= 000     09.09.99  a.m.
//   Fix:= 000
//  ==========================================================
//    General Function:  Chn Object Class CONST
//  ==========================================================

FUNCTION Ram::Ram
VAR_OUTPUT
	ret_code       : CONFSTATES;
END_VAR
VAR
	pObj           : ^OBJ;
	CRC			   : UDINT;
	pFileAdr	   : ^XFileCell;
	result		   : UDINT;		 	
END_VAR

  ram_muxifc := NIL;
  ram_muxhdl := NIL;

// NEUE VERSION
// Diesen Pointer gibt es seit a.m mit pranz und gradl am 2.2.2002 vergangenheitsbewältigung gemacht hat

IF _S_RAM_Hptr <> 0 then 

  pObj 	:= LSL_GetHdr(this);

	//#SR000 Start
	#ifdef LASAL2_OBJ
		#pragma warning (disable:137)
			CRC:=	pObj^.pObjDsc^.SymName.udCRC;
		#pragma warning (default:137)
	#else
	//#SR000 End
		CRC:=	pObj^.pObjDsc^.udCRC;
	#endif		//#SR000

 version :=(GetVersion_sRam())$DINT;
 if version < 2 then

  pRAMaddr$UDINT:=Find_sRam(CRC)$UDINT;
  
  If  pRAMaddr <> 0 Then
 	// -- Daten im Ram ungültig, initialisieren
    If (pRAMaddr$^XramCell^.udType and 16#80000000) = 0 then
	  pRAMaddr^.udData$dint :=Data;
	  pRAMaddr^.udChk:=pRAMaddr^.udData+pRAMaddr^.udCRC32;
	  	// -- Daten im Ram gültig, Auslesen
	else
	  Data:=pRAMaddr^.udData$dint ;
	end_if; 
	pRAMaddr$^XramCell^.udType:=16#C0000000;    // ganz am ende machen wir uns gültig !
  end_if;		
 else
  
	// suchen oder anlegen eines neuen eintrages
    result := Find_sRamFile(CRC,#pRAMaddr$UDINT,#pFileAdr$XFileCell,0);
    If pRAMaddr <> 0 then
	  if result = 0	then
        If (pFileAdr^.udType and 16#80000000) = 0 then
		 // init data it is new one
	     pRAMaddr^$dint  :=Data;
	     pFileAdr^.udType:=16#C0000000;    // ganz am ende machen wir uns gültig !
		else
		  Data := pRAMaddr^$dint;
	  	end_if;
	  else
		// init data it is new one
	    pRAMaddr^$dint :=Data;
	  end_if;  	
	end_if;
	 // writemethode wird überladen dauert 20sekunden bei 10.000 ramzellen (???)
	//this^.data.pMeth^.write := #WriteNew();

 end_if;

ELSE
   // Kein Sram vorhanden
   TRACE_ERR("no SRAM available on this platform (needed by a RAM object)");
END_IF;
	ret_code := C_OK;
END_FUNCTION
//
//    EDI -> cell
//    <-AX = data
FUNCTION Ram::QuickChk
	VAR_INPUT
		pin (EDI) 	: ^RAMcell;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: UDINT;
	END_VAR

  LockOn();
  retcode := pin^.udCRC32 + pin^.udData;
  LockOff();

END_FUNCTION
//------------------------------------------------
// der Klasse Ram fuer alte Version des S_RAM
//------------------------------------------------

FUNCTION VIRTUAL GLOBAL Ram::Data::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  result := input;
  if(input <> Data) then
    
    LockOn();
    Data := input;
    
    if(pRAMaddr <> NIL) then
      if(Version < 2) then
        pRamAddr^.udData := input$udint;
        pRamAddr^.udChk  := pRamAddr^.udCRC32 + input$udint;
      else
        pRamAddr^$udint := input$udint;
      end_if;
    end_if;
    LockOff();
     
  end_if;

END_FUNCTION

//[#ENGLISH]
//Schreibfunktion der Klasse S-RAM bei Version grösser 2

FUNCTION VIRTUAL GLOBAL Ram::WriteNew
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: DINT;
	END_VAR

  retcode := input;
  if(Data <> input) then
    LockOn(); 
    Data := input;
    if(pRamAddr <> NIL) then
      pRamAddr^$udint := input$udint;
    end_if;
    LockOff();
  end_if;

END_FUNCTION
//---------------------- 
//---- OLD VERSION ----
//----------------------
// not supported since 02.2002
FUNCTION  Ram::CompressRAM
  VAR_OUTPUT
     udMoved		: UDINT;
  END_VAR
  
	udMoved :=0; 
  
END_FUNCTION

//---------------------- 
//---- OLD VERSION ----
//----------------------
// not supported since 02.2002
FUNCTION GLOBAL Ram::ChkRAM
END_FUNCTION
//---------------------- 
//---- OLD VERSION ----
//----------------------
// not supported since 02.2002
#pragma warning (disable : 73)
FUNCTION GLOBAL Ram::MakeNewRAMentry
	VAR_INPUT
		udCRC 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pRAM 	: ^RamCell;
	END_VAR
  
	pRam := NIL;
  
END_FUNCTION
//---------------------- 
//---- OLD VERSION ----
//----------------------
// not supported since 02.2002
FUNCTION Ram::SearchRAM
	VAR_INPUT
		udCRC32 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^RamCell;
	END_VAR
  
  retcode := NIL;
  
END_FUNCTION
#pragma warning (default : 73)


FUNCTION GLOBAL Ram::LockOn
  
  if(ram_muxhdl <> nil) then
    ram_muxifc^.MT_Wait$P_MT_Wait(ram_muxhdl); 
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL Ram::LockOff
  
  if(ram_muxhdl <> nil) then
    ram_muxifc^.MT_Signal$P_MT_Signal(ram_muxhdl);
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL Ram::Init

  if(ram_muxifc = nil) then
    OS_CILGet("LSL_MULTITASK", #ram_muxifc$void);
    if(ram_muxifc <> NIL) then
      ram_muxhdl := ram_muxifc^.MT_CreateSemaphore$P_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, "__0RamMux");
    end_if;
  end_if;

END_FUNCTION
