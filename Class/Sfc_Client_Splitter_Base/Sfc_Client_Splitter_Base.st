//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Sfc_Client_Splitter_Base"
	Revision           = "1.2"
	GUID               = "{7F45F978-F41F-4DA9-80BB-05D31820A1FD}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Sfc_Client_Splitter_Base\Tools.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "V1.1 Splitter Class with variable Clients (Baseclass)">
	<Channels>
		<Server Name="To_Splitt" GUID="{156CB9E1-62B6-4EC0-B755-8BE736CFF946}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="splitting value"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="LesMax"/>
		<Dokumentation Revision="1.2" Date="2013-08-19" Author="LesMax" Company="Sigmatek" Description="Rework of the mechanism that finds the correct class header on construction"/>
	</RevDoku>
</Class>
*)
Sfc_Client_Splitter_Base : CLASS
  //Servers:
	To_Splitt 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		m_pDerivedSplitterClsHdr 	: ^ClsHdr;
  //Functions:
				//! <Function Comment="[#DEUTSCH]&#13;&#10; ******************************************************************&#13;&#10;           Client - Splitter Funktion für variable Clients&#13;&#10;     Verteilt die Writefunktion auf die verbundenen Clients auf.&#13;&#10;&#13;&#10;  ACHTUNG : Basisklasse darf keine Clients haben !!&#13;&#10;            Das Konplexe Objegt hingegen darf soviele Clients wie&#13;&#10;            sie es benötigen haben.&#13;&#10; ******************************************************************&#13;&#10;      erstellt   :   BS  :  KW 35/01&#13;&#10; ******************************************************************&#13;&#10;                         CONSTRUCTION&#13;&#10; ******************************************************************&#13;&#10;" Name="Sfc_Client_Splitter_Base"/>
	FUNCTION Sfc_Client_Splitter_Base
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" ******************************************************************&#13;&#10;           Client - Splitter Funktion für variable Clients&#13;&#10;     Verteilt die Writefunktion auf die verbundenen Clients auf.&#13;&#10;  ACHTUNG : Basisklasse darf keine Clients haben !!&#13;&#10;            Das Komplexe Objekt hingegen darf soviele Clients haben, wie&#13;&#10;            sie benötigen.&#13;&#10; ******************************************************************&#13;&#10;      erstellt   :   BS  :  KW 35/01&#13;&#10; ******************************************************************&#13;&#10;                         WRITE Funktion&#13;&#10; ******************************************************************&#13;&#10; ******************************************************************&#13;&#10;           client splitter function for variable clients&#13;&#10;          splitts the channels and calls the write function&#13;&#10; you have to add somemany Clients as you want.&#13;&#10;  automatically each client will get the same value from the&#13;&#10;  Server.&#13;&#10;  Attention : Baseclass is not allowed to have clients !!&#13;&#10; ******************************************************************&#13;&#10;      created   :   BS  :  KW 35/01&#13;&#10; ******************************************************************&#13;&#10;                   operation of WRITE function&#13;&#10; ******************************************************************&#13;&#10;" Name="To_Splitt.Write"/>
	FUNCTION VIRTUAL GLOBAL To_Splitt::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Sfc_Client_Splitter_Base::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SFC_CLIENT_SPLITTER_BASE
1$UINT, 2$UINT, (SIZEOF(::Sfc_Client_Splitter_Base))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(528085301), "Sfc_Client_Splitter_Base", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Sfc_Client_Splitter_Base.To_Splitt.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1120314414), "To_Splitt", 
//Clients:
END_FUNCTION


#define USER_CNT_Sfc_Client_Splitter_Base 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Sfc_Client_Splitter_Base] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Sfc_Client_Splitter_Base::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Sfc_Client_Splitter_Base, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #Write();
	To_Splitt.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF To_Splitt.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= Sfc_Client_Splitter_Base();

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION Sfc_Client_Splitter_Base::Sfc_Client_Splitter_Base
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
	  pObj			: ^Obj;
  END_VAR
	
  // Get the first class header
  pObj		                    := LSL_GetHdr(THIS);
	m_pDerivedSplitterClsHdr	  := pObj^.pClsHdr;
  
  // Find the Class Header of the derived splitter class
  // (It is always the second class in the class hierarchy)
  while (m_pDerivedSplitterClsHdr <> NIL) & (m_pDerivedSplitterClsHdr^.pBaseCls <> NIL) & (m_pDerivedSplitterClsHdr^.pBaseCls^.pBaseCls <> NIL) do
    m_pDerivedSplitterClsHdr  := m_pDerivedSplitterClsHdr^.pBaseCls;
  end_while;
	
	ret_code:= C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Sfc_Client_Splitter_Base::To_Splitt::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
	  pChn			    : ^CltCh;
	  iCnt			    : UINT;
  END_VAR;

  // Update the server value.
	To_Splitt := input;

  // At first get a pointer to the current object.
	pChn := THIS$^CltCh;

  // Add the size of the base class and of all servers of 
  // the derived splitter class in order to get the first client.
  pChn := (pChn$UDINT + SIZEOF(Sfc_Client_Splitter_Base) + SIZEOF(SvrCh) * TO_UDINT(m_pDerivedSplitterClsHdr^.pDsc^.nSvrChs))$^CltCh;

  // Loop through all Clients of the derived 
  // splitter class and forward the write operation.
  iCnt    := 0;
	while iCnt < m_pDerivedSplitterClsHdr^.pDsc^.nCltChs do 
    
    // Forward the call of the write method.
    WR_VIACHNL(THIS$^SVRCH, TO_UINT(pChn$UDINT - THIS$UDINT), input);
		
    // Update the client value.
    pChn^.dData := input;
		
    // Process the next client.
    pChn += SIZEOF(CltCh);      
    iCnt +=1;
    
  end_while;

  // Daten schreiben
	result := Input;
  
END_FUNCTION

