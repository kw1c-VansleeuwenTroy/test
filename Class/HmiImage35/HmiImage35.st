//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "HmiImage35"
	Revision           = "0.4"
	GUID               = "{8B0C09BB-1B65-4F4B-958F-7904F84B9FDC}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ByteSize" GUID="{764293E6-6352-4DCE-A9F6-12A50CB9A3F2}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ClassSvr" GUID="{E3E193A0-A29C-49D3-BD69-04959D21D8B9}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="StdLib" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.4" Date="2018-08-31" Author="kolott" Company="sigmatek" Description="cTor added"/>
		<Dokumentation Revision="0.3" Date="2015-03-04" Author="kolott" Company="sigmatek" Description="name of datatype has changed (_BOX_IMAGELIST --&gt; _BOX_IMAGE) because named is a single image and not a list of images. "/>
		<Dokumentation Revision="0.2" Date="2014-03-26" Author="kolott" Company="sigmatek" Description="innovation: ClassSvr will represent number of generated images for hmi&#13;&#10;server ByteSize added"/>
	</RevDoku>
</Class>
*)
HmiImage35 : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	ByteSize 	: SvrCh_UDINT;
  //Clients:
	StdLib 	: CltChCmd__StdLib;
  //Variables:
  //Functions:
	
	FUNCTION HmiImage35
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL Free;
	
	FUNCTION GLOBAL Start;
	
	FUNCTION GLOBAL CreateList
		VAR_INPUT
			width 	: UDINT;
			height 	: UDINT;
			transparent 	: UINT;
			state 	: UINT;
			datano 	: UDINT;
			dataptr 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^void;
		END_VAR;
	
	FUNCTION DefaultInit;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiImage35::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMIIMAGE35
0$UINT, 4$UINT, (SIZEOF(::HmiImage35))$UINT, 
2$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2724513001), "HmiImage35", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiImage35.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::HmiImage35.ByteSize.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1607089543), "ByteSize", 
//Clients:
(::HmiImage35.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_HmiImage35 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiImage35] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiImage35::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_HmiImage35, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HmiImage35();

END_FUNCTION

//{{LSL_IMPLEMENTATION

#includeC "..\LseEasy\Create.h"

#define BMP_NO_COMPRESSION 0x8000

FUNCTION HmiImage35::HmiImage35
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;
  ClassSvr := 0;
  ByteSize := 0;
  DefaultInit();

END_FUNCTION

FUNCTION HmiImage35::DefaultInit

END_FUNCTION

FUNCTION GLOBAL HmiImage35::Free

  DefaultInit();
  
END_FUNCTION

FUNCTION GLOBAL HmiImage35::Start

  Free();
  ClassSvr := 0;
  ByteSize := 0;

END_FUNCTION

FUNCTION GLOBAL HmiImage35::CreateList
	VAR_INPUT
    width : udint;
    height : udint;
    transparent : uint;
    state : uint;
    datano : udint;
    dataptr : ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^void;
	END_VAR
  VAR
    pbox : ^_BOX_IMAGE;
    size, maxi : udint;
    ph : ^uint;
    xx : uint;
    ppixdat : ^_BMPDAT;
  END_VAR

  retcode := NIL;
  if((datano > 0) & (dataptr <> NIL)) then
    size := datano * 3;
    maxi := width * height * 2;
    
    if(size < maxi) then
      // image mit lauflängenkomprimierung
      retcode := StdLib.MallocV1(size + sizeof(_BOX_IMAGE) - 1, 0);
      if(retcode <> NIL) then
        pbox$^void              := retcode;
        setup_BIGBOX_HEADER(#pbox^.boxhdr, 0);
        pbox^.image.mp          := 16#504D;
        pbox^.image.datano      := datano;
        pbox^.image.width       := width$uint;
        pbox^.image.height      := height$uint;
        pbox^.image.state       := (state and 16#7FFF);
        pbox^.image.transparent := transparent;
        _memcpy(#pbox^.image.data[0], dataptr, size);
        end_BIGBOX_HEADER(#pbox^.boxhdr, size + sizeof(_BOX_IMAGE) - 1);
      end_if;
    else
      // image ohne lauflängenkomprimierung
      retcode := StdLib.MallocV1(maxi + sizeof(_BOX_IMAGE) - 1, 0);
      if(retcode <> NIL) then
        pbox$^void              := retcode;
        setup_BIGBOX_HEADER(#pbox^.boxhdr, 0);
        pbox^.image.mp          := 16#504D;
        pbox^.image.datano      := width * height;
        pbox^.image.width       := width$uint;
        pbox^.image.height      := height$uint;
        pbox^.image.state       := state or 16#8000; // kennung für lauflängenkomprimierung
        pbox^.image.transparent := transparent;
        
        ph$^usint     := #pbox^.image.data[0];
        ppixdat$^void := dataptr;
        while(datano) do
          xx := ppixdat^.no;
          while(xx) do
            ph^ := ppixdat^.col;
            xx -= 1;
            ph += 2;
          end_while;
          ppixdat += sizeof(_BMPDAT);
          datano  -= 1;
        end_while;
        
        end_BIGBOX_HEADER(#pbox^.boxhdr, maxi + sizeof(_BOX_IMAGE) - 1);
      end_if;
    end_if;
  end_if;
  
  if(retcode <> nil) then
    ClassSvr   += 1;
    pbox$^void := retcode;
    ByteSize   += pbox^.boxhdr.size;
  end_if;
  
END_FUNCTION
