//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Source\Common\hmi_nuc.h"

(*!
<Class
	Name               = "HmiFunctionList35"
	Revision           = "0.4"
	GUID               = "{09A0736B-FC37-48EA-946B-FA614E168FAB}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ByteSize" GUID="{667B4F79-7943-4C15-ACCD-8CB55EA3FB6F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ClassSvr" GUID="{2B3E204D-89D4-4D62-82F2-52E522FE4C9F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="HmiVarList" Required="true" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\Common\hmi_nuc.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.4" Date="2018-08-31" Author="kolott" Company="sigmatek" Description="cTor added"/>
		<Dokumentation Revision="0.3" Date="2014-08-28" Author="kolott" Company="sigmatek" Description="function &quot;UserCall&quot; added"/>
		<Dokumentation Revision="0.2" Date="2014-04-28" Author="kolott" Company="sigmatek" Description="call of function &quot;Function Block&quot; activated"/>
		<Dokumentation Revision="0.1" Date="2014-03-28" Author="kolott" Company="sigmatek" Description="server ByteSize added"/>
	</RevDoku>
</Class>
*)
HmiFunctionList35 : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	ByteSize 	: SvrCh_UDINT;
  //Clients:
	HmiVarList 	: CltChCmd_HmiVarList;
  //Variables:
		xData : ARRAY [0..20000] OF USINT;

  //Functions:
	
	FUNCTION HmiFunctionList35
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL Free;
	
	FUNCTION GLOBAL Start;
	
	FUNCTION GLOBAL AddEntry
		VAR_INPUT
			pfb 	: ^HMI_FCTBLOCK;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL End
		VAR_INPUT
			peasy 	: ^LseEasy;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^void;
		END_VAR;
	
	FUNCTION DecodeHMI_ANYTHING
		VAR_INPUT
			pcmd 	: ^USINT;
			pany 	: ^HMI_ANYTHING;
			bitmask 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION FinalizeList
		VAR_INPUT
			peasy 	: ^LseEasy;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION FinalizeFunctionBlock
		VAR_INPUT
			pfb 	: ^_BOX_FUNCTBLOCK;
			peasy 	: ^LseEasy;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION DefaultInit;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd HmiVarList


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HmiFunctionList35::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HMIFUNCTIONLIST35
0$UINT, 4$UINT, (SIZEOF(::HmiFunctionList35))$UINT, 
2$UINT, 1$UINT, 0$UINT, 
TO_UDINT(3385399892), "HmiFunctionList35", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HmiFunctionList35.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::HmiFunctionList35.ByteSize.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1607089543), "ByteSize", 
//Clients:
(::HmiFunctionList35.HmiVarList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3793961451), "HmiVarList", TO_UDINT(3793961451), "HmiVarList", 0$UINT, 17$UINT, 
END_FUNCTION


#define USER_CNT_HmiFunctionList35 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HmiFunctionList35] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HmiFunctionList35::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_HmiFunctionList35, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= HmiFunctionList35();

END_FUNCTION

#pragma usingLtd LseEasy

//{{LSL_IMPLEMENTATION

#includeC "..\LseEasy\Create.h"

#pragma using LseEasy

FUNCTION HmiFunctionList35::HmiFunctionList35
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;
  ClassSvr := 0;
  ByteSize := 0;
  DefaultInit();

END_FUNCTION

FUNCTION HmiFunctionList35::DefaultInit
  var
    pbox : ^_BOX_FUNCTLIST;
  end_var

  pbox$^usint := #xData[0];
  pbox^.no := 0;
  pbox^.boxhdr.crc32 := 0;
  pbox^.boxhdr.size  := 0; 

END_FUNCTION

FUNCTION GLOBAL HmiFunctionList35::Free

  DefaultInit();
  
END_FUNCTION

FUNCTION GLOBAL HmiFunctionList35::Start

  Free();
  ClassSvr := 0;
  ByteSize := 0;
  
END_FUNCTION

FUNCTION AddLine
	VAR_INPUT
		pfb : ^_BOX_FUNCTBLOCK;
    cmd : USINT;
    op1 : DINT;
    op2 : DINT;
	END_VAR
  VAR
  	pd : ^_BOX_FUNCTLINE;
  END_VAR

  pd := #pfb^.data[0]; // decieve boundexceed
  pd += pfb^.no * sizeof(_BOX_FUNCTLINE);
  pd^.cmd := cmd;
  pd^.op1 := op1;
  pd^.op2 := op2;
  pfb^.no += 1;
  
END_FUNCTION

FUNCTION HmiFunctionList35::DecodeHMI_ANYTHING
	VAR_INPUT
		pcmd 	: ^usint;
    pany : ^HMI_ANYTHING;
    bitmask : usint;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := -1;
  
  if(pany^.ima = HMI_IMA_V_SERVERLIST) then
    pcmd^   := pcmd^ or bitmask;
    retcode$udint := HmiVarList.GetAdd35(pany^.value$udint);
  else
    retcode := pany^.value;
  end_if;  

END_FUNCTION

FUNCTION GLOBAL HmiFunctionList35::AddEntry
	VAR_INPUT
		pfb 	: ^HMI_FCTBLOCK;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  var
    pbox : ^_BOX_FUNCTLIST;
    pfun : ^_BOX_FUNCTBLOCK;
    pls  : ^HMI_FCTLINE;
    no, size : udint;
    op1, op2 : dint;
    cmd  : usint;
  end_var

  retcode := 16#FFFFFFFF;
  
  if(pfb <> NIL) then
  
    pbox$^usint := #xData[0];
    pfun        := #pbox^.data + pbox^.boxhdr.size;
    pfun^.no    := 0;

    no  := pfb^.no;
    pls := pfb^.ptr;
    while(no) do
      
      case pls^.qbef of
       HMI_QCALL_SCREEN :        // call screen (1)
         cmd := mCMD_SCREEN;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         AddLine(pfun, cmd, op1, 0);
       HMI_QRETURN :             // goto previous screen (0)
         AddLine(pfun, MCMD_RETURN, 0, 0);
       HMI_QSET_SERVER :         // set server (2)
         cmd := mCMD_SET;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         op2 := DecodeHMI_ANYTHING(#cmd, #pls^.op2, 16#40);
         AddLine(pfun, cmd, op1, op2);
       HMI_QINC_SERVER :         // inc server (1)
         cmd := mCMD_ADD;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         AddLine(pfun, cmd, op1, 1);
       HMI_QDEC_SERVER :         // dec server (1)
         cmd := mCMD_SUB;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         AddLine(pfun, cmd, op1, 1);
       HMI_QADD_SERVER :         // add server (2)
         cmd := mCMD_ADD;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         op2 := DecodeHMI_ANYTHING(#cmd, #pls^.op2, 16#40);
         AddLine(pfun, cmd, op1, op2);
       HMI_QSUB_SERVER :         // sub server (2)
         cmd := mCMD_SUB;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         op2 := DecodeHMI_ANYTHING(#cmd, #pls^.op2, 16#40);
         AddLine(pfun, cmd, op1, op2);
       HMI_QKEY_CODE :           // keycode (1)
         cmd := mCMD_KEYPRESS;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         AddLine(pfun, cmd, op1, 0);
       HMI_QTOGGLE_SERVER :      // toggle server (1)
         cmd := mCMD_TOGGLE;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         AddLine(pfun, cmd, op1, 0);
       HMI_QIF_EQUAL :          // if (2)
         cmd := mCMD_IFEQ;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         op2 := DecodeHMI_ANYTHING(#cmd, #pls^.op2, 16#40);
         AddLine(pfun, cmd, op1, op2);
       HMI_QIF_GREAT :          // if (2)
         cmd := mCMD_IFHIGH;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         op2 := DecodeHMI_ANYTHING(#cmd, #pls^.op2, 16#40);
         AddLine(pfun, cmd, op1, op2);
       HMI_QIF_SMALL :          // if (2)
         cmd := mCMD_IFLOW;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         op2 := DecodeHMI_ANYTHING(#cmd, #pls^.op2, 16#40);
         AddLine(pfun, cmd, op1, op2);
       HMI_QIF_ELSE :           // else (0)
         AddLine(pfun, mCMD_IFELSE, 0, 0);
       HMI_QIF_END :            // end (0)
         AddLine(pfun, mCMD_IFEND, 0, 0);
       HMI_QFUNCTION_BLOCK :     // call functionblock (1)
         // functionblockindex wird später (Finalize) aufgelöst, erstmals tatsächliche funktionsnummer eintragen
         AddLine(pfun, mCMD_CFB, pls^.op1.value, 0); 
       HMI_QUSER_CALL :
         cmd := mCMD_USERCALL;
         op1 := DecodeHMI_ANYTHING(#cmd, #pls^.op1, 16#80);
         op2 := DecodeHMI_ANYTHING(#cmd, #pls^.op2, 16#40);
         AddLine(pfun, cmd, op1, op2);
       
//       HMI_QNOP,                // nothing (0)
//       HMI_QLED,                // illuminate led (2)
//       HMI_QLANGUAGE,           // switch language (1)
//       HMI_QBEEP,               // beep (2)
//       HMI_QUSER_CALL,          // usercall (2)
//       HMI_QCALL_WINDOW,        // call window (1)
//       HMI_QEDIT_SAVE,          // edit save (0)
//       HMI_QOPEN_IO             // open editor by using servernumber (1)
        
      end_case;
      
      pls += sizeof(HMI_FCTLINE);
      no -= 1;
    end_while;
    
    if(pfun^.no > 0) then
      size              := pfun^.no;
      pbox^.boxhdr.size += (size * sizeof(_BOX_FUNCTLINE)) + sizeof(pfun^.no);
      retcode           := pbox^.no;
      pbox^.no          += 1;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL HmiFunctionList35::End
	VAR_INPUT
		peasy 	: ^LseEasy;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^void;
	END_VAR
  var
    pbox : ^_BOX_FUNCTLIST;
  end_var

  FinalizeList(peasy);
  
  pbox$^usint := #xData[0];
  ClassSvr    := pbox^.no;
  end_BIGBOX_HEADER(#pbox^.boxhdr, sizeof(_BIGBOX_HEADER) + sizeof(pbox^.no));
  ByteSize    := pbox^.boxhdr.size;
  retcode     := pbox;

END_FUNCTION

FUNCTION HmiFunctionList35::FinalizeFunctionBlock
  VAR_INPUT
    pfb : ^_BOX_FUNCTBLOCK;
		peasy 	: ^LseEasy;
  END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pfl : ^_BOX_FUNCTLINE;
    nox : udint;
  END_VAR

  retcode := true;

  pfl := #pfb^.data[0];
  nox := pfb^.no;
  while(nox) do
    
    if(pfl^.cmd = mCMD_CFB) then
      pfl^.op1 := peasy^.AddFunctionBlock(pfl^.op1$uint);
      if((pfl^.op1 < 0) | (pfl^.op1 >= 16#FFFF)) then
        pfl^.op1 := -1;
      end_if;
    end_if;
    
    pfl += sizeof(_BOX_FUNCTLINE);
    nox -= 1;
  end_while;

END_FUNCTION

FUNCTION HmiFunctionList35::FinalizeList
	VAR_INPUT
		peasy 	: ^LseEasy;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    pbox : ^_BOX_FUNCTLIST;
    pfb : ^_BOX_FUNCTBLOCK;
    i : udint;
  end_var

  // in dieser funktion werden alle verweise auf "CallFunctionblock" aufgelöst

  retcode     := true;
  pbox$^usint := #xData[0];

  if(pbox^.no > 0) then
    pfb := #pbox^.data[0];
    i   := 0;
    while i < pbox^.no do // vorsicht !! 
      // es kann ein neuer functioblock zur liste addiert werden
      if(FinalizeFunctionBlock(pfb, peasy) = false) then
        retcode := false;
      end_if;
      
      pfb += 1 + to_udint(pfb^.no) * sizeof(_BOX_FUNCTLINE);
      i   += 1;
    end_while;
  end_if;

END_FUNCTION
