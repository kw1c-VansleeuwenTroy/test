//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define USB_StringLength                              _strlen("C:\")          // Länge des Strings für das aktuelle Laufwerk
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "USBDetection"
	Revision           = "1.6"
	GUID               = "{6F90B4C9-9883-4D43-BB9A-1E6758F62D93}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,360)"
	Comment            = "class detects a plugged USB device (USBdetected) &#13;&#10;and writes it&apos;s drive letter to a string object">
	<Channels>
		<Server Name="DriveIndex" GUID="{8DC8535F-10A8-4E97-A19C-85DAACCF8FCC}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="internal index of the plugged USB device"/>
		<Server Name="DriveLetter" GUID="{F6DF6B3F-DB93-4B95-9C1C-8BFE2AC0C4DC}" Class="String" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="drive letter of the plugged USB device  &#13;&#10;&quot;C:\&quot;: means that NO USB device is detected "/>
		<Server Name="DriveListError" GUID="{6570EA22-4A95-4A88-AD0D-58E5B59A909F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="1= function GetDriveListShort failed"/>
		<Server Name="USBdetected" GUID="{DC2ADB7E-DF1C-4F2F-92B9-FD6715CDF71C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="0= no USB device found&#13;&#10;1= USB device is plugged"/>
		<Client Name="FileSys" Required="false" Internal="false" Comment="object channel to FileSys (don&apos;t connect)"/>
		<Client Name="USBDriveLetter" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\USBDetection\USBDetection_de.pdf"/>
			<File Path=".\Class\USBDetection\USBDetection_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FurLuk"/>
		<Dokumentation Revision="1.6" Date="2019-07-10" Author="FurLuk" Company="Sigmatek" Description="global method GetDriveLetter() set to virtual"/>
		<Dokumentation Revision="1.5" Date="2017-10-18" Author="SprDie" Company="Sigmatek" Description="translated comments from german to english&#13;&#10;check if flash drive could be mounted after plug-in event&#13;&#10;check available flash drives once at startup"/>
		<Dokumentation Revision="1.4" Date="2017-08-09" Author="WesAnd" Company="Sigmatek" Description="Update of the drive list also when usb stick disconnected."/>
		<Dokumentation Revision="1.3" Date="2016-10-10" Author="HubChr" Company="Sigmatek" Description="Added documentation pdfs."/>
		<Dokumentation Revision="1.2&#13;&#10;" Date="2015-09-23" Author="BraLis" Company="Sigmatek" Description="the client coDriveLetter from the class AccessControlMain was connected wrongly, now connected with the server DriveLetter from the class USBDetection"/>
		<Dokumentation Revision="1.1" Date="2015-09-22" Company="Sigmatek" Description="Creation."/>
	</RevDoku>
	<Network Name="USBDetection">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{56E9436D-D72C-443B-9EF7-926E2A8F6D47}"
				Class      = "_Global"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
			<Object
				Name       = "USBDriveLetter"
				GUID       = "{1C411560-E619-459A-981E-49A8E0D9D73D}"
				Class      = "String"
				Position   = "(240,300)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(728,210),(518,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="this.USBDriveLetter" Destination="USBDriveLetter.Data"/>
			<Connection Source="this.DriveLetter" Destination="USBDriveLetter.Data" Vertices="(728,390),(556,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Global

USBDetection : CLASS
: _Global
	TYPE
	  Letters :
	  (
	    _A,
	    _B,
	    _C,
	    _D,
	    _E,
	    _F,
	    _G,
	    _H,
	    _I,
	    _J,
	    _K,
	    _L,
	    _M,
	    _N,
	    _O,
	    _P,
	    _Q,
	    _R,
	    _S,
	    _T,
	    _U,
	    _V,
	    _W,
	    _X,
	    _Y,
	    _Z
	  )$UDINT;
	END_TYPE
  //Servers:
	USBdetected 	: SvrCh_DINT;
	DriveListError 	: SvrCh_DINT;
	DriveLetter 	: SvrChCmd_UDINT;
	DriveIndex 	: SvrCh_DINT;
  //Clients:
	FileSys 	: CltChCmd__FileSys;
	USBDriveLetter 	: CltChCmd_String;
  //Variables:
		DriveList : ARRAY [0..25] OF CHAR;

		udUSBdetected 	: UDINT;
		bUSBChecked 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowRun
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="Sets the server DriveLetter, based on the data from the Drivelist." Name="GetDriveLetter"/>
	FUNCTION VIRTUAL GLOBAL GetDriveLetter;
				//! <Function Comment="Gets the data for the Drivelist." Name="GetDriveListInfo"/>
	FUNCTION VIRTUAL GLOBAL GetDriveListInfo;
	
	FUNCTION VIRTUAL GLOBAL DriveLetter::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DriveLetter::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _FileSys


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB USBDetection::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_USBDETECTION
1$UINT, 6$UINT, (SIZEOF(::USBDetection))$UINT, 
4$UINT, 2$UINT, 0$UINT, 
TO_UDINT(216038476), "USBDetection", //Class
TO_UDINT(3788417926), "_Global", 0$UINT, 15$UINT, //Baseclass
//Servers:
(::USBDetection.USBdetected.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1651151399), "USBdetected", 
(::USBDetection.DriveListError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1121438775), "DriveListError", 
(::USBDetection.DriveLetter.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2290356248), "DriveLetter", 
(::USBDetection.DriveIndex.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2956487268), "DriveIndex", 
//Clients:
(::USBDetection.FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::USBDetection.USBDriveLetter.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4178054931), "USBDriveLetter", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
END_FUNCTION


#define USER_CNT_USBDetection 47

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_USBDetection] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION USBDetection::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Global::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Global::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Global::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_USBDetection;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IF_WindowRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #GetDriveLetter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #GetDriveListInfo();

#pragma warning (default : 74)
	_Global::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Global::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	USBdetected.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF USBdetected.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, DriveLetter.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #DriveLetter::Read();
	vmt.CmdTable.Write		:= #DriveLetter::Write();
	DriveLetter.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DriveLetter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DriveIndex.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DriveIndex.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL USBDetection::Init
  
  if _FirstScan then  
  
    // call method of base-class
    _Global::init(); 
    
    // initialize drive letter
    USBDriveLetter.WriteDataOff(USB_StringLength, 0, "C:\");
    DriveIndex.Write(input:=to_dint(2));  // WesAnd v1.4
    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL USBDetection::IF_WindowRun
	VAR_INPUT
		whoami  : ^_WHOAMI;
		pic 	  : ^void;
		event 	: ^_EVENT;
	END_VAR 
  
  // call method of base-class
  _Global::IF_WindowRun(whoami, pic, event);
  
  // event occured on usb-port?
// v1.5 - check available flash drive once at startup  if event^.ftype <> _EVENT_NONE then 
    if ((event^.ftype = _EVENT_LASALOS) & (event^.scancode = 8)) | (bUSBChecked = FALSE) then
    
      // get index of drive letter
      GetDriveListInfo(); // WesAnd v1.4
    
      // flash drive plugged in
      //-----------------------------------------------------------------------------------------
      if (event^.modifier = 1) | (bUSBChecked = FALSE) then
      
        // get index of drive letter
// WesAnd v1.4        GetDriveListInfo();
        
        // flash drive detected
        USBdetected := 1;        
        
        // v1.5 - check at startup done
        bUSBChecked := TRUE;
        
        //*****************************************************************************
        //**                 Set drive letter according to the index                 **
        //*****************************************************************************
        case udUSBdetected of
          
          0:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "A:\");
              
          1:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "B:\");
          
          2:  // v1.5 - reset USBdetected in case that drive could not be mounted
              USBdetected := 0;
          
          3:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "D:\");
              
          4:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "E:\");
              
          5:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "F:\");
              
          6:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "G:\");
              
          7:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "H:\");
              
          8:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "I:\");
              
          9:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "J:\");
              
          10: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "K:\");
              
          11: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "L:\");
              
          12: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "M:\");
              
          13: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "N:\");
              
          14: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "O:\");
              
          15: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "P:\");
              
          16: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "Q:\");
              
          17: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "R:\");
              
          18: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "S:\");
              
          19: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "T:\");
              
          20: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "U:\");
              
          21: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "V:\");
              
          22: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "W:\");
              
          23: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "X:\");
              
          24: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "Y:\");
              
          25: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "Z:\");
              
        end_case; 
        
        
      // flash drive pulled out 
      //-----------------------------------------------------------------------------------------
      elsif event^.modifier = 2 then
      
      // WesAnd v1.4 ---------------------------------------------------------------------------
        //*****************************************************************************
        //**                 Set drive letter according to the index                 **
        //*****************************************************************************
        case udUSBdetected of
          
          0:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "A:\");
              
          1:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "B:\");
          
          2:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "C:\");
              // no flash drive detected
              USBdetected := 0;
              
          3:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "D:\");
              
          4:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "E:\");
              
          5:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "F:\");
              
          6:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "G:\");
              
          7:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "H:\");
              
          8:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "I:\");
              
          9:  USBDriveLetter.WriteDataOff(USB_StringLength, 0, "J:\");
              
          10: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "K:\");
              
          11: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "L:\");
              
          12: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "M:\");
              
          13: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "N:\");
              
          14: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "O:\");
              
          15: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "P:\");
              
          16: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "Q:\");
              
          17: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "R:\");
              
          18: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "S:\");
              
          19: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "T:\");
              
          20: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "U:\");
              
          21: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "V:\");
              
          22: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "W:\");
              
          23: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "X:\");
              
          24: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "Y:\");
              
          25: USBDriveLetter.WriteDataOff(USB_StringLength, 0, "Z:\");
              
        end_case; 
      // WesAnd v1.4 ---------------------------------------------------------------------------
      
        // no flash drive detected
// WesAnd v1.4        USBdetected := 0;
        
// WesAnd v1.4        USBDriveLetter.WriteDataOff(USB_StringLength, 0, "C:\");
        
      end_if;
      
      
    end_if;
//  end_if;
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL USBDetection::GetDriveListInfo
  VAR
    State   : DINT;
  END_VAR  
  
  // get information about the drive list
  State := FileSys.GetDriveListShort(drivelist:= #DriveList$CHAR);
  
  // set DriveListError in case no drive was found
  if State <> 0 then
    DriveListError := 1;
  end_if;   
  
  // get index of flash drive
  GetDriveLetter();
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL USBDetection::GetDriveLetter  
  VAR
    i   : UDINT;
  END_VAR
 
  for i:=0 to 25 do   
    // skip "C:\"
    if i <> 2 then
      
      // check for valid drive data 
      if (Drivelist[i] <> 16#00) then

        // save the last found drive
        udUSBdetected := i;
        
        DriveIndex.Write(input:=to_dint(i));

      end_if;
    // WesAnd v1.4 ------------------
    else
      // Drive "C:\"
      udUSBdetected := i;
      DriveIndex.Write(input:=to_dint(i));
    // WesAnd v1.4 ------------------
    end_if;
    
  end_for;

END_FUNCTION




FUNCTION VIRTUAL GLOBAL USBDetection::DriveLetter::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	DriveLetter := USBDriveLetter.Data.Read();
	output := DriveLetter;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL USBDetection::DriveLetter::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	DriveLetter := input;
	result := (USBDriveLetter.Data.Write(DriveLetter))$UDINT;

END_FUNCTION
