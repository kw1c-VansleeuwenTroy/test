//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_LanguageSelection"
	Revision           = "0.5"
	GUID               = "{BC506192-0C4D-47B6-B2F3-56341A78235C}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "provides functionality and visualisation of language switch">
	<Channels>
		<Client Name="Config" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.5" Date="2016-02-01" Author="kolott" Company="sigmatek" Description="method GetFocus() implemented to ensure doubleclick on first line"/>
		<Dokumentation Revision="0.4" Date="2013-02-15" Author="kolott" Company="sigmatek" Description="dr1830: new client to set lineheight in pixel"/>
	</RevDoku>
	<Network Name="_LanguageSelection">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{C532ADFD-2D8F-44E2-B571-13EDE5D52879}"
				Class      = "_ScrollArea2"
				Position   = "(270,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ActPos"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="ExtendedScrollBar"/>
					<Client Name="LineHighness"/>
					<Client Name="LineWidth"/>
					<Client Name="Lse"/>
					<Client Name="VerticalLevel"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(938,210),(766,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(270,210),(38,210),"/>
			<Connection Source="_base.LineWidth" Destination="this.LineWidth" Vertices="(270,330),(38,270),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(938,270),(766,270),"/>
			<Connection Source="this.ActPos" Destination="_base.ActPos" Vertices="(938,330),(766,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _ScrollArea2

_LanguageSelection : CLASS
: _ScrollArea2
  //Servers:
  //Clients:
	Config 	: CltCh_DINT;
  //Variables:
		LineSpace 	: INT;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method will be called once when the focus will be given to this object&#13;&#10;&#13;&#10;pio ....... pointer to _IO information&#13;&#10;&#13;&#10;return _IFAILED if you dont want to get the focus on the other hand _IDLE&#13;&#10;" Name="GetFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="GetFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return _IFAILED if you dont want to get the focus on the other hand _IDLE" Name="GetFocus.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when redraw of a single line is necessary.&#13;&#10;ps ..... --&gt; to structure _SCROLL&#13;&#10;pr ..... --&gt; to place where line should be drawn&#13;&#10;line ... number of line which should be drawn&#13;&#10;state .. line is selected (TRUE) or passive (FALSE)&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to structure _SCROLL" Name="Line.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to place where line should be drawn" Name="Line.pr"/>
			line 	: UINT;			//! <Variable Comment="16 bit linenumber " Name="Line.line"/>
			state 	: BOOL;			//! <Variable Comment="line is selected (true) or passive (false)" Name="Line.state"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetLineText
		VAR_INPUT
			list 	: ^_TEXT_BUFFER;
			txtno 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_CHAR;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _LanguageSelection::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__LANGUAGESELECTION
0$UINT, 5$UINT, (SIZEOF(::_LanguageSelection))$UINT, 
0$UINT, 1$UINT, 0$UINT, 
TO_UDINT(1108585033), "_LanguageSelection", //Class
TO_UDINT(2779823616), "_ScrollArea2", 0$UINT, 8$UINT, //Baseclass
//Servers:
//Clients:
(::_LanguageSelection.Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(611510522), "Config", 
END_FUNCTION


#define USER_CNT__LanguageSelection 24

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__LanguageSelection] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _LanguageSelection::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _ScrollArea2::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__LanguageSelection;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #GetLineText();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma using _Lse


//*********************Inserted from .\_LanguageSelection\_LanguageSelection_00_00.st*********************



 



FUNCTION __CDECL VIRTUAL GLOBAL _LanguageSelection::IF_Start
VAR_INPUT
	pio		: ^_IO;
	firsttime		: BOOL;
END_VAR
VAR
    pb      : ^BOOL; 
	pvl     : ^_VARLABEL; 
END_VAR

  _ScrollArea2::IF_Start(pio, firsttime); 

  if(firsttime = TRUE) then

    LineSpace := 0; 

    if(pio^.theurge <> NIL) then
	  if(pio^.theurge^.membool.no = 2) then
	    pb     := pio^.theurge^.membool.ptr; 
		Config := 0; 
		if(pb^ = TRUE) then
	      Config := Config or 1; 
        end_if; 
		pb += sizeof(BOOL); 
		if(pb^ = TRUE) then
	      Config := Config or 2; 
        end_if; 
	  end_if; 
	  if(pio^.theurge^.memvarlabel.no = 2) then
	    pvl                := pio^.theurge^.memvarlabel.ptr; 
	    Scroll.line_height := to_uint(pvl^.info[0].value); pvl += sizeof(_VARLABEL); 
        LineSpace          := to_int(pvl^.info[0].value); 
	  end_if; 
	end_if; 

    if(Scroll.line_height = 0) then
	  Scroll.line_height := 10;
    end_if;

    Scroll.position.no       := Prj_GetLanguageNo();
    Scroll.position.begin    := 
    Scroll.position.oldbegin := 
    Scroll.position.pos      := 
    Scroll.position.oldpos   := 0;
    Scroll.position.height   := to_uint((Scroll.scroll_room.xy2.y - Scroll.scroll_room.xy1.y) / Scroll.line_height); 

    if(Scroll.frametype < _THEMEFRAME) then
      Scroll.noclrscr := TRUE;
    end_if;

    if(Config and 1) then
      // cursor not on flag
      Scroll.cursor_dx1 := 45; 
    end_if; 

    if(Config and 2) then
	  // cursor just on statebutton
      Scroll.cursor_dx2 := -((pio^.space.xy2.x - pio^.space.xy1.x) - Scroll.cursor_dx1 - 40); 
    end_if; 

    Scroll.cursor_dy1 := (LineSpace / 2); 
    Scroll.cursor_dy2 := -(LineSpace - (LineSpace / 2)); 
  end_if;   

END_FUNCTION //__CDECL VIRTUAL GLOBAL _LanguageSelection::IF_Start
//[#ENGLISH]
//method is called every time when redraw of a single line is necessary.
//ps ..... --> to structure _SCROLL
//pr ..... --> to place where line should be drawn
//line ... number of line which should be drawn
//state .. line is selected (TRUE) or passive (FALSE)

FUNCTION __CDECL VIRTUAL GLOBAL _LanguageSelection::Line
VAR_INPUT
	ps		: ^_SCROLL;
	pr		: ^_ROOM;
	line		: UINT;
	state		: BOOL;
END_VAR
VAR
	color    : _COLOR; 
	att, axx : _ATTRIB; 
	room     : _ROOM; 
	anything : _ANYTHING; 
	pli      : ^_LANGUAGE_INFO; 
	txt      : ^_CHAR; 
	hptr     : ^UDINT; 
END_VAR

  att        := T_LEFTBOUND or T_COPY or T_SOLID or T_PROP or T_MIDBOUND; 
  room.xy1.y := pr^.xy1.y + (LineSpace / 2); 
  room.xy2.y := pr^.xy2.y - (LineSpace - (LineSpace / 2)); 
  room.xy1.x := pr^.xy1.x; 

  if(state = TRUE) then
    color := ps^.color_activ; 
  else
    color := ps^.color_inactiv; 
  end_if; 

  if(Scroll.frametype < _THEMEFRAME) then
    // delete line
    if((state = TRUE) & (Config and 1)) then
      Graphic.Beam(pr^.xy1.x, room.xy1.y, pr^.xy1.x+45, room.xy2.y, att, GetBackColor(ps^.color_inactiv)); 
      Graphic.Beam(pr^.xy1.x+45, room.xy1.y, pr^.xy2.x, room.xy2.y, att, GetBackColor(color)); 
    else
      Graphic.Beam(pr^.xy1.x, room.xy1.y, pr^.xy2.x, room.xy2.y, att, GetBackColor(color)); 
    end_if; 
  else
    LineBackGround(ps, pr, GetBackColor(color));
	room.xy1.x += 8; 
  end_if;

  if(line < Scroll.position.no) then
	pli := Prj_Get_LANGUAGE_INFO(); 

    if(Config and 1) then
	  // draw flag 
      if(line < pli^.flag.no) then
	    room.xy2.x    := room.xy1.x + 40; 
        anything.list := ICONLST;
        hptr          := pli^.flag.ptr + line * sizeof(DINT);  
        anything.no   := hptr^; 
        out_ANYTHING(#anything, #room, DEFFONT, att, _DEFFRAME, DEFCOLOR, DEFCOLOR, DEFCOLOR, NIL); // flagge ausgeben
      end_if; 
      room.xy1.x += 45; 
    end_if; 
 
    if(Config and 2) then
	  // draw state
      if(GetPenColor(color) = 0) then
        color += 1; 
      end_if; 
      room.xy2.x := room.xy1.x + 40; 
	  if(line = Lse.Language) then
        //out_radiobutton(#room, 1, att, color, GetBackColor_Makro(color), Graphic.MakeColor(WHITE, DARKGRAY)); 
        out_radiobutton(#room, 1, att, color, INVISIBLE, Graphic.MakeColor(WHITE, DARKGRAY)); 
	  else
        //out_radiobutton(#room, 0, att, color, GetBackColor_Makro(color), Graphic.MakeColor(WHITE, DARKGRAY)); 
        out_radiobutton(#room, 0, att, color, INVISIBLE, Graphic.MakeColor(WHITE, DARKGRAY)); 
      end_if; 
	  room.xy1.x += 45; 
    end_if; 

    txt := GetLineText(#pli^.name, to_uint(line));


	axx := font_set_by_language(Scroll.font, to_uint(line)); // set language-font
	att := att or (axx and (T_ITALIC or T_BOLD or T_UNDERLINE or T_STRIKEOUT));
    Graphic.OutTextXY(room.xy1.x, (pr^.xy1.y+pr^.xy2.y)/2, txt, att, Graphic.MakeColor(INVISIBLE, color), sizeof(_CHAR)); // draw languagetext 
  end_if; 

END_FUNCTION //__CDECL VIRTUAL GLOBAL _LanguageSelection::Line
//[#ENGLISH]
//this method is called everytime when the input is active and a event occured
//
//ped ....... pointer to _EDITOR information
//pe ........ pointer to _EVENT information
//
//for the returnstatement there are 3 different possibilities
//_IDLE ..... the system should goon like it is (system goes on)
//_IDIDIT ... i did it (system is ready)
//_IFAILED .. i tried to do my best, but i failed (system is ready)

FUNCTION __CDECL VIRTUAL GLOBAL _LanguageSelection::GetEvent
VAR_INPUT
	ped		: ^_EDITOR;
	pe		: ^_EVENT;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR
VAR
    room : _ROOM; 
END_VAR

  retcode := _IDLE; 

  if(pe^.ftype = _EVENT_HIDPRESS) then
    if((Scroll.position.pos >= 0) & (Scroll.position.pos < Scroll.position.no)) then
      GetLinePosition_SCROLL(#Scroll, to_uint(Scroll.position.pos - Scroll.position.begin), #room);
      if((pe^.dot.x >= room.xy1.x)&(pe^.dot.x <= room.xy2.x)&(pe^.dot.y >= room.xy1.y)&(pe^.dot.y <= room.xy2.y)) then
        Lse.Language.Write(Scroll.Position.pos);
        retcode := _IDIDIT;
      end_if;
    end_if;
  end_if; 

  if(pe^.ftype = _EVENT_KEYPRESS) then
    if(pe^.scancode = _ENTER) then
	    Lse.Language.Write(Scroll.Position.pos); 
      retcode := _IDIDIT; 
	  end_if; 
  end_if; 

  if(retcode = _IDLE) then
    retcode := _ScrollArea2::GetEvent(ped, pe); 
  end_if; 

END_FUNCTION //__CDECL VIRTUAL GLOBAL _LanguageSelection::GetEvent

FUNCTION VIRTUAL GLOBAL _LanguageSelection::GetLineText
VAR_INPUT
	list	: ^_TEXT_BUFFER;
	txtno	: UINT;
END_VAR
VAR_OUTPUT
	retcode		: ^_CHAR;
END_VAR

  retcode := gettext_TEXT_BUFFER(list, txtno);

END_FUNCTION //VIRTUAL GLOBAL _LanguageSelection::GetLineText

FUNCTION __CDECL VIRTUAL GLOBAL _LanguageSelection::GetFocus
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR

  retcode := _ScrollArea::GetFocus(pio);
  Scroll.position.pos := -1;

END_FUNCTION
