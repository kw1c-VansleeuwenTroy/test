//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_MyIO"
	Revision           = "0.3"
	GUID               = "{1DFA17C1-8CBB-11D5-8BC6-0048545E8899}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_MyIO\MyIo.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "is used to create own visualisation-style">
	<Channels>
		<Server Name="Refresh" GUID="{4BE2D441-F26E-11D7-8BCB-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Server0" GUID="{1DFA17C2-8CBB-11D5-8BC6-0048545E8899}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="Graphic" Required="false" Internal="false"/>
		<Client Name="Lse" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.3" Date="2013-07-04" Author="kolott" Company="sigmatek" Description="new method SetData is added"/>
		<Dokumentation Revision="0.2" Date="2013-04-02" Author="kolott" Company="sigmatek" Description="icon added"/>
		<Dokumentation Revision="0.1" Date="2010-12-21" Author="kolott" Company="sigmatek" Description="documentation done"/>
	</RevDoku>
</Class>
*)
_MyIO : CLASS
  //Servers:
	Server0 	: SvrChCmd_DINT;
	Refresh 	: SvrCh_DINT;
  //Clients:
	Lse 	: CltChCmd__Lse;
	Graphic 	: CltChCmd_Graphic;
  //Variables:
		Cursor 	: ^void;
  //Functions:
	
	FUNCTION _MyIO
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="this method will be called once when the focus will be given to this object" Name="GetFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="GetFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return _IFAILED if you dont want to get the focus on the other hand _IDLE" Name="GetFocus.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called once when the focus is taken from object" Name="KillFocus"/>
	FUNCTION __CDECL VIRTUAL GLOBAL KillFocus
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="KillFocus.pio"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="return always _IDLE because you can&apos;t prevent action" Name="KillFocus.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called everytime when the input is active and a event occured" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called everytime when system wants to redraw the io" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called everytime when system wants to get data for defined io.&#13;&#10;&#13;&#10;pr ........ &#13;&#10;pio ....... pointer to io information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to do it let&apos;s return _IDIDIT and initialize the  structure _RESULT&#13;&#10;" Name="GetData"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetData
		VAR_INPUT
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="GetData.pr"/>
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="GetData.pio"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to _VARIABLE information given by LSE" Name="GetData.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="GetData.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)" Name="GetData.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="method is called once after drawing (call of method Draw)&#13;&#10;&#13;&#10;pio ....... &#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Ready"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Ready
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Ready.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Ready.input"/>
		END_VAR;
				//! <Function Comment="method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... &#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
				//! <Function Comment="this method is called right away before the object will be destroyed.&#13;&#10;for example close picture or window&#13;&#10;" Name="IF_End"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_End;
				//! <Function Comment="this method is called right away before the editor will be saved&#13;&#10;" Name="IF_SaveEditor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_SaveEditor
		VAR_INPUT
			pe 	: ^_EDITOR;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
				//! <Function Comment="inside of method you can decide if you want to see the flashing cursor or not.&#13;&#10;return state _IDIDIT if you don&apos;t want to see the flashing cursor. &#13;&#10;on the other hand return state _IDLE&#13;&#10;" Name="IF_DisplayCursor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_DisplayCursor
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
				//! <Function Comment="this method is called after the kernel has done work to the editor.&#13;&#10;" Name="IF_SystemIsReadyWithEditor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_SystemIsReadyWithEditor
		VAR_INPUT
			ped 	: ^_EDITOR;
			pe 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="this method returns if the object is accessible with editor&#13;&#10;return FALSE if you don&apos;t want to get access to object&#13;&#10;on the other hand return TRUE&#13;&#10;" Name="Accessible"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Accessible
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
				//! <Function Comment="this method is called by the kernel and should not be overloaded&#13;&#10;the functionality and the parameter are next to method GetData " Name="CGetData"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CGetData
		VAR_INPUT
			pr 	: ^_RESULT;
			pio 	: ^_IO;
			pv 	: ^_VARIABLE;
			input 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
				//! <Function Comment="this method is called right before the touch editor will appear&#13;&#10;the returncode includes information about the windownumber which will be used as toucheditor.&#13;&#10;return 16#FFFF if you don&apos;t want to open a editor." Name="IF_OpenTouchEditor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_OpenTouchEditor
		VAR_INPUT
			pe 	: ^_EDITOR;
			preselect 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode (AX) 	: UINT;
		END_VAR;
				//! <Function Comment="method is called each time when system wants to store data at defined myio" Name="SetData"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SetData
		VAR_INPUT
			pvl 	: ^_VARLABEL;
			pr 	: ^_RESULT;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
				//! <Function Comment="method is called when activated editor wants to increment or decrement value" Name="IncDecData"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IncDecData
		VAR_INPUT
			pvl 	: ^_VARLABEL;
			pr 	: ^_RESULT;
			do_increment 	: _BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Lse
#pragma usingLtd Graphic


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _MyIO::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__MYIO
0$UINT, 3$UINT, (SIZEOF(::_MyIO))$UINT, 
2$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2980745877), "_MyIO", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_MyIO.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
(::_MyIO.Refresh.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1606704865), "Refresh", 
//Clients:
(::_MyIO.Lse.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(299963966), "Lse", TO_UDINT(1552551876), "_Lse", 0$UINT, 128$UINT, 
(::_MyIO.Graphic.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1140816688), "Graphic", TO_UDINT(1140816688), "Graphic", 0$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT__MyIO 17

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__MyIO] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _MyIO::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__MyIO, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #KillFocus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #IF_Ready();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #IF_End();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #IF_SaveEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #IF_DisplayCursor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #IF_SystemIsReadyWithEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Accessible();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #CGetData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #IF_OpenTouchEditor();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #SetData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #IncDecData();

#pragma warning (default : 74)
	Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Refresh.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Refresh.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _MyIO();

END_FUNCTION

//{{LSL_IMPLEMENTATION


#pragma warning (disable: 73)

FUNCTION  _MyIO::_MyIO
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR

    Cursor := NIL; 
	ret_code	:= C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL __cdecl _MyIO::GetFocus
VAR_INPUT
  pio   : ^_IO;
END_VAR
VAR_OUTPUT
  retcode : _DOIT; 
END_VAR

  Cursor  := Cursor_Get();

  retcode := _IDLE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL __cdecl _MyIO::KillFocus
VAR_INPUT
  pio   : ^_IO;
END_VAR
VAR_OUTPUT
  retcode : _DOIT; 
END_VAR

  Cursor  := NIL; 
  retcode := _IDLE; 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL __cdecl _MyIO::GetEvent
VAR_INPUT
  ped   : ^_EDITOR;
  pe    : ^_EVENT;
END_VAR
VAR_OUTPUT
  retcode : _DOIT; 
END_VAR

  retcode := _IDLE; 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL __cdecl _MyIO::Draw
VAR_INPUT
  pio   : ^_IO;
  pr    : ^_RESULT;
  pv    : ^_VARIABLE;
  input : BOOL;    
END_VAR
VAR_OUTPUT
  retcode : _DOIT; 
END_VAR

//  pio^.doimage := false;
//  free_IMAGE(#pio^.image);

(*
VAR
  act   : _NEWSCREEN; 
END_VAR

  push_screen(#act);

  Graphic.Putimage(#pio^.image, DEFKOORD, DEFKOORD); 

  if(pr^.ftype = RES_TIME) then  // analog watch
    indicator(#pio^.space, 90 - ((pr^.datim.ftime.hour mod 12) * 60 + pr^.datim.ftime.minute) / 2, Graphic.MakeColor(WHITE, LIGHTGRAY)); 
    indicator(#pio^.space, 90 - 6 * pr^.datim.ftime.minute, Graphic.MakeColor(LIGHTRED, RED)); 
    indicator(#pio^.space, 90 - 6 * pr^.datim.ftime.second, Graphic.MakeColor(LIGHTGREEN, GREEN)); 
  else // analog indicator (0-360°)
    indicator(#pio^.space, pr^.value, Graphic.MakeColor(LIGHTGREEN, GREEN)); 
  end_if; 

  pop_screen(#act); 
  copy_screen(#act, #pio^.space); 

  retcode := _IDIDIT; 

VAR
  act   : _NEWSCREEN; 
END_VAR

  push_screen(#act);

  Graphic.Putimage(#pio^.image, DEFKOORD, DEFKOORD); 

  color_course(#pio^.space, to_int(pr^.value), pio^.colback, pio^.coltxt, pio^.attrib); 

  pop_screen(#act); 
  copy_screen(#act, #pio^.space); 
  retcode := _IDIDIT; 
*)


//  font_set_direct(font_seek("000u1600.fNt"));
//  Graphic.OutTextXY(pio^.space.xy1.x, pio^.space.xy1.y, "AaBbCcDdEe", pio^.attrib, WHITE, 1);
//  retcode := _IDIDIT; 

//  Graphic.line(10, 10, 100, 100, pio^.attrib, pio^.colback); 
//  retcode := _IDIDIT; 

(*
VAR
  bmp : ^_BMP; 
  any : _ANYTHING; 
END_VAR
  

  any.list := ICONLST; 
  any.no   := to_uint(pr^.value mod 248); 
  bmp$^void := get_anything(#any, NIL); 
  out_zoom_BMP(#pio^.space, bmp, pio^.attrib); 


  retcode := _IDIDIT; 
*)
(*
VAR
  i : INT; 
  tmp : array[0..10] of char; 
  x : _KOORD; 
END_VAR

  
  tmp[1] :=0; 
  x      := pio^.space.xy1.x; 
  for i:=97 to 125 do
    tmp[0] := i$char; 
    Graphic.OutTextXY(x, pio^.space.xy1.y + 10, #tmp[0], T_COPY or T_SOLID or T_PROP, Graphic.MakeColor(WHITE, BLACK), 1); 
	x += 10; 
  end_for; 
  retcode := _IDIDIT; 
*)   



(*
VAR
  vl : _VARLABEL; 
  variable : _VARIABLE; 
  result : _RESULT;
  txt : ARRAY[0..30] of _CHAR;  
END_VAR

  vl.no := 1; 
  vl.info[0].state := VAR_VAL; 
  vl.info[0].value := 100; 

  if(VarList_GetSystemData(#result, #variable, #vl, _TRUE) = _TRUE) then   
    if(recalculate(#result, #variable, _TRUE) = _TRUE) then
	  format_value(#txt[0], result.value, #variable.info, NIL);
      Graphic.OutTextXY(10, 10, #txt[0], Graphic.MakeColor(BLACK, WHITE), T_COPY or T_SOLID or T_PROP, sizeof(_CHAR)); 
	end_if; 
  end_if; 
*)


//OutMultiTextAlign("JOE", 0, #pio^.space, pio^.font, pio^.attrib, pio^.frametype, pio^.coltxt, pio^.colback, pio^.colframe, 1);


//  flash_gfx(pio^.space.xy1.x, pio^.space.xy1.y, "C:\GIF\013.GIF");
//  retcode := _IDIDIT; 


  retcode := _IDLE; 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL __cdecl _MyIO::GetData
VAR_INPUT
  pr    : ^_RESULT;
  pio   : ^_IO;
  pv    : ^_VARIABLE;
  input : BOOL;    
END_VAR
VAR_OUTPUT
  retcode : _DOIT; 
END_VAR

  retcode := _IDLE; 

END_FUNCTION 


FUNCTION __CDECL VIRTUAL GLOBAL _MyIO::SetData
	VAR_INPUT
		pvl 	: ^_VARLABEL;
		pr 	: ^_RESULT;
	END_VAR
	VAR_OUTPUT
		retcode : _DOIT;
	END_VAR

  retcode := _IDLE;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _MyIO::IncDecData
	VAR_INPUT
		pvl 	: ^_VARLABEL;
		pr 	: ^_RESULT;
		do_increment 	: _BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: _DOIT;
	END_VAR

  retcode := _IDLE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL __cdecl _MyIO::IF_Start
VAR_INPUT
  pio       : ^_IO; 
  firsttime : BOOL; 
END_VAR


//  pio^.brefreshact := TRUE; 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL __cdecl _MyIO::IF_Ready
VAR_INPUT
  pio       : ^_IO; 
  input     : BOOL;
END_VAR


END_FUNCTION


FUNCTION VIRTUAL GLOBAL __cdecl _MyIO::IF_Run
VAR_INPUT
  pio    : ^_IO; 
  input  : BOOL;
END_VAR


END_FUNCTION

FUNCTION VIRTUAL GLOBAL __cdecl _MyIO::IF_End

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _MyIO::IF_SaveEditor
VAR_INPUT
	pe		: ^_EDITOR;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  retcode := _IDLE; 

END_FUNCTION 


FUNCTION __CDECL VIRTUAL GLOBAL _MyIO::IF_DisplayCursor
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR

  retcode := _IDLE; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _MyIO::IF_SystemIsReadyWithEditor
VAR_INPUT
	ped		: ^_EDITOR;
	pe      : ^_EVENT; 
END_VAR


END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _MyIO::Accessible
VAR_INPUT
	pio		: ^_IO;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := TRUE; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _MyIO::CGetData
VAR_INPUT
	pr		: ^_RESULT;
	pio		: ^_IO;
	pv		: ^_VARIABLE;
	input		: BOOL;
END_VAR
VAR_OUTPUT
	retcode		: _DOIT;
END_VAR
  
  retcode := GetData(pr, pio, pv, input); 

  if(Refresh <> 0) then
    pio^.cstate.value$udint := pr^.value$udint xor 16#FFFFFFFF; 
    Refresh := 0; 
  end_if; 

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL _MyIO::IF_OpenTouchEditor
VAR_INPUT
  pe        : ^_EDITOR;
  preselect : UINT;
END_VAR
VAR_OUTPUT
	retcode		: UINT;
END_VAR

  retcode := preselect;

END_FUNCTION
